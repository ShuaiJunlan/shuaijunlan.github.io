{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/images/1.png","path":"images/1.png","modified":0,"renderable":0},{"_id":"source/images/0.png","path":"images/0.png","modified":0,"renderable":0},{"_id":"source/images/1525844998.png","path":"images/1525844998.png","modified":0,"renderable":0},{"_id":"source/images/1525845072.png","path":"images/1525845072.png","modified":0,"renderable":0},{"_id":"source/images/1526016569.png","path":"images/1526016569.png","modified":0,"renderable":0},{"_id":"source/images/AbstractConfig.png","path":"images/AbstractConfig.png","modified":0,"renderable":0},{"_id":"source/images/AnnotationBean.png","path":"images/AnnotationBean.png","modified":0,"renderable":0},{"_id":"source/images/BlockingQueue.png","path":"images/BlockingQueue.png","modified":0,"renderable":0},{"_id":"source/images/Cluster.png","path":"images/Cluster.png","modified":0,"renderable":0},{"_id":"source/images/ReferenceBean.png","path":"images/ReferenceBean.png","modified":0,"renderable":0},{"_id":"source/images/DefaultPromise.png","path":"images/DefaultPromise.png","modified":0,"renderable":0},{"_id":"source/images/RejectedExecutionHandler.png","path":"images/RejectedExecutionHandler.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-07-20 21-01-11.png","path":"images/Screenshot from 2018-07-20 21-01-11.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-07-24 16-02-04.png","path":"images/Screenshot from 2018-07-24 16-02-04.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-09-18 11-16-13.png","path":"images/Screenshot from 2018-09-18 11-16-13.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-10-17 16-41-11.png","path":"images/Screenshot from 2018-10-17 16-41-11.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-12-16 19-34-34.png","path":"images/Screenshot from 2018-12-16 19-34-34.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-12-16 19-40-43.png","path":"images/Screenshot from 2018-12-16 19-40-43.png","modified":0,"renderable":0},{"_id":"source/images/ServiceBean.png","path":"images/ServiceBean.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-12-16 19-42-31.png","path":"images/Screenshot from 2018-12-16 19-42-31.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-12-16 19-43-19.png","path":"images/Screenshot from 2018-12-16 19-43-19.png","modified":0,"renderable":0},{"_id":"source/images/main-page.png","path":"images/main-page.png","modified":0,"renderable":0},{"_id":"source/images/menu-manage.png","path":"images/menu-manage.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-07-20 20-39-27.png","path":"images/Screenshot from 2018-07-20 20-39-27.png","modified":0,"renderable":0},{"_id":"source/images/Java.png","path":"images/Java.png","modified":1,"renderable":0},{"_id":"source/images/Screenshot from 2018-07-20 21-52-02.png","path":"images/Screenshot from 2018-07-20 21-52-02.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-07-21 19-41-49.png","path":"images/Screenshot from 2018-07-21 19-41-49.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-10-02 15-50-13.png","path":"images/Screenshot from 2018-10-02 15-50-13.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-10-02 15-49-47.png","path":"images/Screenshot from 2018-10-02 15-49-47.png","modified":0,"renderable":0},{"_id":"source/images/dubbo-provider.png","path":"images/dubbo-provider.png","modified":0,"renderable":0},{"_id":"source/images/log-manage2.png","path":"images/log-manage2.png","modified":0,"renderable":0},{"_id":"source/images/log-manage1.png","path":"images/log-manage1.png","modified":0,"renderable":0},{"_id":"source/images/1526020447.png","path":"images/1526020447.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-07-21 17-33-12.png","path":"images/Screenshot from 2018-07-21 17-33-12.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-11-23 20-17-54.png","path":"images/Screenshot from 2018-11-23 20-17-54.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-12-16 19-41-44.png","path":"images/Screenshot from 2018-12-16 19-41-44.png","modified":0,"renderable":0},{"_id":"themes/hexo-theme-next-6.4.2/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"source/images/Screenshot from 2018-11-23 20-22-05.png","path":"images/Screenshot from 2018-11-23 20-22-05.png","modified":0,"renderable":0},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next-6.4.2/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"source/images/login-page.png","path":"images/login-page.png","modified":0,"renderable":0},{"_id":"source/images/Screenshot from 2018-12-27 20-39-35.png","path":"images/Screenshot from 2018-12-27 20-39-35.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/style.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/.gitignore","hash":"0378adb9c2dc4855b3198184df4863cb30e4059c","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/.travis.yml","hash":"fb9ac54e875f6ea16d5c83db497f6bd70ae83198","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/LICENSE.md","hash":"f0190c7d83a98464549a6b3a51bb206148d88e1b","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/README.md","hash":"460ef40953c2eccea4f87bc67043aac2eb87b1a9","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/bower.json","hash":"e053c6e073227b953d37480eb3f9ab77292c5460","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/gulpfile.coffee","hash":"67eaf2515100971f6195b60eeebbfe5e8de895ab","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/package.json","hash":"e2bb1bb999c2b1c5b807c40f04682051ba3960b2","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/_config.yml","hash":"84dc2292af053025905f7ffab82295782b4d9b17","modified":1547206475282},{"_id":"source/favicon.ico","hash":"fba3f9ecad58e0bca7379ecffda1ddfe0f0172d3","modified":1542789142000},{"_id":"source/_posts/Autopacking and Autounpacking.md","hash":"1f0e1b5f9b0987ccfa82532eeaf9c8042b2bdff8","modified":1542789142000},{"_id":"source/__CNAME","hash":"d41ca92930ad8c97cd82cc9af9c12cf4f9324ab1","modified":1542789142000},{"_id":"source/_posts/CentOS7-login.md","hash":"1995ab140c12cb01393df452c74506a0504d1fe1","modified":1542789142000},{"_id":"source/_posts/Distributed-Systems-Technologies.md","hash":"f0c9fc2b6d7822fafc935c6383085b50b73b32de","modified":1542789142000},{"_id":"source/_posts/Distributed-Lock-Based-On-Zookeeper.md","hash":"24aea54aa5537714028bc8f930cbbcf470399783","modified":1542789142000},{"_id":"source/_posts/How-to-understand-the-DeadLock.md","hash":"f9da51e9130c2f8d3f7fe92848202fdb19e0428f","modified":1542789142000},{"_id":"source/_posts/Java-Class-and-Object-Initializing-Process.md","hash":"4c5ab7e7c8b2e30bf3967ce196f91989f2a35179","modified":1542789142000},{"_id":"source/_posts/Java-NIO-and-BIO.md","hash":"cf682d5bbf596b8cf189dd36ce8b3af62a33e897","modified":1542789142000},{"_id":"source/_posts/Basing-on-Spring-SpringMVC-MyBatis-Druid-Shrio-developing-web-system.md","hash":"f3dc556d20811180a4bd9d91076500bc332bf7e5","modified":1542885894688},{"_id":"source/_posts/LruCache-On-Map-And-LinkedList.md","hash":"f6bcc95e2bcdefab0f1bf375e7dc6d5cd3af4277","modified":1542789142000},{"_id":"source/_posts/MyBatis-tutorial.md","hash":"98eb6b4553f41183d06d07b3c2e3b79ecb1ce18d","modified":1542789142000},{"_id":"source/_posts/Spring-bean-init-destory.md","hash":"c570beb24ba2931b75d9e1555c20b7d57b35964f","modified":1542789142000},{"_id":"source/_posts/dubbo-basing-on-spring-framework-analysis.md","hash":"689de420c564b84b98765559d126519050017973","modified":1542789142000},{"_id":"source/_posts/dubbo-cluster-fault-tolerance.md","hash":"1c5d266719fab5ff87cc43b106dba25d8e9905b9","modified":1542789142000},{"_id":"source/_posts/dubbo-gracefully-shutdown.md","hash":"129983304a991082c4eeb7bddbf148361967f1c3","modified":1542789142000},{"_id":"source/_posts/dubbo-loadbalance-strategy.md","hash":"aca3ef0a264d89d431141e834a3fa2c9d8eb955c","modified":1542789142000},{"_id":"source/_posts/dubbo-provider-calling-process-source-code-analysis.md","hash":"1a0a315a831b1cf46b2ec1b98be27d92eb2061a3","modified":1542789142000},{"_id":"source/_posts/dubbo-provider-request-and-response-analysis.md","hash":"96da401f154e7a1d70fbdbabf0633567f81ef024","modified":1542789142000},{"_id":"source/_posts/dubbo-proxy-basing-on-javassist.md","hash":"58f5082158e15b43670d737f1965b9413a2411f1","modified":1546779672938},{"_id":"source/_posts/dubbo-router-analysis.md","hash":"9ac4dd842c8c1a0432bab394d871ab7bd17cd732","modified":1542789142000},{"_id":"source/_posts/http.md","hash":"c112ad334bdf2820b60b8d1c24675ea82157d24c","modified":1542789142000},{"_id":"source/_posts/dubbo-spi-analysis.md","hash":"17c449dd710435bc7f71b75947aaed231f8161d9","modified":1542789142000},{"_id":"source/_posts/java-Collections-sort-method.md","hash":"03935f759f1a979e21caf9eafa4de9e4f0dd8ba3","modified":1542789142000},{"_id":"source/_posts/java-basic-knowledge-summary.md","hash":"5a9c7a044669c10d8ac65997952a9c5aee5df7a8","modified":1545810515569},{"_id":"source/_posts/java-cas-and-lock-free.md","hash":"557b54e165862b2cd60ae82505fceebf179225d5","modified":1545914715825},{"_id":"source/_posts/java-blocking-queue.md","hash":"6f7f4d2cc084bd914e1d100b407c8aede73cd7d7","modified":1547179662674},{"_id":"source/_posts/java-constant-pool.md","hash":"02dd70a3e87d69c10120855497df0b5a31f3f1ba","modified":1542789142000},{"_id":"source/_posts/java-abstract-queued-synchronizer.md","hash":"1040aff7ce01a462aac6d08760c37bb0fdf19593","modified":1543029107311},{"_id":"source/_posts/java-creating-thread.md","hash":"842555ede1f4565c101c83b6cc07933a1353681e","modified":1542789142000},{"_id":"source/_posts/java-copy-on-write.md","hash":"1a25335bb21aaa757718b8a41775aad1c647b013","modified":1544014347425},{"_id":"source/_posts/java-spi-introduction.md","hash":"7db5ba4e7568ec5e1140bd657d27f2603978a30d","modified":1542789142000},{"_id":"source/_posts/java-thread-pool.md","hash":"94cc2779f30380f88bad039a39bc255e8c40820e","modified":1542789142000},{"_id":"source/_posts/java-three-point.md","hash":"4b8f7dd9f12c54e5ec074d025f162d5a14744648","modified":1542789142000},{"_id":"source/_posts/java-memory-mapped-file.md","hash":"c728f5da871406642a83b3697a4d303764896d57","modified":1544271636311},{"_id":"source/_posts/libvirt-kvm.md","hash":"2454c1f86a95137c9b1524dd8a2ced292a6208c1","modified":1542789142000},{"_id":"source/_posts/log4j-tutorial.md","hash":"6918231b700dae1bd4638e23770e4841aa323796","modified":1542789142000},{"_id":"source/_posts/netty-bytebuf-data-container.md","hash":"ea3907422fb141213312418f4c196da5659129c8","modified":1542789142000},{"_id":"source/_posts/netty-components-design.md","hash":"6aa7127d06781e8352c00809119a1c86b8362664","modified":1542789142000},{"_id":"source/_posts/netty-future-and-promise.md","hash":"4a4e5f5a71b189c212b13fb2fecf7ec2ee893604","modified":1542789142000},{"_id":"source/_posts/linux-direct-io.md","hash":"28236c47636f9c653f4c72641f2d621b5de39070","modified":1545917345656},{"_id":"source/_posts/netty-introduction.md","hash":"c7fb213bfebc41c23d51a1cbc4e67137ca133d5d","modified":1542789142000},{"_id":"source/_posts/java-phaser.md","hash":"e0f8cd645b50f7fc55c9c72874b4e210d822f9c9","modified":1542789142000},{"_id":"source/_posts/netty-thread-model.md","hash":"eca8294a2793885363b1eb6b61343c4db5c90e1a","modified":1542789142000},{"_id":"source/_posts/netty-transport-methods.md","hash":"694681fdc348f0bb8020c54cc4b8795c6d9b7283","modified":1542789142000},{"_id":"source/_posts/spring-cloud-microservice-demo.md","hash":"910aab7140c5af0254088a0280d2ffada32b8b80","modified":1542789142000},{"_id":"source/_posts/user-thread-and-daemon-thread.md","hash":"1a8e7af11ac60f75125114f380dff993176c9df7","modified":1542789142000},{"_id":"source/images/1.png","hash":"97b2c7c92207e427db659e93ab349b5b4e0f8e41","modified":1542789142000},{"_id":"source/images/0.png","hash":"136a21d243e62548ec5445d7e685b9378d20eddf","modified":1542789142000},{"_id":"source/images/1525844998.png","hash":"697fa9ff08d6867febb19447885b715c402379d2","modified":1542789142000},{"_id":"source/images/1525845072.png","hash":"3317891f2cdc4e8abb58986706a5ae01ceeb1eee","modified":1542789142000},{"_id":"source/images/1526016569.png","hash":"7b9d46009317846a84ea7721aca8087fc9e734f9","modified":1542789142000},{"_id":"source/images/AbstractConfig.png","hash":"51a914beb8b51d9519073ffe61eac80d860d05e3","modified":1542789142000},{"_id":"source/images/AnnotationBean.png","hash":"cfb15872d79398cd99a4212d453a2978dc9e9034","modified":1542789142000},{"_id":"source/images/BlockingQueue.png","hash":"35161ec06793aac12e9586030485bff1d150dc07","modified":1542789142000},{"_id":"source/images/Cluster.png","hash":"c9c4bd2a50f4b1bed6d7b0ebd82eddf1d16f2614","modified":1542789142000},{"_id":"source/images/ReferenceBean.png","hash":"09c507c87eb26a7080520e4c2ad16eaf161a8543","modified":1542789142000},{"_id":"source/images/DefaultPromise.png","hash":"3cfcfa7822991e79e77ebeba2d3a17e16c28035b","modified":1542789142000},{"_id":"source/images/RejectedExecutionHandler.png","hash":"999af7456ebcbd6b46c5bb2746ee4b32a74e46a6","modified":1542789142000},{"_id":"source/images/Screenshot from 2018-07-20 21-01-11.png","hash":"318fac8121f913a6e487d6cc62da2f073ec04a62","modified":1542789142000},{"_id":"source/images/Screenshot from 2018-07-24 16-02-04.png","hash":"a68c06176bff715c9347e8a566a14dc910a18df3","modified":1542789142000},{"_id":"source/images/Screenshot from 2018-09-18 11-16-13.png","hash":"cd78d5d44b9cd20bcc694e5d320a15333243343f","modified":1542789142000},{"_id":"source/images/Screenshot from 2018-10-17 16-41-11.png","hash":"b7678e6c1fbd942b3beacbf63ab9b1b45fae8f20","modified":1542789142000},{"_id":"source/_posts/CentOS7-kvm.md","hash":"043c7a5a23c288902cbd90a38f9eff90b706d6b7","modified":1542789142000},{"_id":"source/_posts/analyse-the-source-code-of-Timer.md","hash":"8978d7b9e58545dfd60c81be7d1439b88f718f47","modified":1542789142000},{"_id":"source/images/Screenshot from 2018-12-16 19-34-34.png","hash":"8fd412992c1c5f03aeb8d59f0704f5b9356a9855","modified":1544960076347},{"_id":"source/images/Screenshot from 2018-12-16 19-40-43.png","hash":"1dd74af351912dd0a053c3e993f5d59ee2d879fe","modified":1544960444908},{"_id":"source/images/ServiceBean.png","hash":"23eabe851e16ed108427d00293243c51793e99d4","modified":1542789142000},{"_id":"source/images/Screenshot from 2018-12-16 19-42-31.png","hash":"1d989c1f6341a9a6297d8b137aa0752afc8884cd","modified":1544960553518},{"_id":"source/images/Screenshot from 2018-12-16 19-43-19.png","hash":"e18ba7c9eba6f31df4d1ab89989e8009e34a6727","modified":1544960600713},{"_id":"source/images/main-page.png","hash":"5f0d1c352b8d8c8de85510fdcec04fe403cfc0d3","modified":1542789142000},{"_id":"source/images/menu-manage.png","hash":"fcdf35a3cbf051eaf2f3e7fce855329e2be9e420","modified":1542789142000},{"_id":"source/categories/index.md","hash":"75a492aad3f36725bac52590e199873002dc9d93","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/ALGOLIA-SEARCH.md","hash":"1dada3c3404445a00367882b8f97cdf092b7943d","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/AUTHORS.md","hash":"51a0a13da55ff3d596970b2f9ab4531c6b2211f2","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/INSTALLATION.md","hash":"b74ef6fedf76cdb156e2265759ee0a789ddd49cc","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/DATA-FILES.md","hash":"9a1895c0a0db705c4c48f512e86917f9af1ec3fb","modified":1542789142000},{"_id":"source/about/index.md","hash":"ea2a08fc98962b6bff2ede7a9311322abb05cd31","modified":1546583343298},{"_id":"themes/hexo-theme-next-6.4.2/docs/LICENSE","hash":"5b702310012d480b40529fd10cf1872f687277a0","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"f2fd611a84dd6f9ed5395b63e187e29e9effbcd3","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/MATH.md","hash":"34a46ca9a05b4570903beaadd4807e6759afb52e","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/UPDATE-FROM-5.1.X.md","hash":"c9f2ed8e15c137b1885d9ca8b7197d9f457971e9","modified":1542789142000},{"_id":"source/tags/index.md","hash":"d4c698b04e976bbae26a0ee4d5a7bf1a6b9ea5a4","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_layout.swig","hash":"2db9b03efc68be842b8f79fe2f0fd7fb09e8885a","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/archive.swig","hash":"4b53070008775ecfd03953bd1b4adfcb0fabcaac","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/category.swig","hash":"f0e3338bfa5efb205d2c28e635e9611f1fff3b55","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/index.swig","hash":"bdcc9f57adef49706b16b107791cacecbc23c1dc","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/page.swig","hash":"9ddf40303f82e3db76d59dc82b6d4eadfed203c6","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/post.swig","hash":"0554f42f90f4a524666c2b520be30b689c1d6a87","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/scripts/helpers.js","hash":"7849f9b9a86fc82d6e186e32a5e26e1f27c49b47","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/scripts/merge-configs.js","hash":"5f96f63e86825fd7028c2522e4111103e261a758","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/schedule.swig","hash":"d99b9eff0cff38caf095445f27c08aaf11a5b862","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/tag.swig","hash":"7cda2822e50b9fee9848a6b81e6c2d1aca830aeb","modified":1542789144000},{"_id":"source/todo/Java▓в╖в▒р│╠╡─╩╟╥╒╩ї.md","hash":"6ac3796ecf229618ac23b514cc1e8fb95ecbb419","modified":1542789142000},{"_id":"source/todo/Netty ╚ы├┼╙ы╩╡╒╜г║╖┬╨┤╬в╨┼ IM ╝┤╩▒═и╤╢╧╡═│▒╩╝╟.md","hash":"d4223f49d8501c8d9d427dbda320de104fad83b8","modified":1542789142000},{"_id":"source/todo/java-phaser.md","hash":"08aeb21977ae1cf39ac45de6308a35449ff85df2","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/.github/CODE_OF_CONDUCT.md","hash":"22f2ccc5522563b67c8663849fc1d6cbae93a8ff","modified":1542789142000},{"_id":"source/todo/java-unsafe-class.md","hash":"6ad2a65c8f9bfb11e2fe1070d47522c07f329a08","modified":1543462919748},{"_id":"themes/hexo-theme-next-6.4.2/.github/ISSUE_TEMPLATE.md","hash":"1e212fe229bd659726b4a3bcf4b5b14e0310ba3a","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/.github/CONTRIBUTING.md","hash":"40b0fd9fdb8586fab98e23f713940e7a2f80e2f9","modified":1542789142000},{"_id":"source/todo/netty-serverside-bootstrap-procedure.md","hash":"9293ea3a789eed09c6303b6fd1ac4ced60141adf","modified":1544710044962},{"_id":"themes/hexo-theme-next-6.4.2/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/.github/PULL_REQUEST_TEMPLATE.md","hash":"36201119490a04107c8179b10202548a9d0e5e60","modified":1542789142000},{"_id":"source/_posts/dubbo-consumer-calling-process-source-code-analysis.md","hash":"ac64795b12aff7de0c9d0a9251b7fd6a60c3cefb","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/.github/stale.yml","hash":"dbd5e6bf89b76ad1f2b081578b239c7ae32755af","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/de.yml","hash":"641e49587d41bb87e4d5932dc3d975754ded7953","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/en.yml","hash":"d66b8b48840443a4f9c72c7696a21e292f685a47","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/fr.yml","hash":"ebcd1f188af8c3f5ef1f0923e794c839fbfae2d4","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/id.yml","hash":"9709a4dbacc56a1571a96b139b872128d6959e90","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/ja.yml","hash":"82afb0a5637ad67065fa5b2624fa56c7c240c3c6","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/it.yml","hash":"4e3adeb10c0fa627935d69ae1783ce0894f5dee5","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/nl.yml","hash":"060efc260c1c529469d739d97dcee79683e8f411","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/ko.yml","hash":"33e065ceb21590b8eb32430a69e76c2f057eb758","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/ru.yml","hash":"720b92a9ec075b68737d296b1f29ad8e01151c85","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/pt-BR.yml","hash":"dc09e290e908744ca28e093dbdd859ca2a20290e","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/tr.yml","hash":"6d2f53d3687a7a46c67c78ab47908accd8812add","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/pt.yml","hash":"53e2a52b9d5dc20c04080acd4f5b954e8699780f","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/zh-CN.yml","hash":"4872eb558ea0729eba300a727186154e9e25cd3a","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/vi.yml","hash":"e2b3b18359ab41d58c64b2002acfedd60a7505a4","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/zh-TW.yml","hash":"dbf4dd87716babb2db4f5332fae9ec190a6f636a","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/languages/zh-HK.yml","hash":"c22113c4a6c748c18093dae56da5a9e8c5b963cd","modified":1542789142000},{"_id":"source/images/Screenshot from 2018-07-20 20-39-27.png","hash":"24334febc9a84ce062cb1c17cc7ec909f153cb65","modified":1542789142000},{"_id":"source/images/Java.png","hash":"fa399f5d32547a48e66eb5c01d1085d08686abd0","modified":1547366747953},{"_id":"source/images/Screenshot from 2018-07-20 21-52-02.png","hash":"2f3d0ff289461ad04ce6d6349d12716fc399b88e","modified":1542789142000},{"_id":"source/images/Screenshot from 2018-07-21 19-41-49.png","hash":"d065904a2cc2bd4c2d67f81c6aa96a9891ddb40d","modified":1542789142000},{"_id":"source/images/Screenshot from 2018-10-02 15-50-13.png","hash":"4189c8672cb762da41a6a746ddfc3a4e719b5cfb","modified":1542789142000},{"_id":"source/images/Screenshot from 2018-10-02 15-49-47.png","hash":"a8408cb997563a9660192a7d2344057eb30bde4c","modified":1542789142000},{"_id":"source/images/dubbo-provider.png","hash":"cfd0779397a2b8d955cac9775a9de33dbb2392bb","modified":1542789142000},{"_id":"source/images/log-manage2.png","hash":"2a37f3d62335a55a0285cf9e3a3f7ca3ab896657","modified":1542789142000},{"_id":"source/images/log-manage1.png","hash":"fb2609c6b62c5c8adf85c2dae83fd9b94ab65279","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542789144000},{"_id":"source/images/1526020447.png","hash":"a4d3d1420c3b196107cf6ac8fecc7872d4561e2f","modified":1542789142000},{"_id":"source/images/Screenshot from 2018-07-21 17-33-12.png","hash":"738918a6f512bdab6acf11a46b134a81f2f782e0","modified":1542789142000},{"_id":"source/images/Screenshot from 2018-11-23 20-17-54.png","hash":"a47b27249177b53f056814ff920c541960a5e16c","modified":1542975476229},{"_id":"source/images/Screenshot from 2018-12-16 19-41-44.png","hash":"f17790b472978af93ed485d187436a04aa518a23","modified":1544960506107},{"_id":"themes/hexo-theme-next-6.4.2/docs/ru/README.md","hash":"caaad965f9d54f82382c934f44a507d37a863fa3","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"e771c5b745608c6fb5ae2fa1c06c61b3699627ec","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"9b512cb820627fcc45c9f77c7a122aa99e021bd5","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/zh-CN/CONTRIBUTING.md","hash":"6ea741f380dc3e90661d12db7e115a94b77643a4","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/zh-CN/INSTALLATION.md","hash":"baca12cc24be082f1db28c7f283493569666321c","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"7214fcd1b5830e62b3ac0836ad2d1b0fa391ae12","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/zh-CN/README.md","hash":"0e6652be1b6bca87479f2601ff89105def200b4c","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/zh-CN/DATA-FILES.md","hash":"67f4a987e7db0ab1ce1ea4c311f2961df07b6681","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"2095d1214a4e519a1d31b67b41c89080fa3285d3","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/zh-CN/MATH.md","hash":"4d68054b062b3c8404b146a155d9624d2d25dd9b","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_custom/head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_macro/post-copyright.swig","hash":"8ff97c3f4eb888207bdc50066053c97d890e0202","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_macro/post-related.swig","hash":"e8dfb86eb62b9c2bc1435d6d1afa95d3b4c7b931","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_macro/post.swig","hash":"00cd242c032341ab0fb5d7f66d4a9aa652eab183","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_macro/reward.swig","hash":"56733f92352b891b0bb1baca293f68f6c8928b0b","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_macro/sidebar.swig","hash":"a9519b4f82aa516e516317d0447bf5c5c7ffb544","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_macro/wechat-subscriber.swig","hash":"7a9b687087793bf5e218cbc345214f927fa5601a","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/breadcrumb.swig","hash":"4b48fdbfe3bf41ddeda4ff74c1ff17ab9f15c14e","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/comments.swig","hash":"412d2a0e18a237e490e1b8bce5547558768b9da3","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/footer.swig","hash":"ec4f8a69dbb2d8ebab7ef28e342eae543eaee241","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/page-header.swig","hash":"206cbd6ac9ca6a219a8516f59beae25b3c770199","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/pagination.swig","hash":"914155d5d758306cff405beefd4a07973fd8fc77","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_scripts/boostrap.swig","hash":"27fb1d81151b9b79683e488579df19eee7e654d6","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_scripts/commons.swig","hash":"f544e21883d249d5a341c684c97bd25831008f07","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_scripts/noscript.swig","hash":"f8c7e729ad6e72b4c705a2c5d5041589c2b4cc52","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_scripts/vendors.swig","hash":"f134aeb8d5bee351e5277edb92ac694af314b75f","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/bookmark.swig","hash":"ed62ea83d3f2c9db2ea57bf23a7d765ed82504c2","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/copy-code.swig","hash":"c62c37474c8de78cf34e54c6219b503ec28d9815","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/exturl.swig","hash":"53861f78a1fb52e96a43cf6909e1530dcf6cbff8","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/github-banner.swig","hash":"736cb278fa09d3b4ed6f305b56353941ea918793","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/needsharebutton.swig","hash":"debba9b7110f635204a15df148194d4c2fd2668b","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/pangu.swig","hash":"ccf0035086e14dcefa24c2907301edf4c37d5448","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/scroll-cookie.swig","hash":"a174d4a0c9188f9c4a2652f49bfa7a60ad0a83e3","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/scripts/tags/button.js","hash":"510f3711a9c9d3e2a844250647d90e8359e7d130","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/scripts/tags/center-quote.js","hash":"4519ab8e6898f2ee90d05cde060375462b937a7d","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/scripts/tags/exturl.js","hash":"83e48148d2f4f8543f6833effa8a26eb0b60f2f0","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/scripts/tags/full-image.js","hash":"ef2c2985a3edb9f69740740c5bc42d4b692c86fd","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/scripts/tags/group-pictures.js","hash":"aface11629970a5c4ee38aaa15550d2caee59560","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/scripts/tags/include-raw.js","hash":"ab4a82a7246265717556c7a42f897430340b88cf","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/scripts/tags/label.js","hash":"bb502616bfabe85de5de903074ec6afe627f8413","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/scripts/tags/note.js","hash":"bd3310a5890bded1bda9ba3ad6f98ee44ecb101a","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/scripts/tags/tabs.js","hash":"2d257e26718d4011509fd6f530d2ea37e50e3e66","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/main.styl","hash":"2a62e2a11e9cdcc69e538d856d6f9ce228a07c93","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1542789144000},{"_id":"source/images/Screenshot from 2018-11-23 20-22-05.png","hash":"f4befebb63c00930fa6954b6e190c28a85f30415","modified":1542975727228},{"_id":"themes/hexo-theme-next-6.4.2/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/docs/ru/UPDATE-FROM-5.1.X.md","hash":"1a4e41adcf5831057f3f7b3025ed4a5ef7c442b4","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/ru/INSTALLATION.md","hash":"7b2963daac19b0c14f98ebef375d5fbce8fc3f44","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/docs/ru/DATA-FILES.md","hash":"a51de08657f5946f4028b11373280ddc04639525","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_macro/menu/menu-badge.swig","hash":"4eb8e222dc337211efb0d3bbdb5e29af3e6ecdb8","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/header/brand.swig","hash":"19050627bc23b0b2c2e65e7248c0f88468eb8ea5","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/header/index.swig","hash":"c909f6e96373c151dea325bcddfdd8c9522421b6","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/header/menu.swig","hash":"f3ae3168801304af3d80ec3b84264e1d4201cb89","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/header/sub-menu.swig","hash":"3f11ae8e9084f39628cd2006931d39a2069b9dd6","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/search/index.swig","hash":"f6454c452b2e90a8c760321bce7e3dc6119b71fa","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_scripts/pages/post-details.swig","hash":"580e9d9c4d8783ee6200d845ae16c98979bf1ea3","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_scripts/schemes/gemini.swig","hash":"c381f638315a007b1baf5fea879161001fe50cd0","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_scripts/schemes/pisces.swig","hash":"c381f638315a007b1baf5fea879161001fe50cd0","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/busuanzi-counter.swig","hash":"1ce5fa218a44cf6e620583e9013e0b674dd6a989","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/firestore.swig","hash":"8ab040fccba41675bc835973515530af8a51f8bd","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/google-analytics.swig","hash":"cfc932c5db04fef64cc56d3ba0b8ddf3a15a63bd","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/lean-analytics.swig","hash":"bd8382d4f12df207ed52f75f6e5fb06527970167","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/search/localsearch.swig","hash":"71c897f9b107dd0de1b7f649633cf583c206a9db","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/comments/disqus.swig","hash":"2440f1e66cb8e39cc2bacfd783fb6fe904a628e9","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/comments/gitment.swig","hash":"292cdd1059b76d3d10486b71c99d9afb3e59ea44","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/comments/index.swig","hash":"34cc66d4dbada2d561ba6f70fd9a75207c5adbd4","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/comments/livere.swig","hash":"c49a3b10b2f2f64a7ac41fa3d436fd2c8d31cca8","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/comments/valine.swig","hash":"d05e70a416963023ee1978e4168d58bcfd956ed3","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/math/index.swig","hash":"30e9e55d9af2ced6e6b156a042026a8b480f0ab0","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/math/katex.swig","hash":"860de4ce6fccc516d2f779a4b600a4214d8c18e2","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/math/mathjax.swig","hash":"c0c2fd87e71f0beb542aa50c0bc875da5aa5c44b","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/affix.js","hash":"ad343aa406fd8181b5f310434817ce98fc2219e3","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/algolia-search.js","hash":"84906eeae57bd06744dd20160b93eacf658f97e2","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/bootstrap.js","hash":"c7e2a588b679d46379124141bb2f30bc2f3210e2","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/exturl.js","hash":"c48aa4b3c0e578a807fd3661e6cd4f3890777437","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/motion.js","hash":"4c7f94e499743f4cc958f6cd1260a93d765d3051","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/post-details.js","hash":"7d309b771e86c7e22ce11cc25625481ef7d5985c","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/scroll-cookie.js","hash":"c4867626afab749404daf321367f9b6b8e223f69","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/scrollspy.js","hash":"68d3690152c89e7adb08bb35ec28dbda2bd93686","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/utils.js","hash":"fa3aab0ba7bc5138c6f8fac436efe5b8dcb97567","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_variables/Gemini.styl","hash":"8d6cf29f63c90364f4d3c336f7c9bb794b4c46cc","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_variables/Pisces.styl","hash":"72927abd51d3a607a6ba32cf882390792b34e834","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_variables/base.styl","hash":"e27a1034b0cd9821bab094565e9aa9bb80c6fa3e","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_mixins/Pisces.styl","hash":"8aa98ae349908736ba43196c42498fd5bdeb780a","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_mixins/base.styl","hash":"d19b630fa97d0b813d56c692a3575a7dddfaa259","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_macro/menu/menu-item.swig","hash":"aab518204d3125e948796a9ba6b56b09cade2d92","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/head/head-unique.swig","hash":"0b8349710caf9691741a457aa746add35245048e","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_partials/head/head.swig","hash":"09109a5c5a301e7cc5e3c7aec32b0164739fc7d4","modified":1542789142000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/search/algolia-search/assets.swig","hash":"6e076b5e183eedf425a445e99851f938789c3194","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/outline/outline.styl","hash":"fbb6be577529c750ef7c872fe7abdc7ab0faf0f8","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/scaffolding/base.styl","hash":"e81b78ecbbf4b709583f393e2b0e8a4f74bacc28","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/scaffolding/mobile.styl","hash":"ab775f23ad475efb25376b5aad752ae8b56cfd8c","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/scaffolding/tables.styl","hash":"60179df0e5c9f7c2e9fda046040536c5d8b02f65","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Gemini/index.styl","hash":"7e4e499964c2112d47e6f9d2b6e87c31ec8269e2","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Mist/_base.styl","hash":"d0e9065b0dbbc01811259f0597d1790268b4881b","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Mist/_menu.styl","hash":"f3aa863adf972569b72f2df6bc6a914e7daace99","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa6c00fdaf8f0ca3b690a5a556671745fb67e2c9","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Mist/index.styl","hash":"2ccb9bdc309b7c1ef183a3dbb0a4621bec54a328","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Muse/_menu.styl","hash":"3cc7646583218d16925ced7b70865e63a901d4a7","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Muse/index.styl","hash":"b26f8a3394d8357a5bfd24d9f8bf62d7b4063ebb","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Pisces/_layout.styl","hash":"ccf5a4761cb0ce451b5e994cfabf8769248a45c1","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Pisces/_menu.styl","hash":"cc961108b12ab97d9216606ceb1cd1cd31ab20f0","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Pisces/_sidebar.styl","hash":"df16dc995eb9ad498df2edcfc3e20528fc9aa133","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Pisces/_sub-menu.styl","hash":"be72740313a9a0477b8a22f62e4c8ffa6d23a2e5","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Pisces/index.styl","hash":"a558803ca81cceae2bdc22c18ef638fcc023681b","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/js/src/schemes/pisces.js","hash":"debe13071e1b5a61ba5045fc73e4e0c8c41d194c","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/footer/footer.styl","hash":"7dd247c8869fdefb5a007045d00f3ef8ceecf300","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/header/header.styl","hash":"34f5ac3c1ed2dd31e9297cc4c0733e71bc2e252f","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/header/github-banner.styl","hash":"3f3d2a43d1a326bad25b633c8ec9ddd87867224c","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/highlight/highlight.styl","hash":"5a3b94bf978a9259d0a3a66bdfa8d7aa336a7934","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/pages/pages.styl","hash":"ad4cae23c8e383f4fabc9a2a95bca6055020d22e","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-expand.styl","hash":"317c9ceda655e9dc373ce8e7b71d20b794fce9a4","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-meta.styl","hash":"330c8884efb5612e7eb03986d87d29e8b0651974","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-reading_progress.styl","hash":"82bc7fa5d38d98e98cc25f9a73189024fda25e63","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-reward.styl","hash":"ff50a32ae6fea5fcdf2939dc9b01e1eb76cc73f0","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-title.styl","hash":"5e6318eea2dfe7d804af9a0b74a0f882a2dac5e0","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post-widgets.styl","hash":"5c3141d58970a0614896b6a62fd7a8a8caf4e401","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/post/post.styl","hash":"81b8d74f417feda024bcdd8020a5623af6dc075a","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"fa57ec9a6f1943c0558856dfba2d6b8faca0cd4d","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/sidebar/sidebar-author.styl","hash":"00a504620c454287111dc0ace64c989e1ff97f54","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"9e05a2232faabb41bcebb51d545d897a76f077da","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/sidebar/sidebar.styl","hash":"94d76e6da600a36d80e2470326ebb6b3be447ccb","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/tags/full-image.styl","hash":"2d58ad90f148e845bc7023751a7a13260600f8d6","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/tags/tags.styl","hash":"f1640253cbbf71d0c04c34c25bd61045894f98bc","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/third-party/algolia-search.styl","hash":"f4d8144c22544bdb89787c14ab9d39578dae4b7c","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/third-party/related-posts.styl","hash":"acfdd76b1c90d2e384affb3d0006a39b524609d2","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/third-party/third-party.styl","hash":"c31fbaec7e6373ecfb8588500b972d451695a6ad","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1542789144000},{"_id":"themes/hexo-theme-next-6.4.2/source/css/_common/components/pages/breadcrumb.styl","hash":"630be616447a982413030e561bbd3a80ac14b120","modified":1542789144000},{"_id":"source/images/login-page.png","hash":"68a7799c6d4eb77d8d43ff6dbe9c644f48ca370f","modified":1542789142000},{"_id":"public/style.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1545913372604},{"_id":"public/search.xml","hash":"7a20ffe88d479c86ac5baf133eae7ec13afbd169","modified":1547179687330},{"_id":"public/tags/index.html","hash":"e9bd8aecde60f22268f356b39374d3c4ed527608","modified":1547206493865},{"_id":"public/categories/index.html","hash":"850cce2c1c4ac9e6e38d7bb628ce79f01cb36b81","modified":1547206493864},{"_id":"public/about/index.html","hash":"aa9a805195201c88cfd545890341217d69c5d262","modified":1547206493864},{"_id":"public/todo/java-phaser.html","hash":"8bb870e41f8a85a3155a13968af3a03fffce1ab3","modified":1547206493865},{"_id":"public/todo/java-unsafe-class.html","hash":"e0fe7382326ea38a7cf1b38a814d221ea349d85c","modified":1547206493865},{"_id":"public/todo/netty-serverside-bootstrap-procedure.html","hash":"a15faf0f3aadc18f515863fb93a7ffde4379a435","modified":1547206493865},{"_id":"public/2018/12/26/java-basic-knowledge-summary/index.html","hash":"64142878dbf8b674f92b1217fafa25428005e67d","modified":1547206493865},{"_id":"public/todo/Netty ╚ы├┼╙ы╩╡╒╜г║╖┬╨┤╬в╨┼ IM ╝┤╩▒═и╤╢╧╡═│▒╩╝╟.html","hash":"fdba75a1904c5ff2af31385e59b86009b7249f60","modified":1547206493865},{"_id":"public/todo/Java▓в╖в▒р│╠╡─╩╟╥╒╩ї.html","hash":"b750748e8e2d688fae4db7f57bda27c59271d6d5","modified":1547206493865},{"_id":"public/2018/11/22/java-abstract-queued-synchronizer/index.html","hash":"ad8537f56ab4e477b66144261e09a444ed876894","modified":1547206493865},{"_id":"public/2018/12/08/java-memory-mapped-file/index.html","hash":"af63d0e0c1d05e67df2c4d7b545f2f51bf0ea6c0","modified":1547206493865},{"_id":"public/2018/10/17/dubbo-router-analysis/index.html","hash":"f6904dd86274e2b6ed51636600c3ca113cdd3cc4","modified":1547206493865},{"_id":"public/2018/10/15/java-blocking-queue/index.html","hash":"95be009787c483d94c33f0b30aed2e7ec4842e76","modified":1547206493866},{"_id":"public/2018/12/15/linux-direct-io/index.html","hash":"1b2820338553270780fff483457a866a94eb40eb","modified":1547206493865},{"_id":"public/2018/12/05/java-copy-on-write/index.html","hash":"4a17972eaead7420f7929e161c54ec65cbceb429","modified":1547206493865},{"_id":"public/2018/10/11/java-thread-pool/index.html","hash":"abebf2146092106776f12df0ec1bd3f978caab70","modified":1547206493866},{"_id":"public/2018/09/24/dubbo-provider-request-and-response-analysis/index.html","hash":"22ba5056fd00fb5800b4cf99ce0ca91eb9d220e5","modified":1547206493866},{"_id":"public/2018/11/08/java-phaser/index.html","hash":"7db5c1879dcd94371f3a34ae405d9cceddb7f256","modified":1547206493865},{"_id":"public/2018/09/22/dubbo-gracefully-shutdown/index.html","hash":"c99fea53545a858729504d3547a1ef16080a0541","modified":1547206493866},{"_id":"public/2018/09/18/dubbo-cluster-fault-tolerance/index.html","hash":"4c9ddebd5e48e50614deb97cbccc02937580a818","modified":1547206493866},{"_id":"public/2018/09/10/dubbo-loadbalance-strategy/index.html","hash":"58ff32649b035c79d836c5e7f99e8c9d5d426ffb","modified":1547206493866},{"_id":"public/2018/09/09/dubbo-provider-calling-process-source-code-analysis/index.html","hash":"b39538afa6a786d8a4b0eac8e3f2619d2b12b4b1","modified":1547206493866},{"_id":"public/2018/08/13/dubbo-basing-on-spring-framework-analysis/index.html","hash":"b60a0a074e18beab8f50bd12c890db9e1a9042fb","modified":1547206493867},{"_id":"public/2018/08/09/dubbo-spi-analysis/index.html","hash":"f039f2b360f8b794a862937fc58b5170769518b3","modified":1547206493867},{"_id":"public/2018/08/05/dubbo-consumer-calling-process-source-code-analysis/index.html","hash":"ef9be2bc0f2bd8fe7237d651bfb772ca1333d1f6","modified":1547206493867},{"_id":"public/2018/09/06/netty-future-and-promise/index.html","hash":"67c7ec7e9ed9218ee577c15476bf03746e483289","modified":1547206493867},{"_id":"public/2018/07/25/spring-cloud-microservice-demo/index.html","hash":"75c5629e9cff5272fe370296dc22d8e7d196450b","modified":1547206493867},{"_id":"public/2018/08/03/java-spi-introduction/index.html","hash":"e00f7bd21ee1437b939db151060a42216110f0b5","modified":1547206493867},{"_id":"public/2018/07/24/netty-bytebuf-data-container/index.html","hash":"75d1cda0640fce0d09c3efda95854a1ecf349826","modified":1547206493867},{"_id":"public/2018/08/02/dubbo-proxy-basing-on-javassist/index.html","hash":"3d198ac21c525539861d5a37471ee0648f79d460","modified":1547206493867},{"_id":"public/2018/07/22/netty-transport-methods/index.html","hash":"4ce183d944a389c58ee486de8676287ed3ea7c41","modified":1547206493867},{"_id":"public/2018/07/20/netty-components-design/index.html","hash":"3f3d261909fc1908f10756058f637675788719ce","modified":1547206493867},{"_id":"public/2018/06/26/netty-thread-model/index.html","hash":"4b8f783691843eca691248c7c2c9bd6f796f9b1e","modified":1547206493867},{"_id":"public/2018/05/19/http/index.html","hash":"feb2f3d664b5a288968a908800368b16cdcb0d52","modified":1547206493867},{"_id":"public/2018/05/10/netty-introduction/index.html","hash":"cd38bbb5636e23f59b5e0ca1c04d2b30d884ef0c","modified":1547206493867},{"_id":"public/2018/04/19/Java-NIO-and-BIO/index.html","hash":"4285f8b085d373e7b1def6ca0c83535307b8e874","modified":1547206493867},{"_id":"public/2018/04/12/LruCache-On-Map-And-LinkedList/index.html","hash":"2c6afef1ea0ac7004f2f8bd23eae17a1bc000777","modified":1547206493868},{"_id":"public/2018/07/04/user-thread-and-daemon-thread/index.html","hash":"b6d7fcc1b7275e8e947af5d376b2df39332fded6","modified":1547206493867},{"_id":"public/2018/03/31/Distributed-Lock-Based-On-Zookeeper/index.html","hash":"a65d2ce5310680195810ad82b65bacbe645e1604","modified":1547206493868},{"_id":"public/2018/04/01/Java-Class-and-Object-Initializing-Process/index.html","hash":"6fc061dbc949edba6f9ebe1f4858f86e2cf64efb","modified":1547206493868},{"_id":"public/2017/11/03/Basing-on-Spring-SpringMVC-MyBatis-Druid-Shrio-developing-web-system/index.html","hash":"9e177faa33f461704259c3464d29948fe5006b47","modified":1547206493868},{"_id":"public/2018/03/22/Distributed-Systems-Technologies/index.html","hash":"fe84130a0ffc7a774f36703493b659ad0f4c50d2","modified":1547206493868},{"_id":"public/2017/06/26/MyBatis-tutorial/index.html","hash":"19b196788b1851256d3d283c8ecb0548d0d82576","modified":1547206493868},{"_id":"public/2018/03/25/How-to-understand-the-DeadLock/index.html","hash":"89df5aa3fd70dec66a5daa9bcff0df3271d3b7ad","modified":1547206493868},{"_id":"public/2017/05/26/java-creating-thread/index.html","hash":"593c5a6161f2c5b5bc7df9c49691bf333745ab0a","modified":1547206493868},{"_id":"public/2017/04/26/log4j-tutorial/index.html","hash":"3dae53027b933b38fcc91b09d4828f2c7b94acae","modified":1547206493868},{"_id":"public/2017/07/26/analyse-the-source-code-of-Timer/index.html","hash":"c6d3aec9e01ae3e2961a9d625cadaf70d2a1ed64","modified":1547206493868},{"_id":"public/2016/11/26/CentOS7-login/index.html","hash":"b7fe834050e523e71d9a760e8898b12cacd64891","modified":1547206493868},{"_id":"public/2017/02/26/java-Collections-sort-method/index.html","hash":"a023a34e8cf137c1c50a2a72505f5889e9e56995","modified":1547206493868},{"_id":"public/2016/10/26/Spring-bean-init-destory/index.html","hash":"0f655cba808b16f64fceb8326df22e05d6e05c71","modified":1547206493869},{"_id":"public/2016/11/20/CentOS7-kvm/index.html","hash":"3127db523d9961f13268d7495fb3a6a7ca70be67","modified":1547206493868},{"_id":"public/2016/09/26/Autopacking and Autounpacking/index.html","hash":"a15e32c30a92ab7e4bae42c3228f3e42f315eeff","modified":1547206493869},{"_id":"public/archives/index.html","hash":"0b28f9be00cb07834f68581a0cfba90f13f26606","modified":1547206493870},{"_id":"public/archives/2016/index.html","hash":"29d12a9238eaccba2bac0689d27876d34ac99b01","modified":1547206493870},{"_id":"public/2016/07/26/java-constant-pool/index.html","hash":"bee77245cc5cbed90c53c94c5bce7c22ec13df9b","modified":1547206493869},{"_id":"public/2016/06/26/java-three-point/index.html","hash":"2067694032db41170465aae0f8c7427b5384bfdb","modified":1547206493869},{"_id":"public/2016/11/16/libvirt-kvm/index.html","hash":"2ef9cef1caf64eac9d7aa98f362b655fcba72cec","modified":1547206493869},{"_id":"public/archives/2016/06/index.html","hash":"f756960c1c24bdfb89b78a2167fa156b985124ad","modified":1547206493870},{"_id":"public/archives/2016/07/index.html","hash":"5ae1d0054e0b281545688b3158dae08d39aaac9c","modified":1547206493870},{"_id":"public/archives/2017/index.html","hash":"2536991077f69956532dfce18b53ac4c17359d86","modified":1547206493870},{"_id":"public/archives/2016/09/index.html","hash":"c3b5fb9bcaece35a06e238e10b4fb5b18f7fd03a","modified":1547206493870},{"_id":"public/archives/2016/10/index.html","hash":"9cbb39fce66aceb86402c2dd1332dc2a9375c391","modified":1547206493870},{"_id":"public/archives/2017/02/index.html","hash":"8f0033924b5d204e64f44687de6e34e3fb5807bb","modified":1547206493870},{"_id":"public/archives/2017/04/index.html","hash":"d78ff26a67293d8d594242deda5fda8e3b063738","modified":1547206493870},{"_id":"public/archives/2016/11/index.html","hash":"a3e5c0b7e4a165f9fda622a7f188736ba52e9acb","modified":1547206493870},{"_id":"public/archives/2017/05/index.html","hash":"f5842258d568c7a6eaacef96f99811d27354fd3e","modified":1547206493870},{"_id":"public/archives/2018/index.html","hash":"443abfad78eca71117ecca489ed1267d4086f38f","modified":1547206493871},{"_id":"public/archives/2017/06/index.html","hash":"8d70a36fd5b00ca807c2d264858bb532b19603e8","modified":1547206493870},{"_id":"public/archives/2018/03/index.html","hash":"67223b31d1b05110dd910a332c8a0e5760268b69","modified":1547206493871},{"_id":"public/archives/2017/07/index.html","hash":"29ec2a89929d9a95fdc5f7dd848f301b729f5bb9","modified":1547206493871},{"_id":"public/archives/2017/11/index.html","hash":"2aca2f73eb54eaa66f6265ce2d17b731d70e00d9","modified":1547206493871},{"_id":"public/archives/2018/04/index.html","hash":"e20a575e7d9cc6b5685db7923e297e06c42f2148","modified":1547206493871},{"_id":"public/archives/2018/05/index.html","hash":"a32b5cf75c015d8339898da976b2a9e44240d843","modified":1547206493871},{"_id":"public/archives/2018/06/index.html","hash":"6542b983e9b67a39dbd47740118020db1b9d7f92","modified":1547206493871},{"_id":"public/archives/2018/07/index.html","hash":"3a3a5e922bdbe715e74fe9aea83513a2da890e6c","modified":1547206493871},{"_id":"public/archives/2018/08/index.html","hash":"601f0cd35f3020f86e32c33880c6cf7c70afc457","modified":1547206493871},{"_id":"public/archives/2018/09/index.html","hash":"3dfa808532a4ba6ec43f5179fa483e8420bfff65","modified":1547206493871},{"_id":"public/archives/2018/10/index.html","hash":"2a2426078e63b6697a9fbef399ed2f3031efb6eb","modified":1547206493871},{"_id":"public/archives/2018/11/index.html","hash":"1a2ee53f41e1f661dc0122b5d3c8ded417d67fd8","modified":1547206493871},{"_id":"public/tags/java/index.html","hash":"f16c090bcc3af86f1b18bc995b33ce2558fd70a8","modified":1547206493871},{"_id":"public/categories/WebSystem/index.html","hash":"beb4acca6ae41c168f7998b47f5cb1c564156056","modified":1547206493870},{"_id":"public/categories/java/index.html","hash":"e307b872ac869953cd1ea24824bd716f5bc6c46e","modified":1547206493870},{"_id":"public/tags/java/page/3/index.html","hash":"3f38c484418d44da40fb55b702c79c7b2b9a6bf3","modified":1547206493871},{"_id":"public/tags/java/page/2/index.html","hash":"c3b33fc2083bd1dd7cfd31351fe930d08218dfa3","modified":1547206493871},{"_id":"public/tags/CentOS/index.html","hash":"a0c10057ed185df2d03e9d35a554b024076915e0","modified":1547206493872},{"_id":"public/tags/zookeeper/index.html","hash":"41458d9e35c5abeb1c33af3315b9c2211ce1f8fb","modified":1547206493872},{"_id":"public/tags/MutliThread/index.html","hash":"84d9f2ad9d49b5370f8c6ce06ed6adf97b71ec78","modified":1547206493872},{"_id":"public/tags/NIO/index.html","hash":"47299b593701c488ceb2202fca016cc3baca9235","modified":1547206493872},{"_id":"public/tags/WebSystem/index.html","hash":"e73484878b691c82bcc4cc49bb65dee324f9cb22","modified":1547206493872},{"_id":"public/tags/MyBatis3/index.html","hash":"9491a1880f925348b2a61507a7009514fad3b285","modified":1547206493872},{"_id":"public/tags/LRU/index.html","hash":"249c11602f708456052e0b8b6c8f68f47ce33fe0","modified":1547206493872},{"_id":"public/tags/dubbo/index.html","hash":"656f2643f0089ae21203c3e2ac60cf1efd57198a","modified":1547206493872},{"_id":"public/tags/Spring/index.html","hash":"f5792c64b25f7ec2568cd6089ea7dcb7decd65ed","modified":1547206493872},{"_id":"public/tags/dubbo/page/2/index.html","hash":"a22599ee6087d16bbd3c0893f4fed7d15db9d270","modified":1547206493872},{"_id":"public/tags/java/page/4/index.html","hash":"b9691462e0b874c8cd644f3ab5c475b6176d3da0","modified":1547206493872},{"_id":"public/archives/2018/12/index.html","hash":"24e79a9b37972fd4aaef8cb6935e2f959b98d392","modified":1547206493871},{"_id":"public/tags/javassist/index.html","hash":"a1f7667722da9e79f2f7f9a946cab23daa275291","modified":1547206493872},{"_id":"public/tags/http/index.html","hash":"3f068eaca83ce4867be815bb735e9bb39a4e75a4","modified":1547206493872},{"_id":"public/tags/SPI/index.html","hash":"aceba8aa7cae104523101f1d5c496582d01b2987","modified":1547206493872},{"_id":"public/tags/虚拟化/index.html","hash":"6d203587516ba88bb92d13c9c37078f053e533b5","modified":1547206493873},{"_id":"public/tags/KVM/index.html","hash":"3a217ca937c31e9633aeaccf6bceff6b8bdc0038","modified":1547206493873},{"_id":"public/tags/网络配置/index.html","hash":"c6fa18020fb814685fb7744280932aa98b91cd13","modified":1547206493873},{"_id":"public/tags/Linux/index.html","hash":"43c58a1d4d7f11b76855b0343583a61bfb639392","modified":1547206493873},{"_id":"public/tags/Netty/index.html","hash":"358123fe86cab42643e568bbca6e282a231afa4d","modified":1547206493873},{"_id":"public/tags/Netty/page/2/index.html","hash":"9ba528aa9711bd3654d6b1eaac6b3b3e125913bc","modified":1547206493873},{"_id":"public/tags/AQS/index.html","hash":"f496189c4ac18663e5f84a701c3bc43bbf24455f","modified":1547206493872},{"_id":"public/tags/Spring-Cloud/index.html","hash":"2b760e39a2edc5b5bb6d94f48f74154c0708a7b8","modified":1547206493873},{"_id":"public/tags/log4j/index.html","hash":"ba8bd87a986e48237345ed22836c65327623c652","modified":1547206493873},{"_id":"public/index.html","hash":"0f994c81e3ef976045a20a9d57029fbe860e899d","modified":1547206493869},{"_id":"public/page/2/index.html","hash":"4cbc433e1585760d751a322ce79ee2b3b78f8459","modified":1547206493869},{"_id":"public/tags/Micro-Service/index.html","hash":"61d2a330c2cca2f649a85a88893ad02e0328b15e","modified":1547206493873},{"_id":"public/page/3/index.html","hash":"4a78162542df289fadc1993806a653f7bdb41938","modified":1547206493869},{"_id":"public/page/4/index.html","hash":"42c025a21cd6359ca8e196641463daccd26f6e48","modified":1547206493869},{"_id":"public/tags/mmap/index.html","hash":"effe8ab7053788a8d3531a271c0433a0ddd4eb97","modified":1547206493872},{"_id":"public/tags/DirectIO/index.html","hash":"f2bdb2fd257eece57b3b9ad5be681d743b5c8cc0","modified":1547206493873},{"_id":"public/page/5/index.html","hash":"65d2fbd1a631418927e204d5356e7844baefe3a0","modified":1547206493869},{"_id":"public/page/6/index.html","hash":"c131a7029f5ec4e4cc08efbfa660c81affd67eb4","modified":1547206493869},{"_id":"public/page/7/index.html","hash":"de64df60b48e369333c379fd5c5077b675260289","modified":1547206493869},{"_id":"public/page/8/index.html","hash":"032bb8ccdf6eb54445aae78dc6d810b8716f1a77","modified":1547206493869},{"_id":"public/page/9/index.html","hash":"ac9f3501aea75bd853872c2b2a29fd68ad6a08c9","modified":1547206493869},{"_id":"public/page/10/index.html","hash":"9a2115c704020603e16777c3b89a3c1c88e20461","modified":1547206493870},{"_id":"public/2018/12/27/java-cas-and-lock-free/index.html","hash":"d74f9b6792a9bec19ca83f89bc6dee07178b6343","modified":1547206493865},{"_id":"public/favicon.ico","hash":"fba3f9ecad58e0bca7379ecffda1ddfe0f0172d3","modified":1545913378037},{"_id":"public/images/0.png","hash":"136a21d243e62548ec5445d7e685b9378d20eddf","modified":1545913378037},{"_id":"public/images/1.png","hash":"97b2c7c92207e427db659e93ab349b5b4e0f8e41","modified":1545913378037},{"_id":"public/images/1525845072.png","hash":"3317891f2cdc4e8abb58986706a5ae01ceeb1eee","modified":1545913378037},{"_id":"public/images/1525844998.png","hash":"697fa9ff08d6867febb19447885b715c402379d2","modified":1545913378037},{"_id":"public/images/AnnotationBean.png","hash":"cfb15872d79398cd99a4212d453a2978dc9e9034","modified":1545913378037},{"_id":"public/images/1526016569.png","hash":"7b9d46009317846a84ea7721aca8087fc9e734f9","modified":1545913378037},{"_id":"public/images/BlockingQueue.png","hash":"35161ec06793aac12e9586030485bff1d150dc07","modified":1545913378037},{"_id":"public/images/AbstractConfig.png","hash":"51a914beb8b51d9519073ffe61eac80d860d05e3","modified":1545913378037},{"_id":"public/images/Cluster.png","hash":"c9c4bd2a50f4b1bed6d7b0ebd82eddf1d16f2614","modified":1545913378037},{"_id":"public/images/DefaultPromise.png","hash":"3cfcfa7822991e79e77ebeba2d3a17e16c28035b","modified":1545913378037},{"_id":"public/images/RejectedExecutionHandler.png","hash":"999af7456ebcbd6b46c5bb2746ee4b32a74e46a6","modified":1545913378038},{"_id":"public/images/Screenshot from 2018-07-20 21-01-11.png","hash":"318fac8121f913a6e487d6cc62da2f073ec04a62","modified":1545913378038},{"_id":"public/images/ReferenceBean.png","hash":"09c507c87eb26a7080520e4c2ad16eaf161a8543","modified":1545913378038},{"_id":"public/images/Screenshot from 2018-09-18 11-16-13.png","hash":"cd78d5d44b9cd20bcc694e5d320a15333243343f","modified":1545913378038},{"_id":"public/images/Screenshot from 2018-07-24 16-02-04.png","hash":"a68c06176bff715c9347e8a566a14dc910a18df3","modified":1545913378038},{"_id":"public/images/Screenshot from 2018-10-17 16-41-11.png","hash":"b7678e6c1fbd942b3beacbf63ab9b1b45fae8f20","modified":1545913378038},{"_id":"public/images/Screenshot from 2018-12-16 19-34-34.png","hash":"8fd412992c1c5f03aeb8d59f0704f5b9356a9855","modified":1545913378038},{"_id":"public/images/Screenshot from 2018-12-16 19-40-43.png","hash":"1dd74af351912dd0a053c3e993f5d59ee2d879fe","modified":1545913378038},{"_id":"public/images/ServiceBean.png","hash":"23eabe851e16ed108427d00293243c51793e99d4","modified":1545913378038},{"_id":"public/images/Screenshot from 2018-12-16 19-42-31.png","hash":"1d989c1f6341a9a6297d8b137aa0752afc8884cd","modified":1545913378038},{"_id":"public/images/Screenshot from 2018-12-16 19-43-19.png","hash":"e18ba7c9eba6f31df4d1ab89989e8009e34a6727","modified":1545913378039},{"_id":"public/images/main-page.png","hash":"5f0d1c352b8d8c8de85510fdcec04fe403cfc0d3","modified":1545913378039},{"_id":"public/images/menu-manage.png","hash":"fcdf35a3cbf051eaf2f3e7fce855329e2be9e420","modified":1545913378039},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1545913378039},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1545913378039},{"_id":"public/images/Screenshot from 2018-12-16 19-41-44.png","hash":"f17790b472978af93ed485d187436a04aa518a23","modified":1545913378039},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1545913378039},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1545913378039},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1545913378039},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1545913378039},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1545913378039},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1545913378039},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1545913378039},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1545913378039},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1545913378039},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1545913378039},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545913378039},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1545913378039},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1545913378039},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1545913378039},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1545913378039},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1545913378039},{"_id":"public/images/Screenshot from 2018-07-20 20-39-27.png","hash":"24334febc9a84ce062cb1c17cc7ec909f153cb65","modified":1545913378835},{"_id":"public/images/Java.png","hash":"fa399f5d32547a48e66eb5c01d1085d08686abd0","modified":1547366763447},{"_id":"public/images/Screenshot from 2018-07-20 21-52-02.png","hash":"2f3d0ff289461ad04ce6d6349d12716fc399b88e","modified":1545913378837},{"_id":"public/images/Screenshot from 2018-07-21 19-41-49.png","hash":"d065904a2cc2bd4c2d67f81c6aa96a9891ddb40d","modified":1545913378838},{"_id":"public/images/Screenshot from 2018-10-02 15-50-13.png","hash":"4189c8672cb762da41a6a746ddfc3a4e719b5cfb","modified":1545913378838},{"_id":"public/images/Screenshot from 2018-10-02 15-49-47.png","hash":"a8408cb997563a9660192a7d2344057eb30bde4c","modified":1545913378838},{"_id":"public/images/dubbo-provider.png","hash":"cfd0779397a2b8d955cac9775a9de33dbb2392bb","modified":1545913378838},{"_id":"public/images/log-manage2.png","hash":"2a37f3d62335a55a0285cf9e3a3f7ca3ab896657","modified":1545913378838},{"_id":"public/images/log-manage1.png","hash":"fb2609c6b62c5c8adf85c2dae83fd9b94ab65279","modified":1545913378838},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1545913378840},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1545913378840},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1545913378840},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1545913378840},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1545913378840},{"_id":"public/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1545913378840},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1545913378840},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1545913378840},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1545913378840},{"_id":"public/js/src/utils.js","hash":"e437eff1d3781c4a1aec9ff2060565524a37c983","modified":1545913378840},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1545913378840},{"_id":"public/css/main.css","hash":"8971c7fe94c5f3fb47ec38d3654d3c6add910f34","modified":1545913378840},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1545913378840},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1545913378840},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1545913378840},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1545913378840},{"_id":"public/images/1526020447.png","hash":"a4d3d1420c3b196107cf6ac8fecc7872d4561e2f","modified":1545913378840},{"_id":"public/images/Screenshot from 2018-07-21 17-33-12.png","hash":"738918a6f512bdab6acf11a46b134a81f2f782e0","modified":1545913378840},{"_id":"public/images/Screenshot from 2018-11-23 20-17-54.png","hash":"a47b27249177b53f056814ff920c541960a5e16c","modified":1545913378841},{"_id":"public/js/src/schemes/pisces.js","hash":"ab3932fa3637a5e23ae6287e78fbfeb54f2c85d2","modified":1545913378846},{"_id":"public/images/Screenshot from 2018-11-23 20-22-05.png","hash":"f4befebb63c00930fa6954b6e190c28a85f30415","modified":1545913378846},{"_id":"public/images/login-page.png","hash":"68a7799c6d4eb77d8d43ff6dbe9c644f48ca370f","modified":1545913378850},{"_id":"source/images/Screenshot from 2018-12-27 20-39-35.png","hash":"2827e64842f6b77e51fe9cc9d126d5bf08abe5b6","modified":1545914408828},{"_id":"public/images/Screenshot from 2018-12-27 20-39-35.png","hash":"2827e64842f6b77e51fe9cc9d126d5bf08abe5b6","modified":1545914605446}],"Category":[{"name":"WebSystem","_id":"cjq6kwn4q000pzjia4ik72n59"},{"name":"java","_id":"cjq6kwn5s0037zjia78umicd3"}],"Data":[],"Page":[{"_content":"","source":"style.css","raw":"","date":"2018-11-22T01:08:55.716Z","updated":"2018-11-21T08:32:22.000Z","path":"style.css","layout":"false","title":"","comments":1,"_id":"cjq6kwmz70000zjiat14ysdyv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2017-07-22T09:46:23.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"title: 分类\ndate: 2017-07-22 17:46:23\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-11-21T08:32:22.000Z","path":"categories/index.html","layout":"page","_id":"cjq6kwn4c0002zjiaxtpvrdac","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"### 帅俊岚\n\n[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/ShuaiJunlan) [![](https://img.shields.io/twitter/follow/ShuaiJunlan.svg?label=Follow&style=social&logoWidth=0)](https://twitter.com/intent/follow?screen_name=ShuaiJunlan)\n\n\n","source":"about/index.md","raw":"### 帅俊岚\n\n[![Tweet](https://img.shields.io/twitter/url/http/shields.io.svg?style=social)](https://twitter.com/ShuaiJunlan) [![](https://img.shields.io/twitter/follow/ShuaiJunlan.svg?label=Follow&style=social&logoWidth=0)](https://twitter.com/intent/follow?screen_name=ShuaiJunlan)\n\n\n","date":"2019-01-04T06:29:03.298Z","updated":"2019-01-04T06:29:03.298Z","path":"about/index.html","_id":"cjq6kwn4e0004zjiauejr13zi","title":"","comments":1,"layout":"page","content":"<h3 id=\"帅俊岚\"><a href=\"#帅俊岚\" class=\"headerlink\" title=\"帅俊岚\"></a>帅俊岚</h3><p><a href=\"https://twitter.com/ShuaiJunlan\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/twitter/url/http/shields.io.svg?style=social\" alt=\"Tweet\"></a> <a href=\"https://twitter.com/intent/follow?screen_name=ShuaiJunlan\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/twitter/follow/ShuaiJunlan.svg?label=Follow&amp;style=social&amp;logoWidth=0\" alt=\"\"></a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"帅俊岚\"><a href=\"#帅俊岚\" class=\"headerlink\" title=\"帅俊岚\"></a>帅俊岚</h3><p><a href=\"https://twitter.com/ShuaiJunlan\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/twitter/url/http/shields.io.svg?style=social\" alt=\"Tweet\"></a> <a href=\"https://twitter.com/intent/follow?screen_name=ShuaiJunlan\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/twitter/follow/ShuaiJunlan.svg?label=Follow&amp;style=social&amp;logoWidth=0\" alt=\"\"></a></p>\n"},{"title":"标签","date":"2017-07-22T09:51:43.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: 标签\ndate: 2017-07-22 17:51:43\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-11-21T08:32:22.000Z","path":"tags/index.html","layout":"page","_id":"cjq6kwn4g0007zjiacnzrdvte","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"#### Java并发编程的是艺术\n\n* 不要将获取锁的过程写在try块中，因为如果在锁获取（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放；\n* ReentrantReadWriteLock，锁降级中读锁的获取是否有必要呢？","source":"todo/Java▓в╖в▒р│╠╡─╩╟╥╒╩ї.md","raw":"#### Java并发编程的是艺术\n\n* 不要将获取锁的过程写在try块中，因为如果在锁获取（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放；\n* ReentrantReadWriteLock，锁降级中读锁的获取是否有必要呢？","date":"2018-11-22T01:08:55.716Z","updated":"2018-11-21T08:32:22.000Z","path":"todo/Java▓в╖в▒р│╠╡─╩╟╥╒╩ї.html","title":"","comments":1,"layout":"page","_id":"cjq6kwn4i0009zjian5bsxgda","content":"<h4 id=\"Java并发编程的是艺术\"><a href=\"#Java并发编程的是艺术\" class=\"headerlink\" title=\"Java并发编程的是艺术\"></a>Java并发编程的是艺术</h4><ul>\n<li>不要将获取锁的过程写在try块中，因为如果在锁获取（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放；</li>\n<li>ReentrantReadWriteLock，锁降级中读锁的获取是否有必要呢？</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Java并发编程的是艺术\"><a href=\"#Java并发编程的是艺术\" class=\"headerlink\" title=\"Java并发编程的是艺术\"></a>Java并发编程的是艺术</h4><ul>\n<li>不要将获取锁的过程写在try块中，因为如果在锁获取（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放；</li>\n<li>ReentrantReadWriteLock，锁降级中读锁的获取是否有必要呢？</li>\n</ul>\n"},{"_content":"### [Netty 入门与实战：仿写微信 IM 即时通讯系统](https://juejin.im/book/5b4bc28bf265da0f60130116)笔记\n\n* Java NIO的selector实现原理？\n* 如何理解下面这句话？\n\n> IO 读写是面向流的，一次性只能从流中读取一个或者多个字节，**并且读完之后流无法再读取，你需要自己缓存数据**。 而 NIO 的读写是面向 Buffer 的，你可以随意读取里面任何一个字节数据，不需要你自己缓存数据，这一切只需要移动读写指针即可。\n\n* 下面是我总结的使用 Netty 不使用 JDK 原生 NIO 的原因\n\n```\n1.使用 JDK 自带的NIO需要了解太多的概念，编程复杂，一不小心 bug 横飞\n2.Netty 底层 IO 模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从 NIO 模型变身为 IO 模型\n3.Netty 自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑\n4.Netty 解决了 JDK 的很多包括空轮询在内的 Bug\n5.Netty 底层对线程，selector 做了很多细小的优化，精心设计的 reactor 线程模型做到非常高效的并发处理\n6.自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手\n7.Netty 社区活跃，遇到问题随时邮件列表或者 issue\n8.Netty 已经历各大 RPC 框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大.\n```\n\n* 回调 `channelRead()` 方法，这里的第二个参数 `msg`，在我们这个场景中，可以直接强转为 `ByteBuf`，为什么 Netty 不直接把这个参数类型定义为 `ByteBuf` ？\n\n","source":"todo/Netty ╚ы├┼╙ы╩╡╒╜г║╖┬╨┤╬в╨┼ IM ╝┤╩▒═и╤╢╧╡═│▒╩╝╟.md","raw":"### [Netty 入门与实战：仿写微信 IM 即时通讯系统](https://juejin.im/book/5b4bc28bf265da0f60130116)笔记\n\n* Java NIO的selector实现原理？\n* 如何理解下面这句话？\n\n> IO 读写是面向流的，一次性只能从流中读取一个或者多个字节，**并且读完之后流无法再读取，你需要自己缓存数据**。 而 NIO 的读写是面向 Buffer 的，你可以随意读取里面任何一个字节数据，不需要你自己缓存数据，这一切只需要移动读写指针即可。\n\n* 下面是我总结的使用 Netty 不使用 JDK 原生 NIO 的原因\n\n```\n1.使用 JDK 自带的NIO需要了解太多的概念，编程复杂，一不小心 bug 横飞\n2.Netty 底层 IO 模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从 NIO 模型变身为 IO 模型\n3.Netty 自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑\n4.Netty 解决了 JDK 的很多包括空轮询在内的 Bug\n5.Netty 底层对线程，selector 做了很多细小的优化，精心设计的 reactor 线程模型做到非常高效的并发处理\n6.自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手\n7.Netty 社区活跃，遇到问题随时邮件列表或者 issue\n8.Netty 已经历各大 RPC 框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大.\n```\n\n* 回调 `channelRead()` 方法，这里的第二个参数 `msg`，在我们这个场景中，可以直接强转为 `ByteBuf`，为什么 Netty 不直接把这个参数类型定义为 `ByteBuf` ？\n\n","date":"2018-11-22T01:08:55.716Z","updated":"2018-11-21T08:32:22.000Z","path":"todo/Netty ╚ы├┼╙ы╩╡╒╜г║╖┬╨┤╬в╨┼ IM ╝┤╩▒═и╤╢╧╡═│▒╩╝╟.html","title":"","comments":1,"layout":"page","_id":"cjq6kwn4j000czjiap15y2n06","content":"<h3 id=\"Netty-入门与实战：仿写微信-IM-即时通讯系统笔记\"><a href=\"#Netty-入门与实战：仿写微信-IM-即时通讯系统笔记\" class=\"headerlink\" title=\"Netty 入门与实战：仿写微信 IM 即时通讯系统笔记\"></a><a href=\"https://juejin.im/book/5b4bc28bf265da0f60130116\" target=\"_blank\" rel=\"noopener\">Netty 入门与实战：仿写微信 IM 即时通讯系统</a>笔记</h3><ul>\n<li>Java NIO的selector实现原理？</li>\n<li>如何理解下面这句话？</li>\n</ul>\n<blockquote>\n<p>IO 读写是面向流的，一次性只能从流中读取一个或者多个字节，<strong>并且读完之后流无法再读取，你需要自己缓存数据</strong>。 而 NIO 的读写是面向 Buffer 的，你可以随意读取里面任何一个字节数据，不需要你自己缓存数据，这一切只需要移动读写指针即可。</p>\n</blockquote>\n<ul>\n<li>下面是我总结的使用 Netty 不使用 JDK 原生 NIO 的原因</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.使用 JDK 自带的NIO需要了解太多的概念，编程复杂，一不小心 bug 横飞</span><br><span class=\"line\">2.Netty 底层 IO 模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从 NIO 模型变身为 IO 模型</span><br><span class=\"line\">3.Netty 自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑</span><br><span class=\"line\">4.Netty 解决了 JDK 的很多包括空轮询在内的 Bug</span><br><span class=\"line\">5.Netty 底层对线程，selector 做了很多细小的优化，精心设计的 reactor 线程模型做到非常高效的并发处理</span><br><span class=\"line\">6.自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手</span><br><span class=\"line\">7.Netty 社区活跃，遇到问题随时邮件列表或者 issue</span><br><span class=\"line\">8.Netty 已经历各大 RPC 框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大.</span><br></pre></td></tr></table></figure>\n<ul>\n<li>回调 <code>channelRead()</code> 方法，这里的第二个参数 <code>msg</code>，在我们这个场景中，可以直接强转为 <code>ByteBuf</code>，为什么 Netty 不直接把这个参数类型定义为 <code>ByteBuf</code> ？</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Netty-入门与实战：仿写微信-IM-即时通讯系统笔记\"><a href=\"#Netty-入门与实战：仿写微信-IM-即时通讯系统笔记\" class=\"headerlink\" title=\"Netty 入门与实战：仿写微信 IM 即时通讯系统笔记\"></a><a href=\"https://juejin.im/book/5b4bc28bf265da0f60130116\" target=\"_blank\" rel=\"noopener\">Netty 入门与实战：仿写微信 IM 即时通讯系统</a>笔记</h3><ul>\n<li>Java NIO的selector实现原理？</li>\n<li>如何理解下面这句话？</li>\n</ul>\n<blockquote>\n<p>IO 读写是面向流的，一次性只能从流中读取一个或者多个字节，<strong>并且读完之后流无法再读取，你需要自己缓存数据</strong>。 而 NIO 的读写是面向 Buffer 的，你可以随意读取里面任何一个字节数据，不需要你自己缓存数据，这一切只需要移动读写指针即可。</p>\n</blockquote>\n<ul>\n<li>下面是我总结的使用 Netty 不使用 JDK 原生 NIO 的原因</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.使用 JDK 自带的NIO需要了解太多的概念，编程复杂，一不小心 bug 横飞</span><br><span class=\"line\">2.Netty 底层 IO 模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从 NIO 模型变身为 IO 模型</span><br><span class=\"line\">3.Netty 自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑</span><br><span class=\"line\">4.Netty 解决了 JDK 的很多包括空轮询在内的 Bug</span><br><span class=\"line\">5.Netty 底层对线程，selector 做了很多细小的优化，精心设计的 reactor 线程模型做到非常高效的并发处理</span><br><span class=\"line\">6.自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手</span><br><span class=\"line\">7.Netty 社区活跃，遇到问题随时邮件列表或者 issue</span><br><span class=\"line\">8.Netty 已经历各大 RPC 框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大.</span><br></pre></td></tr></table></figure>\n<ul>\n<li>回调 <code>channelRead()</code> 方法，这里的第二个参数 <code>msg</code>，在我们这个场景中，可以直接强转为 <code>ByteBuf</code>，为什么 Netty 不直接把这个参数类型定义为 <code>ByteBuf</code> ？</li>\n</ul>\n"},{"_content":"## Guide to the Java Phaser\n\n\n\n> Java 7中新增了一个灵活的线程同步栅栏---**Phaser**，如果你需要在执行某些任务之前等待其他任务执行到某个状态，那么**Phaser**是一个很好的选择，这篇文章将介绍`java.util.concurrent.Phaser`，它和`CountDownLatch`具有相似的功能，但是**Phaser**更灵活。\n\n### 基本术语\n\n在理解Phaser类的运行机制之前，我们先来了解Phaser类中的一些基本术语：\n\n- **Registration**\n\n  开篇我们讲过，Phaser比`CountDownLatch`和`CyclicBarrier`更灵活，因为它可以通过`register()`和`bulkRegister(int parties)`来动态调整注册任务的数量，任务也可以通过执行`arriveAndDeregister()`来注销任务，Phaser允许的最大任务注册数量为`65535`。\n\n- **Arrival**\n\n  正如Phaser类的名字所暗示，每个Phaser实例都会维护一个phase number，初始值为0。每当所有注册的任务都到达Phaser时，phase number累加，并在超过Integer.MAX_VALUE后清零。`arrive()`和`arriveAndDeregister()`方法用于记录到 达，`arriveAndAwaitAdvance()`方法用于记录到达，并且等待其它未到达的任务。\n\n- **Termination**\n\n  Phaser支持终止。Phaser终止之后，***调用`register()`和`bulkRegister(int parties)`方法没有任何效果***，`arriveAndAwaitAdvance()`方法也会立即返回。触发终止的时机是在`protected boolean onAdvance(int phase, int registeredParties)`方法返回时，如果该方法返回true，那么Phaser会被终止，默认实现是在注册任务数为0时返回true`（即 return registeredParties == 0;）`，我们也可以通过重写这个方法来自定义的终止逻辑。此外，`forceTermination()`方法用于强制终止，`isTerminated()`方法用于判断是否已经终止。\n\n- **Tiering**\n\n  Phaser支持层次结构，即通过构造函数`Phaser(Phaser parent)`和`Phaser(Phaser parent, int parties)`构造一个树形结构。这有助于减轻因在单个的Phaser上注册过多的任务而导致的竞争，从而提升吞吐量，代价是增加单个操作的开销。\n\n### 核心API\n\n- Phaser(int parties)，构造方法，与CountDownLatch一样，传入同步的线程数，也支持层次构造Phaser(Phaser parent)。\n- register()，bulkRegister(int Parties)，动态添加一个或多个参与者。\n- arriveAndDeregister()方法，动态撤销线程在phaser的注册，通知phaser对象，该线程已经结束该阶段且不参与后面阶段。\n- isTerminated()，当phaser没有参与同步的线程时（或者onAdvance返回true），phaser是终止态（如果phaser进入终止态arriveAndAwaitAdvance()和awaitAdvance()都会立即返回，不在等待）isTerminated返回true。\n- arrive()方法，通知phaser该线程已经完成该阶段，但不等待其他线程。\n- arriveAndAwaitAdvance()方法，类似await()方法，记录到达线程数，阻塞等待其他线程到达同步点后再继续执行。\n- awaitAdvance(int phase) /awaitAdvanceInterruptibly(int phase) 传入阶段数，只有当前阶段等于phase阶段时才阻塞等待。后者如果线程在休眠被中断会抛出InterruptedException异常（phaser的其他方法对中断都不会抛出异常）。\n- onAdvance(int phase, int registeredParties)方法。参数phase是阶段数，每经过一个阶段该数加1，registeredParties是当注册的线程数。此方法有2个作用：1、当每一个阶段执行完毕，此方法会被自动调用，因此，重载此方法写入的代码会在每个阶段执行完毕时执行，相当于CyclicBarrier的barrierAction。2、当此方法返回true时，意味着Phaser被终止，因此可以巧妙的设置此方法的返回值来终止所有线程。例如：若此方法返回值为 phase >= 3，其含义为当整个线程执行了3个阶段后，程序终止。\n- forceTermination()方法，强制phaser进入终止态。\n\n### 简单示例\n\n```java\n/**\n * @author Shuai Junlan[shuaijunlan@gmail.com].\n * @since Created in 2:26 PM 11/7/18.\n */\npublic class PhaserTest {\n    public static void main(String[] args) \n            throws InterruptedException {\n        final Phaser phaser = new Phaser(1);\n        for (int index = 1; index <= 10; index++){\n            phaser.register();\n            new Thread(\n                    new Player(phaser), \n                    \"Player\" + index).start();\n        }\n        System.out.println(\"Game start\");\n        phaser.arriveAndDeregister();\n\n        while (!phaser.isTerminated()){\n            Thread.sleep(100);\n        }\n        System.out.println(\"Game over\");\n    }\n}\nclass Player implements Runnable{\n    private final Phaser phaser;\n    Player(Phaser phaser){\n        this.phaser = phaser;\n    }\n    @Override\n    public void run() {\n        //First step, waiting for all threads be created\n        phaser.arriveAndAwaitAdvance();\n\n        try {\n            //Second step, waiting for all players be ready\n            Thread.sleep(\n                    new Random().nextInt(100) * 10L);\n            System.out.println(\n                    Thread.currentThread().getName() + \" ready\");\n            phaser.arriveAndAwaitAdvance();\n\n            /////////////////running////////////////////\n\n            //Third step, waiting for all players arrived, then competition finishing.\n            System.out.println(\n                    Thread.currentThread().getName() + \" arrived\");\n            phaser.arriveAndDeregister();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**输出结果：**\n\n```\nGame start\nPlayer10 ready\nPlayer4 ready\nPlayer9 ready\nPlayer1 ready\nPlayer7 ready\nPlayer6 ready\nPlayer8 ready\nPlayer5 ready\nPlayer2 ready\nPlayer3 ready\nPlayer3 arrived\nPlayer5 arrived\nPlayer6 arrived\nPlayer1 arrived\nPlayer4 arrived\nPlayer7 arrived\nPlayer8 arrived\nPlayer9 arrived\nPlayer10 arrived\nPlayer2 arrived\nGame over\n```\n\n","source":"todo/java-phaser.md","raw":"## Guide to the Java Phaser\n\n\n\n> Java 7中新增了一个灵活的线程同步栅栏---**Phaser**，如果你需要在执行某些任务之前等待其他任务执行到某个状态，那么**Phaser**是一个很好的选择，这篇文章将介绍`java.util.concurrent.Phaser`，它和`CountDownLatch`具有相似的功能，但是**Phaser**更灵活。\n\n### 基本术语\n\n在理解Phaser类的运行机制之前，我们先来了解Phaser类中的一些基本术语：\n\n- **Registration**\n\n  开篇我们讲过，Phaser比`CountDownLatch`和`CyclicBarrier`更灵活，因为它可以通过`register()`和`bulkRegister(int parties)`来动态调整注册任务的数量，任务也可以通过执行`arriveAndDeregister()`来注销任务，Phaser允许的最大任务注册数量为`65535`。\n\n- **Arrival**\n\n  正如Phaser类的名字所暗示，每个Phaser实例都会维护一个phase number，初始值为0。每当所有注册的任务都到达Phaser时，phase number累加，并在超过Integer.MAX_VALUE后清零。`arrive()`和`arriveAndDeregister()`方法用于记录到 达，`arriveAndAwaitAdvance()`方法用于记录到达，并且等待其它未到达的任务。\n\n- **Termination**\n\n  Phaser支持终止。Phaser终止之后，***调用`register()`和`bulkRegister(int parties)`方法没有任何效果***，`arriveAndAwaitAdvance()`方法也会立即返回。触发终止的时机是在`protected boolean onAdvance(int phase, int registeredParties)`方法返回时，如果该方法返回true，那么Phaser会被终止，默认实现是在注册任务数为0时返回true`（即 return registeredParties == 0;）`，我们也可以通过重写这个方法来自定义的终止逻辑。此外，`forceTermination()`方法用于强制终止，`isTerminated()`方法用于判断是否已经终止。\n\n- **Tiering**\n\n  Phaser支持层次结构，即通过构造函数`Phaser(Phaser parent)`和`Phaser(Phaser parent, int parties)`构造一个树形结构。这有助于减轻因在单个的Phaser上注册过多的任务而导致的竞争，从而提升吞吐量，代价是增加单个操作的开销。\n\n### 核心API\n\n- Phaser(int parties)，构造方法，与CountDownLatch一样，传入同步的线程数，也支持层次构造Phaser(Phaser parent)。\n- register()，bulkRegister(int Parties)，动态添加一个或多个参与者。\n- arriveAndDeregister()方法，动态撤销线程在phaser的注册，通知phaser对象，该线程已经结束该阶段且不参与后面阶段。\n- isTerminated()，当phaser没有参与同步的线程时（或者onAdvance返回true），phaser是终止态（如果phaser进入终止态arriveAndAwaitAdvance()和awaitAdvance()都会立即返回，不在等待）isTerminated返回true。\n- arrive()方法，通知phaser该线程已经完成该阶段，但不等待其他线程。\n- arriveAndAwaitAdvance()方法，类似await()方法，记录到达线程数，阻塞等待其他线程到达同步点后再继续执行。\n- awaitAdvance(int phase) /awaitAdvanceInterruptibly(int phase) 传入阶段数，只有当前阶段等于phase阶段时才阻塞等待。后者如果线程在休眠被中断会抛出InterruptedException异常（phaser的其他方法对中断都不会抛出异常）。\n- onAdvance(int phase, int registeredParties)方法。参数phase是阶段数，每经过一个阶段该数加1，registeredParties是当注册的线程数。此方法有2个作用：1、当每一个阶段执行完毕，此方法会被自动调用，因此，重载此方法写入的代码会在每个阶段执行完毕时执行，相当于CyclicBarrier的barrierAction。2、当此方法返回true时，意味着Phaser被终止，因此可以巧妙的设置此方法的返回值来终止所有线程。例如：若此方法返回值为 phase >= 3，其含义为当整个线程执行了3个阶段后，程序终止。\n- forceTermination()方法，强制phaser进入终止态。\n\n### 简单示例\n\n```java\n/**\n * @author Shuai Junlan[shuaijunlan@gmail.com].\n * @since Created in 2:26 PM 11/7/18.\n */\npublic class PhaserTest {\n    public static void main(String[] args) \n            throws InterruptedException {\n        final Phaser phaser = new Phaser(1);\n        for (int index = 1; index <= 10; index++){\n            phaser.register();\n            new Thread(\n                    new Player(phaser), \n                    \"Player\" + index).start();\n        }\n        System.out.println(\"Game start\");\n        phaser.arriveAndDeregister();\n\n        while (!phaser.isTerminated()){\n            Thread.sleep(100);\n        }\n        System.out.println(\"Game over\");\n    }\n}\nclass Player implements Runnable{\n    private final Phaser phaser;\n    Player(Phaser phaser){\n        this.phaser = phaser;\n    }\n    @Override\n    public void run() {\n        //First step, waiting for all threads be created\n        phaser.arriveAndAwaitAdvance();\n\n        try {\n            //Second step, waiting for all players be ready\n            Thread.sleep(\n                    new Random().nextInt(100) * 10L);\n            System.out.println(\n                    Thread.currentThread().getName() + \" ready\");\n            phaser.arriveAndAwaitAdvance();\n\n            /////////////////running////////////////////\n\n            //Third step, waiting for all players arrived, then competition finishing.\n            System.out.println(\n                    Thread.currentThread().getName() + \" arrived\");\n            phaser.arriveAndDeregister();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**输出结果：**\n\n```\nGame start\nPlayer10 ready\nPlayer4 ready\nPlayer9 ready\nPlayer1 ready\nPlayer7 ready\nPlayer6 ready\nPlayer8 ready\nPlayer5 ready\nPlayer2 ready\nPlayer3 ready\nPlayer3 arrived\nPlayer5 arrived\nPlayer6 arrived\nPlayer1 arrived\nPlayer4 arrived\nPlayer7 arrived\nPlayer8 arrived\nPlayer9 arrived\nPlayer10 arrived\nPlayer2 arrived\nGame over\n```\n\n","date":"2018-11-22T01:08:55.716Z","updated":"2018-11-21T08:32:22.000Z","path":"todo/java-phaser.html","title":"","comments":1,"layout":"page","_id":"cjq6kwn4l000fzjia19har32o","content":"<h2 id=\"Guide-to-the-Java-Phaser\"><a href=\"#Guide-to-the-Java-Phaser\" class=\"headerlink\" title=\"Guide to the Java Phaser\"></a>Guide to the Java Phaser</h2><blockquote>\n<p>Java 7中新增了一个灵活的线程同步栅栏—<strong>Phaser</strong>，如果你需要在执行某些任务之前等待其他任务执行到某个状态，那么<strong>Phaser</strong>是一个很好的选择，这篇文章将介绍<code>java.util.concurrent.Phaser</code>，它和<code>CountDownLatch</code>具有相似的功能，但是<strong>Phaser</strong>更灵活。</p>\n</blockquote>\n<h3 id=\"基本术语\"><a href=\"#基本术语\" class=\"headerlink\" title=\"基本术语\"></a>基本术语</h3><p>在理解Phaser类的运行机制之前，我们先来了解Phaser类中的一些基本术语：</p>\n<ul>\n<li><p><strong>Registration</strong></p>\n<p>开篇我们讲过，Phaser比<code>CountDownLatch</code>和<code>CyclicBarrier</code>更灵活，因为它可以通过<code>register()</code>和<code>bulkRegister(int parties)</code>来动态调整注册任务的数量，任务也可以通过执行<code>arriveAndDeregister()</code>来注销任务，Phaser允许的最大任务注册数量为<code>65535</code>。</p>\n</li>\n<li><p><strong>Arrival</strong></p>\n<p>正如Phaser类的名字所暗示，每个Phaser实例都会维护一个phase number，初始值为0。每当所有注册的任务都到达Phaser时，phase number累加，并在超过Integer.MAX_VALUE后清零。<code>arrive()</code>和<code>arriveAndDeregister()</code>方法用于记录到 达，<code>arriveAndAwaitAdvance()</code>方法用于记录到达，并且等待其它未到达的任务。</p>\n</li>\n<li><p><strong>Termination</strong></p>\n<p>Phaser支持终止。Phaser终止之后，<strong><em>调用<code>register()</code>和<code>bulkRegister(int parties)</code>方法没有任何效果</em></strong>，<code>arriveAndAwaitAdvance()</code>方法也会立即返回。触发终止的时机是在<code>protected boolean onAdvance(int phase, int registeredParties)</code>方法返回时，如果该方法返回true，那么Phaser会被终止，默认实现是在注册任务数为0时返回true<code>（即 return registeredParties == 0;）</code>，我们也可以通过重写这个方法来自定义的终止逻辑。此外，<code>forceTermination()</code>方法用于强制终止，<code>isTerminated()</code>方法用于判断是否已经终止。</p>\n</li>\n<li><p><strong>Tiering</strong></p>\n<p>Phaser支持层次结构，即通过构造函数<code>Phaser(Phaser parent)</code>和<code>Phaser(Phaser parent, int parties)</code>构造一个树形结构。这有助于减轻因在单个的Phaser上注册过多的任务而导致的竞争，从而提升吞吐量，代价是增加单个操作的开销。</p>\n</li>\n</ul>\n<h3 id=\"核心API\"><a href=\"#核心API\" class=\"headerlink\" title=\"核心API\"></a>核心API</h3><ul>\n<li>Phaser(int parties)，构造方法，与CountDownLatch一样，传入同步的线程数，也支持层次构造Phaser(Phaser parent)。</li>\n<li>register()，bulkRegister(int Parties)，动态添加一个或多个参与者。</li>\n<li>arriveAndDeregister()方法，动态撤销线程在phaser的注册，通知phaser对象，该线程已经结束该阶段且不参与后面阶段。</li>\n<li>isTerminated()，当phaser没有参与同步的线程时（或者onAdvance返回true），phaser是终止态（如果phaser进入终止态arriveAndAwaitAdvance()和awaitAdvance()都会立即返回，不在等待）isTerminated返回true。</li>\n<li>arrive()方法，通知phaser该线程已经完成该阶段，但不等待其他线程。</li>\n<li>arriveAndAwaitAdvance()方法，类似await()方法，记录到达线程数，阻塞等待其他线程到达同步点后再继续执行。</li>\n<li>awaitAdvance(int phase) /awaitAdvanceInterruptibly(int phase) 传入阶段数，只有当前阶段等于phase阶段时才阻塞等待。后者如果线程在休眠被中断会抛出InterruptedException异常（phaser的其他方法对中断都不会抛出异常）。</li>\n<li>onAdvance(int phase, int registeredParties)方法。参数phase是阶段数，每经过一个阶段该数加1，registeredParties是当注册的线程数。此方法有2个作用：1、当每一个阶段执行完毕，此方法会被自动调用，因此，重载此方法写入的代码会在每个阶段执行完毕时执行，相当于CyclicBarrier的barrierAction。2、当此方法返回true时，意味着Phaser被终止，因此可以巧妙的设置此方法的返回值来终止所有线程。例如：若此方法返回值为 phase &gt;= 3，其含义为当整个线程执行了3个阶段后，程序终止。</li>\n<li>forceTermination()方法，强制phaser进入终止态。</li>\n</ul>\n<h3 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Shuai Junlan[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> Created in 2:26 PM 11/7/18.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhaserTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Phaser phaser = <span class=\"keyword\">new</span> Phaser(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">1</span>; index &lt;= <span class=\"number\">10</span>; index++)&#123;</span><br><span class=\"line\">            phaser.register();</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> Player(phaser), </span><br><span class=\"line\">                    <span class=\"string\">\"Player\"</span> + index).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Game start\"</span>);</span><br><span class=\"line\">        phaser.arriveAndDeregister();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!phaser.isTerminated())&#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Game over\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Phaser phaser;</span><br><span class=\"line\">    Player(Phaser phaser)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.phaser = phaser;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//First step, waiting for all threads be created</span></span><br><span class=\"line\">        phaser.arriveAndAwaitAdvance();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//Second step, waiting for all players be ready</span></span><br><span class=\"line\">            Thread.sleep(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">100</span>) * <span class=\"number\">10L</span>);</span><br><span class=\"line\">            System.out.println(</span><br><span class=\"line\">                    Thread.currentThread().getName() + <span class=\"string\">\" ready\"</span>);</span><br><span class=\"line\">            phaser.arriveAndAwaitAdvance();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/////////////////running////////////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//Third step, waiting for all players arrived, then competition finishing.</span></span><br><span class=\"line\">            System.out.println(</span><br><span class=\"line\">                    Thread.currentThread().getName() + <span class=\"string\">\" arrived\"</span>);</span><br><span class=\"line\">            phaser.arriveAndDeregister();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Game start</span><br><span class=\"line\">Player10 ready</span><br><span class=\"line\">Player4 ready</span><br><span class=\"line\">Player9 ready</span><br><span class=\"line\">Player1 ready</span><br><span class=\"line\">Player7 ready</span><br><span class=\"line\">Player6 ready</span><br><span class=\"line\">Player8 ready</span><br><span class=\"line\">Player5 ready</span><br><span class=\"line\">Player2 ready</span><br><span class=\"line\">Player3 ready</span><br><span class=\"line\">Player3 arrived</span><br><span class=\"line\">Player5 arrived</span><br><span class=\"line\">Player6 arrived</span><br><span class=\"line\">Player1 arrived</span><br><span class=\"line\">Player4 arrived</span><br><span class=\"line\">Player7 arrived</span><br><span class=\"line\">Player8 arrived</span><br><span class=\"line\">Player9 arrived</span><br><span class=\"line\">Player10 arrived</span><br><span class=\"line\">Player2 arrived</span><br><span class=\"line\">Game over</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Guide-to-the-Java-Phaser\"><a href=\"#Guide-to-the-Java-Phaser\" class=\"headerlink\" title=\"Guide to the Java Phaser\"></a>Guide to the Java Phaser</h2><blockquote>\n<p>Java 7中新增了一个灵活的线程同步栅栏—<strong>Phaser</strong>，如果你需要在执行某些任务之前等待其他任务执行到某个状态，那么<strong>Phaser</strong>是一个很好的选择，这篇文章将介绍<code>java.util.concurrent.Phaser</code>，它和<code>CountDownLatch</code>具有相似的功能，但是<strong>Phaser</strong>更灵活。</p>\n</blockquote>\n<h3 id=\"基本术语\"><a href=\"#基本术语\" class=\"headerlink\" title=\"基本术语\"></a>基本术语</h3><p>在理解Phaser类的运行机制之前，我们先来了解Phaser类中的一些基本术语：</p>\n<ul>\n<li><p><strong>Registration</strong></p>\n<p>开篇我们讲过，Phaser比<code>CountDownLatch</code>和<code>CyclicBarrier</code>更灵活，因为它可以通过<code>register()</code>和<code>bulkRegister(int parties)</code>来动态调整注册任务的数量，任务也可以通过执行<code>arriveAndDeregister()</code>来注销任务，Phaser允许的最大任务注册数量为<code>65535</code>。</p>\n</li>\n<li><p><strong>Arrival</strong></p>\n<p>正如Phaser类的名字所暗示，每个Phaser实例都会维护一个phase number，初始值为0。每当所有注册的任务都到达Phaser时，phase number累加，并在超过Integer.MAX_VALUE后清零。<code>arrive()</code>和<code>arriveAndDeregister()</code>方法用于记录到 达，<code>arriveAndAwaitAdvance()</code>方法用于记录到达，并且等待其它未到达的任务。</p>\n</li>\n<li><p><strong>Termination</strong></p>\n<p>Phaser支持终止。Phaser终止之后，<strong><em>调用<code>register()</code>和<code>bulkRegister(int parties)</code>方法没有任何效果</em></strong>，<code>arriveAndAwaitAdvance()</code>方法也会立即返回。触发终止的时机是在<code>protected boolean onAdvance(int phase, int registeredParties)</code>方法返回时，如果该方法返回true，那么Phaser会被终止，默认实现是在注册任务数为0时返回true<code>（即 return registeredParties == 0;）</code>，我们也可以通过重写这个方法来自定义的终止逻辑。此外，<code>forceTermination()</code>方法用于强制终止，<code>isTerminated()</code>方法用于判断是否已经终止。</p>\n</li>\n<li><p><strong>Tiering</strong></p>\n<p>Phaser支持层次结构，即通过构造函数<code>Phaser(Phaser parent)</code>和<code>Phaser(Phaser parent, int parties)</code>构造一个树形结构。这有助于减轻因在单个的Phaser上注册过多的任务而导致的竞争，从而提升吞吐量，代价是增加单个操作的开销。</p>\n</li>\n</ul>\n<h3 id=\"核心API\"><a href=\"#核心API\" class=\"headerlink\" title=\"核心API\"></a>核心API</h3><ul>\n<li>Phaser(int parties)，构造方法，与CountDownLatch一样，传入同步的线程数，也支持层次构造Phaser(Phaser parent)。</li>\n<li>register()，bulkRegister(int Parties)，动态添加一个或多个参与者。</li>\n<li>arriveAndDeregister()方法，动态撤销线程在phaser的注册，通知phaser对象，该线程已经结束该阶段且不参与后面阶段。</li>\n<li>isTerminated()，当phaser没有参与同步的线程时（或者onAdvance返回true），phaser是终止态（如果phaser进入终止态arriveAndAwaitAdvance()和awaitAdvance()都会立即返回，不在等待）isTerminated返回true。</li>\n<li>arrive()方法，通知phaser该线程已经完成该阶段，但不等待其他线程。</li>\n<li>arriveAndAwaitAdvance()方法，类似await()方法，记录到达线程数，阻塞等待其他线程到达同步点后再继续执行。</li>\n<li>awaitAdvance(int phase) /awaitAdvanceInterruptibly(int phase) 传入阶段数，只有当前阶段等于phase阶段时才阻塞等待。后者如果线程在休眠被中断会抛出InterruptedException异常（phaser的其他方法对中断都不会抛出异常）。</li>\n<li>onAdvance(int phase, int registeredParties)方法。参数phase是阶段数，每经过一个阶段该数加1，registeredParties是当注册的线程数。此方法有2个作用：1、当每一个阶段执行完毕，此方法会被自动调用，因此，重载此方法写入的代码会在每个阶段执行完毕时执行，相当于CyclicBarrier的barrierAction。2、当此方法返回true时，意味着Phaser被终止，因此可以巧妙的设置此方法的返回值来终止所有线程。例如：若此方法返回值为 phase &gt;= 3，其含义为当整个线程执行了3个阶段后，程序终止。</li>\n<li>forceTermination()方法，强制phaser进入终止态。</li>\n</ul>\n<h3 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Shuai Junlan[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> Created in 2:26 PM 11/7/18.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhaserTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Phaser phaser = <span class=\"keyword\">new</span> Phaser(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">1</span>; index &lt;= <span class=\"number\">10</span>; index++)&#123;</span><br><span class=\"line\">            phaser.register();</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> Player(phaser), </span><br><span class=\"line\">                    <span class=\"string\">\"Player\"</span> + index).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Game start\"</span>);</span><br><span class=\"line\">        phaser.arriveAndDeregister();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!phaser.isTerminated())&#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Game over\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Phaser phaser;</span><br><span class=\"line\">    Player(Phaser phaser)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.phaser = phaser;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//First step, waiting for all threads be created</span></span><br><span class=\"line\">        phaser.arriveAndAwaitAdvance();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//Second step, waiting for all players be ready</span></span><br><span class=\"line\">            Thread.sleep(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">100</span>) * <span class=\"number\">10L</span>);</span><br><span class=\"line\">            System.out.println(</span><br><span class=\"line\">                    Thread.currentThread().getName() + <span class=\"string\">\" ready\"</span>);</span><br><span class=\"line\">            phaser.arriveAndAwaitAdvance();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/////////////////running////////////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//Third step, waiting for all players arrived, then competition finishing.</span></span><br><span class=\"line\">            System.out.println(</span><br><span class=\"line\">                    Thread.currentThread().getName() + <span class=\"string\">\" arrived\"</span>);</span><br><span class=\"line\">            phaser.arriveAndDeregister();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Game start</span><br><span class=\"line\">Player10 ready</span><br><span class=\"line\">Player4 ready</span><br><span class=\"line\">Player9 ready</span><br><span class=\"line\">Player1 ready</span><br><span class=\"line\">Player7 ready</span><br><span class=\"line\">Player6 ready</span><br><span class=\"line\">Player8 ready</span><br><span class=\"line\">Player5 ready</span><br><span class=\"line\">Player2 ready</span><br><span class=\"line\">Player3 ready</span><br><span class=\"line\">Player3 arrived</span><br><span class=\"line\">Player5 arrived</span><br><span class=\"line\">Player6 arrived</span><br><span class=\"line\">Player1 arrived</span><br><span class=\"line\">Player4 arrived</span><br><span class=\"line\">Player7 arrived</span><br><span class=\"line\">Player8 arrived</span><br><span class=\"line\">Player9 arrived</span><br><span class=\"line\">Player10 arrived</span><br><span class=\"line\">Player2 arrived</span><br><span class=\"line\">Game over</span><br></pre></td></tr></table></figure>\n"},{"title":"Java中Unsafe类详解","date":"2018-11-29T03:05:23.000Z","tags":["java"],"_content":"\n1. VM \"intrinsification.\" ie CAS (Compare-And-Swap) used in Lock-Free Hash Tables eg:sun.misc.Unsafe.compareAndSwapInt it can make real JNI calls into native code that contains special instructions for CAS\n\n   read more about CAS here <http://en.wikipedia.org/wiki/Compare-and-swap>\n\n2. The sun.misc.Unsafe functionality of the host VM can be used to allocate uninitialized objects and then interpret the constructor invocation as any other method call.\n\n3. One can track the data from the native address.It is possible to retrieve an object’s memory address using the java.lang.Unsafe class, and operate on its fields directly via unsafe get/put methods!\n\n4. Compile time optimizations for JVM. HIgh performance VM using \"magic\", requiring low-level operations. eg: <http://en.wikipedia.org/wiki/Jikes_RVM>\n\n5. Allocating memory, sun.misc.Unsafe.allocateMemory eg:- DirectByteBuffer constructor internally calls it when ByteBuffer.allocateDirect is invoked\n\n6. Tracing the call stack and replaying with values instantiated by sun.misc.Unsafe, useful for instrumentation\n\n7. sun.misc.Unsafe.arrayBaseOffset and arrayIndexScale can be used to develop arraylets,a technique for efficiently breaking up large arrays into smaller objects to limit the real-time cost of scan, update or move operations on large objects\n\n8. <http://robaustin.wikidot.com/how-to-write-to-direct-memory-locations-in-java>\n\n### Reference\n\n* https://stackoverflow.com/questions/5574241/why-does-sun-misc-unsafe-exist-and-how-can-it-be-used-in-the-real-world\n* http://bytescrolls.blogspot.com/2011/04/interesting-uses-of-sunmiscunsafe.html","source":"todo/java-unsafe-class.md","raw":"---\ntitle: Java中Unsafe类详解\ndate: 2018-11-29 11:05:23\ntags:\n    - java\n---\n\n1. VM \"intrinsification.\" ie CAS (Compare-And-Swap) used in Lock-Free Hash Tables eg:sun.misc.Unsafe.compareAndSwapInt it can make real JNI calls into native code that contains special instructions for CAS\n\n   read more about CAS here <http://en.wikipedia.org/wiki/Compare-and-swap>\n\n2. The sun.misc.Unsafe functionality of the host VM can be used to allocate uninitialized objects and then interpret the constructor invocation as any other method call.\n\n3. One can track the data from the native address.It is possible to retrieve an object’s memory address using the java.lang.Unsafe class, and operate on its fields directly via unsafe get/put methods!\n\n4. Compile time optimizations for JVM. HIgh performance VM using \"magic\", requiring low-level operations. eg: <http://en.wikipedia.org/wiki/Jikes_RVM>\n\n5. Allocating memory, sun.misc.Unsafe.allocateMemory eg:- DirectByteBuffer constructor internally calls it when ByteBuffer.allocateDirect is invoked\n\n6. Tracing the call stack and replaying with values instantiated by sun.misc.Unsafe, useful for instrumentation\n\n7. sun.misc.Unsafe.arrayBaseOffset and arrayIndexScale can be used to develop arraylets,a technique for efficiently breaking up large arrays into smaller objects to limit the real-time cost of scan, update or move operations on large objects\n\n8. <http://robaustin.wikidot.com/how-to-write-to-direct-memory-locations-in-java>\n\n### Reference\n\n* https://stackoverflow.com/questions/5574241/why-does-sun-misc-unsafe-exist-and-how-can-it-be-used-in-the-real-world\n* http://bytescrolls.blogspot.com/2011/04/interesting-uses-of-sunmiscunsafe.html","updated":"2018-11-29T03:41:59.748Z","path":"todo/java-unsafe-class.html","comments":1,"layout":"page","_id":"cjq6kwn4n000hzjiad04nqs7s","content":"<ol>\n<li><p>VM “intrinsification.” ie CAS (Compare-And-Swap) used in Lock-Free Hash Tables eg:sun.misc.Unsafe.compareAndSwapInt it can make real JNI calls into native code that contains special instructions for CAS</p>\n<p>read more about CAS here <a href=\"http://en.wikipedia.org/wiki/Compare-and-swap\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Compare-and-swap</a></p>\n</li>\n<li><p>The sun.misc.Unsafe functionality of the host VM can be used to allocate uninitialized objects and then interpret the constructor invocation as any other method call.</p>\n</li>\n<li><p>One can track the data from the native address.It is possible to retrieve an object’s memory address using the java.lang.Unsafe class, and operate on its fields directly via unsafe get/put methods!</p>\n</li>\n<li><p>Compile time optimizations for JVM. HIgh performance VM using “magic”, requiring low-level operations. eg: <a href=\"http://en.wikipedia.org/wiki/Jikes_RVM\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Jikes_RVM</a></p>\n</li>\n<li><p>Allocating memory, sun.misc.Unsafe.allocateMemory eg:- DirectByteBuffer constructor internally calls it when ByteBuffer.allocateDirect is invoked</p>\n</li>\n<li><p>Tracing the call stack and replaying with values instantiated by sun.misc.Unsafe, useful for instrumentation</p>\n</li>\n<li><p>sun.misc.Unsafe.arrayBaseOffset and arrayIndexScale can be used to develop arraylets,a technique for efficiently breaking up large arrays into smaller objects to limit the real-time cost of scan, update or move operations on large objects</p>\n</li>\n<li><p><a href=\"http://robaustin.wikidot.com/how-to-write-to-direct-memory-locations-in-java\" target=\"_blank\" rel=\"noopener\">http://robaustin.wikidot.com/how-to-write-to-direct-memory-locations-in-java</a></p>\n</li>\n</ol>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ul>\n<li><a href=\"https://stackoverflow.com/questions/5574241/why-does-sun-misc-unsafe-exist-and-how-can-it-be-used-in-the-real-world\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/5574241/why-does-sun-misc-unsafe-exist-and-how-can-it-be-used-in-the-real-world</a></li>\n<li><a href=\"http://bytescrolls.blogspot.com/2011/04/interesting-uses-of-sunmiscunsafe.html\" target=\"_blank\" rel=\"noopener\">http://bytescrolls.blogspot.com/2011/04/interesting-uses-of-sunmiscunsafe.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>VM “intrinsification.” ie CAS (Compare-And-Swap) used in Lock-Free Hash Tables eg:sun.misc.Unsafe.compareAndSwapInt it can make real JNI calls into native code that contains special instructions for CAS</p>\n<p>read more about CAS here <a href=\"http://en.wikipedia.org/wiki/Compare-and-swap\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Compare-and-swap</a></p>\n</li>\n<li><p>The sun.misc.Unsafe functionality of the host VM can be used to allocate uninitialized objects and then interpret the constructor invocation as any other method call.</p>\n</li>\n<li><p>One can track the data from the native address.It is possible to retrieve an object’s memory address using the java.lang.Unsafe class, and operate on its fields directly via unsafe get/put methods!</p>\n</li>\n<li><p>Compile time optimizations for JVM. HIgh performance VM using “magic”, requiring low-level operations. eg: <a href=\"http://en.wikipedia.org/wiki/Jikes_RVM\" target=\"_blank\" rel=\"noopener\">http://en.wikipedia.org/wiki/Jikes_RVM</a></p>\n</li>\n<li><p>Allocating memory, sun.misc.Unsafe.allocateMemory eg:- DirectByteBuffer constructor internally calls it when ByteBuffer.allocateDirect is invoked</p>\n</li>\n<li><p>Tracing the call stack and replaying with values instantiated by sun.misc.Unsafe, useful for instrumentation</p>\n</li>\n<li><p>sun.misc.Unsafe.arrayBaseOffset and arrayIndexScale can be used to develop arraylets,a technique for efficiently breaking up large arrays into smaller objects to limit the real-time cost of scan, update or move operations on large objects</p>\n</li>\n<li><p><a href=\"http://robaustin.wikidot.com/how-to-write-to-direct-memory-locations-in-java\" target=\"_blank\" rel=\"noopener\">http://robaustin.wikidot.com/how-to-write-to-direct-memory-locations-in-java</a></p>\n</li>\n</ol>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><ul>\n<li><a href=\"https://stackoverflow.com/questions/5574241/why-does-sun-misc-unsafe-exist-and-how-can-it-be-used-in-the-real-world\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/5574241/why-does-sun-misc-unsafe-exist-and-how-can-it-be-used-in-the-real-world</a></li>\n<li><a href=\"http://bytescrolls.blogspot.com/2011/04/interesting-uses-of-sunmiscunsafe.html\" target=\"_blank\" rel=\"noopener\">http://bytescrolls.blogspot.com/2011/04/interesting-uses-of-sunmiscunsafe.html</a></li>\n</ul>\n"},{"title":"Netty服务端启动过程分析","date":"2018-12-06T03:10:53.000Z","tags":["netty"],"_content":"\n### Difficult\n\n","source":"todo/netty-serverside-bootstrap-procedure.md","raw":"---\ntitle: Netty服务端启动过程分析\ndate: 2018-12-06 11:10:53\ntags:\n    - netty\n---\n\n### Difficult\n\n","updated":"2018-12-13T14:07:24.962Z","path":"todo/netty-serverside-bootstrap-procedure.html","comments":1,"layout":"page","_id":"cjq6kwn4o000lzjiavcg82sbq","content":"<h3 id=\"Difficult\"><a href=\"#Difficult\" class=\"headerlink\" title=\"Difficult\"></a>Difficult</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Difficult\"><a href=\"#Difficult\" class=\"headerlink\" title=\"Difficult\"></a>Difficult</h3>"}],"Post":[{"title":"Autoboxing and Autounboxing","date":"2016-09-26T02:07:15.000Z","_content":"### 前言：\n\n* 首先我们要知道Java中有哪些基本数据类型以及它们各自的封装类:package java.lang;\n\n| 基本数据类型   | 封装类         |\n|:-------------:|:-------------:|\n| byte          | Byte          |\n| boolean       | Boolean       |\n| char          | Character     |\n| short         | Short         |\n| int           | Integer       |\n| long          | Long          |\n| float         | Float         |\n| double        | Double        |\n\n<!-- more -->\n\n### 一、什么是Autoboxing\n\n> java中Autoboxing是指将基本数据类型自动转换成封装类类型。比如说：\n\n```java\npublic void test1()\n{\n    int a = 10;\n    Integer b = a;\n    System.out.println(b);\n\n    Character d = 'c';\n    System.out.println(d);\n}\n```\n\n> * 函数参数为封装类类型时，调用时传递基本数据类型，会发生Autoboxing。\n* 将基本数据类型变量赋值给封装类类型时，会发生Autoboxing。\n\n### 二、什么是Autounboxing\n\n> java中Autounboxing是指将封装类类型自动转换成基本数据类型。比如说：\n\n```java\npublic void test2()\n{\n    Integer a = new Integer(10);\n    int b = a;\n    System.out.println(b);\n\n    Character c = 'c';\n    char d = c;\n    System.out.println(d);\n}\n```\n> * 函数参数为基本数据类型，调用时传递封装类类型，会发生Autounboxing。\n* 将封装类类型变量赋值给基本数据类型，或者直接用封装类类型进行基本运算，会发生Autounboxing。\n\n\n### 三、以int类型为例，讲解Autoboxing和Autounboxing实现原理\n> 先来看一段代码反汇编的结果\n\n* java代码\n    ```java\n    package com.sh.$16.$12.$22;\n    /**\n     * Created by Mr SJL on 2016/12/22.\n     *\n     * @Author Junlan Shuai\n     */\n\n    import java.util.ArrayList;\n    import java.util.List;\n\n    public class App1\n    {\n        public static void main(String[] args)\n        {\n            Integer integer = 10;\n            int i = integer;\n        }\n\n    }\n    ```\n* 反汇编结果\n    ```java\n    public class com.sh.$16.$12.$22.App1 {\n      public com.sh.$16.$12.$22.App1();\n        Code:\n           0: aload_0\n           1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n           4: return\n\n      public static void main(java.lang.String[]);\n        Code:\n           0: bipush        10\n           2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n           5: astore_1\n           6: aload_1\n           7: invokevirtual #3                  // Method java/lang/Integer.intValue:()I\n          10: istore_2\n          11: return\n    }\n\n    ```\n\n> 从以上java代码可以看出，“Integer integer = 10;”此句发生了Autoboxing。</br>\n从汇编结果可以看出，实际在编译的时候发生了，Integer a = Integer.valueOf(10);调用了Integer类的valueOf方法。\n\n```java\n/**\n * Returns an {@code Integer} instance representing the specified\n * {@code int} value.  If a new {@code Integer} instance is not\n * required, this method should generally be used in preference to\n * the constructor {@link #Integer(int)}, as this method is likely\n * to yield significantly better space and time performance by\n * caching frequently requested values.\n *\n * This method will always cache values in the range -128 to 127,\n * inclusive, and may cache other values outside of this range.\n *\n * @param  i an {@code int} value.\n * @return an {@code Integer} instance representing {@code i}.\n * @since  1.5\n */\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n> 从以上java代码可以看出，“int i = integer;”此句发生了Autounboxing。</br>\n从汇编结果可以看出，实际在编译的时候发生了，int i = integer.intValue();调用了Integer类的intValue方法。\n\n```java\n/**\n * Returns the value of this {@code Integer} as an\n * {@code int}.\n */\npublic int intValue() {\n    return value;\n}\n```\n### 四、总结\n\n> 其他基本数据类型的Autoboxing and Autounboxing也满足此。\n\n----\n#### 思考：\n```java\npackage com.sh.$16.$12.$24;\n\n/**\n * Created by Mr SJL on 2016/12/24.\n *\n * @Author Junlan Shuai\n */\npublic class App2\n{\n    public static void main(String[] args)\n    {\n        int a = 10;\n        int b = 10;\n        Integer c = new Integer(10);\n        Integer d = Integer.valueOf(10);\n        Integer e = 2000;\n        Integer f = 2000;\n\n        System.out.println(\"a=b:\" +(a==b));\n        System.out.println(\"a=c:\" +(a==c));\n        System.out.println(\"a=d:\" +(a==d));\n        System.out.println(\"c=d:\" +(c==d));\n        System.out.println(\"e=f:\" +(e==f));\n    }\n}\n\n// 运行结果：\na=b:true\na=c:true\na=d:true\nc=d:false\ne=f:false\n```\n","source":"_posts/Autopacking and Autounpacking.md","raw":"---\ntitle: Autoboxing and Autounboxing\ndate: 2016-09-26 10:07:15\ntags:\n    - java\n---\n### 前言：\n\n* 首先我们要知道Java中有哪些基本数据类型以及它们各自的封装类:package java.lang;\n\n| 基本数据类型   | 封装类         |\n|:-------------:|:-------------:|\n| byte          | Byte          |\n| boolean       | Boolean       |\n| char          | Character     |\n| short         | Short         |\n| int           | Integer       |\n| long          | Long          |\n| float         | Float         |\n| double        | Double        |\n\n<!-- more -->\n\n### 一、什么是Autoboxing\n\n> java中Autoboxing是指将基本数据类型自动转换成封装类类型。比如说：\n\n```java\npublic void test1()\n{\n    int a = 10;\n    Integer b = a;\n    System.out.println(b);\n\n    Character d = 'c';\n    System.out.println(d);\n}\n```\n\n> * 函数参数为封装类类型时，调用时传递基本数据类型，会发生Autoboxing。\n* 将基本数据类型变量赋值给封装类类型时，会发生Autoboxing。\n\n### 二、什么是Autounboxing\n\n> java中Autounboxing是指将封装类类型自动转换成基本数据类型。比如说：\n\n```java\npublic void test2()\n{\n    Integer a = new Integer(10);\n    int b = a;\n    System.out.println(b);\n\n    Character c = 'c';\n    char d = c;\n    System.out.println(d);\n}\n```\n> * 函数参数为基本数据类型，调用时传递封装类类型，会发生Autounboxing。\n* 将封装类类型变量赋值给基本数据类型，或者直接用封装类类型进行基本运算，会发生Autounboxing。\n\n\n### 三、以int类型为例，讲解Autoboxing和Autounboxing实现原理\n> 先来看一段代码反汇编的结果\n\n* java代码\n    ```java\n    package com.sh.$16.$12.$22;\n    /**\n     * Created by Mr SJL on 2016/12/22.\n     *\n     * @Author Junlan Shuai\n     */\n\n    import java.util.ArrayList;\n    import java.util.List;\n\n    public class App1\n    {\n        public static void main(String[] args)\n        {\n            Integer integer = 10;\n            int i = integer;\n        }\n\n    }\n    ```\n* 反汇编结果\n    ```java\n    public class com.sh.$16.$12.$22.App1 {\n      public com.sh.$16.$12.$22.App1();\n        Code:\n           0: aload_0\n           1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n           4: return\n\n      public static void main(java.lang.String[]);\n        Code:\n           0: bipush        10\n           2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n           5: astore_1\n           6: aload_1\n           7: invokevirtual #3                  // Method java/lang/Integer.intValue:()I\n          10: istore_2\n          11: return\n    }\n\n    ```\n\n> 从以上java代码可以看出，“Integer integer = 10;”此句发生了Autoboxing。</br>\n从汇编结果可以看出，实际在编译的时候发生了，Integer a = Integer.valueOf(10);调用了Integer类的valueOf方法。\n\n```java\n/**\n * Returns an {@code Integer} instance representing the specified\n * {@code int} value.  If a new {@code Integer} instance is not\n * required, this method should generally be used in preference to\n * the constructor {@link #Integer(int)}, as this method is likely\n * to yield significantly better space and time performance by\n * caching frequently requested values.\n *\n * This method will always cache values in the range -128 to 127,\n * inclusive, and may cache other values outside of this range.\n *\n * @param  i an {@code int} value.\n * @return an {@code Integer} instance representing {@code i}.\n * @since  1.5\n */\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n```\n> 从以上java代码可以看出，“int i = integer;”此句发生了Autounboxing。</br>\n从汇编结果可以看出，实际在编译的时候发生了，int i = integer.intValue();调用了Integer类的intValue方法。\n\n```java\n/**\n * Returns the value of this {@code Integer} as an\n * {@code int}.\n */\npublic int intValue() {\n    return value;\n}\n```\n### 四、总结\n\n> 其他基本数据类型的Autoboxing and Autounboxing也满足此。\n\n----\n#### 思考：\n```java\npackage com.sh.$16.$12.$24;\n\n/**\n * Created by Mr SJL on 2016/12/24.\n *\n * @Author Junlan Shuai\n */\npublic class App2\n{\n    public static void main(String[] args)\n    {\n        int a = 10;\n        int b = 10;\n        Integer c = new Integer(10);\n        Integer d = Integer.valueOf(10);\n        Integer e = 2000;\n        Integer f = 2000;\n\n        System.out.println(\"a=b:\" +(a==b));\n        System.out.println(\"a=c:\" +(a==c));\n        System.out.println(\"a=d:\" +(a==d));\n        System.out.println(\"c=d:\" +(c==d));\n        System.out.println(\"e=f:\" +(e==f));\n    }\n}\n\n// 运行结果：\na=b:true\na=c:true\na=d:true\nc=d:false\ne=f:false\n```\n","slug":"Autopacking and Autounpacking","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn490001zjiaf8vzvu6y","content":"<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><ul>\n<li>首先我们要知道Java中有哪些基本数据类型以及它们各自的封装类:package java.lang;</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">基本数据类型</th>\n<th style=\"text-align:center\">封装类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">byte</td>\n<td style=\"text-align:center\">Byte</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">Boolean</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">char</td>\n<td style=\"text-align:center\">Character</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">short</td>\n<td style=\"text-align:center\">Short</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">Integer</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">long</td>\n<td style=\"text-align:center\">Long</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">float</td>\n<td style=\"text-align:center\">Float</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">double</td>\n<td style=\"text-align:center\">Double</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h3 id=\"一、什么是Autoboxing\"><a href=\"#一、什么是Autoboxing\" class=\"headerlink\" title=\"一、什么是Autoboxing\"></a>一、什么是Autoboxing</h3><blockquote>\n<p>java中Autoboxing是指将基本数据类型自动转换成封装类类型。比如说：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    Integer b = a;</span><br><span class=\"line\">    System.out.println(b);</span><br><span class=\"line\"></span><br><span class=\"line\">    Character d = <span class=\"string\">'c'</span>;</span><br><span class=\"line\">    System.out.println(d);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>函数参数为封装类类型时，调用时传递基本数据类型，会发生Autoboxing。</li>\n<li>将基本数据类型变量赋值给封装类类型时，会发生Autoboxing。</li>\n</ul>\n</blockquote>\n<h3 id=\"二、什么是Autounboxing\"><a href=\"#二、什么是Autounboxing\" class=\"headerlink\" title=\"二、什么是Autounboxing\"></a>二、什么是Autounboxing</h3><blockquote>\n<p>java中Autounboxing是指将封装类类型自动转换成基本数据类型。比如说：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Integer a = <span class=\"keyword\">new</span> Integer(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = a;</span><br><span class=\"line\">    System.out.println(b);</span><br><span class=\"line\"></span><br><span class=\"line\">    Character c = <span class=\"string\">'c'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d = c;</span><br><span class=\"line\">    System.out.println(d);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>函数参数为基本数据类型，调用时传递封装类类型，会发生Autounboxing。</li>\n<li>将封装类类型变量赋值给基本数据类型，或者直接用封装类类型进行基本运算，会发生Autounboxing。</li>\n</ul>\n</blockquote>\n<h3 id=\"三、以int类型为例，讲解Autoboxing和Autounboxing实现原理\"><a href=\"#三、以int类型为例，讲解Autoboxing和Autounboxing实现原理\" class=\"headerlink\" title=\"三、以int类型为例，讲解Autoboxing和Autounboxing实现原理\"></a>三、以int类型为例，讲解Autoboxing和Autounboxing实现原理</h3><blockquote>\n<p>先来看一段代码反汇编的结果</p>\n</blockquote>\n<ul>\n<li><p>java代码</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.$<span class=\"number\">16</span>.$<span class=\"number\">12</span>.$<span class=\"number\">22</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/12/22.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App1</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Integer integer = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = integer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>反汇编结果</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">sh</span>.$16.$12.$22.<span class=\"title\">App1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> com.sh.$<span class=\"number\">16</span>.$<span class=\"number\">12</span>.$<span class=\"number\">22</span>.App1();</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V</span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: bipush        <span class=\"number\">10</span></span><br><span class=\"line\">       2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class=\"line\">       <span class=\"number\">5</span>: astore_1</span><br><span class=\"line\">       <span class=\"number\">6</span>: aload_1</span><br><span class=\"line\">       7: invokevirtual #3                  // Method java/lang/Integer.intValue:()I</span><br><span class=\"line\">      <span class=\"number\">10</span>: istore_2</span><br><span class=\"line\">      <span class=\"number\">11</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>从以上java代码可以看出，“Integer integer = 10;”此句发生了Autoboxing。<br><br>从汇编结果可以看出，实际在编译的时候发生了，Integer a = Integer.valueOf(10);调用了Integer类的valueOf方法。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an &#123;<span class=\"doctag\">@code</span> Integer&#125; instance representing the specified</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> int&#125; value.  If a new &#123;<span class=\"doctag\">@code</span> Integer&#125; instance is not</span></span><br><span class=\"line\"><span class=\"comment\"> * required, this method should generally be used in preference to</span></span><br><span class=\"line\"><span class=\"comment\"> * the constructor &#123;<span class=\"doctag\">@link</span> #Integer(int)&#125;, as this method is likely</span></span><br><span class=\"line\"><span class=\"comment\"> * to yield significantly better space and time performance by</span></span><br><span class=\"line\"><span class=\"comment\"> * caching frequently requested values.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This method will always cache values in the range -128 to 127,</span></span><br><span class=\"line\"><span class=\"comment\"> * inclusive, and may cache other values outside of this range.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  i an &#123;<span class=\"doctag\">@code</span> int&#125; value.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> an &#123;<span class=\"doctag\">@code</span> Integer&#125; instance representing &#123;<span class=\"doctag\">@code</span> i&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span>  1.5</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从以上java代码可以看出，“int i = integer;”此句发生了Autounboxing。<br><br>从汇编结果可以看出，实际在编译的时候发生了，int i = integer.intValue();调用了Integer类的intValue方法。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the value of this &#123;<span class=\"doctag\">@code</span> Integer&#125; as an</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> int&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">intValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h3><blockquote>\n<p>其他基本数据类型的Autoboxing and Autounboxing也满足此。</p>\n</blockquote>\n<hr>\n<h4 id=\"思考：\"><a href=\"#思考：\" class=\"headerlink\" title=\"思考：\"></a>思考：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.$<span class=\"number\">16</span>.$<span class=\"number\">12</span>.$<span class=\"number\">24</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/12/24.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App2</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">        Integer c = <span class=\"keyword\">new</span> Integer(<span class=\"number\">10</span>);</span><br><span class=\"line\">        Integer d = Integer.valueOf(<span class=\"number\">10</span>);</span><br><span class=\"line\">        Integer e = <span class=\"number\">2000</span>;</span><br><span class=\"line\">        Integer f = <span class=\"number\">2000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"a=b:\"</span> +(a==b));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"a=c:\"</span> +(a==c));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"a=d:\"</span> +(a==d));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"c=d:\"</span> +(c==d));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"e=f:\"</span> +(e==f));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行结果：</span></span><br><span class=\"line\">a=b:<span class=\"keyword\">true</span></span><br><span class=\"line\">a=c:<span class=\"keyword\">true</span></span><br><span class=\"line\">a=d:<span class=\"keyword\">true</span></span><br><span class=\"line\">c=d:<span class=\"keyword\">false</span></span><br><span class=\"line\">e=f:<span class=\"keyword\">false</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><ul>\n<li>首先我们要知道Java中有哪些基本数据类型以及它们各自的封装类:package java.lang;</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">基本数据类型</th>\n<th style=\"text-align:center\">封装类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">byte</td>\n<td style=\"text-align:center\">Byte</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">Boolean</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">char</td>\n<td style=\"text-align:center\">Character</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">short</td>\n<td style=\"text-align:center\">Short</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">Integer</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">long</td>\n<td style=\"text-align:center\">Long</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">float</td>\n<td style=\"text-align:center\">Float</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">double</td>\n<td style=\"text-align:center\">Double</td>\n</tr>\n</tbody>\n</table>","more":"<h3 id=\"一、什么是Autoboxing\"><a href=\"#一、什么是Autoboxing\" class=\"headerlink\" title=\"一、什么是Autoboxing\"></a>一、什么是Autoboxing</h3><blockquote>\n<p>java中Autoboxing是指将基本数据类型自动转换成封装类类型。比如说：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    Integer b = a;</span><br><span class=\"line\">    System.out.println(b);</span><br><span class=\"line\"></span><br><span class=\"line\">    Character d = <span class=\"string\">'c'</span>;</span><br><span class=\"line\">    System.out.println(d);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>函数参数为封装类类型时，调用时传递基本数据类型，会发生Autoboxing。</li>\n<li>将基本数据类型变量赋值给封装类类型时，会发生Autoboxing。</li>\n</ul>\n</blockquote>\n<h3 id=\"二、什么是Autounboxing\"><a href=\"#二、什么是Autounboxing\" class=\"headerlink\" title=\"二、什么是Autounboxing\"></a>二、什么是Autounboxing</h3><blockquote>\n<p>java中Autounboxing是指将封装类类型自动转换成基本数据类型。比如说：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Integer a = <span class=\"keyword\">new</span> Integer(<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = a;</span><br><span class=\"line\">    System.out.println(b);</span><br><span class=\"line\"></span><br><span class=\"line\">    Character c = <span class=\"string\">'c'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> d = c;</span><br><span class=\"line\">    System.out.println(d);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>函数参数为基本数据类型，调用时传递封装类类型，会发生Autounboxing。</li>\n<li>将封装类类型变量赋值给基本数据类型，或者直接用封装类类型进行基本运算，会发生Autounboxing。</li>\n</ul>\n</blockquote>\n<h3 id=\"三、以int类型为例，讲解Autoboxing和Autounboxing实现原理\"><a href=\"#三、以int类型为例，讲解Autoboxing和Autounboxing实现原理\" class=\"headerlink\" title=\"三、以int类型为例，讲解Autoboxing和Autounboxing实现原理\"></a>三、以int类型为例，讲解Autoboxing和Autounboxing实现原理</h3><blockquote>\n<p>先来看一段代码反汇编的结果</p>\n</blockquote>\n<ul>\n<li><p>java代码</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.$<span class=\"number\">16</span>.$<span class=\"number\">12</span>.$<span class=\"number\">22</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/12/22.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App1</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Integer integer = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = integer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>反汇编结果</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">com</span>.<span class=\"title\">sh</span>.$16.$12.$22.<span class=\"title\">App1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> com.sh.$<span class=\"number\">16</span>.$<span class=\"number\">12</span>.$<span class=\"number\">22</span>.App1();</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V</span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(java.lang.String[])</span></span>;</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: bipush        <span class=\"number\">10</span></span><br><span class=\"line\">       2: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class=\"line\">       <span class=\"number\">5</span>: astore_1</span><br><span class=\"line\">       <span class=\"number\">6</span>: aload_1</span><br><span class=\"line\">       7: invokevirtual #3                  // Method java/lang/Integer.intValue:()I</span><br><span class=\"line\">      <span class=\"number\">10</span>: istore_2</span><br><span class=\"line\">      <span class=\"number\">11</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>从以上java代码可以看出，“Integer integer = 10;”此句发生了Autoboxing。<br><br>从汇编结果可以看出，实际在编译的时候发生了，Integer a = Integer.valueOf(10);调用了Integer类的valueOf方法。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns an &#123;<span class=\"doctag\">@code</span> Integer&#125; instance representing the specified</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> int&#125; value.  If a new &#123;<span class=\"doctag\">@code</span> Integer&#125; instance is not</span></span><br><span class=\"line\"><span class=\"comment\"> * required, this method should generally be used in preference to</span></span><br><span class=\"line\"><span class=\"comment\"> * the constructor &#123;<span class=\"doctag\">@link</span> #Integer(int)&#125;, as this method is likely</span></span><br><span class=\"line\"><span class=\"comment\"> * to yield significantly better space and time performance by</span></span><br><span class=\"line\"><span class=\"comment\"> * caching frequently requested values.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * This method will always cache values in the range -128 to 127,</span></span><br><span class=\"line\"><span class=\"comment\"> * inclusive, and may cache other values outside of this range.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span>  i an &#123;<span class=\"doctag\">@code</span> int&#125; value.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> an &#123;<span class=\"doctag\">@code</span> Integer&#125; instance representing &#123;<span class=\"doctag\">@code</span> i&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span>  1.5</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title\">valueOf</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Integer(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从以上java代码可以看出，“int i = integer;”此句发生了Autounboxing。<br><br>从汇编结果可以看出，实际在编译的时候发生了，int i = integer.intValue();调用了Integer类的intValue方法。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the value of this &#123;<span class=\"doctag\">@code</span> Integer&#125; as an</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> int&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">intValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h3><blockquote>\n<p>其他基本数据类型的Autoboxing and Autounboxing也满足此。</p>\n</blockquote>\n<hr>\n<h4 id=\"思考：\"><a href=\"#思考：\" class=\"headerlink\" title=\"思考：\"></a>思考：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.$<span class=\"number\">16</span>.$<span class=\"number\">12</span>.$<span class=\"number\">24</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/12/24.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App2</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">        Integer c = <span class=\"keyword\">new</span> Integer(<span class=\"number\">10</span>);</span><br><span class=\"line\">        Integer d = Integer.valueOf(<span class=\"number\">10</span>);</span><br><span class=\"line\">        Integer e = <span class=\"number\">2000</span>;</span><br><span class=\"line\">        Integer f = <span class=\"number\">2000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"a=b:\"</span> +(a==b));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"a=c:\"</span> +(a==c));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"a=d:\"</span> +(a==d));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"c=d:\"</span> +(c==d));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"e=f:\"</span> +(e==f));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行结果：</span></span><br><span class=\"line\">a=b:<span class=\"keyword\">true</span></span><br><span class=\"line\">a=c:<span class=\"keyword\">true</span></span><br><span class=\"line\">a=d:<span class=\"keyword\">true</span></span><br><span class=\"line\">c=d:<span class=\"keyword\">false</span></span><br><span class=\"line\">e=f:<span class=\"keyword\">false</span></span><br></pre></td></tr></table></figure>"},{"title":"CentOS7设置免密登陆","date":"2016-11-26T02:07:15.000Z","_content":"\n* 基本环境\n    * master(centOS7-4:192.168.1.75)\n    * slave1(CentOS7-1:192.168.1.21)\n    * slave2(CentOS7-2:192.168.1.129)\n\n* 前提条件\n\n    > 要保证这三台机器之间可以互相ping通\n\n<!-- more -->\n\n* 基本配置\n    > 在slave1机器上输入命令：vi /etc/ssh/sshd_config\n\n    > 在master机器上输入命令：vi /etc/ssh/sshd_config\n\n    ![image]( http://learningnotes-1251679769.costj.myqcloud.com/linux/8.png  \"图片\")\n\n* 在master和slave1上建立相同的用户，此文章以root用户为例，读者可以自行创建其他用户。\n\n    1. 登陆到master机器上\n    2. 执行命令：mkdir .ssh（创建.ssh文件夹），如果存在此文件夹可以不用创建\n    3. 进入到.ssh目录（执行命令：cd .ssh）,并执行命令：ssh-keygen -t rsa，并一直回车，出现以下结果：\n\n        ![image]( http://learningnotes-1251679769.costj.myqcloud.com/linux/9.png  \"图片\")\n\n        > 可以看到在.ssh目录下面生成了两个文件：id_rsa（私钥）和id_rsa.pub（公钥）两个文件\n\n    4. 使用root用户登陆slave1，同样执行1-3步。\n\n    5. 合并id_rsa.pub，追加到authorized_key文件中\n        * root登录master, 在“.ssh”文件夹下，执行命令：scp id_rsa.pub  root@slave1:~/.ssh/authorized_keys\n\n            ![image]( http://learningnotes-1251679769.costj.myqcloud.com/linux/10.png  \"图片\")\n\n            > 拷贝master的公钥id_rsa.pub到slave1的.ssh/authorized_keys。此过程会要求输入密码。\n\n    6. test登录slave,在“.ssh”文件夹下，输入命令：cat id_rsa.pub >> authorized.keys,把slave1的公钥id_rsa.pub追加到slave的authorized_keys文件。\n\n    7. 在slave1的“.ssh”文件夹下，复制authorized_keys到master的root，命令“scp authorized_keys root@master:~/.ssh/\"，此时，master “.ssh”文件夹下，已经存在与slave1相同的authorized_keys文件\n\n* 测试登陆\n\n    >输入命令：ssh master，登陆到master系统\n\n    ![image]( http://learningnotes-1251679769.costj.myqcloud.com/linux/11.png  \"图片\")\n\n    > 输入命令：exit，退出系统\n","source":"_posts/CentOS7-login.md","raw":"---\ntitle: CentOS7设置免密登陆\ndate: 2016-11-26 10:07:15\ntags:\n    - CentOS\n---\n\n* 基本环境\n    * master(centOS7-4:192.168.1.75)\n    * slave1(CentOS7-1:192.168.1.21)\n    * slave2(CentOS7-2:192.168.1.129)\n\n* 前提条件\n\n    > 要保证这三台机器之间可以互相ping通\n\n<!-- more -->\n\n* 基本配置\n    > 在slave1机器上输入命令：vi /etc/ssh/sshd_config\n\n    > 在master机器上输入命令：vi /etc/ssh/sshd_config\n\n    ![image]( http://learningnotes-1251679769.costj.myqcloud.com/linux/8.png  \"图片\")\n\n* 在master和slave1上建立相同的用户，此文章以root用户为例，读者可以自行创建其他用户。\n\n    1. 登陆到master机器上\n    2. 执行命令：mkdir .ssh（创建.ssh文件夹），如果存在此文件夹可以不用创建\n    3. 进入到.ssh目录（执行命令：cd .ssh）,并执行命令：ssh-keygen -t rsa，并一直回车，出现以下结果：\n\n        ![image]( http://learningnotes-1251679769.costj.myqcloud.com/linux/9.png  \"图片\")\n\n        > 可以看到在.ssh目录下面生成了两个文件：id_rsa（私钥）和id_rsa.pub（公钥）两个文件\n\n    4. 使用root用户登陆slave1，同样执行1-3步。\n\n    5. 合并id_rsa.pub，追加到authorized_key文件中\n        * root登录master, 在“.ssh”文件夹下，执行命令：scp id_rsa.pub  root@slave1:~/.ssh/authorized_keys\n\n            ![image]( http://learningnotes-1251679769.costj.myqcloud.com/linux/10.png  \"图片\")\n\n            > 拷贝master的公钥id_rsa.pub到slave1的.ssh/authorized_keys。此过程会要求输入密码。\n\n    6. test登录slave,在“.ssh”文件夹下，输入命令：cat id_rsa.pub >> authorized.keys,把slave1的公钥id_rsa.pub追加到slave的authorized_keys文件。\n\n    7. 在slave1的“.ssh”文件夹下，复制authorized_keys到master的root，命令“scp authorized_keys root@master:~/.ssh/\"，此时，master “.ssh”文件夹下，已经存在与slave1相同的authorized_keys文件\n\n* 测试登陆\n\n    >输入命令：ssh master，登陆到master系统\n\n    ![image]( http://learningnotes-1251679769.costj.myqcloud.com/linux/11.png  \"图片\")\n\n    > 输入命令：exit，退出系统\n","slug":"CentOS7-login","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4c0003zjiakp30jxne","content":"<ul>\n<li><p>基本环境</p>\n<ul>\n<li>master(centOS7-4:192.168.1.75)</li>\n<li>slave1(CentOS7-1:192.168.1.21)</li>\n<li>slave2(CentOS7-2:192.168.1.129)</li>\n</ul>\n</li>\n<li><p>前提条件</p>\n<blockquote>\n<p>要保证这三台机器之间可以互相ping通</p>\n</blockquote>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>基本配置</p>\n<blockquote>\n<p>在slave1机器上输入命令：vi /etc/ssh/sshd_config</p>\n<p>在master机器上输入命令：vi /etc/ssh/sshd_config</p>\n</blockquote>\n<p>  <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/8.png\" alt=\"image\" title=\"图片\"></p>\n</li>\n<li><p>在master和slave1上建立相同的用户，此文章以root用户为例，读者可以自行创建其他用户。</p>\n<ol>\n<li>登陆到master机器上</li>\n<li>执行命令：mkdir .ssh（创建.ssh文件夹），如果存在此文件夹可以不用创建</li>\n<li><p>进入到.ssh目录（执行命令：cd .ssh）,并执行命令：ssh-keygen -t rsa，并一直回车，出现以下结果：</p>\n<p> <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/9.png\" alt=\"image\" title=\"图片\"></p>\n<blockquote>\n<p>可以看到在.ssh目录下面生成了两个文件：id_rsa（私钥）和id_rsa.pub（公钥）两个文件</p>\n</blockquote>\n</li>\n<li><p>使用root用户登陆slave1，同样执行1-3步。</p>\n</li>\n<li><p>合并id_rsa.pub，追加到authorized_key文件中</p>\n<ul>\n<li><p>root登录master, 在“.ssh”文件夹下，执行命令：scp id_rsa.pub  root@slave1:~/.ssh/authorized_keys</p>\n<p>  <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/10.png\" alt=\"image\" title=\"图片\"></p>\n<blockquote>\n<p>拷贝master的公钥id_rsa.pub到slave1的.ssh/authorized_keys。此过程会要求输入密码。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>test登录slave,在“.ssh”文件夹下，输入命令：cat id_rsa.pub &gt;&gt; authorized.keys,把slave1的公钥id_rsa.pub追加到slave的authorized_keys文件。</p>\n</li>\n<li><p>在slave1的“.ssh”文件夹下，复制authorized_keys到master的root，命令“scp authorized_keys root@master:~/.ssh/“，此时，master “.ssh”文件夹下，已经存在与slave1相同的authorized_keys文件</p>\n</li>\n</ol>\n</li>\n<li><p>测试登陆</p>\n<blockquote>\n<p>输入命令：ssh master，登陆到master系统</p>\n</blockquote>\n<p>  <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/11.png\" alt=\"image\" title=\"图片\"></p>\n<blockquote>\n<p>输入命令：exit，退出系统</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><p>基本环境</p>\n<ul>\n<li>master(centOS7-4:192.168.1.75)</li>\n<li>slave1(CentOS7-1:192.168.1.21)</li>\n<li>slave2(CentOS7-2:192.168.1.129)</li>\n</ul>\n</li>\n<li><p>前提条件</p>\n<blockquote>\n<p>要保证这三台机器之间可以互相ping通</p>\n</blockquote>\n</li>\n</ul>","more":"<ul>\n<li><p>基本配置</p>\n<blockquote>\n<p>在slave1机器上输入命令：vi /etc/ssh/sshd_config</p>\n<p>在master机器上输入命令：vi /etc/ssh/sshd_config</p>\n</blockquote>\n<p>  <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/8.png\" alt=\"image\" title=\"图片\"></p>\n</li>\n<li><p>在master和slave1上建立相同的用户，此文章以root用户为例，读者可以自行创建其他用户。</p>\n<ol>\n<li>登陆到master机器上</li>\n<li>执行命令：mkdir .ssh（创建.ssh文件夹），如果存在此文件夹可以不用创建</li>\n<li><p>进入到.ssh目录（执行命令：cd .ssh）,并执行命令：ssh-keygen -t rsa，并一直回车，出现以下结果：</p>\n<p> <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/9.png\" alt=\"image\" title=\"图片\"></p>\n<blockquote>\n<p>可以看到在.ssh目录下面生成了两个文件：id_rsa（私钥）和id_rsa.pub（公钥）两个文件</p>\n</blockquote>\n</li>\n<li><p>使用root用户登陆slave1，同样执行1-3步。</p>\n</li>\n<li><p>合并id_rsa.pub，追加到authorized_key文件中</p>\n<ul>\n<li><p>root登录master, 在“.ssh”文件夹下，执行命令：scp id_rsa.pub  root@slave1:~/.ssh/authorized_keys</p>\n<p>  <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/10.png\" alt=\"image\" title=\"图片\"></p>\n<blockquote>\n<p>拷贝master的公钥id_rsa.pub到slave1的.ssh/authorized_keys。此过程会要求输入密码。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>test登录slave,在“.ssh”文件夹下，输入命令：cat id_rsa.pub &gt;&gt; authorized.keys,把slave1的公钥id_rsa.pub追加到slave的authorized_keys文件。</p>\n</li>\n<li><p>在slave1的“.ssh”文件夹下，复制authorized_keys到master的root，命令“scp authorized_keys root@master:~/.ssh/“，此时，master “.ssh”文件夹下，已经存在与slave1相同的authorized_keys文件</p>\n</li>\n</ol>\n</li>\n<li><p>测试登陆</p>\n<blockquote>\n<p>输入命令：ssh master，登陆到master系统</p>\n</blockquote>\n<p>  <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/11.png\" alt=\"image\" title=\"图片\"></p>\n<blockquote>\n<p>输入命令：exit，退出系统</p>\n</blockquote>\n</li>\n</ul>"},{"title":"Distributed-Systems-Technologies","date":"2018-03-22T02:42:49.000Z","_content":"\n### 1.分布式系统中基本概念及常用技术介绍\n\n#### 网络I/O模型\n\n##### 1.同步和异步\n\n* 同步：\n* 异步：\n\n##### 2.阻塞和非阻塞\n\n* 阻塞：\n* 非阻塞:\n\n##### 3.UNIX网络I/O模型\n\n#### 远程过程调用（RPC）\n\n<!-- more -->\n\n### 2.分布式系统架构体系\n\n #### 基于对象的体系结构\n\n#### 面向服务的架构（SOA）\n\n#### REST风格的架构\n\n#### 微服务架构（MSA）\n\n#### 容器技术\n\n#### Serverless架构原则\n\n### 3.分布式消息服务\n\n#### ActiveMQ\n\n#### RabbitMQ\n\n#### RocketMQ\n\n#### Kafka\n\n\n\n\n\n\n\n","source":"_posts/Distributed-Systems-Technologies.md","raw":"---\ntitle: Distributed-Systems-Technologies\ndate: 2018-03-22 10:42:49\ntags: \n---\n\n### 1.分布式系统中基本概念及常用技术介绍\n\n#### 网络I/O模型\n\n##### 1.同步和异步\n\n* 同步：\n* 异步：\n\n##### 2.阻塞和非阻塞\n\n* 阻塞：\n* 非阻塞:\n\n##### 3.UNIX网络I/O模型\n\n#### 远程过程调用（RPC）\n\n<!-- more -->\n\n### 2.分布式系统架构体系\n\n #### 基于对象的体系结构\n\n#### 面向服务的架构（SOA）\n\n#### REST风格的架构\n\n#### 微服务架构（MSA）\n\n#### 容器技术\n\n#### Serverless架构原则\n\n### 3.分布式消息服务\n\n#### ActiveMQ\n\n#### RabbitMQ\n\n#### RocketMQ\n\n#### Kafka\n\n\n\n\n\n\n\n","slug":"Distributed-Systems-Technologies","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4f0006zjiaro3cdhj3","content":"<h3 id=\"1-分布式系统中基本概念及常用技术介绍\"><a href=\"#1-分布式系统中基本概念及常用技术介绍\" class=\"headerlink\" title=\"1.分布式系统中基本概念及常用技术介绍\"></a>1.分布式系统中基本概念及常用技术介绍</h3><h4 id=\"网络I-O模型\"><a href=\"#网络I-O模型\" class=\"headerlink\" title=\"网络I/O模型\"></a>网络I/O模型</h4><h5 id=\"1-同步和异步\"><a href=\"#1-同步和异步\" class=\"headerlink\" title=\"1.同步和异步\"></a>1.同步和异步</h5><ul>\n<li>同步：</li>\n<li>异步：</li>\n</ul>\n<h5 id=\"2-阻塞和非阻塞\"><a href=\"#2-阻塞和非阻塞\" class=\"headerlink\" title=\"2.阻塞和非阻塞\"></a>2.阻塞和非阻塞</h5><ul>\n<li>阻塞：</li>\n<li>非阻塞:</li>\n</ul>\n<h5 id=\"3-UNIX网络I-O模型\"><a href=\"#3-UNIX网络I-O模型\" class=\"headerlink\" title=\"3.UNIX网络I/O模型\"></a>3.UNIX网络I/O模型</h5><h4 id=\"远程过程调用（RPC）\"><a href=\"#远程过程调用（RPC）\" class=\"headerlink\" title=\"远程过程调用（RPC）\"></a>远程过程调用（RPC）</h4><a id=\"more\"></a>\n<h3 id=\"2-分布式系统架构体系\"><a href=\"#2-分布式系统架构体系\" class=\"headerlink\" title=\"2.分布式系统架构体系\"></a>2.分布式系统架构体系</h3><h4 id=\"基于对象的体系结构\"><a href=\"#基于对象的体系结构\" class=\"headerlink\" title=\"基于对象的体系结构\"></a>基于对象的体系结构</h4><h4 id=\"面向服务的架构（SOA）\"><a href=\"#面向服务的架构（SOA）\" class=\"headerlink\" title=\"面向服务的架构（SOA）\"></a>面向服务的架构（SOA）</h4><h4 id=\"REST风格的架构\"><a href=\"#REST风格的架构\" class=\"headerlink\" title=\"REST风格的架构\"></a>REST风格的架构</h4><h4 id=\"微服务架构（MSA）\"><a href=\"#微服务架构（MSA）\" class=\"headerlink\" title=\"微服务架构（MSA）\"></a>微服务架构（MSA）</h4><h4 id=\"容器技术\"><a href=\"#容器技术\" class=\"headerlink\" title=\"容器技术\"></a>容器技术</h4><h4 id=\"Serverless架构原则\"><a href=\"#Serverless架构原则\" class=\"headerlink\" title=\"Serverless架构原则\"></a>Serverless架构原则</h4><h3 id=\"3-分布式消息服务\"><a href=\"#3-分布式消息服务\" class=\"headerlink\" title=\"3.分布式消息服务\"></a>3.分布式消息服务</h3><h4 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h4><h4 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h4><h4 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h4><h4 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h4>","site":{"data":{}},"excerpt":"<h3 id=\"1-分布式系统中基本概念及常用技术介绍\"><a href=\"#1-分布式系统中基本概念及常用技术介绍\" class=\"headerlink\" title=\"1.分布式系统中基本概念及常用技术介绍\"></a>1.分布式系统中基本概念及常用技术介绍</h3><h4 id=\"网络I-O模型\"><a href=\"#网络I-O模型\" class=\"headerlink\" title=\"网络I/O模型\"></a>网络I/O模型</h4><h5 id=\"1-同步和异步\"><a href=\"#1-同步和异步\" class=\"headerlink\" title=\"1.同步和异步\"></a>1.同步和异步</h5><ul>\n<li>同步：</li>\n<li>异步：</li>\n</ul>\n<h5 id=\"2-阻塞和非阻塞\"><a href=\"#2-阻塞和非阻塞\" class=\"headerlink\" title=\"2.阻塞和非阻塞\"></a>2.阻塞和非阻塞</h5><ul>\n<li>阻塞：</li>\n<li>非阻塞:</li>\n</ul>\n<h5 id=\"3-UNIX网络I-O模型\"><a href=\"#3-UNIX网络I-O模型\" class=\"headerlink\" title=\"3.UNIX网络I/O模型\"></a>3.UNIX网络I/O模型</h5><h4 id=\"远程过程调用（RPC）\"><a href=\"#远程过程调用（RPC）\" class=\"headerlink\" title=\"远程过程调用（RPC）\"></a>远程过程调用（RPC）</h4>","more":"<h3 id=\"2-分布式系统架构体系\"><a href=\"#2-分布式系统架构体系\" class=\"headerlink\" title=\"2.分布式系统架构体系\"></a>2.分布式系统架构体系</h3><h4 id=\"基于对象的体系结构\"><a href=\"#基于对象的体系结构\" class=\"headerlink\" title=\"基于对象的体系结构\"></a>基于对象的体系结构</h4><h4 id=\"面向服务的架构（SOA）\"><a href=\"#面向服务的架构（SOA）\" class=\"headerlink\" title=\"面向服务的架构（SOA）\"></a>面向服务的架构（SOA）</h4><h4 id=\"REST风格的架构\"><a href=\"#REST风格的架构\" class=\"headerlink\" title=\"REST风格的架构\"></a>REST风格的架构</h4><h4 id=\"微服务架构（MSA）\"><a href=\"#微服务架构（MSA）\" class=\"headerlink\" title=\"微服务架构（MSA）\"></a>微服务架构（MSA）</h4><h4 id=\"容器技术\"><a href=\"#容器技术\" class=\"headerlink\" title=\"容器技术\"></a>容器技术</h4><h4 id=\"Serverless架构原则\"><a href=\"#Serverless架构原则\" class=\"headerlink\" title=\"Serverless架构原则\"></a>Serverless架构原则</h4><h3 id=\"3-分布式消息服务\"><a href=\"#3-分布式消息服务\" class=\"headerlink\" title=\"3.分布式消息服务\"></a>3.分布式消息服务</h3><h4 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h4><h4 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h4><h4 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h4><h4 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h4>"},{"title":"基于Zookeeper实现分布式锁","date":"2018-03-31T08:53:40.000Z","_content":"\n## 基于Zookeeper实现分布式锁\n\n```java\nimport com.google.common.base.Strings;\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport org.apache.zookeeper.*;\n\nimport java.io.IOException;\nimport java.util.concurrent.*;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 15:37 2018/3/31.\n */\npublic class DistributedLockBasedOnZookeeper {\n    private String hostPort = \"host:port\";\n    private String lockNameSpace = \"/myLock\";\n    private String nodeString = lockNameSpace + \"/test1\";\n    private ZooKeeper zk;\n\n    public  DistributedLockBasedOnZookeeper(){\n        try {\n            zk = new ZooKeeper(hostPort, 6000, event -> {\n                System.out.println(\"Receive event \" + event);\n                if (Watcher.Event.KeeperState.SyncConnected == event.getState()){\n                    System.out.println(\"Connection is established...\");\n                }\n            });\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    private void ensureRootPath() throws InterruptedException {\n        try {\n            if (zk.exists(lockNameSpace, true) == null){\n                zk.create(lockNameSpace, \"\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n        } catch (KeeperException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void watchNode(String nodeString, final Thread thread){\n        try {\n            zk.exists(nodeString, event -> {\n                System.out.println(\"==\" + event.toString());\n                if (event.getType() == Watcher.Event.EventType.NodeDeleted){\n                    System.out.println(\"There is a Thread released lock.....\");\n                    thread.interrupt();\n                }\n                try {\n                    zk.exists(nodeString, true);\n                } catch (KeeperException e) {\n                    e.printStackTrace();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n        } catch (KeeperException e) {\n            e.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * get Lock\n     * @return\n     */\n    public boolean getLock() throws InterruptedException {\n        String path = null;\n        ensureRootPath();\n        watchNode(nodeString, Thread.currentThread());\n        while (true){\n            try {\n                path = zk.create(nodeString, \"\".getBytes(),ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n            } catch (KeeperException e) {\n                System.out.println(Thread.currentThread().getName() + \"getting Lock but can not get\");\n                Thread.sleep(5000);\n            }\n            if (!Strings.nullToEmpty(path).trim().isEmpty()){\n                System.out.println(Thread.currentThread().getName() + \" get Lock...\");\n                return true;\n            }\n        }\n    }\n\n    /**\n     * release Lock\n     */\n    public void unlock(){\n        try {\n            zk.delete(nodeString, -1);\n            System.out.println(Thread.currentThread().getName() + \" release Lock...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (KeeperException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"demo-pool-%d\").build();\n        ExecutorService service = new ThreadPoolExecutor(10, 10, 1000L, TimeUnit.MILLISECONDS,\n                new ArrayBlockingQueue<>(1024), threadFactory, new ThreadPoolExecutor.AbortPolicy());\n\n        for (int i = 0; i < 4; i++){\n            service.execute(() -> {\n                DistributedLockBasedOnZookeeper lockBasedOnZookeeper = new DistributedLockBasedOnZookeeper();\n                try {\n                    lockBasedOnZookeeper.getLock();\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                lockBasedOnZookeeper.unlock();\n            });\n        }\n        service.shutdown();\n    }\n}\n\n```\n\n","source":"_posts/Distributed-Lock-Based-On-Zookeeper.md","raw":"---\ntitle: 基于Zookeeper实现分布式锁\ndate: 2018-03-31 16:53:40\ntags:\n    - zookeeper\n---\n\n## 基于Zookeeper实现分布式锁\n\n```java\nimport com.google.common.base.Strings;\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport org.apache.zookeeper.*;\n\nimport java.io.IOException;\nimport java.util.concurrent.*;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 15:37 2018/3/31.\n */\npublic class DistributedLockBasedOnZookeeper {\n    private String hostPort = \"host:port\";\n    private String lockNameSpace = \"/myLock\";\n    private String nodeString = lockNameSpace + \"/test1\";\n    private ZooKeeper zk;\n\n    public  DistributedLockBasedOnZookeeper(){\n        try {\n            zk = new ZooKeeper(hostPort, 6000, event -> {\n                System.out.println(\"Receive event \" + event);\n                if (Watcher.Event.KeeperState.SyncConnected == event.getState()){\n                    System.out.println(\"Connection is established...\");\n                }\n            });\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    private void ensureRootPath() throws InterruptedException {\n        try {\n            if (zk.exists(lockNameSpace, true) == null){\n                zk.create(lockNameSpace, \"\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }\n        } catch (KeeperException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void watchNode(String nodeString, final Thread thread){\n        try {\n            zk.exists(nodeString, event -> {\n                System.out.println(\"==\" + event.toString());\n                if (event.getType() == Watcher.Event.EventType.NodeDeleted){\n                    System.out.println(\"There is a Thread released lock.....\");\n                    thread.interrupt();\n                }\n                try {\n                    zk.exists(nodeString, true);\n                } catch (KeeperException e) {\n                    e.printStackTrace();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n        } catch (KeeperException e) {\n            e.printStackTrace();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * get Lock\n     * @return\n     */\n    public boolean getLock() throws InterruptedException {\n        String path = null;\n        ensureRootPath();\n        watchNode(nodeString, Thread.currentThread());\n        while (true){\n            try {\n                path = zk.create(nodeString, \"\".getBytes(),ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n            } catch (KeeperException e) {\n                System.out.println(Thread.currentThread().getName() + \"getting Lock but can not get\");\n                Thread.sleep(5000);\n            }\n            if (!Strings.nullToEmpty(path).trim().isEmpty()){\n                System.out.println(Thread.currentThread().getName() + \" get Lock...\");\n                return true;\n            }\n        }\n    }\n\n    /**\n     * release Lock\n     */\n    public void unlock(){\n        try {\n            zk.delete(nodeString, -1);\n            System.out.println(Thread.currentThread().getName() + \" release Lock...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (KeeperException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"demo-pool-%d\").build();\n        ExecutorService service = new ThreadPoolExecutor(10, 10, 1000L, TimeUnit.MILLISECONDS,\n                new ArrayBlockingQueue<>(1024), threadFactory, new ThreadPoolExecutor.AbortPolicy());\n\n        for (int i = 0; i < 4; i++){\n            service.execute(() -> {\n                DistributedLockBasedOnZookeeper lockBasedOnZookeeper = new DistributedLockBasedOnZookeeper();\n                try {\n                    lockBasedOnZookeeper.getLock();\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                lockBasedOnZookeeper.unlock();\n            });\n        }\n        service.shutdown();\n    }\n}\n\n```\n\n","slug":"Distributed-Lock-Based-On-Zookeeper","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4h0008zjia583ezy0k","content":"<h2 id=\"基于Zookeeper实现分布式锁\"><a href=\"#基于Zookeeper实现分布式锁\" class=\"headerlink\" title=\"基于Zookeeper实现分布式锁\"></a>基于Zookeeper实现分布式锁</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.google.common.base.Strings;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.google.common.util.concurrent.ThreadFactoryBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.zookeeper.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 15:37 2018/3/31.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DistributedLockBasedOnZookeeper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String hostPort = <span class=\"string\">\"host:port\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String lockNameSpace = <span class=\"string\">\"/myLock\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String nodeString = lockNameSpace + <span class=\"string\">\"/test1\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ZooKeeper zk;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"title\">DistributedLockBasedOnZookeeper</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zk = <span class=\"keyword\">new</span> ZooKeeper(hostPort, <span class=\"number\">6000</span>, event -&gt; &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Receive event \"</span> + event);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Watcher.Event.KeeperState.SyncConnected == event.getState())&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"Connection is established...\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureRootPath</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zk.exists(lockNameSpace, <span class=\"keyword\">true</span>) == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                zk.create(lockNameSpace, <span class=\"string\">\"\"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">watchNode</span><span class=\"params\">(String nodeString, <span class=\"keyword\">final</span> Thread thread)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zk.exists(nodeString, event -&gt; &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"==\"</span> + event.toString());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (event.getType() == Watcher.Event.EventType.NodeDeleted)&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"There is a Thread released lock.....\"</span>);</span><br><span class=\"line\">                    thread.interrupt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    zk.exists(nodeString, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * get Lock</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">getLock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        String path = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        ensureRootPath();</span><br><span class=\"line\">        watchNode(nodeString, Thread.currentThread());</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                path = zk.create(nodeString, <span class=\"string\">\"\"</span>.getBytes(),ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"getting Lock but can not get\"</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Strings.nullToEmpty(path).trim().isEmpty())&#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" get Lock...\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * release Lock</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zk.delete(nodeString, -<span class=\"number\">1</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" release Lock...\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ThreadFactory threadFactory = <span class=\"keyword\">new</span> ThreadFactoryBuilder().setNameFormat(<span class=\"string\">\"demo-pool-%d\"</span>).build();</span><br><span class=\"line\">        ExecutorService service = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">1000L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">1024</span>), threadFactory, <span class=\"keyword\">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            service.execute(() -&gt; &#123;</span><br><span class=\"line\">                DistributedLockBasedOnZookeeper lockBasedOnZookeeper = <span class=\"keyword\">new</span> DistributedLockBasedOnZookeeper();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lockBasedOnZookeeper.getLock();</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                lockBasedOnZookeeper.unlock();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        service.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基于Zookeeper实现分布式锁\"><a href=\"#基于Zookeeper实现分布式锁\" class=\"headerlink\" title=\"基于Zookeeper实现分布式锁\"></a>基于Zookeeper实现分布式锁</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.google.common.base.Strings;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.google.common.util.concurrent.ThreadFactoryBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.zookeeper.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 15:37 2018/3/31.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DistributedLockBasedOnZookeeper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String hostPort = <span class=\"string\">\"host:port\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String lockNameSpace = <span class=\"string\">\"/myLock\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String nodeString = lockNameSpace + <span class=\"string\">\"/test1\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ZooKeeper zk;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"title\">DistributedLockBasedOnZookeeper</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zk = <span class=\"keyword\">new</span> ZooKeeper(hostPort, <span class=\"number\">6000</span>, event -&gt; &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Receive event \"</span> + event);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Watcher.Event.KeeperState.SyncConnected == event.getState())&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"Connection is established...\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureRootPath</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (zk.exists(lockNameSpace, <span class=\"keyword\">true</span>) == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                zk.create(lockNameSpace, <span class=\"string\">\"\"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">watchNode</span><span class=\"params\">(String nodeString, <span class=\"keyword\">final</span> Thread thread)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zk.exists(nodeString, event -&gt; &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"==\"</span> + event.toString());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (event.getType() == Watcher.Event.EventType.NodeDeleted)&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"There is a Thread released lock.....\"</span>);</span><br><span class=\"line\">                    thread.interrupt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    zk.exists(nodeString, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * get Lock</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">getLock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        String path = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        ensureRootPath();</span><br><span class=\"line\">        watchNode(nodeString, Thread.currentThread());</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                path = zk.create(nodeString, <span class=\"string\">\"\"</span>.getBytes(),ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\"getting Lock but can not get\"</span>);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Strings.nullToEmpty(path).trim().isEmpty())&#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" get Lock...\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * release Lock</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            zk.delete(nodeString, -<span class=\"number\">1</span>);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">\" release Lock...\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (KeeperException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ThreadFactory threadFactory = <span class=\"keyword\">new</span> ThreadFactoryBuilder().setNameFormat(<span class=\"string\">\"demo-pool-%d\"</span>).build();</span><br><span class=\"line\">        ExecutorService service = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">10</span>, <span class=\"number\">10</span>, <span class=\"number\">1000L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">1024</span>), threadFactory, <span class=\"keyword\">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            service.execute(() -&gt; &#123;</span><br><span class=\"line\">                DistributedLockBasedOnZookeeper lockBasedOnZookeeper = <span class=\"keyword\">new</span> DistributedLockBasedOnZookeeper();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    lockBasedOnZookeeper.getLock();</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                lockBasedOnZookeeper.unlock();</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        service.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"How-to-understand-the-DeadLock","date":"2018-03-25T05:23:26.000Z","_content":"\n## 如何理解如下代码会造成DeadLock\n\n```java\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 10:36 2018/4/14.\n */\npublic class DeadLock {\n    static class Friend{\n        private final String name;\n        public Friend(String name){\n            this.name = name;\n        }\n\n        public String getName(){\n            return this.name;\n        }\n\n        public synchronized void bow(Friend friend){\n            System.out.format(\"%s:%s\" + \" has bowed to me!%n\", this.name, friend.getName());\n            friend.bowBack(this);\n        }\n        public synchronized void bowBack(Friend friend){\n            System.out.format(\"%s:%s\" + \" has bowed back to me!%n\", this.name, friend.getName());\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final Friend friendA = new Friend(\"Shuai\");\n        final Friend friendB = new Friend(\"Junlan\");\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2,\n                2, 1000L, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(2));\n        /// Why not using this way to create ThreadPool?\n        // ExecutorService fixedThreadPool = Executors.newFixedThreadPool(2);\n        threadPoolExecutor.execute(() -> friendA.bow(friendB));\n        threadPoolExecutor.execute(() -> friendB.bow(friendA));\n        threadPoolExecutor.shutdown();\n\n    }\n}\n```\n\n**output**\n\n```\nShuai:Junlan has bowed to me!\nJunlan:Shuai has bowed to me!\n```\n\n**Conclusion**\n\n* 类的实例对类中所有的synchronized方法都持有锁；（表述不够官方）","source":"_posts/How-to-understand-the-DeadLock.md","raw":"---\ntitle: How-to-understand-the-DeadLock\ndate: 2018-03-25 13:23:26\ntags:\n    - java\n    - MutliThread\n---\n\n## 如何理解如下代码会造成DeadLock\n\n```java\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 10:36 2018/4/14.\n */\npublic class DeadLock {\n    static class Friend{\n        private final String name;\n        public Friend(String name){\n            this.name = name;\n        }\n\n        public String getName(){\n            return this.name;\n        }\n\n        public synchronized void bow(Friend friend){\n            System.out.format(\"%s:%s\" + \" has bowed to me!%n\", this.name, friend.getName());\n            friend.bowBack(this);\n        }\n        public synchronized void bowBack(Friend friend){\n            System.out.format(\"%s:%s\" + \" has bowed back to me!%n\", this.name, friend.getName());\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final Friend friendA = new Friend(\"Shuai\");\n        final Friend friendB = new Friend(\"Junlan\");\n        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2,\n                2, 1000L, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<>(2));\n        /// Why not using this way to create ThreadPool?\n        // ExecutorService fixedThreadPool = Executors.newFixedThreadPool(2);\n        threadPoolExecutor.execute(() -> friendA.bow(friendB));\n        threadPoolExecutor.execute(() -> friendB.bow(friendA));\n        threadPoolExecutor.shutdown();\n\n    }\n}\n```\n\n**output**\n\n```\nShuai:Junlan has bowed to me!\nJunlan:Shuai has bowed to me!\n```\n\n**Conclusion**\n\n* 类的实例对类中所有的synchronized方法都持有锁；（表述不够官方）","slug":"How-to-understand-the-DeadLock","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4j000azjiaa69ql759","content":"<h2 id=\"如何理解如下代码会造成DeadLock\"><a href=\"#如何理解如下代码会造成DeadLock\" class=\"headerlink\" title=\"如何理解如下代码会造成DeadLock\"></a>如何理解如下代码会造成DeadLock</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 10:36 2018/4/14.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Friend</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Friend</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">bow</span><span class=\"params\">(Friend friend)</span></span>&#123;</span><br><span class=\"line\">            System.out.format(<span class=\"string\">\"%s:%s\"</span> + <span class=\"string\">\" has bowed to me!%n\"</span>, <span class=\"keyword\">this</span>.name, friend.getName());</span><br><span class=\"line\">            friend.bowBack(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">bowBack</span><span class=\"params\">(Friend friend)</span></span>&#123;</span><br><span class=\"line\">            System.out.format(<span class=\"string\">\"%s:%s\"</span> + <span class=\"string\">\" has bowed back to me!%n\"</span>, <span class=\"keyword\">this</span>.name, friend.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Friend friendA = <span class=\"keyword\">new</span> Friend(<span class=\"string\">\"Shuai\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Friend friendB = <span class=\"keyword\">new</span> Friend(<span class=\"string\">\"Junlan\"</span>);</span><br><span class=\"line\">        ThreadPoolExecutor threadPoolExecutor = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">2</span>,</span><br><span class=\"line\">                <span class=\"number\">2</span>, <span class=\"number\">1000L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">2</span>));</span><br><span class=\"line\">        <span class=\"comment\">/// Why not using this way to create ThreadPool?</span></span><br><span class=\"line\">        <span class=\"comment\">// ExecutorService fixedThreadPool = Executors.newFixedThreadPool(2);</span></span><br><span class=\"line\">        threadPoolExecutor.execute(() -&gt; friendA.bow(friendB));</span><br><span class=\"line\">        threadPoolExecutor.execute(() -&gt; friendB.bow(friendA));</span><br><span class=\"line\">        threadPoolExecutor.shutdown();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>output</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shuai:Junlan has bowed to me!</span><br><span class=\"line\">Junlan:Shuai has bowed to me!</span><br></pre></td></tr></table></figure>\n<p><strong>Conclusion</strong></p>\n<ul>\n<li>类的实例对类中所有的synchronized方法都持有锁；（表述不够官方）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"如何理解如下代码会造成DeadLock\"><a href=\"#如何理解如下代码会造成DeadLock\" class=\"headerlink\" title=\"如何理解如下代码会造成DeadLock\"></a>如何理解如下代码会造成DeadLock</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 10:36 2018/4/14.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Friend</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String name;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Friend</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">bow</span><span class=\"params\">(Friend friend)</span></span>&#123;</span><br><span class=\"line\">            System.out.format(<span class=\"string\">\"%s:%s\"</span> + <span class=\"string\">\" has bowed to me!%n\"</span>, <span class=\"keyword\">this</span>.name, friend.getName());</span><br><span class=\"line\">            friend.bowBack(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">bowBack</span><span class=\"params\">(Friend friend)</span></span>&#123;</span><br><span class=\"line\">            System.out.format(<span class=\"string\">\"%s:%s\"</span> + <span class=\"string\">\" has bowed back to me!%n\"</span>, <span class=\"keyword\">this</span>.name, friend.getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Friend friendA = <span class=\"keyword\">new</span> Friend(<span class=\"string\">\"Shuai\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Friend friendB = <span class=\"keyword\">new</span> Friend(<span class=\"string\">\"Junlan\"</span>);</span><br><span class=\"line\">        ThreadPoolExecutor threadPoolExecutor = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">2</span>,</span><br><span class=\"line\">                <span class=\"number\">2</span>, <span class=\"number\">1000L</span>, TimeUnit.MILLISECONDS, <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">2</span>));</span><br><span class=\"line\">        <span class=\"comment\">/// Why not using this way to create ThreadPool?</span></span><br><span class=\"line\">        <span class=\"comment\">// ExecutorService fixedThreadPool = Executors.newFixedThreadPool(2);</span></span><br><span class=\"line\">        threadPoolExecutor.execute(() -&gt; friendA.bow(friendB));</span><br><span class=\"line\">        threadPoolExecutor.execute(() -&gt; friendB.bow(friendA));</span><br><span class=\"line\">        threadPoolExecutor.shutdown();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>output</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shuai:Junlan has bowed to me!</span><br><span class=\"line\">Junlan:Shuai has bowed to me!</span><br></pre></td></tr></table></figure>\n<p><strong>Conclusion</strong></p>\n<ul>\n<li>类的实例对类中所有的synchronized方法都持有锁；（表述不够官方）</li>\n</ul>\n"},{"title":"Java类与对象初始化过程","date":"2018-04-01T10:58:32.000Z","_content":"\n## 看看如下代码，输出结果是啥？\n\n```java\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 18:59 2018/4/1.\n */\npublic class Test {\n    public static int k = 0;\n    public static Test t1 = new Test(\"t1\");\n    public static Test t2 = new Test(\"t2\");\n    public static int i = print(\"i\");\n    public static int n = 99;\n    public int j = print(\"j\");\n    static {\n        print(\"静态块\");\n    }\n    public Test(String string){\n        System.out.println((++k) + \":\" + string + \" i=\" + i + \" n=\" + n);\n        ++i;\n        ++n;\n    }\n    {\n        print(\"构造块\");\n    }\n    public static int print(String string){\n        System.out.println((++k) + \":\" + string + \" i=\" + i + \" n=\" + n);\n        ++n;\n        return ++i;\n    }\n\n    public static void main(String[] args) {\n        Test test = new Test(\"init\");\n    }\n}\n\n```\n<!-- more -->\n\n**Output**\n\n```\n1:j i=0 n=0\n2:构造块 i=1 n=1\n3:t1 i=2 n=2\n4:j i=3 n=3\n5:构造块 i=4 n=4\n6:t2 i=5 n=5\n7:i i=6 n=6\n8:静态块 i=7 n=99\n9:j i=8 n=100\n10:构造块 i=9 n=101\n11:init i=10 n=102\n```\n\n**Reference**\n\n* [Java类与对象初始化的过程](https://maimai.cn/article/detail?fid=327435262)","source":"_posts/Java-Class-and-Object-Initializing-Process.md","raw":"---\ntitle: Java类与对象初始化过程\ndate: 2018-04-01 18:58:32\ntags:\n    - java\n---\n\n## 看看如下代码，输出结果是啥？\n\n```java\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 18:59 2018/4/1.\n */\npublic class Test {\n    public static int k = 0;\n    public static Test t1 = new Test(\"t1\");\n    public static Test t2 = new Test(\"t2\");\n    public static int i = print(\"i\");\n    public static int n = 99;\n    public int j = print(\"j\");\n    static {\n        print(\"静态块\");\n    }\n    public Test(String string){\n        System.out.println((++k) + \":\" + string + \" i=\" + i + \" n=\" + n);\n        ++i;\n        ++n;\n    }\n    {\n        print(\"构造块\");\n    }\n    public static int print(String string){\n        System.out.println((++k) + \":\" + string + \" i=\" + i + \" n=\" + n);\n        ++n;\n        return ++i;\n    }\n\n    public static void main(String[] args) {\n        Test test = new Test(\"init\");\n    }\n}\n\n```\n<!-- more -->\n\n**Output**\n\n```\n1:j i=0 n=0\n2:构造块 i=1 n=1\n3:t1 i=2 n=2\n4:j i=3 n=3\n5:构造块 i=4 n=4\n6:t2 i=5 n=5\n7:i i=6 n=6\n8:静态块 i=7 n=99\n9:j i=8 n=100\n10:构造块 i=9 n=101\n11:init i=10 n=102\n```\n\n**Reference**\n\n* [Java类与对象初始化的过程](https://maimai.cn/article/detail?fid=327435262)","slug":"Java-Class-and-Object-Initializing-Process","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4k000ezjiap12rh78g","content":"<h2 id=\"看看如下代码，输出结果是啥？\"><a href=\"#看看如下代码，输出结果是啥？\" class=\"headerlink\" title=\"看看如下代码，输出结果是啥？\"></a>看看如下代码，输出结果是啥？</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 18:59 2018/4/1.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Test t1 = <span class=\"keyword\">new</span> Test(<span class=\"string\">\"t1\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Test t2 = <span class=\"keyword\">new</span> Test(<span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i = print(<span class=\"string\">\"i\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> n = <span class=\"number\">99</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> j = print(<span class=\"string\">\"j\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        print(<span class=\"string\">\"静态块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String string)</span></span>&#123;</span><br><span class=\"line\">        System.out.println((++k) + <span class=\"string\">\":\"</span> + string + <span class=\"string\">\" i=\"</span> + i + <span class=\"string\">\" n=\"</span> + n);</span><br><span class=\"line\">        ++i;</span><br><span class=\"line\">        ++n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        print(<span class=\"string\">\"构造块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">print</span><span class=\"params\">(String string)</span></span>&#123;</span><br><span class=\"line\">        System.out.println((++k) + <span class=\"string\">\":\"</span> + string + <span class=\"string\">\" i=\"</span> + i + <span class=\"string\">\" n=\"</span> + n);</span><br><span class=\"line\">        ++n;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ++i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Test test = <span class=\"keyword\">new</span> Test(<span class=\"string\">\"init\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p><strong>Output</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1:j i=0 n=0</span><br><span class=\"line\">2:构造块 i=1 n=1</span><br><span class=\"line\">3:t1 i=2 n=2</span><br><span class=\"line\">4:j i=3 n=3</span><br><span class=\"line\">5:构造块 i=4 n=4</span><br><span class=\"line\">6:t2 i=5 n=5</span><br><span class=\"line\">7:i i=6 n=6</span><br><span class=\"line\">8:静态块 i=7 n=99</span><br><span class=\"line\">9:j i=8 n=100</span><br><span class=\"line\">10:构造块 i=9 n=101</span><br><span class=\"line\">11:init i=10 n=102</span><br></pre></td></tr></table></figure>\n<p><strong>Reference</strong></p>\n<ul>\n<li><a href=\"https://maimai.cn/article/detail?fid=327435262\" target=\"_blank\" rel=\"noopener\">Java类与对象初始化的过程</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"看看如下代码，输出结果是啥？\"><a href=\"#看看如下代码，输出结果是啥？\" class=\"headerlink\" title=\"看看如下代码，输出结果是啥？\"></a>看看如下代码，输出结果是啥？</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 18:59 2018/4/1.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Test t1 = <span class=\"keyword\">new</span> Test(<span class=\"string\">\"t1\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Test t2 = <span class=\"keyword\">new</span> Test(<span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i = print(<span class=\"string\">\"i\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> n = <span class=\"number\">99</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> j = print(<span class=\"string\">\"j\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        print(<span class=\"string\">\"静态块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Test</span><span class=\"params\">(String string)</span></span>&#123;</span><br><span class=\"line\">        System.out.println((++k) + <span class=\"string\">\":\"</span> + string + <span class=\"string\">\" i=\"</span> + i + <span class=\"string\">\" n=\"</span> + n);</span><br><span class=\"line\">        ++i;</span><br><span class=\"line\">        ++n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        print(<span class=\"string\">\"构造块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">print</span><span class=\"params\">(String string)</span></span>&#123;</span><br><span class=\"line\">        System.out.println((++k) + <span class=\"string\">\":\"</span> + string + <span class=\"string\">\" i=\"</span> + i + <span class=\"string\">\" n=\"</span> + n);</span><br><span class=\"line\">        ++n;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ++i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Test test = <span class=\"keyword\">new</span> Test(<span class=\"string\">\"init\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<p><strong>Output</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1:j i=0 n=0</span><br><span class=\"line\">2:构造块 i=1 n=1</span><br><span class=\"line\">3:t1 i=2 n=2</span><br><span class=\"line\">4:j i=3 n=3</span><br><span class=\"line\">5:构造块 i=4 n=4</span><br><span class=\"line\">6:t2 i=5 n=5</span><br><span class=\"line\">7:i i=6 n=6</span><br><span class=\"line\">8:静态块 i=7 n=99</span><br><span class=\"line\">9:j i=8 n=100</span><br><span class=\"line\">10:构造块 i=9 n=101</span><br><span class=\"line\">11:init i=10 n=102</span><br></pre></td></tr></table></figure>\n<p><strong>Reference</strong></p>\n<ul>\n<li><a href=\"https://maimai.cn/article/detail?fid=327435262\" target=\"_blank\" rel=\"noopener\">Java类与对象初始化的过程</a></li>\n</ul>"},{"title":"Java NIO and BIO","date":"2018-04-19T10:43:24.000Z","_content":"\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1526020447.png?raw=true)\n\n我们都知NIO是非阻塞IO，BIO是阻塞IO，那到底什么是阻塞，什么是非阻塞呢，它们与同步/异步又有什么区别呢？先来了解一下阻塞/非阻塞，同步/异步的概念。\n\n<!-- more -->\n\n#### 阻塞/非阻塞/同步/异步\n\n* 阻塞：\n\n  当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；\n\n\n* 非阻塞：\n\n  当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。\n\n* 同步：\n\n  可以理解为在执行一个函数或方法，只有接收到返回的值或消息后才会继续往下执行其他的命令。\n\n  ![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1525844998.png?raw=true)\n\n  callee执行完成才返回\n  返回值即结果\n\n\n* 异步：\n\n  可以理解为在执行一个函数或方法，不用等待其返回，继续往下执行其他的命令。\n\n  ![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1525845072.png?raw=true)\n\n  callee不需要执行完成就可返回\n  caller要获取结果，需要通过轮询、回调等机制\n\n\n**Update**\n\n> 同步与异步的区别：函数调用发生时，消息(参数)从caller传递到callee，控制权(指令执行)从caller转移到callee。调用返回时，控制权从callee转移到caller。两者的区别在于，callee是否需要等待执行完成才将控制权转移给caller。\n\n#### 阻塞IO和非阻塞IO\n\n通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。\n\n当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：\n\n* 查看数据是否就绪；\n* 进行数据拷贝（内核将数据拷贝到用户线程）。\n\n那么阻塞（BIO）和非阻塞（NIO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。\n\nJava中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待，从jdk1.4开始引入NIO。\t\n\n#### 基于Java API实现NioServer\n\n```java\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 14:19 2018/4/15.\n *\n * 基于Java API实现NIO server\n */\npublic class PlainNioServer {\n    public void server(int port) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.configureBlocking(false);\n        ServerSocket serverSocket =serverSocketChannel.socket();\n        //将服务器绑定到选定的端口\n        InetSocketAddress address = new InetSocketAddress(port);\n        serverSocket.bind(address);\n        //打开Selector来处理Channel\n        Selector selector = Selector.open();\n        //将ServerSocket注册到Selector以接受连接\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        final ByteBuffer msg = ByteBuffer.wrap(\"Hi! \\r\\n\".getBytes());\n\n        for (;;){\n            try {\n                //等待需要处理的新事件；阻塞将一直持续到下一个传入事件\n                selector.select();\n            } catch (IOException ex){\n                ex.printStackTrace();\n                break;\n            }\n            //获取所有接收事件的SelectorKey实例\n            Set<SelectionKey> readyKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = readyKeys.iterator();\n            while (iterator.hasNext()){\n                SelectionKey key = iterator.next();\n                iterator.remove();\n                //检查事件是否是一个新的已经就绪可以被接受的连接\n                if (key.isAcceptable()){\n                    ServerSocketChannel server = (ServerSocketChannel) key.channel();\n                    SocketChannel client = server.accept();\n                    client.configureBlocking(false);\n                    //接受客户端，并将它注册到选择器\n                    client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, msg.duplicate());\n                    System.out.println(\"Accepted connection from \" + client);\n\n                }\n                //检查套接字是否已经准备好写数据\n                if (key.isWritable()){\n                    SocketChannel client = (SocketChannel)key.channel();\n                    ByteBuffer byteBuffer = (ByteBuffer)key.attachment();\n                    while (byteBuffer.hasRemaining()){\n                        //将数据写到已连接的客户端\n                        if (client.write(byteBuffer) == 0){\n                            break;\n                        }\n                    }\n                    //关闭连接\n                    client.close();\n\n                }\n                key.cancel();\n                key.channel().close();\n            }\n        }\n\n    }\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/Java-NIO-and-BIO.md","raw":"---\ntitle: Java NIO and BIO\ndate: 2018-04-19 18:43:24\ntags:\n    - java\n    - NIO\n---\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1526020447.png?raw=true)\n\n我们都知NIO是非阻塞IO，BIO是阻塞IO，那到底什么是阻塞，什么是非阻塞呢，它们与同步/异步又有什么区别呢？先来了解一下阻塞/非阻塞，同步/异步的概念。\n\n<!-- more -->\n\n#### 阻塞/非阻塞/同步/异步\n\n* 阻塞：\n\n  当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；\n\n\n* 非阻塞：\n\n  当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。\n\n* 同步：\n\n  可以理解为在执行一个函数或方法，只有接收到返回的值或消息后才会继续往下执行其他的命令。\n\n  ![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1525844998.png?raw=true)\n\n  callee执行完成才返回\n  返回值即结果\n\n\n* 异步：\n\n  可以理解为在执行一个函数或方法，不用等待其返回，继续往下执行其他的命令。\n\n  ![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1525845072.png?raw=true)\n\n  callee不需要执行完成就可返回\n  caller要获取结果，需要通过轮询、回调等机制\n\n\n**Update**\n\n> 同步与异步的区别：函数调用发生时，消息(参数)从caller传递到callee，控制权(指令执行)从caller转移到callee。调用返回时，控制权从callee转移到caller。两者的区别在于，callee是否需要等待执行完成才将控制权转移给caller。\n\n#### 阻塞IO和非阻塞IO\n\n通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。\n\n当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：\n\n* 查看数据是否就绪；\n* 进行数据拷贝（内核将数据拷贝到用户线程）。\n\n那么阻塞（BIO）和非阻塞（NIO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。\n\nJava中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待，从jdk1.4开始引入NIO。\t\n\n#### 基于Java API实现NioServer\n\n```java\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 14:19 2018/4/15.\n *\n * 基于Java API实现NIO server\n */\npublic class PlainNioServer {\n    public void server(int port) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.configureBlocking(false);\n        ServerSocket serverSocket =serverSocketChannel.socket();\n        //将服务器绑定到选定的端口\n        InetSocketAddress address = new InetSocketAddress(port);\n        serverSocket.bind(address);\n        //打开Selector来处理Channel\n        Selector selector = Selector.open();\n        //将ServerSocket注册到Selector以接受连接\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        final ByteBuffer msg = ByteBuffer.wrap(\"Hi! \\r\\n\".getBytes());\n\n        for (;;){\n            try {\n                //等待需要处理的新事件；阻塞将一直持续到下一个传入事件\n                selector.select();\n            } catch (IOException ex){\n                ex.printStackTrace();\n                break;\n            }\n            //获取所有接收事件的SelectorKey实例\n            Set<SelectionKey> readyKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = readyKeys.iterator();\n            while (iterator.hasNext()){\n                SelectionKey key = iterator.next();\n                iterator.remove();\n                //检查事件是否是一个新的已经就绪可以被接受的连接\n                if (key.isAcceptable()){\n                    ServerSocketChannel server = (ServerSocketChannel) key.channel();\n                    SocketChannel client = server.accept();\n                    client.configureBlocking(false);\n                    //接受客户端，并将它注册到选择器\n                    client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, msg.duplicate());\n                    System.out.println(\"Accepted connection from \" + client);\n\n                }\n                //检查套接字是否已经准备好写数据\n                if (key.isWritable()){\n                    SocketChannel client = (SocketChannel)key.channel();\n                    ByteBuffer byteBuffer = (ByteBuffer)key.attachment();\n                    while (byteBuffer.hasRemaining()){\n                        //将数据写到已连接的客户端\n                        if (client.write(byteBuffer) == 0){\n                            break;\n                        }\n                    }\n                    //关闭连接\n                    client.close();\n\n                }\n                key.cancel();\n                key.channel().close();\n            }\n        }\n\n    }\n}\n```\n\n\n\n\n\n\n\n","slug":"Java-NIO-and-BIO","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4m000gzjiadyfe35j2","content":"<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1526020447.png?raw=true\" alt=\"\"></p>\n<p>我们都知NIO是非阻塞IO，BIO是阻塞IO，那到底什么是阻塞，什么是非阻塞呢，它们与同步/异步又有什么区别呢？先来了解一下阻塞/非阻塞，同步/异步的概念。</p>\n<a id=\"more\"></a>\n<h4 id=\"阻塞-非阻塞-同步-异步\"><a href=\"#阻塞-非阻塞-同步-异步\" class=\"headerlink\" title=\"阻塞/非阻塞/同步/异步\"></a>阻塞/非阻塞/同步/异步</h4><ul>\n<li><p>阻塞：</p>\n<p>当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；</p>\n</li>\n</ul>\n<ul>\n<li><p>非阻塞：</p>\n<p>当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。</p>\n</li>\n<li><p>同步：</p>\n<p>可以理解为在执行一个函数或方法，只有接收到返回的值或消息后才会继续往下执行其他的命令。</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1525844998.png?raw=true\" alt=\"\"></p>\n<p>callee执行完成才返回<br>返回值即结果</p>\n</li>\n</ul>\n<ul>\n<li><p>异步：</p>\n<p>可以理解为在执行一个函数或方法，不用等待其返回，继续往下执行其他的命令。</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1525845072.png?raw=true\" alt=\"\"></p>\n<p>callee不需要执行完成就可返回<br>caller要获取结果，需要通过轮询、回调等机制</p>\n</li>\n</ul>\n<p><strong>Update</strong></p>\n<blockquote>\n<p>同步与异步的区别：函数调用发生时，消息(参数)从caller传递到callee，控制权(指令执行)从caller转移到callee。调用返回时，控制权从callee转移到caller。两者的区别在于，callee是否需要等待执行完成才将控制权转移给caller。</p>\n</blockquote>\n<h4 id=\"阻塞IO和非阻塞IO\"><a href=\"#阻塞IO和非阻塞IO\" class=\"headerlink\" title=\"阻塞IO和非阻塞IO\"></a>阻塞IO和非阻塞IO</h4><p>通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。</p>\n<p>当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：</p>\n<ul>\n<li>查看数据是否就绪；</li>\n<li>进行数据拷贝（内核将数据拷贝到用户线程）。</li>\n</ul>\n<p>那么阻塞（BIO）和非阻塞（NIO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。</p>\n<p>Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待，从jdk1.4开始引入NIO。    </p>\n<h4 id=\"基于Java-API实现NioServer\"><a href=\"#基于Java-API实现NioServer\" class=\"headerlink\" title=\"基于Java API实现NioServer\"></a>基于Java API实现NioServer</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 14:19 2018/4/15.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 基于Java API实现NIO server</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlainNioServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">server</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        ServerSocket serverSocket =serverSocketChannel.socket();</span><br><span class=\"line\">        <span class=\"comment\">//将服务器绑定到选定的端口</span></span><br><span class=\"line\">        InetSocketAddress address = <span class=\"keyword\">new</span> InetSocketAddress(port);</span><br><span class=\"line\">        serverSocket.bind(address);</span><br><span class=\"line\">        <span class=\"comment\">//打开Selector来处理Channel</span></span><br><span class=\"line\">        Selector selector = Selector.open();</span><br><span class=\"line\">        <span class=\"comment\">//将ServerSocket注册到Selector以接受连接</span></span><br><span class=\"line\">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ByteBuffer msg = ByteBuffer.wrap(<span class=\"string\">\"Hi! \\r\\n\"</span>.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//等待需要处理的新事件；阻塞将一直持续到下一个传入事件</span></span><br><span class=\"line\">                selector.select();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ex)&#123;</span><br><span class=\"line\">                ex.printStackTrace();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//获取所有接收事件的SelectorKey实例</span></span><br><span class=\"line\">            Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();</span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iterator.hasNext())&#123;</span><br><span class=\"line\">                SelectionKey key = iterator.next();</span><br><span class=\"line\">                iterator.remove();</span><br><span class=\"line\">                <span class=\"comment\">//检查事件是否是一个新的已经就绪可以被接受的连接</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.isAcceptable())&#123;</span><br><span class=\"line\">                    ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                    SocketChannel client = server.accept();</span><br><span class=\"line\">                    client.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//接受客户端，并将它注册到选择器</span></span><br><span class=\"line\">                    client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, msg.duplicate());</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"Accepted connection from \"</span> + client);</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//检查套接字是否已经准备好写数据</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.isWritable())&#123;</span><br><span class=\"line\">                    SocketChannel client = (SocketChannel)key.channel();</span><br><span class=\"line\">                    ByteBuffer byteBuffer = (ByteBuffer)key.attachment();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (byteBuffer.hasRemaining())&#123;</span><br><span class=\"line\">                        <span class=\"comment\">//将数据写到已连接的客户端</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (client.write(byteBuffer) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//关闭连接</span></span><br><span class=\"line\">                    client.close();</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                key.cancel();</span><br><span class=\"line\">                key.channel().close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1526020447.png?raw=true\" alt=\"\"></p>\n<p>我们都知NIO是非阻塞IO，BIO是阻塞IO，那到底什么是阻塞，什么是非阻塞呢，它们与同步/异步又有什么区别呢？先来了解一下阻塞/非阻塞，同步/异步的概念。</p>","more":"<h4 id=\"阻塞-非阻塞-同步-异步\"><a href=\"#阻塞-非阻塞-同步-异步\" class=\"headerlink\" title=\"阻塞/非阻塞/同步/异步\"></a>阻塞/非阻塞/同步/异步</h4><ul>\n<li><p>阻塞：</p>\n<p>当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；</p>\n</li>\n</ul>\n<ul>\n<li><p>非阻塞：</p>\n<p>当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。</p>\n</li>\n<li><p>同步：</p>\n<p>可以理解为在执行一个函数或方法，只有接收到返回的值或消息后才会继续往下执行其他的命令。</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1525844998.png?raw=true\" alt=\"\"></p>\n<p>callee执行完成才返回<br>返回值即结果</p>\n</li>\n</ul>\n<ul>\n<li><p>异步：</p>\n<p>可以理解为在执行一个函数或方法，不用等待其返回，继续往下执行其他的命令。</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1525845072.png?raw=true\" alt=\"\"></p>\n<p>callee不需要执行完成就可返回<br>caller要获取结果，需要通过轮询、回调等机制</p>\n</li>\n</ul>\n<p><strong>Update</strong></p>\n<blockquote>\n<p>同步与异步的区别：函数调用发生时，消息(参数)从caller传递到callee，控制权(指令执行)从caller转移到callee。调用返回时，控制权从callee转移到caller。两者的区别在于，callee是否需要等待执行完成才将控制权转移给caller。</p>\n</blockquote>\n<h4 id=\"阻塞IO和非阻塞IO\"><a href=\"#阻塞IO和非阻塞IO\" class=\"headerlink\" title=\"阻塞IO和非阻塞IO\"></a>阻塞IO和非阻塞IO</h4><p>通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。</p>\n<p>当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：</p>\n<ul>\n<li>查看数据是否就绪；</li>\n<li>进行数据拷贝（内核将数据拷贝到用户线程）。</li>\n</ul>\n<p>那么阻塞（BIO）和非阻塞（NIO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。</p>\n<p>Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待，从jdk1.4开始引入NIO。    </p>\n<h4 id=\"基于Java-API实现NioServer\"><a href=\"#基于Java-API实现NioServer\" class=\"headerlink\" title=\"基于Java API实现NioServer\"></a>基于Java API实现NioServer</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 14:19 2018/4/15.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 基于Java API实现NIO server</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlainNioServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">server</span><span class=\"params\">(<span class=\"keyword\">int</span> port)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class=\"line\">        serverSocketChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        ServerSocket serverSocket =serverSocketChannel.socket();</span><br><span class=\"line\">        <span class=\"comment\">//将服务器绑定到选定的端口</span></span><br><span class=\"line\">        InetSocketAddress address = <span class=\"keyword\">new</span> InetSocketAddress(port);</span><br><span class=\"line\">        serverSocket.bind(address);</span><br><span class=\"line\">        <span class=\"comment\">//打开Selector来处理Channel</span></span><br><span class=\"line\">        Selector selector = Selector.open();</span><br><span class=\"line\">        <span class=\"comment\">//将ServerSocket注册到Selector以接受连接</span></span><br><span class=\"line\">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ByteBuffer msg = ByteBuffer.wrap(<span class=\"string\">\"Hi! \\r\\n\"</span>.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//等待需要处理的新事件；阻塞将一直持续到下一个传入事件</span></span><br><span class=\"line\">                selector.select();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ex)&#123;</span><br><span class=\"line\">                ex.printStackTrace();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//获取所有接收事件的SelectorKey实例</span></span><br><span class=\"line\">            Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys();</span><br><span class=\"line\">            Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (iterator.hasNext())&#123;</span><br><span class=\"line\">                SelectionKey key = iterator.next();</span><br><span class=\"line\">                iterator.remove();</span><br><span class=\"line\">                <span class=\"comment\">//检查事件是否是一个新的已经就绪可以被接受的连接</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.isAcceptable())&#123;</span><br><span class=\"line\">                    ServerSocketChannel server = (ServerSocketChannel) key.channel();</span><br><span class=\"line\">                    SocketChannel client = server.accept();</span><br><span class=\"line\">                    client.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//接受客户端，并将它注册到选择器</span></span><br><span class=\"line\">                    client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, msg.duplicate());</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"Accepted connection from \"</span> + client);</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//检查套接字是否已经准备好写数据</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.isWritable())&#123;</span><br><span class=\"line\">                    SocketChannel client = (SocketChannel)key.channel();</span><br><span class=\"line\">                    ByteBuffer byteBuffer = (ByteBuffer)key.attachment();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (byteBuffer.hasRemaining())&#123;</span><br><span class=\"line\">                        <span class=\"comment\">//将数据写到已连接的客户端</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (client.write(byteBuffer) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//关闭连接</span></span><br><span class=\"line\">                    client.close();</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                key.cancel();</span><br><span class=\"line\">                key.channel().close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Basing on Spring SpringMVC MyBatis Druid Shrio developing web system","date":"2017-11-03T03:46:39.000Z","_content":"源码下载地址：[https://github.com/shuaijunlan/Autumn-Framework](https://github.com/shuaijunlan/Autumn-Framework)\n\n在线Demo：[http://autumn.shuaijunlan.cn](http://autumn.shuaijunlan.cn)\n\n#### 项目介绍\n`Autumn-Framework`旨在提供通用的web系统解决方案，目前由作者本人一个人维护，更新速度缓慢，但是会持续更新，此项目适合初学者学习使用，也欢迎您加入我一起维护整个项目。\n\n<!-- more -->\n\n#### 效果图\n* 登录界面\n  ![登录界面][login]\n* 系统主界面\n  ![系统主界面][main]\n* 菜单管理\n  ![菜单管理][menu]\n* 日志管理\n  ![日志管理][log]\n\n  ![日志管理][log1]\n\n#### 技术选型\n前端以`Layui`为主要框架，并使用了`ECharts`、`editor.md`等其他第三方插件</br>\n后端主要使用`Spring`、`SpringMVC`、`MyBatis`、`Shiro`、`Druid`、`Ehcache`构建整个web系统，并使用Maven管理项目，使用Mysql存储数据，使用tomcat部署web系统。\n\n#### 代码结构\n```\n.\n└── src-------------------------------------------源码根目录\n    └── main\n        ├── java\n        │   └── com\n        │       └── autumnframework\n        │           └── cms\n        │               ├── architect-------------包含常用的工具类和常量\n        │               │   ├── conf\n        │               │   ├── constant\n        │               │   ├── filter\n        │               │   ├── interceptor\n        │               │   └── utils\n        │               ├── controller------------控制器层\n        │               │   └── system\n        │               ├── dao-------------------dao层\n        │               │   ├── bomapper\n        │               │   └── vomapper\n        │               │       ├── impl\n        │               │       └── interfaces\n        │               ├── model-----------------model层\n        │               │   ├── bo\n        │               │   ├── po\n        │               │   └── vo\n        │               ├── service---------------service层\n        │               │   ├── impl\n        │               │   └── interfaces\n        │               └── shiroconfig-----------shiro配置\n        │                   ├── filter\n        │                   └── realm\n        ├── resources----------------------------资源文件目录\n        │   ├── mapperxml------------------------mapper映射文件\n        │   ├── mybatis-generator----------------mybatis-generator配置文件\n        │   └── spring---------------------------所有与spring相关的配置文件\n        └── webapp-------------------------------前端源码文件\n            ├── BasePlu--------------------------公共库\n            ├── comm\n            ├── Lib------------------------------第三方库\n            │   ├── Echarts-3.7.2\n            │   ├── editor.md\n            │   ├── jquery\n            │   └── layui_v2.1.2\n            ├── static--------------------------静态资源\n            ├── Sys-----------------------------系统功能插件目录\n            │   ├── js\n            │   └── plugin\n            └── WEB-INF\n                └── views\n                    ├── error-------------------异常目录\n                    └── main--------------------系统主界面目录\n```\n\n#### 运行系统\n* 拷贝代码到本地`git clone git@github.com:shuaijunlan/Autumn-Framework.git`\n* 进入Autumn-Framework目录`cd Autumn-Framework`\n* 执行`mvn install`\n* 再进入cms目录`cd cms`\n* 在执行`mvn tomcat7:run`\n* 最后在浏览器中访问`localhost:8081`，就可以看到登录界面\n* Tips：以上所有操作基于您的电脑已经安装了`jdk8`、`maven`和`git`环境\n\n#### FAQ\n\n\n#### 联系作者\n您有任何问题都可以随时联系我！ \n\nEmail：shuaijunlan@gmail.com\n\n-----------------------------\n[login]:https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/login-page.png?raw=true \"登录界面\"\n[main]:https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/main-page.png?raw=true  \"系统主界面\"\"\n[menu]:https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/menu-manage.png?raw=true  \"菜单管理\"\"\n[log]:https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/log-manage1.png?raw=true \"日志管理\"\n[log1]:https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/log-manage2.png?raw=true  \"日志管理\"\n\n","source":"_posts/Basing-on-Spring-SpringMVC-MyBatis-Druid-Shrio-developing-web-system.md","raw":"---\ntitle: Basing on Spring SpringMVC MyBatis Druid Shrio developing web system\ndate: 2017-11-03 11:46:39\ntags:\n    - WebSystem\ncategories:\n    - WebSystem\n---\n源码下载地址：[https://github.com/shuaijunlan/Autumn-Framework](https://github.com/shuaijunlan/Autumn-Framework)\n\n在线Demo：[http://autumn.shuaijunlan.cn](http://autumn.shuaijunlan.cn)\n\n#### 项目介绍\n`Autumn-Framework`旨在提供通用的web系统解决方案，目前由作者本人一个人维护，更新速度缓慢，但是会持续更新，此项目适合初学者学习使用，也欢迎您加入我一起维护整个项目。\n\n<!-- more -->\n\n#### 效果图\n* 登录界面\n  ![登录界面][login]\n* 系统主界面\n  ![系统主界面][main]\n* 菜单管理\n  ![菜单管理][menu]\n* 日志管理\n  ![日志管理][log]\n\n  ![日志管理][log1]\n\n#### 技术选型\n前端以`Layui`为主要框架，并使用了`ECharts`、`editor.md`等其他第三方插件</br>\n后端主要使用`Spring`、`SpringMVC`、`MyBatis`、`Shiro`、`Druid`、`Ehcache`构建整个web系统，并使用Maven管理项目，使用Mysql存储数据，使用tomcat部署web系统。\n\n#### 代码结构\n```\n.\n└── src-------------------------------------------源码根目录\n    └── main\n        ├── java\n        │   └── com\n        │       └── autumnframework\n        │           └── cms\n        │               ├── architect-------------包含常用的工具类和常量\n        │               │   ├── conf\n        │               │   ├── constant\n        │               │   ├── filter\n        │               │   ├── interceptor\n        │               │   └── utils\n        │               ├── controller------------控制器层\n        │               │   └── system\n        │               ├── dao-------------------dao层\n        │               │   ├── bomapper\n        │               │   └── vomapper\n        │               │       ├── impl\n        │               │       └── interfaces\n        │               ├── model-----------------model层\n        │               │   ├── bo\n        │               │   ├── po\n        │               │   └── vo\n        │               ├── service---------------service层\n        │               │   ├── impl\n        │               │   └── interfaces\n        │               └── shiroconfig-----------shiro配置\n        │                   ├── filter\n        │                   └── realm\n        ├── resources----------------------------资源文件目录\n        │   ├── mapperxml------------------------mapper映射文件\n        │   ├── mybatis-generator----------------mybatis-generator配置文件\n        │   └── spring---------------------------所有与spring相关的配置文件\n        └── webapp-------------------------------前端源码文件\n            ├── BasePlu--------------------------公共库\n            ├── comm\n            ├── Lib------------------------------第三方库\n            │   ├── Echarts-3.7.2\n            │   ├── editor.md\n            │   ├── jquery\n            │   └── layui_v2.1.2\n            ├── static--------------------------静态资源\n            ├── Sys-----------------------------系统功能插件目录\n            │   ├── js\n            │   └── plugin\n            └── WEB-INF\n                └── views\n                    ├── error-------------------异常目录\n                    └── main--------------------系统主界面目录\n```\n\n#### 运行系统\n* 拷贝代码到本地`git clone git@github.com:shuaijunlan/Autumn-Framework.git`\n* 进入Autumn-Framework目录`cd Autumn-Framework`\n* 执行`mvn install`\n* 再进入cms目录`cd cms`\n* 在执行`mvn tomcat7:run`\n* 最后在浏览器中访问`localhost:8081`，就可以看到登录界面\n* Tips：以上所有操作基于您的电脑已经安装了`jdk8`、`maven`和`git`环境\n\n#### FAQ\n\n\n#### 联系作者\n您有任何问题都可以随时联系我！ \n\nEmail：shuaijunlan@gmail.com\n\n-----------------------------\n[login]:https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/login-page.png?raw=true \"登录界面\"\n[main]:https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/main-page.png?raw=true  \"系统主界面\"\"\n[menu]:https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/menu-manage.png?raw=true  \"菜单管理\"\"\n[log]:https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/log-manage1.png?raw=true \"日志管理\"\n[log1]:https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/log-manage2.png?raw=true  \"日志管理\"\n\n","slug":"Basing-on-Spring-SpringMVC-MyBatis-Druid-Shrio-developing-web-system","published":1,"updated":"2018-11-22T11:24:54.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4o000kzjiaaf3tn6n8","content":"<p>源码下载地址：<a href=\"https://github.com/shuaijunlan/Autumn-Framework\" target=\"_blank\" rel=\"noopener\">https://github.com/shuaijunlan/Autumn-Framework</a></p>\n<p>在线Demo：<a href=\"http://autumn.shuaijunlan.cn\" target=\"_blank\" rel=\"noopener\">http://autumn.shuaijunlan.cn</a></p>\n<h4 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h4><p><code>Autumn-Framework</code>旨在提供通用的web系统解决方案，目前由作者本人一个人维护，更新速度缓慢，但是会持续更新，此项目适合初学者学习使用，也欢迎您加入我一起维护整个项目。</p>\n<a id=\"more\"></a>\n<h4 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h4><ul>\n<li>登录界面<br><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/login-page.png?raw=true\" alt=\"登录界面\" title=\"登录界面\"></li>\n<li>系统主界面<br><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/main-page.png?raw=true\" alt=\"系统主界面\" title=\"系统主界面&quot;\"></li>\n<li>菜单管理<br><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/menu-manage.png?raw=true\" alt=\"菜单管理\" title=\"菜单管理&quot;\"></li>\n<li><p>日志管理<br><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/log-manage1.png?raw=true\" alt=\"日志管理\" title=\"日志管理\"></p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/log-manage2.png?raw=true\" alt=\"日志管理\" title=\"日志管理\"></p>\n</li>\n</ul>\n<h4 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h4><p>前端以<code>Layui</code>为主要框架，并使用了<code>ECharts</code>、<code>editor.md</code>等其他第三方插件<br><br>后端主要使用<code>Spring</code>、<code>SpringMVC</code>、<code>MyBatis</code>、<code>Shiro</code>、<code>Druid</code>、<code>Ehcache</code>构建整个web系统，并使用Maven管理项目，使用Mysql存储数据，使用tomcat部署web系统。</p>\n<h4 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">└── src-------------------------------------------源码根目录</span><br><span class=\"line\">    └── main</span><br><span class=\"line\">        ├── java</span><br><span class=\"line\">        │   └── com</span><br><span class=\"line\">        │       └── autumnframework</span><br><span class=\"line\">        │           └── cms</span><br><span class=\"line\">        │               ├── architect-------------包含常用的工具类和常量</span><br><span class=\"line\">        │               │   ├── conf</span><br><span class=\"line\">        │               │   ├── constant</span><br><span class=\"line\">        │               │   ├── filter</span><br><span class=\"line\">        │               │   ├── interceptor</span><br><span class=\"line\">        │               │   └── utils</span><br><span class=\"line\">        │               ├── controller------------控制器层</span><br><span class=\"line\">        │               │   └── system</span><br><span class=\"line\">        │               ├── dao-------------------dao层</span><br><span class=\"line\">        │               │   ├── bomapper</span><br><span class=\"line\">        │               │   └── vomapper</span><br><span class=\"line\">        │               │       ├── impl</span><br><span class=\"line\">        │               │       └── interfaces</span><br><span class=\"line\">        │               ├── model-----------------model层</span><br><span class=\"line\">        │               │   ├── bo</span><br><span class=\"line\">        │               │   ├── po</span><br><span class=\"line\">        │               │   └── vo</span><br><span class=\"line\">        │               ├── service---------------service层</span><br><span class=\"line\">        │               │   ├── impl</span><br><span class=\"line\">        │               │   └── interfaces</span><br><span class=\"line\">        │               └── shiroconfig-----------shiro配置</span><br><span class=\"line\">        │                   ├── filter</span><br><span class=\"line\">        │                   └── realm</span><br><span class=\"line\">        ├── resources----------------------------资源文件目录</span><br><span class=\"line\">        │   ├── mapperxml------------------------mapper映射文件</span><br><span class=\"line\">        │   ├── mybatis-generator----------------mybatis-generator配置文件</span><br><span class=\"line\">        │   └── spring---------------------------所有与spring相关的配置文件</span><br><span class=\"line\">        └── webapp-------------------------------前端源码文件</span><br><span class=\"line\">            ├── BasePlu--------------------------公共库</span><br><span class=\"line\">            ├── comm</span><br><span class=\"line\">            ├── Lib------------------------------第三方库</span><br><span class=\"line\">            │   ├── Echarts-3.7.2</span><br><span class=\"line\">            │   ├── editor.md</span><br><span class=\"line\">            │   ├── jquery</span><br><span class=\"line\">            │   └── layui_v2.1.2</span><br><span class=\"line\">            ├── static--------------------------静态资源</span><br><span class=\"line\">            ├── Sys-----------------------------系统功能插件目录</span><br><span class=\"line\">            │   ├── js</span><br><span class=\"line\">            │   └── plugin</span><br><span class=\"line\">            └── WEB-INF</span><br><span class=\"line\">                └── views</span><br><span class=\"line\">                    ├── error-------------------异常目录</span><br><span class=\"line\">                    └── main--------------------系统主界面目录</span><br></pre></td></tr></table></figure>\n<h4 id=\"运行系统\"><a href=\"#运行系统\" class=\"headerlink\" title=\"运行系统\"></a>运行系统</h4><ul>\n<li>拷贝代码到本地<code>git clone git@github.com:shuaijunlan/Autumn-Framework.git</code></li>\n<li>进入Autumn-Framework目录<code>cd Autumn-Framework</code></li>\n<li>执行<code>mvn install</code></li>\n<li>再进入cms目录<code>cd cms</code></li>\n<li>在执行<code>mvn tomcat7:run</code></li>\n<li>最后在浏览器中访问<code>localhost:8081</code>，就可以看到登录界面</li>\n<li>Tips：以上所有操作基于您的电脑已经安装了<code>jdk8</code>、<code>maven</code>和<code>git</code>环境</li>\n</ul>\n<h4 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h4><h4 id=\"联系作者\"><a href=\"#联系作者\" class=\"headerlink\" title=\"联系作者\"></a>联系作者</h4><p>您有任何问题都可以随时联系我！ </p>\n<p>Email：shuaijunlan@gmail.com</p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>源码下载地址：<a href=\"https://github.com/shuaijunlan/Autumn-Framework\" target=\"_blank\" rel=\"noopener\">https://github.com/shuaijunlan/Autumn-Framework</a></p>\n<p>在线Demo：<a href=\"http://autumn.shuaijunlan.cn\" target=\"_blank\" rel=\"noopener\">http://autumn.shuaijunlan.cn</a></p>\n<h4 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h4><p><code>Autumn-Framework</code>旨在提供通用的web系统解决方案，目前由作者本人一个人维护，更新速度缓慢，但是会持续更新，此项目适合初学者学习使用，也欢迎您加入我一起维护整个项目。</p>","more":"<h4 id=\"效果图\"><a href=\"#效果图\" class=\"headerlink\" title=\"效果图\"></a>效果图</h4><ul>\n<li>登录界面<br><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/login-page.png?raw=true\" alt=\"登录界面\" title=\"登录界面\"></li>\n<li>系统主界面<br><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/main-page.png?raw=true\" alt=\"系统主界面\" title=\"系统主界面&quot;\"></li>\n<li>菜单管理<br><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/menu-manage.png?raw=true\" alt=\"菜单管理\" title=\"菜单管理&quot;\"></li>\n<li><p>日志管理<br><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/log-manage1.png?raw=true\" alt=\"日志管理\" title=\"日志管理\"></p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/log-manage2.png?raw=true\" alt=\"日志管理\" title=\"日志管理\"></p>\n</li>\n</ul>\n<h4 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h4><p>前端以<code>Layui</code>为主要框架，并使用了<code>ECharts</code>、<code>editor.md</code>等其他第三方插件<br><br>后端主要使用<code>Spring</code>、<code>SpringMVC</code>、<code>MyBatis</code>、<code>Shiro</code>、<code>Druid</code>、<code>Ehcache</code>构建整个web系统，并使用Maven管理项目，使用Mysql存储数据，使用tomcat部署web系统。</p>\n<h4 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">└── src-------------------------------------------源码根目录</span><br><span class=\"line\">    └── main</span><br><span class=\"line\">        ├── java</span><br><span class=\"line\">        │   └── com</span><br><span class=\"line\">        │       └── autumnframework</span><br><span class=\"line\">        │           └── cms</span><br><span class=\"line\">        │               ├── architect-------------包含常用的工具类和常量</span><br><span class=\"line\">        │               │   ├── conf</span><br><span class=\"line\">        │               │   ├── constant</span><br><span class=\"line\">        │               │   ├── filter</span><br><span class=\"line\">        │               │   ├── interceptor</span><br><span class=\"line\">        │               │   └── utils</span><br><span class=\"line\">        │               ├── controller------------控制器层</span><br><span class=\"line\">        │               │   └── system</span><br><span class=\"line\">        │               ├── dao-------------------dao层</span><br><span class=\"line\">        │               │   ├── bomapper</span><br><span class=\"line\">        │               │   └── vomapper</span><br><span class=\"line\">        │               │       ├── impl</span><br><span class=\"line\">        │               │       └── interfaces</span><br><span class=\"line\">        │               ├── model-----------------model层</span><br><span class=\"line\">        │               │   ├── bo</span><br><span class=\"line\">        │               │   ├── po</span><br><span class=\"line\">        │               │   └── vo</span><br><span class=\"line\">        │               ├── service---------------service层</span><br><span class=\"line\">        │               │   ├── impl</span><br><span class=\"line\">        │               │   └── interfaces</span><br><span class=\"line\">        │               └── shiroconfig-----------shiro配置</span><br><span class=\"line\">        │                   ├── filter</span><br><span class=\"line\">        │                   └── realm</span><br><span class=\"line\">        ├── resources----------------------------资源文件目录</span><br><span class=\"line\">        │   ├── mapperxml------------------------mapper映射文件</span><br><span class=\"line\">        │   ├── mybatis-generator----------------mybatis-generator配置文件</span><br><span class=\"line\">        │   └── spring---------------------------所有与spring相关的配置文件</span><br><span class=\"line\">        └── webapp-------------------------------前端源码文件</span><br><span class=\"line\">            ├── BasePlu--------------------------公共库</span><br><span class=\"line\">            ├── comm</span><br><span class=\"line\">            ├── Lib------------------------------第三方库</span><br><span class=\"line\">            │   ├── Echarts-3.7.2</span><br><span class=\"line\">            │   ├── editor.md</span><br><span class=\"line\">            │   ├── jquery</span><br><span class=\"line\">            │   └── layui_v2.1.2</span><br><span class=\"line\">            ├── static--------------------------静态资源</span><br><span class=\"line\">            ├── Sys-----------------------------系统功能插件目录</span><br><span class=\"line\">            │   ├── js</span><br><span class=\"line\">            │   └── plugin</span><br><span class=\"line\">            └── WEB-INF</span><br><span class=\"line\">                └── views</span><br><span class=\"line\">                    ├── error-------------------异常目录</span><br><span class=\"line\">                    └── main--------------------系统主界面目录</span><br></pre></td></tr></table></figure>\n<h4 id=\"运行系统\"><a href=\"#运行系统\" class=\"headerlink\" title=\"运行系统\"></a>运行系统</h4><ul>\n<li>拷贝代码到本地<code>git clone git@github.com:shuaijunlan/Autumn-Framework.git</code></li>\n<li>进入Autumn-Framework目录<code>cd Autumn-Framework</code></li>\n<li>执行<code>mvn install</code></li>\n<li>再进入cms目录<code>cd cms</code></li>\n<li>在执行<code>mvn tomcat7:run</code></li>\n<li>最后在浏览器中访问<code>localhost:8081</code>，就可以看到登录界面</li>\n<li>Tips：以上所有操作基于您的电脑已经安装了<code>jdk8</code>、<code>maven</code>和<code>git</code>环境</li>\n</ul>\n<h4 id=\"FAQ\"><a href=\"#FAQ\" class=\"headerlink\" title=\"FAQ\"></a>FAQ</h4><h4 id=\"联系作者\"><a href=\"#联系作者\" class=\"headerlink\" title=\"联系作者\"></a>联系作者</h4><p>您有任何问题都可以随时联系我！ </p>\n<p>Email：shuaijunlan@gmail.com</p>\n<hr>"},{"title":"基于HashMap和双向链表实现LRUCache","date":"2018-04-12T05:23:18.000Z","_content":"\n> 使用HashMap和双向链表实现LRUCache，HashMap用来定位节点是否已经存在，时间复杂度为O(1)，双向链表用来用来实现LRU规则，移动节点的时间复杂度也是O(1)，代码如下：\n\n<!-- more -->\n\n```java\npackage cn.shuaijunlan.cache.lru;\n\nimport java.util.HashMap;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 10:48 2018/4/12.\n */\npublic class LruCacheOnLinkedAndMap<K, V> {\n    /**\n     * 定义双向链表节点\n     * @param <K>\n     * @param <V>\n     */\n    private class Entry<K, V>{\n        Entry pre;\n        Entry next;\n        K key;\n        V value;\n        public Entry(K key,V value){\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    /**\n     * 缓存大小\n     */\n    private final int size;\n    /**\n     * 存储Entry Node\n     */\n    private HashMap<K,Entry<K,V>> map;\n    /**\n     * 链表尾节点\n     */\n    private Entry last;\n    /**\n     * 链表头节点\n     */\n    private Entry first;\n\n    public LruCacheOnLinkedAndMap(int size){\n        if (size <= 0){\n            throw new IllegalArgumentException(\"The size of Cache must more than zero!\");\n        }\n        this.size = size;\n        map = new HashMap();\n    }\n\n    public void put(K key, V value){\n        Entry entry = map.get(key);\n        if (entry == null){\n            if (map.size() >= this.size){\n                removeLast();\n            }\n            entry = new Entry(key, value);\n        }\n        entry.value = value;\n        moveToFirst(entry);\n        map.put(key, entry);\n    }\n\n    /**\n     * 删除尾节点\n     */\n    public void removeLast(){\n        if (last != null){\n            map.remove(last.key);\n            last = last.pre;\n            if (last == null){\n                first = null;\n            }else {\n                last.next = null;\n            }\n        }\n    }\n    public Entry get(K key){\n        Entry entry = map.get(key);\n        if (entry == null){\n            return null;\n        }\n        moveToFirst(entry);\n        return entry;\n    }\n\n    /**\n     * 根据LRU规则，将最近使用的节点移至链表头部\n     * @param entry\n     */\n    public void moveToFirst(Entry entry){\n        if (entry == first){\n            return;\n        }\n        if (entry.pre != null){\n            entry.pre.next = entry.next;\n        }\n        if (entry.next != null){\n            entry.next.pre = entry.pre;\n        }\n        if (entry == last){\n            last = last.pre;\n\n        }\n        if (first == null || last == null){\n            first = last = entry;\n            return;\n        }\n        entry.next = first;\n        first.pre = entry;\n        first = entry;\n        entry.pre = null;\n    }\n\n    public void print() {\n        Entry temp = first;\n        while (temp != null){\n            System.out.println(\"Key:\" + temp.key + \"   Value:\" + temp.value);\n            temp = temp.next;\n        }\n        System.out.println(map.size());\n    }\n\n    /**\n     * 测试函数\n     * @param args\n     */\n    public static void main(String[] args) {\n        LruCacheOnLinkedAndMap<String, Integer> lruCacheOnLinkedAndMap = new LruCacheOnLinkedAndMap<>(6);\n        lruCacheOnLinkedAndMap.put(\"s\", 1);\n        lruCacheOnLinkedAndMap.put(\"h\", 2);\n        lruCacheOnLinkedAndMap.put(\"u\", 3);\n        lruCacheOnLinkedAndMap.put(\"a\", 8);\n        lruCacheOnLinkedAndMap.put(\"i\", 4);\n        lruCacheOnLinkedAndMap.put(\"j\", 7);\n        lruCacheOnLinkedAndMap.put(\"u\", 1);\n        lruCacheOnLinkedAndMap.put(\"s\", 10);\n        lruCacheOnLinkedAndMap.print();\n    }\n\n}\n```\n\n","source":"_posts/LruCache-On-Map-And-LinkedList.md","raw":"---\ntitle: 基于HashMap和双向链表实现LRUCache\ndate: 2018-04-12 13:23:18\ntags:\n    - LRU\n---\n\n> 使用HashMap和双向链表实现LRUCache，HashMap用来定位节点是否已经存在，时间复杂度为O(1)，双向链表用来用来实现LRU规则，移动节点的时间复杂度也是O(1)，代码如下：\n\n<!-- more -->\n\n```java\npackage cn.shuaijunlan.cache.lru;\n\nimport java.util.HashMap;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 10:48 2018/4/12.\n */\npublic class LruCacheOnLinkedAndMap<K, V> {\n    /**\n     * 定义双向链表节点\n     * @param <K>\n     * @param <V>\n     */\n    private class Entry<K, V>{\n        Entry pre;\n        Entry next;\n        K key;\n        V value;\n        public Entry(K key,V value){\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    /**\n     * 缓存大小\n     */\n    private final int size;\n    /**\n     * 存储Entry Node\n     */\n    private HashMap<K,Entry<K,V>> map;\n    /**\n     * 链表尾节点\n     */\n    private Entry last;\n    /**\n     * 链表头节点\n     */\n    private Entry first;\n\n    public LruCacheOnLinkedAndMap(int size){\n        if (size <= 0){\n            throw new IllegalArgumentException(\"The size of Cache must more than zero!\");\n        }\n        this.size = size;\n        map = new HashMap();\n    }\n\n    public void put(K key, V value){\n        Entry entry = map.get(key);\n        if (entry == null){\n            if (map.size() >= this.size){\n                removeLast();\n            }\n            entry = new Entry(key, value);\n        }\n        entry.value = value;\n        moveToFirst(entry);\n        map.put(key, entry);\n    }\n\n    /**\n     * 删除尾节点\n     */\n    public void removeLast(){\n        if (last != null){\n            map.remove(last.key);\n            last = last.pre;\n            if (last == null){\n                first = null;\n            }else {\n                last.next = null;\n            }\n        }\n    }\n    public Entry get(K key){\n        Entry entry = map.get(key);\n        if (entry == null){\n            return null;\n        }\n        moveToFirst(entry);\n        return entry;\n    }\n\n    /**\n     * 根据LRU规则，将最近使用的节点移至链表头部\n     * @param entry\n     */\n    public void moveToFirst(Entry entry){\n        if (entry == first){\n            return;\n        }\n        if (entry.pre != null){\n            entry.pre.next = entry.next;\n        }\n        if (entry.next != null){\n            entry.next.pre = entry.pre;\n        }\n        if (entry == last){\n            last = last.pre;\n\n        }\n        if (first == null || last == null){\n            first = last = entry;\n            return;\n        }\n        entry.next = first;\n        first.pre = entry;\n        first = entry;\n        entry.pre = null;\n    }\n\n    public void print() {\n        Entry temp = first;\n        while (temp != null){\n            System.out.println(\"Key:\" + temp.key + \"   Value:\" + temp.value);\n            temp = temp.next;\n        }\n        System.out.println(map.size());\n    }\n\n    /**\n     * 测试函数\n     * @param args\n     */\n    public static void main(String[] args) {\n        LruCacheOnLinkedAndMap<String, Integer> lruCacheOnLinkedAndMap = new LruCacheOnLinkedAndMap<>(6);\n        lruCacheOnLinkedAndMap.put(\"s\", 1);\n        lruCacheOnLinkedAndMap.put(\"h\", 2);\n        lruCacheOnLinkedAndMap.put(\"u\", 3);\n        lruCacheOnLinkedAndMap.put(\"a\", 8);\n        lruCacheOnLinkedAndMap.put(\"i\", 4);\n        lruCacheOnLinkedAndMap.put(\"j\", 7);\n        lruCacheOnLinkedAndMap.put(\"u\", 1);\n        lruCacheOnLinkedAndMap.put(\"s\", 10);\n        lruCacheOnLinkedAndMap.print();\n    }\n\n}\n```\n\n","slug":"LruCache-On-Map-And-LinkedList","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4p000nzjia7n63vlnp","content":"<blockquote>\n<p>使用HashMap和双向链表实现LRUCache，HashMap用来定位节点是否已经存在，时间复杂度为O(1)，双向链表用来用来实现LRU规则，移动节点的时间复杂度也是O(1)，代码如下：</p>\n</blockquote>\n<a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.shuaijunlan.cache.lru;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 10:48 2018/4/12.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LruCacheOnLinkedAndMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义双向链表节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;K&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;V&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt;</span>&#123;</span><br><span class=\"line\">        Entry pre;</span><br><span class=\"line\">        Entry next;</span><br><span class=\"line\">        K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Entry</span><span class=\"params\">(K key,V value)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 存储Entry Node</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HashMap&lt;K,Entry&lt;K,V&gt;&gt; map;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 链表尾节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry last;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 链表头节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry first;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCacheOnLinkedAndMap</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"The size of Cache must more than zero!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span></span>&#123;</span><br><span class=\"line\">        Entry entry = map.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entry == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.size() &gt;= <span class=\"keyword\">this</span>.size)&#123;</span><br><span class=\"line\">                removeLast();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            entry = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        entry.value = value;</span><br><span class=\"line\">        moveToFirst(entry);</span><br><span class=\"line\">        map.put(key, entry);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除尾节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeLast</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (last != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            map.remove(last.key);</span><br><span class=\"line\">            last = last.pre;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                first = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                last.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Entry <span class=\"title\">get</span><span class=\"params\">(K key)</span></span>&#123;</span><br><span class=\"line\">        Entry entry = map.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entry == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        moveToFirst(entry);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> entry;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据LRU规则，将最近使用的节点移至链表头部</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> entry</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToFirst</span><span class=\"params\">(Entry entry)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entry == first)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entry.pre != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            entry.pre.next = entry.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entry.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            entry.next.pre = entry.pre;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entry == last)&#123;</span><br><span class=\"line\">            last = last.pre;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span> || last == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            first = last = entry;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        entry.next = first;</span><br><span class=\"line\">        first.pre = entry;</span><br><span class=\"line\">        first = entry;</span><br><span class=\"line\">        entry.pre = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Entry temp = first;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Key:\"</span> + temp.key + <span class=\"string\">\"   Value:\"</span> + temp.value);</span><br><span class=\"line\">            temp = temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(map.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试函数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LruCacheOnLinkedAndMap&lt;String, Integer&gt; lruCacheOnLinkedAndMap = <span class=\"keyword\">new</span> LruCacheOnLinkedAndMap&lt;&gt;(<span class=\"number\">6</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"s\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"h\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"u\"</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"a\"</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"i\"</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"j\"</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"u\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"s\"</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.print();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>使用HashMap和双向链表实现LRUCache，HashMap用来定位节点是否已经存在，时间复杂度为O(1)，双向链表用来用来实现LRU规则，移动节点的时间复杂度也是O(1)，代码如下：</p>\n</blockquote>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.shuaijunlan.cache.lru;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 10:48 2018/4/12.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LruCacheOnLinkedAndMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义双向链表节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;K&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;V&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt;</span>&#123;</span><br><span class=\"line\">        Entry pre;</span><br><span class=\"line\">        Entry next;</span><br><span class=\"line\">        K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Entry</span><span class=\"params\">(K key,V value)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 缓存大小</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 存储Entry Node</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HashMap&lt;K,Entry&lt;K,V&gt;&gt; map;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 链表尾节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry last;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 链表头节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Entry first;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LruCacheOnLinkedAndMap</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"The size of Cache must more than zero!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span></span>&#123;</span><br><span class=\"line\">        Entry entry = map.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entry == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.size() &gt;= <span class=\"keyword\">this</span>.size)&#123;</span><br><span class=\"line\">                removeLast();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            entry = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        entry.value = value;</span><br><span class=\"line\">        moveToFirst(entry);</span><br><span class=\"line\">        map.put(key, entry);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除尾节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeLast</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (last != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            map.remove(last.key);</span><br><span class=\"line\">            last = last.pre;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                first = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                last.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Entry <span class=\"title\">get</span><span class=\"params\">(K key)</span></span>&#123;</span><br><span class=\"line\">        Entry entry = map.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entry == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        moveToFirst(entry);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> entry;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据LRU规则，将最近使用的节点移至链表头部</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> entry</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToFirst</span><span class=\"params\">(Entry entry)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entry == first)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entry.pre != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            entry.pre.next = entry.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entry.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            entry.next.pre = entry.pre;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (entry == last)&#123;</span><br><span class=\"line\">            last = last.pre;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span> || last == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            first = last = entry;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        entry.next = first;</span><br><span class=\"line\">        first.pre = entry;</span><br><span class=\"line\">        first = entry;</span><br><span class=\"line\">        entry.pre = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Entry temp = first;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Key:\"</span> + temp.key + <span class=\"string\">\"   Value:\"</span> + temp.value);</span><br><span class=\"line\">            temp = temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(map.size());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试函数</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        LruCacheOnLinkedAndMap&lt;String, Integer&gt; lruCacheOnLinkedAndMap = <span class=\"keyword\">new</span> LruCacheOnLinkedAndMap&lt;&gt;(<span class=\"number\">6</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"s\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"h\"</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"u\"</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"a\"</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"i\"</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"j\"</span>, <span class=\"number\">7</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"u\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.put(<span class=\"string\">\"s\"</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">        lruCacheOnLinkedAndMap.print();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"MyBatis实战（一)","date":"2017-06-26T02:07:15.000Z","_content":"### 一、MyBatis框架简介\n\n> MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。\n\n<!-- more -->\n\n### 二、使用MyBatis框架与原生开发方式对比\n\n1. 数据库连接配置：\n\n    * 使用MyBatis框架：\n\n        ```XML\n        <environments default=\"development\">  \n            <environment id=\"development\">  \n                <transactionManager type=\"JDBC\"/>  \n                <dataSource type=\"POOLED\">  \n                    <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>  \n                    <property name=\"url\" value=\"jdbc:mysql://115.28.61.171:3306/xx\"/>  \n                    <property name=\"username\" value=\"root\"/>  \n                    <property name=\"password\" value=\"********\"/>  \n                </dataSource>  \n            </environment>  \n        </environments>\n        ```\n    * 使用JDBC：\n\n        ```Java\n        public Connection conn = null;   \n        public String url=\"jdbc:mysql://134.78.21.143:3306/xx\";  \n        public String password=\"********\";  \n        public String dbName=\"root\";  \n        public String driverName=\"com.mysql.jdbc.Driver\";  \n        public Connection getConnection()throws ClassNotFoundException,SQLException   \n        {  \n           try {  \n                   Class.forName(driverName);//指定连接类型  \n                   conn = DriverManager.getConnection(url, dbName, password);//获取连接  \n\n            }catch (SQLException e)  \n            {  \n                e.printStackTrace();  \n            }  \n           return conn;  \n        }  \n        ```\n\n2. 查询数据库\n\n    * 使用MyBatis框架：\n\n        ```XML\n        <mapper namespace=\"com.mb.interfaces.IWcUserOperation\">  \n            <resultMap type=\"WcUser\" id=\"resultListUser\">  \n                <id column=\"id\" property=\"id\"/>  \n                <result column=\"openid\" property=\"openid\"/>  \n                <result column=\"nickname\" property=\"nickname\"/>  \n                <result column=\"province\" property=\"province\"/>  \n            </resultMap>  \n            <select id=\"selectUserById\" parameterType=\"int\"  resultType=\"WcUser\">  \n                select * from WXUSER where id= #{id}  \n            </select>  \n        </mapper>\n        ```\n\n        ```Java\n        IWcUserOperation userOperation  = session.getMapper(IWcUserOperation.class);  \n        WcUser wcUser = userOperation.selectUserById(15);  \n        ```\n    * 使用JDBC：\n\n        ```Java\n        public void getArticle(Connection conn, ArtisvrInitPara yjsvrInitPara, JSONObject jo)  \n        {  \n            String sql = \"select * from \"+yjsvrInitPara.getTabname()+\" where \"+yjsvrInitPara.getExp();    \n\n            try {  \n                st= conn.createStatement();  \n                rs= st.executeQuery(sql);  \n                System.out.println(rs);  \n\n                while(rs.next())  \n                {  \n                    Article ar= new Article();  \n\n                    ar.setId(       rs.getInt(\"id\"));  \n                    ar.setClasses(  rs.getString(\"classes\"));  \n                    ar.setContent(  rs.getString(\"content\"));  \n                    ar.setClirate(  rs.getInt(\"clirate\"));  \n                    ar.setTitle(    rs.getString(\"title\"));  \n                    ar.setFbtime(   rs.getString(\"fbtime\"));  \n\n                    list.add(ar);  \n                }  \n            } catch (SQLException e)   \n            {  \n                e.printStackTrace();  \n            }  \n            JSONArray ja=JSONArray.fromObject(list);  \n            jo.put(\"ret\", ja);  \n            ms.close(rs, st, conn);  \n        }  \n        ```\n### 三、总结\n\n> 使用Mybatis框架可以直接将数据表中每个字段映射到实体类的属性，简化了使用JDBC带来的复杂度。\n\n\n### 附录：（完整Demo）\n\n（暂时没有时间整理Demo，后期提供）\n\n----\n持续更新中。。。。。。\n","source":"_posts/MyBatis-tutorial.md","raw":"---\ntitle: MyBatis实战（一)\ndate: 2017-06-26 10:07:15\ntags:\n    - MyBatis3\n---\n### 一、MyBatis框架简介\n\n> MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。\n\n<!-- more -->\n\n### 二、使用MyBatis框架与原生开发方式对比\n\n1. 数据库连接配置：\n\n    * 使用MyBatis框架：\n\n        ```XML\n        <environments default=\"development\">  \n            <environment id=\"development\">  \n                <transactionManager type=\"JDBC\"/>  \n                <dataSource type=\"POOLED\">  \n                    <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>  \n                    <property name=\"url\" value=\"jdbc:mysql://115.28.61.171:3306/xx\"/>  \n                    <property name=\"username\" value=\"root\"/>  \n                    <property name=\"password\" value=\"********\"/>  \n                </dataSource>  \n            </environment>  \n        </environments>\n        ```\n    * 使用JDBC：\n\n        ```Java\n        public Connection conn = null;   \n        public String url=\"jdbc:mysql://134.78.21.143:3306/xx\";  \n        public String password=\"********\";  \n        public String dbName=\"root\";  \n        public String driverName=\"com.mysql.jdbc.Driver\";  \n        public Connection getConnection()throws ClassNotFoundException,SQLException   \n        {  \n           try {  \n                   Class.forName(driverName);//指定连接类型  \n                   conn = DriverManager.getConnection(url, dbName, password);//获取连接  \n\n            }catch (SQLException e)  \n            {  \n                e.printStackTrace();  \n            }  \n           return conn;  \n        }  \n        ```\n\n2. 查询数据库\n\n    * 使用MyBatis框架：\n\n        ```XML\n        <mapper namespace=\"com.mb.interfaces.IWcUserOperation\">  \n            <resultMap type=\"WcUser\" id=\"resultListUser\">  \n                <id column=\"id\" property=\"id\"/>  \n                <result column=\"openid\" property=\"openid\"/>  \n                <result column=\"nickname\" property=\"nickname\"/>  \n                <result column=\"province\" property=\"province\"/>  \n            </resultMap>  \n            <select id=\"selectUserById\" parameterType=\"int\"  resultType=\"WcUser\">  \n                select * from WXUSER where id= #{id}  \n            </select>  \n        </mapper>\n        ```\n\n        ```Java\n        IWcUserOperation userOperation  = session.getMapper(IWcUserOperation.class);  \n        WcUser wcUser = userOperation.selectUserById(15);  \n        ```\n    * 使用JDBC：\n\n        ```Java\n        public void getArticle(Connection conn, ArtisvrInitPara yjsvrInitPara, JSONObject jo)  \n        {  \n            String sql = \"select * from \"+yjsvrInitPara.getTabname()+\" where \"+yjsvrInitPara.getExp();    \n\n            try {  \n                st= conn.createStatement();  \n                rs= st.executeQuery(sql);  \n                System.out.println(rs);  \n\n                while(rs.next())  \n                {  \n                    Article ar= new Article();  \n\n                    ar.setId(       rs.getInt(\"id\"));  \n                    ar.setClasses(  rs.getString(\"classes\"));  \n                    ar.setContent(  rs.getString(\"content\"));  \n                    ar.setClirate(  rs.getInt(\"clirate\"));  \n                    ar.setTitle(    rs.getString(\"title\"));  \n                    ar.setFbtime(   rs.getString(\"fbtime\"));  \n\n                    list.add(ar);  \n                }  \n            } catch (SQLException e)   \n            {  \n                e.printStackTrace();  \n            }  \n            JSONArray ja=JSONArray.fromObject(list);  \n            jo.put(\"ret\", ja);  \n            ms.close(rs, st, conn);  \n        }  \n        ```\n### 三、总结\n\n> 使用Mybatis框架可以直接将数据表中每个字段映射到实体类的属性，简化了使用JDBC带来的复杂度。\n\n\n### 附录：（完整Demo）\n\n（暂时没有时间整理Demo，后期提供）\n\n----\n持续更新中。。。。。。\n","slug":"MyBatis-tutorial","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4q000qzjia3wg3nk5u","content":"<h3 id=\"一、MyBatis框架简介\"><a href=\"#一、MyBatis框架简介\" class=\"headerlink\" title=\"一、MyBatis框架简介\"></a>一、MyBatis框架简介</h3><blockquote>\n<p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"二、使用MyBatis框架与原生开发方式对比\"><a href=\"#二、使用MyBatis框架与原生开发方式对比\" class=\"headerlink\" title=\"二、使用MyBatis框架与原生开发方式对比\"></a>二、使用MyBatis框架与原生开发方式对比</h3><ol>\n<li><p>数据库连接配置：</p>\n<ul>\n<li><p>使用MyBatis框架：</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">environments</span> <span class=\"attr\">default</span>=<span class=\"string\">\"development\"</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">environment</span> <span class=\"attr\">id</span>=<span class=\"string\">\"development\"</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">transactionManager</span> <span class=\"attr\">type</span>=<span class=\"string\">\"JDBC\"</span>/&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driver\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>/&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://115.28.61.171:3306/xx\"</span>/&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>/&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"********\"</span>/&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">environment</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用JDBC：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Connection conn = <span class=\"keyword\">null</span>;   </span><br><span class=\"line\"><span class=\"keyword\">public</span> String url=<span class=\"string\">\"jdbc:mysql://134.78.21.143:3306/xx\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">public</span> String password=<span class=\"string\">\"********\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">public</span> String dbName=<span class=\"string\">\"root\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">public</span> String driverName=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span><span class=\"keyword\">throws</span> ClassNotFoundException,SQLException   </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">           Class.forName(driverName);<span class=\"comment\">//指定连接类型  </span></span><br><span class=\"line\">           conn = DriverManager.getConnection(url, dbName, password);<span class=\"comment\">//获取连接  </span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span> (SQLException e)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        e.printStackTrace();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">   <span class=\"keyword\">return</span> conn;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>查询数据库</p>\n<ul>\n<li><p>使用MyBatis框架：</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"com.mb.interfaces.IWcUserOperation\"</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">type</span>=<span class=\"string\">\"WcUser\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"resultListUser\"</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">\"id\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"id\"</span>/&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">\"openid\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"openid\"</span>/&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">\"nickname\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"nickname\"</span>/&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">\"province\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"province\"</span>/&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"selectUserById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span>  <span class=\"attr\">resultType</span>=<span class=\"string\">\"WcUser\"</span>&gt;</span>  </span><br><span class=\"line\">        select * from WXUSER where id= #&#123;id&#125;  </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IWcUserOperation userOperation  = session.getMapper(IWcUserOperation.class);  </span><br><span class=\"line\">WcUser wcUser = userOperation.selectUserById(<span class=\"number\">15</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用JDBC：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getArticle</span><span class=\"params\">(Connection conn, ArtisvrInitPara yjsvrInitPara, JSONObject jo)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    String sql = <span class=\"string\">\"select * from \"</span>+yjsvrInitPara.getTabname()+<span class=\"string\">\" where \"</span>+yjsvrInitPara.getExp();    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">        st= conn.createStatement();  </span><br><span class=\"line\">        rs= st.executeQuery(sql);  </span><br><span class=\"line\">        System.out.println(rs);  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(rs.next())  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            Article ar= <span class=\"keyword\">new</span> Article();  </span><br><span class=\"line\"></span><br><span class=\"line\">            ar.setId(       rs.getInt(<span class=\"string\">\"id\"</span>));  </span><br><span class=\"line\">            ar.setClasses(  rs.getString(<span class=\"string\">\"classes\"</span>));  </span><br><span class=\"line\">            ar.setContent(  rs.getString(<span class=\"string\">\"content\"</span>));  </span><br><span class=\"line\">            ar.setClirate(  rs.getInt(<span class=\"string\">\"clirate\"</span>));  </span><br><span class=\"line\">            ar.setTitle(    rs.getString(<span class=\"string\">\"title\"</span>));  </span><br><span class=\"line\">            ar.setFbtime(   rs.getString(<span class=\"string\">\"fbtime\"</span>));  </span><br><span class=\"line\"></span><br><span class=\"line\">            list.add(ar);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SQLException e)   </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        e.printStackTrace();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    JSONArray ja=JSONArray.fromObject(list);  </span><br><span class=\"line\">    jo.put(<span class=\"string\">\"ret\"</span>, ja);  </span><br><span class=\"line\">    ms.close(rs, st, conn);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><blockquote>\n<p>使用Mybatis框架可以直接将数据表中每个字段映射到实体类的属性，简化了使用JDBC带来的复杂度。</p>\n</blockquote>\n<h3 id=\"附录：（完整Demo）\"><a href=\"#附录：（完整Demo）\" class=\"headerlink\" title=\"附录：（完整Demo）\"></a>附录：（完整Demo）</h3><p>（暂时没有时间整理Demo，后期提供）</p>\n<hr>\n<p>持续更新中。。。。。。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、MyBatis框架简介\"><a href=\"#一、MyBatis框架简介\" class=\"headerlink\" title=\"一、MyBatis框架简介\"></a>一、MyBatis框架简介</h3><blockquote>\n<p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>\n</blockquote>","more":"<h3 id=\"二、使用MyBatis框架与原生开发方式对比\"><a href=\"#二、使用MyBatis框架与原生开发方式对比\" class=\"headerlink\" title=\"二、使用MyBatis框架与原生开发方式对比\"></a>二、使用MyBatis框架与原生开发方式对比</h3><ol>\n<li><p>数据库连接配置：</p>\n<ul>\n<li><p>使用MyBatis框架：</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">environments</span> <span class=\"attr\">default</span>=<span class=\"string\">\"development\"</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">environment</span> <span class=\"attr\">id</span>=<span class=\"string\">\"development\"</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">transactionManager</span> <span class=\"attr\">type</span>=<span class=\"string\">\"JDBC\"</span>/&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driver\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>/&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://115.28.61.171:3306/xx\"</span>/&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>/&gt;</span>  </span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"********\"</span>/&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">environment</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用JDBC：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> Connection conn = <span class=\"keyword\">null</span>;   </span><br><span class=\"line\"><span class=\"keyword\">public</span> String url=<span class=\"string\">\"jdbc:mysql://134.78.21.143:3306/xx\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">public</span> String password=<span class=\"string\">\"********\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">public</span> String dbName=<span class=\"string\">\"root\"</span>;  </span><br><span class=\"line\"><span class=\"keyword\">public</span> String driverName=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>;  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span><span class=\"keyword\">throws</span> ClassNotFoundException,SQLException   </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">           Class.forName(driverName);<span class=\"comment\">//指定连接类型  </span></span><br><span class=\"line\">           conn = DriverManager.getConnection(url, dbName, password);<span class=\"comment\">//获取连接  </span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span> (SQLException e)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        e.printStackTrace();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">   <span class=\"keyword\">return</span> conn;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>查询数据库</p>\n<ul>\n<li><p>使用MyBatis框架：</p>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"com.mb.interfaces.IWcUserOperation\"</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">type</span>=<span class=\"string\">\"WcUser\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"resultListUser\"</span>&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">\"id\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"id\"</span>/&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">\"openid\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"openid\"</span>/&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">\"nickname\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"nickname\"</span>/&gt;</span>  </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">column</span>=<span class=\"string\">\"province\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"province\"</span>/&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span>  </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"selectUserById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span>  <span class=\"attr\">resultType</span>=<span class=\"string\">\"WcUser\"</span>&gt;</span>  </span><br><span class=\"line\">        select * from WXUSER where id= #&#123;id&#125;  </span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IWcUserOperation userOperation  = session.getMapper(IWcUserOperation.class);  </span><br><span class=\"line\">WcUser wcUser = userOperation.selectUserById(<span class=\"number\">15</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用JDBC：</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getArticle</span><span class=\"params\">(Connection conn, ArtisvrInitPara yjsvrInitPara, JSONObject jo)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    String sql = <span class=\"string\">\"select * from \"</span>+yjsvrInitPara.getTabname()+<span class=\"string\">\" where \"</span>+yjsvrInitPara.getExp();    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">        st= conn.createStatement();  </span><br><span class=\"line\">        rs= st.executeQuery(sql);  </span><br><span class=\"line\">        System.out.println(rs);  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(rs.next())  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            Article ar= <span class=\"keyword\">new</span> Article();  </span><br><span class=\"line\"></span><br><span class=\"line\">            ar.setId(       rs.getInt(<span class=\"string\">\"id\"</span>));  </span><br><span class=\"line\">            ar.setClasses(  rs.getString(<span class=\"string\">\"classes\"</span>));  </span><br><span class=\"line\">            ar.setContent(  rs.getString(<span class=\"string\">\"content\"</span>));  </span><br><span class=\"line\">            ar.setClirate(  rs.getInt(<span class=\"string\">\"clirate\"</span>));  </span><br><span class=\"line\">            ar.setTitle(    rs.getString(<span class=\"string\">\"title\"</span>));  </span><br><span class=\"line\">            ar.setFbtime(   rs.getString(<span class=\"string\">\"fbtime\"</span>));  </span><br><span class=\"line\"></span><br><span class=\"line\">            list.add(ar);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (SQLException e)   </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        e.printStackTrace();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    JSONArray ja=JSONArray.fromObject(list);  </span><br><span class=\"line\">    jo.put(<span class=\"string\">\"ret\"</span>, ja);  </span><br><span class=\"line\">    ms.close(rs, st, conn);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h3><blockquote>\n<p>使用Mybatis框架可以直接将数据表中每个字段映射到实体类的属性，简化了使用JDBC带来的复杂度。</p>\n</blockquote>\n<h3 id=\"附录：（完整Demo）\"><a href=\"#附录：（完整Demo）\" class=\"headerlink\" title=\"附录：（完整Demo）\"></a>附录：（完整Demo）</h3><p>（暂时没有时间整理Demo，后期提供）</p>\n<hr>\n<p>持续更新中。。。。。。</p>"},{"title":"Spring中Bean的初始化与销毁（基于Spring4.x）","date":"2016-10-26T02:07:15.000Z","_content":"\n1. 通过在bean中设置init-method和destroy-method\n\n    > 配置bean</br>\n    > spring-lifecycle.xml\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n        <bean id=\"beanLifeCycle\" class=\"com.sh.imcdemo.services.impl.BeanLifeCycle\" init-method=\"start\" destroy-method=\"stop\"></bean>\n    </beans>\n    ```\n\n    > com.sh.imcdemo.services.impl 实现类\n\n<!-- more -->\n\n    ```java\n    package com.sh.imcdemo.services.impl;\n    /**\n     * Created by Mr SJL on 2016/11/26.\n     *\n     * @Author Junlan Shuai\n     */\n    public class BeanLifeCycle\n    {\n        public void start()\n        {\n            System.out.println(\"Bean start.\");\n        }\n        public void stop()\n        {\n            System.out.println(\"Bean stop.\");\n        }\n    }\n    ```\n\n2. 通过实现InitializingBean和DisposableBean接口\n\n    > 配置bean</br>\n    > spring-lifecycle.xml\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n        <bean id=\"beanLifeCycle1\" class=\"com.sh.imcdemo.services.impl.BeanLifeCycle\"></bean>\n    </beans>\n    ```\n\n    > com.sh.imcdemo.services.impl实现类\n\n    ```java\n    package com.sh.imcdemo.services.impl;\n\n    import org.springframework.beans.factory.DisposableBean;\n    import org.springframework.beans.factory.InitializingBean;\n\n    /**\n     * Created by Mr SJL on 2016/11/26.\n     *\n     * @Author Junlan Shuai\n     */\n    public class BeanLifeCycle implements InitializingBean, DisposableBean\n    {\n\n        public void destroy() throws Exception\n        {\n            System.out.println(\"Bean destory.\");\n        }\n\n        public void afterPropertiesSet() throws Exception\n        {\n            System.out.println(\"Bean afterPropertiesSet.\");\n\n        }\n    }\n\n    ```\n\n3. 通过设置default-destroy-method和default-init-method\n\n    > 对于同一配置文件下的所有的Bean都会使用该默认的初始化和销毁方法（但有特殊情况，见本篇总结部分）\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\n            default-destroy-method=\"defaultDestroy\" default-init-method=\"defaultInit\">\n        <bean id=\"beanLifeCycle\" class=\"com.sh.imcdemo.services.impl.BeanLifeCycle\"></bean>\n    </beans>\n    ```\n\n    > com.sh.imcdemo.services.impl\n\n    ```java\n    package com.sh.imcdemo.services.impl;\n\n    /**\n     * Created by Mr SJL on 2016/11/26.\n     *\n     * @Author Junlan Shuai\n     */\n    public class BeanLifeCycle\n    {\n        public void defaultInit()\n        {\n            System.out.println(\"Bean defaultInit.\");\n        }\n        public void defaultDestroy()\n        {\n            System.out.println(\"Bean defaultDestory\");\n        }\n    }\n    ```\n4. 总结\n\n    * 当三种方式同时使用时，我们会发现，第三种方式被覆盖了，另外两种方式的输出先后顺序是：先是2再是1。\n    * 当使用第3种方式时，实现类中不一定非要实现该默认方法，如果没有该方法，则没有处理。\n    * 当第2种和第3中方式同时使用时，默认方法却没有被覆盖，两者都会输出，但是第1种和第3种同时使用时，默认方法却被覆盖了。（？？？）\n\n### 附录\n\n> 测试基类 com.sh.imcdemo.unitTest\n\n```java\npackage com.sh.imcdemo.unitTest;\nimport org.apache.commons.lang.StringUtils;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.springframework.beans.BeansException;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n/**\n * Created by Mr SJL on 2016/11/26.\n *\n * @Author Junlan Shuai\n */\npublic class UnitTestBase\n{\n    private ClassPathXmlApplicationContext context;\n\n    private String springXmlpath;\n    public UnitTestBase()\n    {\n\n    }\n    public UnitTestBase(String springXmlpath)\n    {\n        this.springXmlpath = springXmlpath;\n    }\n    @Before\n    public void before()\n    {\n        if (StringUtils.isEmpty(springXmlpath))\n        {\n            springXmlpath = \"classpath*:spring-*.xml\";\n        }\n        try\n        {\n            context = new ClassPathXmlApplicationContext(springXmlpath.split(\"[,\\\\s]+\"));\n            context.start();\n        }\n        catch (BeansException e)\n        {\n            e.printStackTrace();\n        }\n\n    }\n    @After\n    public void after()\n    {\n        context.destroy();\n    }\n\n    protected <T extends Object> T getBean(String beanId)\n    {\n        return (T)context.getBean(beanId);\n    }\n    protected <T extends Object> T getBean(Class<T> clas)\n    {\n        return context.getBean(clas);\n    }\n\n}\n\n```\n> 测试类com.sh.imcdemo.unitTest\n\n```java\npackage com.sh.imcdemo.unitTest;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.BlockJUnit4ClassRunner;\n\n/**\n * Created by Mr SJL on 2016/11/26.\n *\n * @Author Junlan Shuai\n */\n@RunWith(BlockJUnit4ClassRunner.class)\npublic class App3 extends UnitTestBase\n{\n    public App3()\n    {\n        super(\"classpath:spring-lifecycle.xml\");\n    }\n    @Test\n    public void test1()\n    {\n        super.getBean(\"beanLifeCycle\");\n    }\n\n    @Test\n    public void test2()\n    {\n        super.getBean(\"beanLifeCycle1\");\n    }\n\n}\n```\n\n> 依赖包pom.xml\n\n```xml\n<spring.version>4.3.2.RELEASE</spring.version>\n<junit.version>4.11</junit.version>\n\n\n<!-- Spring依赖包-->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-core</artifactId>\n    <version>${spring.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>${spring.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-aop</artifactId>\n    <version>${spring.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-beans</artifactId>\n    <version>${spring.version}</version>\n</dependency>\n\n<!-- 单元测试包 -->\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>${junit.version}</version>\n</dependency>\n```\n","source":"_posts/Spring-bean-init-destory.md","raw":"---\ntitle: Spring中Bean的初始化与销毁（基于Spring4.x）\ndate: 2016-10-26 10:07:15\ntags:\n    - Spring\n---\n\n1. 通过在bean中设置init-method和destroy-method\n\n    > 配置bean</br>\n    > spring-lifecycle.xml\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n        <bean id=\"beanLifeCycle\" class=\"com.sh.imcdemo.services.impl.BeanLifeCycle\" init-method=\"start\" destroy-method=\"stop\"></bean>\n    </beans>\n    ```\n\n    > com.sh.imcdemo.services.impl 实现类\n\n<!-- more -->\n\n    ```java\n    package com.sh.imcdemo.services.impl;\n    /**\n     * Created by Mr SJL on 2016/11/26.\n     *\n     * @Author Junlan Shuai\n     */\n    public class BeanLifeCycle\n    {\n        public void start()\n        {\n            System.out.println(\"Bean start.\");\n        }\n        public void stop()\n        {\n            System.out.println(\"Bean stop.\");\n        }\n    }\n    ```\n\n2. 通过实现InitializingBean和DisposableBean接口\n\n    > 配置bean</br>\n    > spring-lifecycle.xml\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n        <bean id=\"beanLifeCycle1\" class=\"com.sh.imcdemo.services.impl.BeanLifeCycle\"></bean>\n    </beans>\n    ```\n\n    > com.sh.imcdemo.services.impl实现类\n\n    ```java\n    package com.sh.imcdemo.services.impl;\n\n    import org.springframework.beans.factory.DisposableBean;\n    import org.springframework.beans.factory.InitializingBean;\n\n    /**\n     * Created by Mr SJL on 2016/11/26.\n     *\n     * @Author Junlan Shuai\n     */\n    public class BeanLifeCycle implements InitializingBean, DisposableBean\n    {\n\n        public void destroy() throws Exception\n        {\n            System.out.println(\"Bean destory.\");\n        }\n\n        public void afterPropertiesSet() throws Exception\n        {\n            System.out.println(\"Bean afterPropertiesSet.\");\n\n        }\n    }\n\n    ```\n\n3. 通过设置default-destroy-method和default-init-method\n\n    > 对于同一配置文件下的所有的Bean都会使用该默认的初始化和销毁方法（但有特殊情况，见本篇总结部分）\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\n            default-destroy-method=\"defaultDestroy\" default-init-method=\"defaultInit\">\n        <bean id=\"beanLifeCycle\" class=\"com.sh.imcdemo.services.impl.BeanLifeCycle\"></bean>\n    </beans>\n    ```\n\n    > com.sh.imcdemo.services.impl\n\n    ```java\n    package com.sh.imcdemo.services.impl;\n\n    /**\n     * Created by Mr SJL on 2016/11/26.\n     *\n     * @Author Junlan Shuai\n     */\n    public class BeanLifeCycle\n    {\n        public void defaultInit()\n        {\n            System.out.println(\"Bean defaultInit.\");\n        }\n        public void defaultDestroy()\n        {\n            System.out.println(\"Bean defaultDestory\");\n        }\n    }\n    ```\n4. 总结\n\n    * 当三种方式同时使用时，我们会发现，第三种方式被覆盖了，另外两种方式的输出先后顺序是：先是2再是1。\n    * 当使用第3种方式时，实现类中不一定非要实现该默认方法，如果没有该方法，则没有处理。\n    * 当第2种和第3中方式同时使用时，默认方法却没有被覆盖，两者都会输出，但是第1种和第3种同时使用时，默认方法却被覆盖了。（？？？）\n\n### 附录\n\n> 测试基类 com.sh.imcdemo.unitTest\n\n```java\npackage com.sh.imcdemo.unitTest;\nimport org.apache.commons.lang.StringUtils;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.springframework.beans.BeansException;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n/**\n * Created by Mr SJL on 2016/11/26.\n *\n * @Author Junlan Shuai\n */\npublic class UnitTestBase\n{\n    private ClassPathXmlApplicationContext context;\n\n    private String springXmlpath;\n    public UnitTestBase()\n    {\n\n    }\n    public UnitTestBase(String springXmlpath)\n    {\n        this.springXmlpath = springXmlpath;\n    }\n    @Before\n    public void before()\n    {\n        if (StringUtils.isEmpty(springXmlpath))\n        {\n            springXmlpath = \"classpath*:spring-*.xml\";\n        }\n        try\n        {\n            context = new ClassPathXmlApplicationContext(springXmlpath.split(\"[,\\\\s]+\"));\n            context.start();\n        }\n        catch (BeansException e)\n        {\n            e.printStackTrace();\n        }\n\n    }\n    @After\n    public void after()\n    {\n        context.destroy();\n    }\n\n    protected <T extends Object> T getBean(String beanId)\n    {\n        return (T)context.getBean(beanId);\n    }\n    protected <T extends Object> T getBean(Class<T> clas)\n    {\n        return context.getBean(clas);\n    }\n\n}\n\n```\n> 测试类com.sh.imcdemo.unitTest\n\n```java\npackage com.sh.imcdemo.unitTest;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.BlockJUnit4ClassRunner;\n\n/**\n * Created by Mr SJL on 2016/11/26.\n *\n * @Author Junlan Shuai\n */\n@RunWith(BlockJUnit4ClassRunner.class)\npublic class App3 extends UnitTestBase\n{\n    public App3()\n    {\n        super(\"classpath:spring-lifecycle.xml\");\n    }\n    @Test\n    public void test1()\n    {\n        super.getBean(\"beanLifeCycle\");\n    }\n\n    @Test\n    public void test2()\n    {\n        super.getBean(\"beanLifeCycle1\");\n    }\n\n}\n```\n\n> 依赖包pom.xml\n\n```xml\n<spring.version>4.3.2.RELEASE</spring.version>\n<junit.version>4.11</junit.version>\n\n\n<!-- Spring依赖包-->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-core</artifactId>\n    <version>${spring.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>${spring.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-aop</artifactId>\n    <version>${spring.version}</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-beans</artifactId>\n    <version>${spring.version}</version>\n</dependency>\n\n<!-- 单元测试包 -->\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>${junit.version}</version>\n</dependency>\n```\n","slug":"Spring-bean-init-destory","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4r000szjiad8o46at1","content":"<ol>\n<li><p>通过在bean中设置init-method和destroy-method</p>\n<blockquote>\n<p>配置bean<br><br>spring-lifecycle.xml</p>\n</blockquote>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"beanLifeCycle\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sh.imcdemo.services.impl.BeanLifeCycle\"</span> <span class=\"attr\">init-method</span>=<span class=\"string\">\"start\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"stop\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>com.sh.imcdemo.services.impl 实现类</p>\n</blockquote>\n</li>\n</ol>\n<a id=\"more\"></a>\n<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.imcdemo.services.impl;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/26.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanLifeCycle</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Bean start.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Bean stop.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><ol>\n<li><p>通过实现InitializingBean和DisposableBean接口</p>\n<blockquote>\n<p>配置bean<br><br>spring-lifecycle.xml</p>\n</blockquote>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"beanLifeCycle1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sh.imcdemo.services.impl.BeanLifeCycle\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>com.sh.imcdemo.services.impl实现类</p>\n</blockquote>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.imcdemo.services.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/26.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanLifeCycle</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span>, <span class=\"title\">DisposableBean</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Bean destory.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Bean afterPropertiesSet.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过设置default-destroy-method和default-init-method</p>\n<blockquote>\n<p>对于同一配置文件下的所有的Bean都会使用该默认的初始化和销毁方法（但有特殊情况，见本篇总结部分）</p>\n</blockquote>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">default-destroy-method</span>=<span class=\"string\">\"defaultDestroy\"</span> <span class=\"attr\">default-init-method</span>=<span class=\"string\">\"defaultInit\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"beanLifeCycle\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sh.imcdemo.services.impl.BeanLifeCycle\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>com.sh.imcdemo.services.impl</p>\n</blockquote>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.imcdemo.services.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/26.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanLifeCycle</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">defaultInit</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Bean defaultInit.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">defaultDestroy</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Bean defaultDestory\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>总结</p>\n<ul>\n<li>当三种方式同时使用时，我们会发现，第三种方式被覆盖了，另外两种方式的输出先后顺序是：先是2再是1。</li>\n<li>当使用第3种方式时，实现类中不一定非要实现该默认方法，如果没有该方法，则没有处理。</li>\n<li>当第2种和第3中方式同时使用时，默认方法却没有被覆盖，两者都会输出，但是第1种和第3种同时使用时，默认方法却被覆盖了。（？？？）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><blockquote>\n<p>测试基类 com.sh.imcdemo.unitTest</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.imcdemo.unitTest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.lang.StringUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.After;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.BeansException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/26.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnitTestBase</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassPathXmlApplicationContext context;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String springXmlpath;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UnitTestBase</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UnitTestBase</span><span class=\"params\">(String springXmlpath)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.springXmlpath = springXmlpath;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(springXmlpath))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            springXmlpath = <span class=\"string\">\"classpath*:spring-*.xml\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(springXmlpath.split(<span class=\"string\">\"[,\\\\s]+\"</span>));</span><br><span class=\"line\">            context.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (BeansException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@After</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">after</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        context.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T extends Object&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(String beanId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)context.getBean(beanId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T extends Object&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(Class&lt;T&gt; clas)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> context.getBean(clas);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>测试类com.sh.imcdemo.unitTest</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.imcdemo.unitTest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runners.BlockJUnit4ClassRunner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/26.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(BlockJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App3</span> <span class=\"keyword\">extends</span> <span class=\"title\">UnitTestBase</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">App3</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">\"classpath:spring-lifecycle.xml\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.getBean(<span class=\"string\">\"beanLifeCycle\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.getBean(<span class=\"string\">\"beanLifeCycle1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>依赖包pom.xml</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">spring.version</span>&gt;</span>4.3.2.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">spring.version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">junit.version</span>&gt;</span>4.11<span class=\"tag\">&lt;/<span class=\"name\">junit.version</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Spring依赖包--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-beans<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 单元测试包 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;junit.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<ol>\n<li><p>通过在bean中设置init-method和destroy-method</p>\n<blockquote>\n<p>配置bean<br><br>spring-lifecycle.xml</p>\n</blockquote>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"beanLifeCycle\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sh.imcdemo.services.impl.BeanLifeCycle\"</span> <span class=\"attr\">init-method</span>=<span class=\"string\">\"start\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"stop\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>com.sh.imcdemo.services.impl 实现类</p>\n</blockquote>\n</li>\n</ol>","more":"<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.imcdemo.services.impl;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/26.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanLifeCycle</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Bean start.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Bean stop.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><ol>\n<li><p>通过实现InitializingBean和DisposableBean接口</p>\n<blockquote>\n<p>配置bean<br><br>spring-lifecycle.xml</p>\n</blockquote>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"beanLifeCycle1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sh.imcdemo.services.impl.BeanLifeCycle\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>com.sh.imcdemo.services.impl实现类</p>\n</blockquote>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.imcdemo.services.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/26.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanLifeCycle</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span>, <span class=\"title\">DisposableBean</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Bean destory.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Bean afterPropertiesSet.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过设置default-destroy-method和default-init-method</p>\n<blockquote>\n<p>对于同一配置文件下的所有的Bean都会使用该默认的初始化和销毁方法（但有特殊情况，见本篇总结部分）</p>\n</blockquote>\n <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">default-destroy-method</span>=<span class=\"string\">\"defaultDestroy\"</span> <span class=\"attr\">default-init-method</span>=<span class=\"string\">\"defaultInit\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"beanLifeCycle\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.sh.imcdemo.services.impl.BeanLifeCycle\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>com.sh.imcdemo.services.impl</p>\n</blockquote>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.imcdemo.services.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/26.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanLifeCycle</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">defaultInit</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Bean defaultInit.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">defaultDestroy</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Bean defaultDestory\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>总结</p>\n<ul>\n<li>当三种方式同时使用时，我们会发现，第三种方式被覆盖了，另外两种方式的输出先后顺序是：先是2再是1。</li>\n<li>当使用第3种方式时，实现类中不一定非要实现该默认方法，如果没有该方法，则没有处理。</li>\n<li>当第2种和第3中方式同时使用时，默认方法却没有被覆盖，两者都会输出，但是第1种和第3种同时使用时，默认方法却被覆盖了。（？？？）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><blockquote>\n<p>测试基类 com.sh.imcdemo.unitTest</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.imcdemo.unitTest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.lang.StringUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.After;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.BeansException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/26.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UnitTestBase</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ClassPathXmlApplicationContext context;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String springXmlpath;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UnitTestBase</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UnitTestBase</span><span class=\"params\">(String springXmlpath)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.springXmlpath = springXmlpath;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(springXmlpath))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            springXmlpath = <span class=\"string\">\"classpath*:spring-*.xml\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(springXmlpath.split(<span class=\"string\">\"[,\\\\s]+\"</span>));</span><br><span class=\"line\">            context.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (BeansException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@After</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">after</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        context.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T extends Object&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(String beanId)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T)context.getBean(beanId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T extends Object&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(Class&lt;T&gt; clas)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> context.getBean(clas);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>测试类com.sh.imcdemo.unitTest</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.imcdemo.unitTest;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runners.BlockJUnit4ClassRunner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/26.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(BlockJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App3</span> <span class=\"keyword\">extends</span> <span class=\"title\">UnitTestBase</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">App3</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">\"classpath:spring-lifecycle.xml\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.getBean(<span class=\"string\">\"beanLifeCycle\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.getBean(<span class=\"string\">\"beanLifeCycle1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>依赖包pom.xml</p>\n</blockquote>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">spring.version</span>&gt;</span>4.3.2.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">spring.version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">junit.version</span>&gt;</span>4.11<span class=\"tag\">&lt;/<span class=\"name\">junit.version</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Spring依赖包--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-beans<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 单元测试包 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;junit.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"基于Spring构建Dubbo源码分析","date":"2018-08-13T13:06:34.000Z","_content":"\n从Dubbo 2.7.0的项目依赖来看，依赖的Spring Framework版本是`4.3.16.RELEASE`：\n\n```xml\n<properties>\n\t<spring_version>4.3.16.RELEASE</spring_version>\n</properties>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-framework-bom</artifactId>\n    <version>${spring_version}</version>\n    <type>pom</type>\n    <scope>import</scope>\n</dependency>\n```\n\nDubbo是基于Spring构建和运行的，兼容Spring配置，Dubbo利用了SpringFramework的Extensible XML authoring 特性，扩展了Spring标签，关于如何利用Spring扩展标签，可以参考官方文档[ 《Extensible XML authoring》](https://docs.spring.io/spring/docs/4.3.16.RELEASE/spring-framework-reference/htmlsingle/#xml-custom)：\n\n* 编写xml，描述需要扩展的标签的配置属性，dubbo实现放在jar包`META-INF/dubbo.xsd`文件里 同时通过编写`META-INF/spring.handlers`文件，提供给spring，内容如下：\n\n  ```\n  http\\://dubbo.apache.org/schema/dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler\n  http\\://code.alibabatech.com/schema/dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler\n  ```\n\n* 编写一个NamespaceHandler接口实现类，dubbo中的实现类是DubboNamespaceHandler，同时通过编写`META-INF/spring.schemas`文件提供给Spring，内容如下：\n\n  ```\n  http\\://dubbo.apache.org/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd\n  http\\://code.alibabatech.com/schema/dubbo/dubbo.xsd=META-INF/compat/dubbo.xsd\n  ```\n\n* 编写一个或多个BeanDefinitionParser实现类，用来解析扩展的元素，Dubbo实现类是DubboBeanDefinitionParaser\n\n* 把以上解析组件注册给Spring\n\n<!-- more -->\n\n#### 解析DubboNamespaceHandler实现\n\n首先来看一下DubboNamespaceHandler类的源代码：\n\n```java\npublic class DubboNamespaceHandler extends NamespaceHandlerSupport {\n\n    static {\n        Version.checkDuplicate(DubboNamespaceHandler.class);\n    }\n\n    @Override\n    public void init() {\n        //注册每个标签对应的解析类\n        registerBeanDefinitionParser(\"application\", new DubboBeanDefinitionParser(ApplicationConfig.class, true));\n        registerBeanDefinitionParser(\"module\", new DubboBeanDefinitionParser(ModuleConfig.class, true));\n        registerBeanDefinitionParser(\"registry\", new DubboBeanDefinitionParser(RegistryConfig.class, true));\n        registerBeanDefinitionParser(\"monitor\", new DubboBeanDefinitionParser(MonitorConfig.class, true));\n        registerBeanDefinitionParser(\"provider\", new DubboBeanDefinitionParser(ProviderConfig.class, true));\n        registerBeanDefinitionParser(\"consumer\", new DubboBeanDefinitionParser(ConsumerConfig.class, true));\n        registerBeanDefinitionParser(\"protocol\", new DubboBeanDefinitionParser(ProtocolConfig.class, true));\n        registerBeanDefinitionParser(\"service\", new DubboBeanDefinitionParser(ServiceBean.class, true));\n        registerBeanDefinitionParser(\"reference\", new DubboBeanDefinitionParser(ReferenceBean.class, false));\n        registerBeanDefinitionParser(\"annotation\", new AnnotationBeanDefinitionParser());\n    }\n\n}\n```\n\n上面提到的10个扩展标签，分别对应10个配置类，类的层次关系如下图(右键-->Open image in new tab)：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/AbstractConfig.png?raw=true)\n\n如上图可以看出，主要基类是AbstractConfig和AbstractMethodConfig，而AbstractConfig又是所有类的基类，这10个配置类中ReferenceBean，ServiceBean，AnnotationBean 3个类又都实现了若干spring接口，这3个类算是利用spring完成dubbo调用的驱动类，后面要分别看源码。\n\n#### 解析DubboBeanDefinitionParser类\n\n这个类实现了BeanDefinitionParser接口，这是个Spring的原生接口，里面只有一个方法：\n\n```java\npublic interface BeanDefinitionParser {\n\n\t/**\n\t * Parse the specified {@link Element} and register the resulting\n\t * {@link BeanDefinition BeanDefinition(s)} with the\n\t * {@link org.springframework.beans.factory.xml.ParserContext#getRegistry() BeanDefinitionRegistry}\n\t * embedded in the supplied {@link ParserContext}.\n\t * <p>Implementations must return the primary {@link BeanDefinition} that results\n\t * from the parse if they will ever be used in a nested fashion (for example as\n\t * an inner tag in a {@code <property/>} tag). Implementations may return\n\t * {@code null} if they will <strong>not</strong> be used in a nested fashion.\n\t * @param element the element that is to be parsed into one or more {@link BeanDefinition BeanDefinitions}\n\t * @param parserContext the object encapsulating the current state of the parsing process;\n\t * provides access to a {@link org.springframework.beans.factory.support.BeanDefinitionRegistry}\n\t * @return the primary {@link BeanDefinition}\n\t */\n\tBeanDefinition parse(Element element, ParserContext parserContext);\n\n}\n```\n\n根据接口的定义，这个方法实现，需要解析Element元素成原生的BeanDefinition类对象，然后利用ParserContext对象的getRegistry()返回的注册器来注册解析后的BeanDefinition类的对象，最后返回这个BeanDefination类对象，下面是Dubbo的实现，主要是完成Spring配置到Spring容器内部BeanDefination转化的过程，下面来分析`parse()`方法：\n\n```java\n@SuppressWarnings(\"unchecked\")\nprivate static BeanDefinition parse(Element element, ParserContext parserContext, Class<?> beanClass, boolean required) {\n    RootBeanDefinition beanDefinition = new RootBeanDefinition();\n    beanDefinition.setBeanClass(beanClass);\n    beanDefinition.setLazyInit(false);\n    String id = element.getAttribute(\"id\");\n    if ((id == null || id.length() == 0) && required) {\n        String generatedBeanName = element.getAttribute(\"name\");\n        if (generatedBeanName == null || generatedBeanName.length() == 0) {\n            if (ProtocolConfig.class.equals(beanClass)) {\n                generatedBeanName = \"dubbo\";\n            } else {\n                generatedBeanName = element.getAttribute(\"interface\");\n            }\n        }\n        if (generatedBeanName == null || generatedBeanName.length() == 0) {\n            generatedBeanName = beanClass.getName();\n        }\n        id = generatedBeanName;\n        int counter = 2;\n        while (parserContext.getRegistry().containsBeanDefinition(id)) {\n            id = generatedBeanName + (counter++);\n        }\n    }\n    if (id != null && id.length() > 0) {\n        if (parserContext.getRegistry().containsBeanDefinition(id)) {\n            throw new IllegalStateException(\"Duplicate spring bean id \" + id);\n        }\n        parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);\n        beanDefinition.getPropertyValues().addPropertyValue(\"id\", id);\n    }\n    if (ProtocolConfig.class.equals(beanClass)) {\n        for (String name : parserContext.getRegistry().getBeanDefinitionNames()) {\n            BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);\n            PropertyValue property = definition.getPropertyValues().getPropertyValue(\"protocol\");\n            if (property != null) {\n                Object value = property.getValue();\n                if (value instanceof ProtocolConfig && id.equals(((ProtocolConfig) value).getName())) {\n                    definition.getPropertyValues().addPropertyValue(\"protocol\", new RuntimeBeanReference(id));\n                }\n            }\n        }\n    } else if (ServiceBean.class.equals(beanClass)) {\n        String className = element.getAttribute(\"class\");\n        if (className != null && className.length() > 0) {\n            RootBeanDefinition classDefinition = new RootBeanDefinition();\n            classDefinition.setBeanClass(ReflectUtils.forName(className));\n            classDefinition.setLazyInit(false);\n            parseProperties(element.getChildNodes(), classDefinition);\n            beanDefinition.getPropertyValues().addPropertyValue(\"ref\", new BeanDefinitionHolder(classDefinition, id + \"Impl\"));\n        }\n    } else if (ProviderConfig.class.equals(beanClass)) {\n        parseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition);\n    } else if (ConsumerConfig.class.equals(beanClass)) {\n        parseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition);\n    }\n    Set<String> props = new HashSet<String>();\n    ManagedMap parameters = null;\n    for (Method setter : beanClass.getMethods()) {\n        String name = setter.getName();\n        if (name.length() > 3 && name.startsWith(\"set\")\n            && Modifier.isPublic(setter.getModifiers())\n            && setter.getParameterTypes().length == 1) {\n            Class<?> type = setter.getParameterTypes()[0];\n            String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \"-\");\n            props.add(property);\n            Method getter = null;\n            try {\n                getter = beanClass.getMethod(\"get\" + name.substring(3), new Class<?>[0]);\n            } catch (NoSuchMethodException e) {\n                try {\n                    getter = beanClass.getMethod(\"is\" + name.substring(3), new Class<?>[0]);\n                } catch (NoSuchMethodException e2) {\n                }\n            }\n            if (getter == null\n                || !Modifier.isPublic(getter.getModifiers())\n                || !type.equals(getter.getReturnType())) {\n                continue;\n            }\n            if (\"parameters\".equals(property)) {\n                parameters = parseParameters(element.getChildNodes(), beanDefinition);\n            } else if (\"methods\".equals(property)) {\n                parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);\n            } else if (\"arguments\".equals(property)) {\n                parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);\n            } else {\n                String value = element.getAttribute(property);\n                if (value != null) {\n                    value = value.trim();\n                    if (value.length() > 0) {\n                        if (\"registry\".equals(property) && RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) {\n                            RegistryConfig registryConfig = new RegistryConfig();\n                            registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);\n                            beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);\n                        } else if (\"registry\".equals(property) && value.indexOf(',') != -1) {\n                            parseMultiRef(\"registries\", value, beanDefinition, parserContext);\n                        } else if (\"provider\".equals(property) && value.indexOf(',') != -1) {\n                            parseMultiRef(\"providers\", value, beanDefinition, parserContext);\n                        } else if (\"protocol\".equals(property) && value.indexOf(',') != -1) {\n                            parseMultiRef(\"protocols\", value, beanDefinition, parserContext);\n                        } else {\n                            Object reference;\n                            if (isPrimitive(type)) {\n                                if (\"async\".equals(property) && \"false\".equals(value)\n                                    || \"timeout\".equals(property) && \"0\".equals(value)\n                                    || \"delay\".equals(property) && \"0\".equals(value)\n                                    || \"version\".equals(property) && \"0.0.0\".equals(value)\n                                    || \"stat\".equals(property) && \"-1\".equals(value)\n                                    || \"reliable\".equals(property) && \"false\".equals(value)) {\n                                    // backward compatibility for the default value in old version's xsd\n                                    value = null;\n                                }\n                                reference = value;\n                            } else if (\"protocol\".equals(property)\n                                       && ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(value)\n                                       && (!parserContext.getRegistry().containsBeanDefinition(value)\n                                           || !ProtocolConfig.class.getName().equals(parserContext.getRegistry().getBeanDefinition(value).getBeanClassName()))) {\n                                if (\"dubbo:provider\".equals(element.getTagName())) {\n                                    logger.warn(\"Recommended replace <dubbo:provider protocol=\\\"\" + value + \"\\\" ... /> to <dubbo:protocol name=\\\"\" + value + \"\\\" ... />\");\n                                }\n                                // backward compatibility\n                                ProtocolConfig protocol = new ProtocolConfig();\n                                protocol.setName(value);\n                                reference = protocol;\n                            } else if (\"onreturn\".equals(property)) {\n                                int index = value.lastIndexOf(\".\");\n                                String returnRef = value.substring(0, index);\n                                String returnMethod = value.substring(index + 1);\n                                reference = new RuntimeBeanReference(returnRef);\n                                beanDefinition.getPropertyValues().addPropertyValue(\"onreturnMethod\", returnMethod);\n                            } else if (\"onthrow\".equals(property)) {\n                                int index = value.lastIndexOf(\".\");\n                                String throwRef = value.substring(0, index);\n                                String throwMethod = value.substring(index + 1);\n                                reference = new RuntimeBeanReference(throwRef);\n                                beanDefinition.getPropertyValues().addPropertyValue(\"onthrowMethod\", throwMethod);\n                            } else if (\"oninvoke\".equals(property)) {\n                                int index = value.lastIndexOf(\".\");\n                                String invokeRef = value.substring(0, index);\n                                String invokeRefMethod = value.substring(index + 1);\n                                reference = new RuntimeBeanReference(invokeRef);\n                                beanDefinition.getPropertyValues().addPropertyValue(\"oninvokeMethod\", invokeRefMethod);\n                            } else {\n                                if (\"ref\".equals(property) && parserContext.getRegistry().containsBeanDefinition(value)) {\n                                    BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);\n                                    if (!refBean.isSingleton()) {\n                                        throw new IllegalStateException(\"The exported service ref \" + value + \" must be singleton! Please set the \" + value + \" bean scope to singleton, eg: <bean id=\\\"\" + value + \"\\\" scope=\\\"singleton\\\" ...>\");\n                                    }\n                                }\n                                reference = new RuntimeBeanReference(value);\n                            }\n                            beanDefinition.getPropertyValues().addPropertyValue(property, reference);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    NamedNodeMap attributes = element.getAttributes();\n    int len = attributes.getLength();\n    for (int i = 0; i < len; i++) {\n        Node node = attributes.item(i);\n        String name = node.getLocalName();\n        if (!props.contains(name)) {\n            if (parameters == null) {\n                parameters = new ManagedMap();\n            }\n            String value = node.getNodeValue();\n            parameters.put(name, new TypedStringValue(value, String.class));\n        }\n    }\n    if (parameters != null) {\n        beanDefinition.getPropertyValues().addPropertyValue(\"parameters\", parameters);\n    }\n    return beanDefinition;\n}\n```\n\n#### ReferenceBean类\n\nReferenceBean类主要完成早适当的时机（Spring Bean初始化完成或者用户通过Spring容器获取bean）根据服务调用方法配置，生成服务调用代理工作，ReferenceBean类继承如下：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/ReferenceBean.png?raw=true)\n\n可以看到ReferenceBean实现了FactoryBean、ApplicationContextAware、FactoryBean、InitializingBean及DisposableBean四个接口，通过Spring的回调机制，完成Spring容器的传入，获取Bean类型，Bean初始化和Destory定制等操作，ReferenceBean类里的具体实现如下：\n\n```java\n//实现ApplicationContextAware接口的方法，在bean初始化时，回传bean所在容器的引用\n@Override\npublic void setApplicationContext(ApplicationContext applicationContext) {\n    this.applicationContext = applicationContext;\n    SpringExtensionFactory.addApplicationContext(applicationContext);\n}\n//实现FactoryBean接口的方法，返回一个Bean实例，在使用Spring API从容器中获取一个bean时调用，\n//这里返回的是reference的代理的代理类实例\n@Override\npublic Object getObject() throws Exception {\n    return get();\n}\n//实现FactoryBean接口的方法，返回一个bean的类型\n@Override\npublic Class<?> getObjectType() {\n    return getInterfaceClass();\n}\n//实现FactoryBean接口的方法，返回一个bean是否是单例\n@Override\n@Parameter(excluded = true)\npublic boolean isSingleton() {\n    return true;\n}\n//实现InitializingBean的接口方法，在bean所有属性都赋值后，由spring回调执行\n//这个方法里可以做些初始化定制\n@Override\n@SuppressWarnings({\"unchecked\"})\npublic void afterPropertiesSet() throws Exception {\n    if (getConsumer() == null) {\n        //BeanFactoryUtils.beansOfTypeIncludingAncestors()是Spring的一个工具类\n        //返回指定容器里，ConsumerConfig.class类及其子类的Bean，如果还没初始化，会触发初始化的过程，依赖注入的概念a\n        Map<String, ConsumerConfig> consumerConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConsumerConfig.class, false, false);\n        if (consumerConfigMap != null && consumerConfigMap.size() > 0) {\n            ConsumerConfig consumerConfig = null;\n            //遍历map，默认设置ConsumerConfig\n            for (ConsumerConfig config : consumerConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                    if (consumerConfig != null) {\n                        throw new IllegalStateException(\"Duplicate consumer configs: \" + consumerConfig + \" and \" + config);\n                    }\n                    consumerConfig = config;\n                }\n            }\n            //设置ConsumerConfig\n            if (consumerConfig != null) {\n                setConsumer(consumerConfig);\n            }\n        }\n    }\n    //设置ApplicationConfig\n    if (getApplication() == null\n        && (getConsumer() == null || getConsumer().getApplication() == null)) {\n        Map<String, ApplicationConfig> applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);\n        if (applicationConfigMap != null && applicationConfigMap.size() > 0) {\n            ApplicationConfig applicationConfig = null;\n            for (ApplicationConfig config : applicationConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                    if (applicationConfig != null) {\n                        throw new IllegalStateException(\"Duplicate application configs: \" + applicationConfig + \" and \" + config);\n                    }\n                    applicationConfig = config;\n                }\n            }\n            if (applicationConfig != null) {\n                setApplication(applicationConfig);\n            }\n        }\n    }\n    //设置ModuleConfig\n    if (getModule() == null\n        && (getConsumer() == null || getConsumer().getModule() == null)) {\n        Map<String, ModuleConfig> moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);\n        if (moduleConfigMap != null && moduleConfigMap.size() > 0) {\n            ModuleConfig moduleConfig = null;\n            for (ModuleConfig config : moduleConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                    if (moduleConfig != null) {\n                        throw new IllegalStateException(\"Duplicate module configs: \" + moduleConfig + \" and \" + config);\n                    }\n                    moduleConfig = config;\n                }\n            }\n            if (moduleConfig != null) {\n                setModule(moduleConfig);\n            }\n        }\n    }\n    //设置注册中心\n    if ((getRegistries() == null || getRegistries().isEmpty())\n        && (getConsumer() == null || getConsumer().getRegistries() == null || getConsumer().getRegistries().isEmpty())\n        && (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().isEmpty())) {\n        //多个注册中心\n        Map<String, RegistryConfig> registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);\n        if (registryConfigMap != null && registryConfigMap.size() > 0) {\n            List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n            for (RegistryConfig config : registryConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                    registryConfigs.add(config);\n                }\n            }\n            if (registryConfigs != null && !registryConfigs.isEmpty()) {\n                super.setRegistries(registryConfigs);\n            }\n        }\n    }\n    //设置监控中心\n    if (getMonitor() == null\n        && (getConsumer() == null || getConsumer().getMonitor() == null)\n        && (getApplication() == null || getApplication().getMonitor() == null)) {\n        Map<String, MonitorConfig> monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);\n        if (monitorConfigMap != null && monitorConfigMap.size() > 0) {\n            MonitorConfig monitorConfig = null;\n            for (MonitorConfig config : monitorConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                    if (monitorConfig != null) {\n                        throw new IllegalStateException(\"Duplicate monitor configs: \" + monitorConfig + \" and \" + config);\n                    }\n                    monitorConfig = config;\n                }\n            }\n            if (monitorConfig != null) {\n                setMonitor(monitorConfig);\n            }\n        }\n    }\n    //是否bean创建后就初始化代理\n    Boolean b = isInit();\n    if (b == null && getConsumer() != null) {\n        b = getConsumer().isInit();\n    }\n    if (b != null && b.booleanValue()) \n        //立即初始化代理  \n        getObject();\n    }\n}\n//DisposableBean的方法，做销毁处理\n@Override\npublic void destroy() {\n    // do nothing\n}\n```\n\n#### ServiceBean类\n\nServiceBean类主要完成在适当时机（Spring容器初始化完成或者服务实例初始化完成）根据服务提供方的配置暴露发布服务的工作，ServiceBean类继承关系如下：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/ServiceBean.png?raw=true)\n\n可以看到ServiceBean及其基类实现了BeanNameAware、ApplicationContextAware、ApplicationListener、DisposableBean、InitializingBean接口，通过Spring回调机制完成Spring容器引用传入，bean初始化和destory过程定制，以及监听并处理Spring事件的操作，ServiceBean类具体实现如下：\n\n```java\n//传入bean所在容器的引用\n@Override\npublic void setApplicationContext(ApplicationContext applicationContext) {\n    this.applicationContext = applicationContext;\n    //把Spring容器传入SpringExtensionFactory\n    SpringExtensionFactory.addApplicationContext(applicationContext);\n    //获取容易addApplicationListener方法，把当前类加入到容器监听队列\n    if (applicationContext != null) {\n        SPRING_CONTEXT = applicationContext;\n        try {\n            Method method = applicationContext.getClass().getMethod(\"addApplicationListener\", ApplicationListener.class); // backward compatibility to spring 2.0.1\n            method.invoke(applicationContext, this);\n            supportedApplicationListener = true;\n        } catch (Throwable t) {\n            if (applicationContext instanceof AbstractApplicationContext) {\n                try {\n                    Method method = AbstractApplicationContext.class.getDeclaredMethod(\"addListener\", ApplicationListener.class); // backward compatibility to spring 2.0.1\n                    if (!method.isAccessible()) {\n                        method.setAccessible(true);\n                    }\n                    method.invoke(applicationContext, this);\n                    //设置监听器后设为true\n                    supportedApplicationListener = true;\n                } catch (Throwable t2) {\n                }\n            }\n        }\n    }\n}\n//设置beanName值\n@Override\npublic void setBeanName(String name) {\n    this.beanName = name;\n}\n\n/**\n     * Gets associated {@link Service}\n     *\n     * @return associated {@link Service}\n     */\npublic Service getService() {\n    return service;\n}\n//实现ApplicationListener接口方法，接受并处理在容器初始化完成时发布的ContextRefreshedEvent事件\n//即容器初始化完成后暴露服务\n@Override\npublic void onApplicationEvent(ContextRefreshedEvent event) {\n    if (isDelay() && !isExported() && !isUnexported()) {\n        if (logger.isInfoEnabled()) {\n            logger.info(\"The service ready on spring started. service: \" + getInterface());\n        }\n        //执行暴露过程\n        export();\n    }\n}\n//判断是否延迟暴露\nprivate boolean isDelay() {\n    Integer delay = getDelay();\n    ProviderConfig provider = getProvider();\n    if (delay == null && provider != null) {\n        delay = provider.getDelay();\n    }\n    return supportedApplicationListener && (delay == null || delay == -1);\n}\n//InitializinBean接口方法，Bean属性初始化后，操作处理\n@Override\n@SuppressWarnings({\"unchecked\", \"deprecation\"})\npublic void afterPropertiesSet() throws Exception {\n    // 设置ProviderConfig\n    if (getProvider() == null) {\n        Map<String, ProviderConfig> providerConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, false, false);\n        if (providerConfigMap != null && providerConfigMap.size() > 0) {\n            Map<String, ProtocolConfig> protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);\n            if ((protocolConfigMap == null || protocolConfigMap.size() == 0)\n                && providerConfigMap.size() > 1) { // backward compatibility\n                List<ProviderConfig> providerConfigs = new ArrayList<ProviderConfig>();\n                for (ProviderConfig config : providerConfigMap.values()) {\n                    if (config.isDefault() != null && config.isDefault()) {\n                        providerConfigs.add(config);\n                    }\n                }\n                if (!providerConfigs.isEmpty()) {\n                    setProviders(providerConfigs);\n                }\n            } else {\n                ProviderConfig providerConfig = null;\n                for (ProviderConfig config : providerConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault()) {\n                        if (providerConfig != null) {\n                            throw new IllegalStateException(\"Duplicate provider configs: \" + providerConfig + \" and \" + config);\n                        }\n                        providerConfig = config;\n                    }\n                }\n                if (providerConfig != null) {\n                    setProvider(providerConfig);\n                }\n            }\n        }\n    }\n    //设置ApplicationConfig\n    if (getApplication() == null\n        && (getProvider() == null || getProvider().getApplication() == null)) {\n        Map<String, ApplicationConfig> applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);\n        if (applicationConfigMap != null && applicationConfigMap.size() > 0) {\n            ApplicationConfig applicationConfig = null;\n            for (ApplicationConfig config : applicationConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault()) {\n                    if (applicationConfig != null) {\n                        throw new IllegalStateException(\"Duplicate application configs: \" + applicationConfig + \" and \" + config);\n                    }\n                    applicationConfig = config;\n                }\n            }\n            if (applicationConfig != null) {\n                setApplication(applicationConfig);\n            }\n        }\n    }\n    //设置模块\n    if (getModule() == null\n        && (getProvider() == null || getProvider().getModule() == null)) {\n        Map<String, ModuleConfig> moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);\n        if (moduleConfigMap != null && moduleConfigMap.size() > 0) {\n            ModuleConfig moduleConfig = null;\n            for (ModuleConfig config : moduleConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault()) {\n                    if (moduleConfig != null) {\n                        throw new IllegalStateException(\"Duplicate module configs: \" + moduleConfig + \" and \" + config);\n                    }\n                    moduleConfig = config;\n                }\n            }\n            if (moduleConfig != null) {\n                setModule(moduleConfig);\n            }\n        }\n    }\n    //设置注册中心\n    if ((getRegistries() == null || getRegistries().isEmpty())\n        && (getProvider() == null || getProvider().getRegistries() == null || getProvider().getRegistries().isEmpty())\n        && (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().isEmpty())) {\n        Map<String, RegistryConfig> registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);\n        if (registryConfigMap != null && registryConfigMap.size() > 0) {\n            List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n            for (RegistryConfig config : registryConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault()) {\n                    registryConfigs.add(config);\n                }\n            }\n            if (!registryConfigs.isEmpty()) {\n                super.setRegistries(registryConfigs);\n            }\n        }\n    }\n    //设置监控中心\n    if (getMonitor() == null\n        && (getProvider() == null || getProvider().getMonitor() == null)\n        && (getApplication() == null || getApplication().getMonitor() == null)) {\n        Map<String, MonitorConfig> monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);\n        if (monitorConfigMap != null && monitorConfigMap.size() > 0) {\n            MonitorConfig monitorConfig = null;\n            for (MonitorConfig config : monitorConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault()) {\n                    if (monitorConfig != null) {\n                        throw new IllegalStateException(\"Duplicate monitor configs: \" + monitorConfig + \" and \" + config);\n                    }\n                    monitorConfig = config;\n                }\n            }\n            if (monitorConfig != null) {\n                setMonitor(monitorConfig);\n            }\n        }\n    }\n    //服务协议，可以有多个\n    if ((getProtocols() == null || getProtocols().isEmpty())\n        && (getProvider() == null || getProvider().getProtocols() == null || getProvider().getProtocols().isEmpty())) {\n        Map<String, ProtocolConfig> protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);\n        if (protocolConfigMap != null && protocolConfigMap.size() > 0) {\n            List<ProtocolConfig> protocolConfigs = new ArrayList<ProtocolConfig>();\n            for (ProtocolConfig config : protocolConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault()) {\n                    protocolConfigs.add(config);\n                }\n            }\n            if (!protocolConfigs.isEmpty()) {\n                super.setProtocols(protocolConfigs);\n            }\n        }\n    }\n    //设置服务路径（类全名）\n    if (getPath() == null || getPath().length() == 0) {\n        if (beanName != null && beanName.length() > 0\n            && getInterface() != null && getInterface().length() > 0\n            && beanName.startsWith(getInterface())) {\n            setPath(beanName);\n        }\n    }\n    //是否延迟暴露\n    if (!isDelay()) {\n        //暴露服务\n        export();\n    }\n}\n```\n\n#### AnnotationBean类\n\n这个类使得dubbo具有自动包扫描功能支持dubbo通过注解配置service和Reference bean（有些属性不能注解配置），病完成ServiceBean和ReferenceBean相同的功能，类图如下：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/AnnotationBean.png?raw=true)\n\n可以看到AnnotationBean类实现了接口DisposableBean、BeanFactoryPostProcessor、BeanPostProcessor、ApplicationContextAware，同样用过Spring接口方法回调，实现Bean实例的初始化预处理。\n\nAnnotationBean类是基于ClassPathBeanDefinationScanner类实现的，看下`org.springframework.context.annotation.ClassPathBeanDefinationScanner`类官方解释[ClassPathBeanDefinationScanner](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ClassPathBeanDefinitionScanner.html)：\n\n```\nA bean definition scanner that detects bean candidates on the classpath, registering corresponding bean definitions with a given registry (BeanFactory or ApplicationContext).\nCandidate classes are detected through configurable type filters. The default filters include classes that are annotated with Spring's @Component, @Repository, @Service, or @Controller stereotype.\n\nAlso supports Java EE 6's ManagedBean and JSR-330's Named annotations, if available.\n```\n\n大概意思就是，ClassPathBeanDefinitionScanner将会扫描classpath下的bean，并且向注册器注册（BeanFactory或者ApplicationContext）bean definition，通过配置的过滤器检测bean，默认会检测被@Component, @Repository, @Service, or @Controller注解的类。\n\n下面来分析AnnotationBean类的核心代码：\n\n```java\n//设置扫描的包名，以逗号分隔包名\npublic void setPackage(String annotationPackage) {\n    this.annotationPackage = annotationPackage;\n    this.annotationPackages = (annotationPackage == null || annotationPackage.length() == 0) ? null\n        : Constants.COMMA_SPLIT_PATTERN.split(annotationPackage);\n}\n//实现Spring回调接口方法，传入容器引用\n@Override\npublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n    this.applicationContext = applicationContext;\n}\n//实现BeanFactoryPostProcessor接口，这个方法会在所有的bean definitions已加载，但是还没有实例化之前回调执行\n//可以在Bean初始化之前定制化一些操作，这里做的是调用org.springframework.context.annotation.ClassPathBeanDefinitionScanner的scan方法\n//扫描注册由Service(Dubbo定义)注解的Bean，都是用反射完成的\n@Override\npublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)\n    throws BeansException {\n    if (annotationPackage == null || annotationPackage.length() == 0) {\n        return;\n    }\n    if (beanFactory instanceof BeanDefinitionRegistry) {\n        try {\n            // init scanner\n            //利用反射构造ClassPathBeanDefinitionScanner实例，用的这个构造方法，\n            // useDefaultFilters=true 默认扫描 spring 4种的注解\n            // public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {\n            //\t\tthis(registry, useDefaultFilters, getOrCreateEnvironment(registry));\n            //\t}\n            Class<?> scannerClass = ReflectUtils.forName(\"org.springframework.context.annotation.ClassPathBeanDefinitionScanner\");\n            Object scanner = scannerClass.getConstructor(new Class<?>[]{BeanDefinitionRegistry.class, boolean.class}).newInstance((BeanDefinitionRegistry) beanFactory, true);\n            // add filter\n            //通过filter 添加新要扫描的注解，也是用的反射 这里是 AnnotationTypeFilte\n            Class<?> filterClass = ReflectUtils.forName(\"org.springframework.core.type.filter.AnnotationTypeFilter\");\n            Object filter = filterClass.getConstructor(Class.class).newInstance(Service.class);\n            //获取添加filter的方法，并调用\n            Method addIncludeFilter = scannerClass.getMethod(\"addIncludeFilter\", ReflectUtils.forName(\"org.springframework.core.type.filter.TypeFilter\"));\n            addIncludeFilter.invoke(scanner, filter);\n            // scan packages\n            //获取ClassPathBeanDefinitionScanner的scan()方法，开始扫描\n            String[] packages = Constants.COMMA_SPLIT_PATTERN.split(annotationPackage);\n            Method scan = scannerClass.getMethod(\"scan\", String[].class);\n            scan.invoke(scanner, new Object[]{packages});\n        } catch (Throwable e) {\n            // spring 2.0\n        }\n    }\n}\n//实现DisposableBean接口，在bean析构时，调用相关方法，释放资源\n@Override\npublic void destroy() {\n\n    //  This will only be called for singleton scope bean, and expected to be called by spring shutdown hook when BeanFactory/ApplicationContext destroys.\n    //  We will guarantee dubbo related resources being released with dubbo shutdown hook.\n\n    //  for (ServiceConfig<?> serviceConfig : serviceConfigs) {\n    //      try {\n    //          serviceConfig.unexport();\n    //      } catch (Throwable e) {\n    //          logger.error(e.getMessage(), e);\n    //      }\n    //  }\n\n    for (ReferenceConfig<?> referenceConfig : referenceConfigs.values()) {\n        try {\n            referenceConfig.destroy();\n        } catch (Throwable e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n}\n//实现BeanPostProcessor接口方法，在Bean初始化之后，比如在afterPropertiesSet后由Spring回调执行\n//这个方法完成类似ServiceBean的工作\n@Override\npublic Object postProcessAfterInitialization(Object bean, String beanName)\n    throws BeansException {\n    //检查是否匹配包名\n    if (!isMatchPackage(bean)) {\n        return bean;\n    }\n    //手动创建ServiceBean并暴露服务\n    Service service = bean.getClass().getAnnotation(Service.class);\n    if (service != null) {\n        ServiceBean<Object> serviceConfig = new ServiceBean<Object>(service);\n        serviceConfig.setRef(bean);\n        if (void.class.equals(service.interfaceClass())\n            && \"\".equals(service.interfaceName())) {\n            if (bean.getClass().getInterfaces().length > 0) {\n                serviceConfig.setInterface(bean.getClass().getInterfaces()[0]);\n            } else {\n                throw new IllegalStateException(\"Failed to export remote service class \" + bean.getClass().getName() + \", cause: The @Service undefined interfaceClass or interfaceName, and the service class unimplemented any interfaces.\");\n            }\n        }\n        if (applicationContext != null) {\n            serviceConfig.setApplicationContext(applicationContext);\n            if (service.registry().length > 0) {\n                List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n                for (String registryId : service.registry()) {\n                    if (registryId != null && registryId.length() > 0) {\n                        registryConfigs.add(applicationContext.getBean(registryId, RegistryConfig.class));\n                    }\n                }\n                serviceConfig.setRegistries(registryConfigs);\n            }\n            if (service.provider().length() > 0) {\n                serviceConfig.setProvider(applicationContext.getBean(service.provider(), ProviderConfig.class));\n            }\n            if (service.monitor().length() > 0) {\n                serviceConfig.setMonitor(applicationContext.getBean(service.monitor(), MonitorConfig.class));\n            }\n            if (service.application().length() > 0) {\n                serviceConfig.setApplication(applicationContext.getBean(service.application(), ApplicationConfig.class));\n            }\n            if (service.module().length() > 0) {\n                serviceConfig.setModule(applicationContext.getBean(service.module(), ModuleConfig.class));\n            }\n            if (service.provider().length() > 0) {\n                serviceConfig.setProvider(applicationContext.getBean(service.provider(), ProviderConfig.class));\n            }\n            if (service.protocol().length > 0) {\n                List<ProtocolConfig> protocolConfigs = new ArrayList<ProtocolConfig>();\n                for (String protocolId : service.protocol()) {\n                    if (protocolId != null && protocolId.length() > 0) {\n                        protocolConfigs.add(applicationContext.getBean(protocolId, ProtocolConfig.class));\n                    }\n                }\n                serviceConfig.setProtocols(protocolConfigs);\n            }\n            if (service.tag().length() > 0) {\n                serviceConfig.setTag(service.tag());\n            }\n            try {\n                serviceConfig.afterPropertiesSet();\n            } catch (RuntimeException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n        }\n        serviceConfigs.add(serviceConfig);\n        serviceConfig.export();\n    }\n    return bean;\n}\n//实现BeanPostProcessor接口方法，在Bean初始化前，比如在afterPropertiesSet前，由Spring回调执行\n//这个方法完成类似ReferenceBean的工作\n@Override\npublic Object postProcessBeforeInitialization(Object bean, String beanName)\n    throws BeansException {\n    if (!isMatchPackage(bean)) {\n        return bean;\n    }\n    //因为Dubbo Reference注解只能在类的字段或者方法上\n    //通过Bean的set方法上找dubbo注解\n    Method[] methods = bean.getClass().getMethods();\n    for (Method method : methods) {\n        String name = method.getName();\n        if (name.length() > 3 && name.startsWith(\"set\")\n            && method.getParameterTypes().length == 1\n            && Modifier.isPublic(method.getModifiers())\n            && !Modifier.isStatic(method.getModifiers())) {\n            try {\n                Reference reference = method.getAnnotation(Reference.class);\n                if (reference != null) {\n                    Object value = refer(reference, method.getParameterTypes()[0]);\n                    if (value != null) {\n                        method.invoke(bean, value);\n                    }\n                }\n            } catch (Throwable e) {\n                logger.error(\"Failed to init remote service reference at method \" + name + \" in class \" + bean.getClass().getName() + \", cause: \" + e.getMessage(), e);\n            }\n        }\n    }\n    //通过bean的字段上找dubbo注解\n    Field[] fields = bean.getClass().getDeclaredFields();\n    for (Field field : fields) {\n        try {\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n            Reference reference = field.getAnnotation(Reference.class);\n            if (reference != null) {\n                Object value = refer(reference, field.getType());\n                if (value != null) {\n                    field.set(bean, value);\n                }\n            }\n        } catch (Throwable e) {\n            logger.error(\"Failed to init remote service reference at filed \" + field.getName() + \" in class \" + bean.getClass().getName() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n    return bean;\n}\n//通过解析Reference注解里的值，去构造服务调用配置，最后调用创建代理的方法\nprivate Object refer(Reference reference, Class<?> referenceClass) { //method.getParameterTypes()[0]\n    String interfaceName;\n    if (!\"\".equals(reference.interfaceName())) {\n        interfaceName = reference.interfaceName();\n    } else if (!void.class.equals(reference.interfaceClass())) {\n        interfaceName = reference.interfaceClass().getName();\n    } else if (referenceClass.isInterface()) {\n        interfaceName = referenceClass.getName();\n    } else {\n        throw new IllegalStateException(\"The @Reference undefined interfaceClass or interfaceName, and the property type \" + referenceClass.getName() + \" is not a interface.\");\n    }\n    String key = reference.group() + \"/\" + interfaceName + \":\" + reference.version();\n    ReferenceBean<?> referenceConfig = referenceConfigs.get(key);\n    if (referenceConfig == null) {\n        referenceConfig = new ReferenceBean<Object>(reference);\n        if (void.class.equals(reference.interfaceClass())\n            && \"\".equals(reference.interfaceName())\n            && referenceClass.isInterface()) {\n            referenceConfig.setInterface(referenceClass);\n        }\n        if (applicationContext != null) {\n            referenceConfig.setApplicationContext(applicationContext);\n            if (reference.registry().length > 0) {\n                List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n                for (String registryId : reference.registry()) {\n                    if (registryId != null && registryId.length() > 0) {\n                        registryConfigs.add(applicationContext.getBean(registryId, RegistryConfig.class));\n                    }\n                }\n                referenceConfig.setRegistries(registryConfigs);\n            }\n            if (reference.consumer().length() > 0) {\n                referenceConfig.setConsumer(applicationContext.getBean(reference.consumer(), ConsumerConfig.class));\n            }\n            if (reference.monitor().length() > 0) {\n                referenceConfig.setMonitor(applicationContext.getBean(reference.monitor(), MonitorConfig.class));\n            }\n            if (reference.application().length() > 0) {\n                referenceConfig.setApplication(applicationContext.getBean(reference.application(), ApplicationConfig.class));\n            }\n            if (reference.module().length() > 0) {\n                referenceConfig.setModule(applicationContext.getBean(reference.module(), ModuleConfig.class));\n            }\n            if (reference.consumer().length() > 0) {\n                referenceConfig.setConsumer(applicationContext.getBean(reference.consumer(), ConsumerConfig.class));\n            }\n            try {\n                referenceConfig.afterPropertiesSet();\n            } catch (RuntimeException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n        }\n        referenceConfigs.putIfAbsent(key, referenceConfig);\n        referenceConfig = referenceConfigs.get(key);\n    }\n    return referenceConfig.get();\n}\n\nprivate boolean isMatchPackage(Object bean) {\n    if (annotationPackages == null || annotationPackages.length == 0) {\n        return true;\n    }\n    String beanClassName = bean.getClass().getName();\n    for (String pkg : annotationPackages) {\n        if (beanClassName.startsWith(pkg)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n","source":"_posts/dubbo-basing-on-spring-framework-analysis.md","raw":"---\ntitle: 基于Spring构建Dubbo源码分析\ndate: 2018-08-13 21:06:34\ntags:\n    - dubbo\n---\n\n从Dubbo 2.7.0的项目依赖来看，依赖的Spring Framework版本是`4.3.16.RELEASE`：\n\n```xml\n<properties>\n\t<spring_version>4.3.16.RELEASE</spring_version>\n</properties>\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-framework-bom</artifactId>\n    <version>${spring_version}</version>\n    <type>pom</type>\n    <scope>import</scope>\n</dependency>\n```\n\nDubbo是基于Spring构建和运行的，兼容Spring配置，Dubbo利用了SpringFramework的Extensible XML authoring 特性，扩展了Spring标签，关于如何利用Spring扩展标签，可以参考官方文档[ 《Extensible XML authoring》](https://docs.spring.io/spring/docs/4.3.16.RELEASE/spring-framework-reference/htmlsingle/#xml-custom)：\n\n* 编写xml，描述需要扩展的标签的配置属性，dubbo实现放在jar包`META-INF/dubbo.xsd`文件里 同时通过编写`META-INF/spring.handlers`文件，提供给spring，内容如下：\n\n  ```\n  http\\://dubbo.apache.org/schema/dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler\n  http\\://code.alibabatech.com/schema/dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler\n  ```\n\n* 编写一个NamespaceHandler接口实现类，dubbo中的实现类是DubboNamespaceHandler，同时通过编写`META-INF/spring.schemas`文件提供给Spring，内容如下：\n\n  ```\n  http\\://dubbo.apache.org/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd\n  http\\://code.alibabatech.com/schema/dubbo/dubbo.xsd=META-INF/compat/dubbo.xsd\n  ```\n\n* 编写一个或多个BeanDefinitionParser实现类，用来解析扩展的元素，Dubbo实现类是DubboBeanDefinitionParaser\n\n* 把以上解析组件注册给Spring\n\n<!-- more -->\n\n#### 解析DubboNamespaceHandler实现\n\n首先来看一下DubboNamespaceHandler类的源代码：\n\n```java\npublic class DubboNamespaceHandler extends NamespaceHandlerSupport {\n\n    static {\n        Version.checkDuplicate(DubboNamespaceHandler.class);\n    }\n\n    @Override\n    public void init() {\n        //注册每个标签对应的解析类\n        registerBeanDefinitionParser(\"application\", new DubboBeanDefinitionParser(ApplicationConfig.class, true));\n        registerBeanDefinitionParser(\"module\", new DubboBeanDefinitionParser(ModuleConfig.class, true));\n        registerBeanDefinitionParser(\"registry\", new DubboBeanDefinitionParser(RegistryConfig.class, true));\n        registerBeanDefinitionParser(\"monitor\", new DubboBeanDefinitionParser(MonitorConfig.class, true));\n        registerBeanDefinitionParser(\"provider\", new DubboBeanDefinitionParser(ProviderConfig.class, true));\n        registerBeanDefinitionParser(\"consumer\", new DubboBeanDefinitionParser(ConsumerConfig.class, true));\n        registerBeanDefinitionParser(\"protocol\", new DubboBeanDefinitionParser(ProtocolConfig.class, true));\n        registerBeanDefinitionParser(\"service\", new DubboBeanDefinitionParser(ServiceBean.class, true));\n        registerBeanDefinitionParser(\"reference\", new DubboBeanDefinitionParser(ReferenceBean.class, false));\n        registerBeanDefinitionParser(\"annotation\", new AnnotationBeanDefinitionParser());\n    }\n\n}\n```\n\n上面提到的10个扩展标签，分别对应10个配置类，类的层次关系如下图(右键-->Open image in new tab)：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/AbstractConfig.png?raw=true)\n\n如上图可以看出，主要基类是AbstractConfig和AbstractMethodConfig，而AbstractConfig又是所有类的基类，这10个配置类中ReferenceBean，ServiceBean，AnnotationBean 3个类又都实现了若干spring接口，这3个类算是利用spring完成dubbo调用的驱动类，后面要分别看源码。\n\n#### 解析DubboBeanDefinitionParser类\n\n这个类实现了BeanDefinitionParser接口，这是个Spring的原生接口，里面只有一个方法：\n\n```java\npublic interface BeanDefinitionParser {\n\n\t/**\n\t * Parse the specified {@link Element} and register the resulting\n\t * {@link BeanDefinition BeanDefinition(s)} with the\n\t * {@link org.springframework.beans.factory.xml.ParserContext#getRegistry() BeanDefinitionRegistry}\n\t * embedded in the supplied {@link ParserContext}.\n\t * <p>Implementations must return the primary {@link BeanDefinition} that results\n\t * from the parse if they will ever be used in a nested fashion (for example as\n\t * an inner tag in a {@code <property/>} tag). Implementations may return\n\t * {@code null} if they will <strong>not</strong> be used in a nested fashion.\n\t * @param element the element that is to be parsed into one or more {@link BeanDefinition BeanDefinitions}\n\t * @param parserContext the object encapsulating the current state of the parsing process;\n\t * provides access to a {@link org.springframework.beans.factory.support.BeanDefinitionRegistry}\n\t * @return the primary {@link BeanDefinition}\n\t */\n\tBeanDefinition parse(Element element, ParserContext parserContext);\n\n}\n```\n\n根据接口的定义，这个方法实现，需要解析Element元素成原生的BeanDefinition类对象，然后利用ParserContext对象的getRegistry()返回的注册器来注册解析后的BeanDefinition类的对象，最后返回这个BeanDefination类对象，下面是Dubbo的实现，主要是完成Spring配置到Spring容器内部BeanDefination转化的过程，下面来分析`parse()`方法：\n\n```java\n@SuppressWarnings(\"unchecked\")\nprivate static BeanDefinition parse(Element element, ParserContext parserContext, Class<?> beanClass, boolean required) {\n    RootBeanDefinition beanDefinition = new RootBeanDefinition();\n    beanDefinition.setBeanClass(beanClass);\n    beanDefinition.setLazyInit(false);\n    String id = element.getAttribute(\"id\");\n    if ((id == null || id.length() == 0) && required) {\n        String generatedBeanName = element.getAttribute(\"name\");\n        if (generatedBeanName == null || generatedBeanName.length() == 0) {\n            if (ProtocolConfig.class.equals(beanClass)) {\n                generatedBeanName = \"dubbo\";\n            } else {\n                generatedBeanName = element.getAttribute(\"interface\");\n            }\n        }\n        if (generatedBeanName == null || generatedBeanName.length() == 0) {\n            generatedBeanName = beanClass.getName();\n        }\n        id = generatedBeanName;\n        int counter = 2;\n        while (parserContext.getRegistry().containsBeanDefinition(id)) {\n            id = generatedBeanName + (counter++);\n        }\n    }\n    if (id != null && id.length() > 0) {\n        if (parserContext.getRegistry().containsBeanDefinition(id)) {\n            throw new IllegalStateException(\"Duplicate spring bean id \" + id);\n        }\n        parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);\n        beanDefinition.getPropertyValues().addPropertyValue(\"id\", id);\n    }\n    if (ProtocolConfig.class.equals(beanClass)) {\n        for (String name : parserContext.getRegistry().getBeanDefinitionNames()) {\n            BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);\n            PropertyValue property = definition.getPropertyValues().getPropertyValue(\"protocol\");\n            if (property != null) {\n                Object value = property.getValue();\n                if (value instanceof ProtocolConfig && id.equals(((ProtocolConfig) value).getName())) {\n                    definition.getPropertyValues().addPropertyValue(\"protocol\", new RuntimeBeanReference(id));\n                }\n            }\n        }\n    } else if (ServiceBean.class.equals(beanClass)) {\n        String className = element.getAttribute(\"class\");\n        if (className != null && className.length() > 0) {\n            RootBeanDefinition classDefinition = new RootBeanDefinition();\n            classDefinition.setBeanClass(ReflectUtils.forName(className));\n            classDefinition.setLazyInit(false);\n            parseProperties(element.getChildNodes(), classDefinition);\n            beanDefinition.getPropertyValues().addPropertyValue(\"ref\", new BeanDefinitionHolder(classDefinition, id + \"Impl\"));\n        }\n    } else if (ProviderConfig.class.equals(beanClass)) {\n        parseNested(element, parserContext, ServiceBean.class, true, \"service\", \"provider\", id, beanDefinition);\n    } else if (ConsumerConfig.class.equals(beanClass)) {\n        parseNested(element, parserContext, ReferenceBean.class, false, \"reference\", \"consumer\", id, beanDefinition);\n    }\n    Set<String> props = new HashSet<String>();\n    ManagedMap parameters = null;\n    for (Method setter : beanClass.getMethods()) {\n        String name = setter.getName();\n        if (name.length() > 3 && name.startsWith(\"set\")\n            && Modifier.isPublic(setter.getModifiers())\n            && setter.getParameterTypes().length == 1) {\n            Class<?> type = setter.getParameterTypes()[0];\n            String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), \"-\");\n            props.add(property);\n            Method getter = null;\n            try {\n                getter = beanClass.getMethod(\"get\" + name.substring(3), new Class<?>[0]);\n            } catch (NoSuchMethodException e) {\n                try {\n                    getter = beanClass.getMethod(\"is\" + name.substring(3), new Class<?>[0]);\n                } catch (NoSuchMethodException e2) {\n                }\n            }\n            if (getter == null\n                || !Modifier.isPublic(getter.getModifiers())\n                || !type.equals(getter.getReturnType())) {\n                continue;\n            }\n            if (\"parameters\".equals(property)) {\n                parameters = parseParameters(element.getChildNodes(), beanDefinition);\n            } else if (\"methods\".equals(property)) {\n                parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);\n            } else if (\"arguments\".equals(property)) {\n                parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);\n            } else {\n                String value = element.getAttribute(property);\n                if (value != null) {\n                    value = value.trim();\n                    if (value.length() > 0) {\n                        if (\"registry\".equals(property) && RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) {\n                            RegistryConfig registryConfig = new RegistryConfig();\n                            registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);\n                            beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);\n                        } else if (\"registry\".equals(property) && value.indexOf(',') != -1) {\n                            parseMultiRef(\"registries\", value, beanDefinition, parserContext);\n                        } else if (\"provider\".equals(property) && value.indexOf(',') != -1) {\n                            parseMultiRef(\"providers\", value, beanDefinition, parserContext);\n                        } else if (\"protocol\".equals(property) && value.indexOf(',') != -1) {\n                            parseMultiRef(\"protocols\", value, beanDefinition, parserContext);\n                        } else {\n                            Object reference;\n                            if (isPrimitive(type)) {\n                                if (\"async\".equals(property) && \"false\".equals(value)\n                                    || \"timeout\".equals(property) && \"0\".equals(value)\n                                    || \"delay\".equals(property) && \"0\".equals(value)\n                                    || \"version\".equals(property) && \"0.0.0\".equals(value)\n                                    || \"stat\".equals(property) && \"-1\".equals(value)\n                                    || \"reliable\".equals(property) && \"false\".equals(value)) {\n                                    // backward compatibility for the default value in old version's xsd\n                                    value = null;\n                                }\n                                reference = value;\n                            } else if (\"protocol\".equals(property)\n                                       && ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(value)\n                                       && (!parserContext.getRegistry().containsBeanDefinition(value)\n                                           || !ProtocolConfig.class.getName().equals(parserContext.getRegistry().getBeanDefinition(value).getBeanClassName()))) {\n                                if (\"dubbo:provider\".equals(element.getTagName())) {\n                                    logger.warn(\"Recommended replace <dubbo:provider protocol=\\\"\" + value + \"\\\" ... /> to <dubbo:protocol name=\\\"\" + value + \"\\\" ... />\");\n                                }\n                                // backward compatibility\n                                ProtocolConfig protocol = new ProtocolConfig();\n                                protocol.setName(value);\n                                reference = protocol;\n                            } else if (\"onreturn\".equals(property)) {\n                                int index = value.lastIndexOf(\".\");\n                                String returnRef = value.substring(0, index);\n                                String returnMethod = value.substring(index + 1);\n                                reference = new RuntimeBeanReference(returnRef);\n                                beanDefinition.getPropertyValues().addPropertyValue(\"onreturnMethod\", returnMethod);\n                            } else if (\"onthrow\".equals(property)) {\n                                int index = value.lastIndexOf(\".\");\n                                String throwRef = value.substring(0, index);\n                                String throwMethod = value.substring(index + 1);\n                                reference = new RuntimeBeanReference(throwRef);\n                                beanDefinition.getPropertyValues().addPropertyValue(\"onthrowMethod\", throwMethod);\n                            } else if (\"oninvoke\".equals(property)) {\n                                int index = value.lastIndexOf(\".\");\n                                String invokeRef = value.substring(0, index);\n                                String invokeRefMethod = value.substring(index + 1);\n                                reference = new RuntimeBeanReference(invokeRef);\n                                beanDefinition.getPropertyValues().addPropertyValue(\"oninvokeMethod\", invokeRefMethod);\n                            } else {\n                                if (\"ref\".equals(property) && parserContext.getRegistry().containsBeanDefinition(value)) {\n                                    BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);\n                                    if (!refBean.isSingleton()) {\n                                        throw new IllegalStateException(\"The exported service ref \" + value + \" must be singleton! Please set the \" + value + \" bean scope to singleton, eg: <bean id=\\\"\" + value + \"\\\" scope=\\\"singleton\\\" ...>\");\n                                    }\n                                }\n                                reference = new RuntimeBeanReference(value);\n                            }\n                            beanDefinition.getPropertyValues().addPropertyValue(property, reference);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    NamedNodeMap attributes = element.getAttributes();\n    int len = attributes.getLength();\n    for (int i = 0; i < len; i++) {\n        Node node = attributes.item(i);\n        String name = node.getLocalName();\n        if (!props.contains(name)) {\n            if (parameters == null) {\n                parameters = new ManagedMap();\n            }\n            String value = node.getNodeValue();\n            parameters.put(name, new TypedStringValue(value, String.class));\n        }\n    }\n    if (parameters != null) {\n        beanDefinition.getPropertyValues().addPropertyValue(\"parameters\", parameters);\n    }\n    return beanDefinition;\n}\n```\n\n#### ReferenceBean类\n\nReferenceBean类主要完成早适当的时机（Spring Bean初始化完成或者用户通过Spring容器获取bean）根据服务调用方法配置，生成服务调用代理工作，ReferenceBean类继承如下：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/ReferenceBean.png?raw=true)\n\n可以看到ReferenceBean实现了FactoryBean、ApplicationContextAware、FactoryBean、InitializingBean及DisposableBean四个接口，通过Spring的回调机制，完成Spring容器的传入，获取Bean类型，Bean初始化和Destory定制等操作，ReferenceBean类里的具体实现如下：\n\n```java\n//实现ApplicationContextAware接口的方法，在bean初始化时，回传bean所在容器的引用\n@Override\npublic void setApplicationContext(ApplicationContext applicationContext) {\n    this.applicationContext = applicationContext;\n    SpringExtensionFactory.addApplicationContext(applicationContext);\n}\n//实现FactoryBean接口的方法，返回一个Bean实例，在使用Spring API从容器中获取一个bean时调用，\n//这里返回的是reference的代理的代理类实例\n@Override\npublic Object getObject() throws Exception {\n    return get();\n}\n//实现FactoryBean接口的方法，返回一个bean的类型\n@Override\npublic Class<?> getObjectType() {\n    return getInterfaceClass();\n}\n//实现FactoryBean接口的方法，返回一个bean是否是单例\n@Override\n@Parameter(excluded = true)\npublic boolean isSingleton() {\n    return true;\n}\n//实现InitializingBean的接口方法，在bean所有属性都赋值后，由spring回调执行\n//这个方法里可以做些初始化定制\n@Override\n@SuppressWarnings({\"unchecked\"})\npublic void afterPropertiesSet() throws Exception {\n    if (getConsumer() == null) {\n        //BeanFactoryUtils.beansOfTypeIncludingAncestors()是Spring的一个工具类\n        //返回指定容器里，ConsumerConfig.class类及其子类的Bean，如果还没初始化，会触发初始化的过程，依赖注入的概念a\n        Map<String, ConsumerConfig> consumerConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConsumerConfig.class, false, false);\n        if (consumerConfigMap != null && consumerConfigMap.size() > 0) {\n            ConsumerConfig consumerConfig = null;\n            //遍历map，默认设置ConsumerConfig\n            for (ConsumerConfig config : consumerConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                    if (consumerConfig != null) {\n                        throw new IllegalStateException(\"Duplicate consumer configs: \" + consumerConfig + \" and \" + config);\n                    }\n                    consumerConfig = config;\n                }\n            }\n            //设置ConsumerConfig\n            if (consumerConfig != null) {\n                setConsumer(consumerConfig);\n            }\n        }\n    }\n    //设置ApplicationConfig\n    if (getApplication() == null\n        && (getConsumer() == null || getConsumer().getApplication() == null)) {\n        Map<String, ApplicationConfig> applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);\n        if (applicationConfigMap != null && applicationConfigMap.size() > 0) {\n            ApplicationConfig applicationConfig = null;\n            for (ApplicationConfig config : applicationConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                    if (applicationConfig != null) {\n                        throw new IllegalStateException(\"Duplicate application configs: \" + applicationConfig + \" and \" + config);\n                    }\n                    applicationConfig = config;\n                }\n            }\n            if (applicationConfig != null) {\n                setApplication(applicationConfig);\n            }\n        }\n    }\n    //设置ModuleConfig\n    if (getModule() == null\n        && (getConsumer() == null || getConsumer().getModule() == null)) {\n        Map<String, ModuleConfig> moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);\n        if (moduleConfigMap != null && moduleConfigMap.size() > 0) {\n            ModuleConfig moduleConfig = null;\n            for (ModuleConfig config : moduleConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                    if (moduleConfig != null) {\n                        throw new IllegalStateException(\"Duplicate module configs: \" + moduleConfig + \" and \" + config);\n                    }\n                    moduleConfig = config;\n                }\n            }\n            if (moduleConfig != null) {\n                setModule(moduleConfig);\n            }\n        }\n    }\n    //设置注册中心\n    if ((getRegistries() == null || getRegistries().isEmpty())\n        && (getConsumer() == null || getConsumer().getRegistries() == null || getConsumer().getRegistries().isEmpty())\n        && (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().isEmpty())) {\n        //多个注册中心\n        Map<String, RegistryConfig> registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);\n        if (registryConfigMap != null && registryConfigMap.size() > 0) {\n            List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n            for (RegistryConfig config : registryConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                    registryConfigs.add(config);\n                }\n            }\n            if (registryConfigs != null && !registryConfigs.isEmpty()) {\n                super.setRegistries(registryConfigs);\n            }\n        }\n    }\n    //设置监控中心\n    if (getMonitor() == null\n        && (getConsumer() == null || getConsumer().getMonitor() == null)\n        && (getApplication() == null || getApplication().getMonitor() == null)) {\n        Map<String, MonitorConfig> monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);\n        if (monitorConfigMap != null && monitorConfigMap.size() > 0) {\n            MonitorConfig monitorConfig = null;\n            for (MonitorConfig config : monitorConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault().booleanValue()) {\n                    if (monitorConfig != null) {\n                        throw new IllegalStateException(\"Duplicate monitor configs: \" + monitorConfig + \" and \" + config);\n                    }\n                    monitorConfig = config;\n                }\n            }\n            if (monitorConfig != null) {\n                setMonitor(monitorConfig);\n            }\n        }\n    }\n    //是否bean创建后就初始化代理\n    Boolean b = isInit();\n    if (b == null && getConsumer() != null) {\n        b = getConsumer().isInit();\n    }\n    if (b != null && b.booleanValue()) \n        //立即初始化代理  \n        getObject();\n    }\n}\n//DisposableBean的方法，做销毁处理\n@Override\npublic void destroy() {\n    // do nothing\n}\n```\n\n#### ServiceBean类\n\nServiceBean类主要完成在适当时机（Spring容器初始化完成或者服务实例初始化完成）根据服务提供方的配置暴露发布服务的工作，ServiceBean类继承关系如下：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/ServiceBean.png?raw=true)\n\n可以看到ServiceBean及其基类实现了BeanNameAware、ApplicationContextAware、ApplicationListener、DisposableBean、InitializingBean接口，通过Spring回调机制完成Spring容器引用传入，bean初始化和destory过程定制，以及监听并处理Spring事件的操作，ServiceBean类具体实现如下：\n\n```java\n//传入bean所在容器的引用\n@Override\npublic void setApplicationContext(ApplicationContext applicationContext) {\n    this.applicationContext = applicationContext;\n    //把Spring容器传入SpringExtensionFactory\n    SpringExtensionFactory.addApplicationContext(applicationContext);\n    //获取容易addApplicationListener方法，把当前类加入到容器监听队列\n    if (applicationContext != null) {\n        SPRING_CONTEXT = applicationContext;\n        try {\n            Method method = applicationContext.getClass().getMethod(\"addApplicationListener\", ApplicationListener.class); // backward compatibility to spring 2.0.1\n            method.invoke(applicationContext, this);\n            supportedApplicationListener = true;\n        } catch (Throwable t) {\n            if (applicationContext instanceof AbstractApplicationContext) {\n                try {\n                    Method method = AbstractApplicationContext.class.getDeclaredMethod(\"addListener\", ApplicationListener.class); // backward compatibility to spring 2.0.1\n                    if (!method.isAccessible()) {\n                        method.setAccessible(true);\n                    }\n                    method.invoke(applicationContext, this);\n                    //设置监听器后设为true\n                    supportedApplicationListener = true;\n                } catch (Throwable t2) {\n                }\n            }\n        }\n    }\n}\n//设置beanName值\n@Override\npublic void setBeanName(String name) {\n    this.beanName = name;\n}\n\n/**\n     * Gets associated {@link Service}\n     *\n     * @return associated {@link Service}\n     */\npublic Service getService() {\n    return service;\n}\n//实现ApplicationListener接口方法，接受并处理在容器初始化完成时发布的ContextRefreshedEvent事件\n//即容器初始化完成后暴露服务\n@Override\npublic void onApplicationEvent(ContextRefreshedEvent event) {\n    if (isDelay() && !isExported() && !isUnexported()) {\n        if (logger.isInfoEnabled()) {\n            logger.info(\"The service ready on spring started. service: \" + getInterface());\n        }\n        //执行暴露过程\n        export();\n    }\n}\n//判断是否延迟暴露\nprivate boolean isDelay() {\n    Integer delay = getDelay();\n    ProviderConfig provider = getProvider();\n    if (delay == null && provider != null) {\n        delay = provider.getDelay();\n    }\n    return supportedApplicationListener && (delay == null || delay == -1);\n}\n//InitializinBean接口方法，Bean属性初始化后，操作处理\n@Override\n@SuppressWarnings({\"unchecked\", \"deprecation\"})\npublic void afterPropertiesSet() throws Exception {\n    // 设置ProviderConfig\n    if (getProvider() == null) {\n        Map<String, ProviderConfig> providerConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, false, false);\n        if (providerConfigMap != null && providerConfigMap.size() > 0) {\n            Map<String, ProtocolConfig> protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);\n            if ((protocolConfigMap == null || protocolConfigMap.size() == 0)\n                && providerConfigMap.size() > 1) { // backward compatibility\n                List<ProviderConfig> providerConfigs = new ArrayList<ProviderConfig>();\n                for (ProviderConfig config : providerConfigMap.values()) {\n                    if (config.isDefault() != null && config.isDefault()) {\n                        providerConfigs.add(config);\n                    }\n                }\n                if (!providerConfigs.isEmpty()) {\n                    setProviders(providerConfigs);\n                }\n            } else {\n                ProviderConfig providerConfig = null;\n                for (ProviderConfig config : providerConfigMap.values()) {\n                    if (config.isDefault() == null || config.isDefault()) {\n                        if (providerConfig != null) {\n                            throw new IllegalStateException(\"Duplicate provider configs: \" + providerConfig + \" and \" + config);\n                        }\n                        providerConfig = config;\n                    }\n                }\n                if (providerConfig != null) {\n                    setProvider(providerConfig);\n                }\n            }\n        }\n    }\n    //设置ApplicationConfig\n    if (getApplication() == null\n        && (getProvider() == null || getProvider().getApplication() == null)) {\n        Map<String, ApplicationConfig> applicationConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, false, false);\n        if (applicationConfigMap != null && applicationConfigMap.size() > 0) {\n            ApplicationConfig applicationConfig = null;\n            for (ApplicationConfig config : applicationConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault()) {\n                    if (applicationConfig != null) {\n                        throw new IllegalStateException(\"Duplicate application configs: \" + applicationConfig + \" and \" + config);\n                    }\n                    applicationConfig = config;\n                }\n            }\n            if (applicationConfig != null) {\n                setApplication(applicationConfig);\n            }\n        }\n    }\n    //设置模块\n    if (getModule() == null\n        && (getProvider() == null || getProvider().getModule() == null)) {\n        Map<String, ModuleConfig> moduleConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, false, false);\n        if (moduleConfigMap != null && moduleConfigMap.size() > 0) {\n            ModuleConfig moduleConfig = null;\n            for (ModuleConfig config : moduleConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault()) {\n                    if (moduleConfig != null) {\n                        throw new IllegalStateException(\"Duplicate module configs: \" + moduleConfig + \" and \" + config);\n                    }\n                    moduleConfig = config;\n                }\n            }\n            if (moduleConfig != null) {\n                setModule(moduleConfig);\n            }\n        }\n    }\n    //设置注册中心\n    if ((getRegistries() == null || getRegistries().isEmpty())\n        && (getProvider() == null || getProvider().getRegistries() == null || getProvider().getRegistries().isEmpty())\n        && (getApplication() == null || getApplication().getRegistries() == null || getApplication().getRegistries().isEmpty())) {\n        Map<String, RegistryConfig> registryConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, false, false);\n        if (registryConfigMap != null && registryConfigMap.size() > 0) {\n            List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n            for (RegistryConfig config : registryConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault()) {\n                    registryConfigs.add(config);\n                }\n            }\n            if (!registryConfigs.isEmpty()) {\n                super.setRegistries(registryConfigs);\n            }\n        }\n    }\n    //设置监控中心\n    if (getMonitor() == null\n        && (getProvider() == null || getProvider().getMonitor() == null)\n        && (getApplication() == null || getApplication().getMonitor() == null)) {\n        Map<String, MonitorConfig> monitorConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, false, false);\n        if (monitorConfigMap != null && monitorConfigMap.size() > 0) {\n            MonitorConfig monitorConfig = null;\n            for (MonitorConfig config : monitorConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault()) {\n                    if (monitorConfig != null) {\n                        throw new IllegalStateException(\"Duplicate monitor configs: \" + monitorConfig + \" and \" + config);\n                    }\n                    monitorConfig = config;\n                }\n            }\n            if (monitorConfig != null) {\n                setMonitor(monitorConfig);\n            }\n        }\n    }\n    //服务协议，可以有多个\n    if ((getProtocols() == null || getProtocols().isEmpty())\n        && (getProvider() == null || getProvider().getProtocols() == null || getProvider().getProtocols().isEmpty())) {\n        Map<String, ProtocolConfig> protocolConfigMap = applicationContext == null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, false, false);\n        if (protocolConfigMap != null && protocolConfigMap.size() > 0) {\n            List<ProtocolConfig> protocolConfigs = new ArrayList<ProtocolConfig>();\n            for (ProtocolConfig config : protocolConfigMap.values()) {\n                if (config.isDefault() == null || config.isDefault()) {\n                    protocolConfigs.add(config);\n                }\n            }\n            if (!protocolConfigs.isEmpty()) {\n                super.setProtocols(protocolConfigs);\n            }\n        }\n    }\n    //设置服务路径（类全名）\n    if (getPath() == null || getPath().length() == 0) {\n        if (beanName != null && beanName.length() > 0\n            && getInterface() != null && getInterface().length() > 0\n            && beanName.startsWith(getInterface())) {\n            setPath(beanName);\n        }\n    }\n    //是否延迟暴露\n    if (!isDelay()) {\n        //暴露服务\n        export();\n    }\n}\n```\n\n#### AnnotationBean类\n\n这个类使得dubbo具有自动包扫描功能支持dubbo通过注解配置service和Reference bean（有些属性不能注解配置），病完成ServiceBean和ReferenceBean相同的功能，类图如下：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/AnnotationBean.png?raw=true)\n\n可以看到AnnotationBean类实现了接口DisposableBean、BeanFactoryPostProcessor、BeanPostProcessor、ApplicationContextAware，同样用过Spring接口方法回调，实现Bean实例的初始化预处理。\n\nAnnotationBean类是基于ClassPathBeanDefinationScanner类实现的，看下`org.springframework.context.annotation.ClassPathBeanDefinationScanner`类官方解释[ClassPathBeanDefinationScanner](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ClassPathBeanDefinitionScanner.html)：\n\n```\nA bean definition scanner that detects bean candidates on the classpath, registering corresponding bean definitions with a given registry (BeanFactory or ApplicationContext).\nCandidate classes are detected through configurable type filters. The default filters include classes that are annotated with Spring's @Component, @Repository, @Service, or @Controller stereotype.\n\nAlso supports Java EE 6's ManagedBean and JSR-330's Named annotations, if available.\n```\n\n大概意思就是，ClassPathBeanDefinitionScanner将会扫描classpath下的bean，并且向注册器注册（BeanFactory或者ApplicationContext）bean definition，通过配置的过滤器检测bean，默认会检测被@Component, @Repository, @Service, or @Controller注解的类。\n\n下面来分析AnnotationBean类的核心代码：\n\n```java\n//设置扫描的包名，以逗号分隔包名\npublic void setPackage(String annotationPackage) {\n    this.annotationPackage = annotationPackage;\n    this.annotationPackages = (annotationPackage == null || annotationPackage.length() == 0) ? null\n        : Constants.COMMA_SPLIT_PATTERN.split(annotationPackage);\n}\n//实现Spring回调接口方法，传入容器引用\n@Override\npublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n    this.applicationContext = applicationContext;\n}\n//实现BeanFactoryPostProcessor接口，这个方法会在所有的bean definitions已加载，但是还没有实例化之前回调执行\n//可以在Bean初始化之前定制化一些操作，这里做的是调用org.springframework.context.annotation.ClassPathBeanDefinitionScanner的scan方法\n//扫描注册由Service(Dubbo定义)注解的Bean，都是用反射完成的\n@Override\npublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)\n    throws BeansException {\n    if (annotationPackage == null || annotationPackage.length() == 0) {\n        return;\n    }\n    if (beanFactory instanceof BeanDefinitionRegistry) {\n        try {\n            // init scanner\n            //利用反射构造ClassPathBeanDefinitionScanner实例，用的这个构造方法，\n            // useDefaultFilters=true 默认扫描 spring 4种的注解\n            // public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {\n            //\t\tthis(registry, useDefaultFilters, getOrCreateEnvironment(registry));\n            //\t}\n            Class<?> scannerClass = ReflectUtils.forName(\"org.springframework.context.annotation.ClassPathBeanDefinitionScanner\");\n            Object scanner = scannerClass.getConstructor(new Class<?>[]{BeanDefinitionRegistry.class, boolean.class}).newInstance((BeanDefinitionRegistry) beanFactory, true);\n            // add filter\n            //通过filter 添加新要扫描的注解，也是用的反射 这里是 AnnotationTypeFilte\n            Class<?> filterClass = ReflectUtils.forName(\"org.springframework.core.type.filter.AnnotationTypeFilter\");\n            Object filter = filterClass.getConstructor(Class.class).newInstance(Service.class);\n            //获取添加filter的方法，并调用\n            Method addIncludeFilter = scannerClass.getMethod(\"addIncludeFilter\", ReflectUtils.forName(\"org.springframework.core.type.filter.TypeFilter\"));\n            addIncludeFilter.invoke(scanner, filter);\n            // scan packages\n            //获取ClassPathBeanDefinitionScanner的scan()方法，开始扫描\n            String[] packages = Constants.COMMA_SPLIT_PATTERN.split(annotationPackage);\n            Method scan = scannerClass.getMethod(\"scan\", String[].class);\n            scan.invoke(scanner, new Object[]{packages});\n        } catch (Throwable e) {\n            // spring 2.0\n        }\n    }\n}\n//实现DisposableBean接口，在bean析构时，调用相关方法，释放资源\n@Override\npublic void destroy() {\n\n    //  This will only be called for singleton scope bean, and expected to be called by spring shutdown hook when BeanFactory/ApplicationContext destroys.\n    //  We will guarantee dubbo related resources being released with dubbo shutdown hook.\n\n    //  for (ServiceConfig<?> serviceConfig : serviceConfigs) {\n    //      try {\n    //          serviceConfig.unexport();\n    //      } catch (Throwable e) {\n    //          logger.error(e.getMessage(), e);\n    //      }\n    //  }\n\n    for (ReferenceConfig<?> referenceConfig : referenceConfigs.values()) {\n        try {\n            referenceConfig.destroy();\n        } catch (Throwable e) {\n            logger.error(e.getMessage(), e);\n        }\n    }\n}\n//实现BeanPostProcessor接口方法，在Bean初始化之后，比如在afterPropertiesSet后由Spring回调执行\n//这个方法完成类似ServiceBean的工作\n@Override\npublic Object postProcessAfterInitialization(Object bean, String beanName)\n    throws BeansException {\n    //检查是否匹配包名\n    if (!isMatchPackage(bean)) {\n        return bean;\n    }\n    //手动创建ServiceBean并暴露服务\n    Service service = bean.getClass().getAnnotation(Service.class);\n    if (service != null) {\n        ServiceBean<Object> serviceConfig = new ServiceBean<Object>(service);\n        serviceConfig.setRef(bean);\n        if (void.class.equals(service.interfaceClass())\n            && \"\".equals(service.interfaceName())) {\n            if (bean.getClass().getInterfaces().length > 0) {\n                serviceConfig.setInterface(bean.getClass().getInterfaces()[0]);\n            } else {\n                throw new IllegalStateException(\"Failed to export remote service class \" + bean.getClass().getName() + \", cause: The @Service undefined interfaceClass or interfaceName, and the service class unimplemented any interfaces.\");\n            }\n        }\n        if (applicationContext != null) {\n            serviceConfig.setApplicationContext(applicationContext);\n            if (service.registry().length > 0) {\n                List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n                for (String registryId : service.registry()) {\n                    if (registryId != null && registryId.length() > 0) {\n                        registryConfigs.add(applicationContext.getBean(registryId, RegistryConfig.class));\n                    }\n                }\n                serviceConfig.setRegistries(registryConfigs);\n            }\n            if (service.provider().length() > 0) {\n                serviceConfig.setProvider(applicationContext.getBean(service.provider(), ProviderConfig.class));\n            }\n            if (service.monitor().length() > 0) {\n                serviceConfig.setMonitor(applicationContext.getBean(service.monitor(), MonitorConfig.class));\n            }\n            if (service.application().length() > 0) {\n                serviceConfig.setApplication(applicationContext.getBean(service.application(), ApplicationConfig.class));\n            }\n            if (service.module().length() > 0) {\n                serviceConfig.setModule(applicationContext.getBean(service.module(), ModuleConfig.class));\n            }\n            if (service.provider().length() > 0) {\n                serviceConfig.setProvider(applicationContext.getBean(service.provider(), ProviderConfig.class));\n            }\n            if (service.protocol().length > 0) {\n                List<ProtocolConfig> protocolConfigs = new ArrayList<ProtocolConfig>();\n                for (String protocolId : service.protocol()) {\n                    if (protocolId != null && protocolId.length() > 0) {\n                        protocolConfigs.add(applicationContext.getBean(protocolId, ProtocolConfig.class));\n                    }\n                }\n                serviceConfig.setProtocols(protocolConfigs);\n            }\n            if (service.tag().length() > 0) {\n                serviceConfig.setTag(service.tag());\n            }\n            try {\n                serviceConfig.afterPropertiesSet();\n            } catch (RuntimeException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n        }\n        serviceConfigs.add(serviceConfig);\n        serviceConfig.export();\n    }\n    return bean;\n}\n//实现BeanPostProcessor接口方法，在Bean初始化前，比如在afterPropertiesSet前，由Spring回调执行\n//这个方法完成类似ReferenceBean的工作\n@Override\npublic Object postProcessBeforeInitialization(Object bean, String beanName)\n    throws BeansException {\n    if (!isMatchPackage(bean)) {\n        return bean;\n    }\n    //因为Dubbo Reference注解只能在类的字段或者方法上\n    //通过Bean的set方法上找dubbo注解\n    Method[] methods = bean.getClass().getMethods();\n    for (Method method : methods) {\n        String name = method.getName();\n        if (name.length() > 3 && name.startsWith(\"set\")\n            && method.getParameterTypes().length == 1\n            && Modifier.isPublic(method.getModifiers())\n            && !Modifier.isStatic(method.getModifiers())) {\n            try {\n                Reference reference = method.getAnnotation(Reference.class);\n                if (reference != null) {\n                    Object value = refer(reference, method.getParameterTypes()[0]);\n                    if (value != null) {\n                        method.invoke(bean, value);\n                    }\n                }\n            } catch (Throwable e) {\n                logger.error(\"Failed to init remote service reference at method \" + name + \" in class \" + bean.getClass().getName() + \", cause: \" + e.getMessage(), e);\n            }\n        }\n    }\n    //通过bean的字段上找dubbo注解\n    Field[] fields = bean.getClass().getDeclaredFields();\n    for (Field field : fields) {\n        try {\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n            Reference reference = field.getAnnotation(Reference.class);\n            if (reference != null) {\n                Object value = refer(reference, field.getType());\n                if (value != null) {\n                    field.set(bean, value);\n                }\n            }\n        } catch (Throwable e) {\n            logger.error(\"Failed to init remote service reference at filed \" + field.getName() + \" in class \" + bean.getClass().getName() + \", cause: \" + e.getMessage(), e);\n        }\n    }\n    return bean;\n}\n//通过解析Reference注解里的值，去构造服务调用配置，最后调用创建代理的方法\nprivate Object refer(Reference reference, Class<?> referenceClass) { //method.getParameterTypes()[0]\n    String interfaceName;\n    if (!\"\".equals(reference.interfaceName())) {\n        interfaceName = reference.interfaceName();\n    } else if (!void.class.equals(reference.interfaceClass())) {\n        interfaceName = reference.interfaceClass().getName();\n    } else if (referenceClass.isInterface()) {\n        interfaceName = referenceClass.getName();\n    } else {\n        throw new IllegalStateException(\"The @Reference undefined interfaceClass or interfaceName, and the property type \" + referenceClass.getName() + \" is not a interface.\");\n    }\n    String key = reference.group() + \"/\" + interfaceName + \":\" + reference.version();\n    ReferenceBean<?> referenceConfig = referenceConfigs.get(key);\n    if (referenceConfig == null) {\n        referenceConfig = new ReferenceBean<Object>(reference);\n        if (void.class.equals(reference.interfaceClass())\n            && \"\".equals(reference.interfaceName())\n            && referenceClass.isInterface()) {\n            referenceConfig.setInterface(referenceClass);\n        }\n        if (applicationContext != null) {\n            referenceConfig.setApplicationContext(applicationContext);\n            if (reference.registry().length > 0) {\n                List<RegistryConfig> registryConfigs = new ArrayList<RegistryConfig>();\n                for (String registryId : reference.registry()) {\n                    if (registryId != null && registryId.length() > 0) {\n                        registryConfigs.add(applicationContext.getBean(registryId, RegistryConfig.class));\n                    }\n                }\n                referenceConfig.setRegistries(registryConfigs);\n            }\n            if (reference.consumer().length() > 0) {\n                referenceConfig.setConsumer(applicationContext.getBean(reference.consumer(), ConsumerConfig.class));\n            }\n            if (reference.monitor().length() > 0) {\n                referenceConfig.setMonitor(applicationContext.getBean(reference.monitor(), MonitorConfig.class));\n            }\n            if (reference.application().length() > 0) {\n                referenceConfig.setApplication(applicationContext.getBean(reference.application(), ApplicationConfig.class));\n            }\n            if (reference.module().length() > 0) {\n                referenceConfig.setModule(applicationContext.getBean(reference.module(), ModuleConfig.class));\n            }\n            if (reference.consumer().length() > 0) {\n                referenceConfig.setConsumer(applicationContext.getBean(reference.consumer(), ConsumerConfig.class));\n            }\n            try {\n                referenceConfig.afterPropertiesSet();\n            } catch (RuntimeException e) {\n                throw e;\n            } catch (Exception e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n        }\n        referenceConfigs.putIfAbsent(key, referenceConfig);\n        referenceConfig = referenceConfigs.get(key);\n    }\n    return referenceConfig.get();\n}\n\nprivate boolean isMatchPackage(Object bean) {\n    if (annotationPackages == null || annotationPackages.length == 0) {\n        return true;\n    }\n    String beanClassName = bean.getClass().getName();\n    for (String pkg : annotationPackages) {\n        if (beanClassName.startsWith(pkg)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n","slug":"dubbo-basing-on-spring-framework-analysis","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4s000uzjialms1axf5","content":"<p>从Dubbo 2.7.0的项目依赖来看，依赖的Spring Framework版本是<code>4.3.16.RELEASE</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">spring_version</span>&gt;</span>4.3.16.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">spring_version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-framework-bom<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring_version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Dubbo是基于Spring构建和运行的，兼容Spring配置，Dubbo利用了SpringFramework的Extensible XML authoring 特性，扩展了Spring标签，关于如何利用Spring扩展标签，可以参考官方文档<a href=\"https://docs.spring.io/spring/docs/4.3.16.RELEASE/spring-framework-reference/htmlsingle/#xml-custom\" target=\"_blank\" rel=\"noopener\"> 《Extensible XML authoring》</a>：</p>\n<ul>\n<li><p>编写xml，描述需要扩展的标签的配置属性，dubbo实现放在jar包<code>META-INF/dubbo.xsd</code>文件里 同时通过编写<code>META-INF/spring.handlers</code>文件，提供给spring，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http\\://dubbo.apache.org/schema/dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler</span><br><span class=\"line\">http\\://code.alibabatech.com/schema/dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写一个NamespaceHandler接口实现类，dubbo中的实现类是DubboNamespaceHandler，同时通过编写<code>META-INF/spring.schemas</code>文件提供给Spring，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http\\://dubbo.apache.org/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd</span><br><span class=\"line\">http\\://code.alibabatech.com/schema/dubbo/dubbo.xsd=META-INF/compat/dubbo.xsd</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写一个或多个BeanDefinitionParser实现类，用来解析扩展的元素，Dubbo实现类是DubboBeanDefinitionParaser</p>\n</li>\n<li><p>把以上解析组件注册给Spring</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"解析DubboNamespaceHandler实现\"><a href=\"#解析DubboNamespaceHandler实现\" class=\"headerlink\" title=\"解析DubboNamespaceHandler实现\"></a>解析DubboNamespaceHandler实现</h4><p>首先来看一下DubboNamespaceHandler类的源代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DubboNamespaceHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注册每个标签对应的解析类</span></span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"application\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"module\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ModuleConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"registry\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"monitor\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(MonitorConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"provider\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"consumer\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"protocol\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"service\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"reference\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"annotation\"</span>, <span class=\"keyword\">new</span> AnnotationBeanDefinitionParser());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面提到的10个扩展标签，分别对应10个配置类，类的层次关系如下图(右键–&gt;Open image in new tab)：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/AbstractConfig.png?raw=true\" alt=\"\"></p>\n<p>如上图可以看出，主要基类是AbstractConfig和AbstractMethodConfig，而AbstractConfig又是所有类的基类，这10个配置类中ReferenceBean，ServiceBean，AnnotationBean 3个类又都实现了若干spring接口，这3个类算是利用spring完成dubbo调用的驱动类，后面要分别看源码。</p>\n<h4 id=\"解析DubboBeanDefinitionParser类\"><a href=\"#解析DubboBeanDefinitionParser类\" class=\"headerlink\" title=\"解析DubboBeanDefinitionParser类\"></a>解析DubboBeanDefinitionParser类</h4><p>这个类实现了BeanDefinitionParser接口，这是个Spring的原生接口，里面只有一个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BeanDefinitionParser</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Parse the specified &#123;<span class=\"doctag\">@link</span> Element&#125; and register the resulting</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#123;<span class=\"doctag\">@link</span> BeanDefinition BeanDefinition(s)&#125; with the</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#123;<span class=\"doctag\">@link</span> org.springframework.beans.factory.xml.ParserContext#getRegistry() BeanDefinitionRegistry&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * embedded in the supplied &#123;<span class=\"doctag\">@link</span> ParserContext&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;Implementations must return the primary &#123;<span class=\"doctag\">@link</span> BeanDefinition&#125; that results</span></span><br><span class=\"line\"><span class=\"comment\">\t * from the parse if they will ever be used in a nested fashion (for example as</span></span><br><span class=\"line\"><span class=\"comment\">\t * an inner tag in a &#123;<span class=\"doctag\">@code</span> &lt;property/&gt;&#125; tag). Implementations may return</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#123;<span class=\"doctag\">@code</span> null&#125; if they will &lt;strong&gt;not&lt;/strong&gt; be used in a nested fashion.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> element the element that is to be parsed into one or more &#123;<span class=\"doctag\">@link</span> BeanDefinition BeanDefinitions&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> parserContext the object encapsulating the current state of the parsing process;</span></span><br><span class=\"line\"><span class=\"comment\">\t * provides access to a &#123;<span class=\"doctag\">@link</span> org.springframework.beans.factory.support.BeanDefinitionRegistry&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the primary &#123;<span class=\"doctag\">@link</span> BeanDefinition&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">BeanDefinition <span class=\"title\">parse</span><span class=\"params\">(Element element, ParserContext parserContext)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据接口的定义，这个方法实现，需要解析Element元素成原生的BeanDefinition类对象，然后利用ParserContext对象的getRegistry()返回的注册器来注册解析后的BeanDefinition类的对象，最后返回这个BeanDefination类对象，下面是Dubbo的实现，主要是完成Spring配置到Spring容器内部BeanDefination转化的过程，下面来分析<code>parse()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> BeanDefinition <span class=\"title\">parse</span><span class=\"params\">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class=\"keyword\">boolean</span> required)</span> </span>&#123;</span><br><span class=\"line\">    RootBeanDefinition beanDefinition = <span class=\"keyword\">new</span> RootBeanDefinition();</span><br><span class=\"line\">    beanDefinition.setBeanClass(beanClass);</span><br><span class=\"line\">    beanDefinition.setLazyInit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    String id = element.getAttribute(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((id == <span class=\"keyword\">null</span> || id.length() == <span class=\"number\">0</span>) &amp;&amp; required) &#123;</span><br><span class=\"line\">        String generatedBeanName = element.getAttribute(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (generatedBeanName == <span class=\"keyword\">null</span> || generatedBeanName.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ProtocolConfig.class.equals(beanClass)) &#123;</span><br><span class=\"line\">                generatedBeanName = <span class=\"string\">\"dubbo\"</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                generatedBeanName = element.getAttribute(<span class=\"string\">\"interface\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (generatedBeanName == <span class=\"keyword\">null</span> || generatedBeanName.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            generatedBeanName = beanClass.getName();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        id = generatedBeanName;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> counter = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class=\"line\">            id = generatedBeanName + (counter++);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (id != <span class=\"keyword\">null</span> &amp;&amp; id.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate spring bean id \"</span> + id);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);</span><br><span class=\"line\">        beanDefinition.getPropertyValues().addPropertyValue(<span class=\"string\">\"id\"</span>, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ProtocolConfig.class.equals(beanClass)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : parserContext.getRegistry().getBeanDefinitionNames()) &#123;</span><br><span class=\"line\">            BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);</span><br><span class=\"line\">            PropertyValue property = definition.getPropertyValues().getPropertyValue(<span class=\"string\">\"protocol\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (property != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                Object value = property.getValue();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) &#123;</span><br><span class=\"line\">                    definition.getPropertyValues().addPropertyValue(<span class=\"string\">\"protocol\"</span>, <span class=\"keyword\">new</span> RuntimeBeanReference(id));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ServiceBean.class.equals(beanClass)) &#123;</span><br><span class=\"line\">        String className = element.getAttribute(<span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (className != <span class=\"keyword\">null</span> &amp;&amp; className.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            RootBeanDefinition classDefinition = <span class=\"keyword\">new</span> RootBeanDefinition();</span><br><span class=\"line\">            classDefinition.setBeanClass(ReflectUtils.forName(className));</span><br><span class=\"line\">            classDefinition.setLazyInit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            parseProperties(element.getChildNodes(), classDefinition);</span><br><span class=\"line\">            beanDefinition.getPropertyValues().addPropertyValue(<span class=\"string\">\"ref\"</span>, <span class=\"keyword\">new</span> BeanDefinitionHolder(classDefinition, id + <span class=\"string\">\"Impl\"</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ProviderConfig.class.equals(beanClass)) &#123;</span><br><span class=\"line\">        parseNested(element, parserContext, ServiceBean.class, <span class=\"keyword\">true</span>, <span class=\"string\">\"service\"</span>, <span class=\"string\">\"provider\"</span>, id, beanDefinition);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ConsumerConfig.class.equals(beanClass)) &#123;</span><br><span class=\"line\">        parseNested(element, parserContext, ReferenceBean.class, <span class=\"keyword\">false</span>, <span class=\"string\">\"reference\"</span>, <span class=\"string\">\"consumer\"</span>, id, beanDefinition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Set&lt;String&gt; props = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">    ManagedMap parameters = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method setter : beanClass.getMethods()) &#123;</span><br><span class=\"line\">        String name = setter.getName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name.length() &gt; <span class=\"number\">3</span> &amp;&amp; name.startsWith(<span class=\"string\">\"set\"</span>)</span><br><span class=\"line\">            &amp;&amp; Modifier.isPublic(setter.getModifiers())</span><br><span class=\"line\">            &amp;&amp; setter.getParameterTypes().length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; type = setter.getParameterTypes()[<span class=\"number\">0</span>];</span><br><span class=\"line\">            String property = StringUtils.camelToSplitName(name.substring(<span class=\"number\">3</span>, <span class=\"number\">4</span>).toLowerCase() + name.substring(<span class=\"number\">4</span>), <span class=\"string\">\"-\"</span>);</span><br><span class=\"line\">            props.add(property);</span><br><span class=\"line\">            Method getter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                getter = beanClass.getMethod(<span class=\"string\">\"get\"</span> + name.substring(<span class=\"number\">3</span>), <span class=\"keyword\">new</span> Class&lt;?&gt;[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    getter = beanClass.getMethod(<span class=\"string\">\"is\"</span> + name.substring(<span class=\"number\">3</span>), <span class=\"keyword\">new</span> Class&lt;?&gt;[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e2) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (getter == <span class=\"keyword\">null</span></span><br><span class=\"line\">                || !Modifier.isPublic(getter.getModifiers())</span><br><span class=\"line\">                || !type.equals(getter.getReturnType())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">\"parameters\"</span>.equals(property)) &#123;</span><br><span class=\"line\">                parameters = parseParameters(element.getChildNodes(), beanDefinition);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"methods\"</span>.equals(property)) &#123;</span><br><span class=\"line\">                parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"arguments\"</span>.equals(property)) &#123;</span><br><span class=\"line\">                parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                String value = element.getAttribute(property);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    value = value.trim();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (value.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (<span class=\"string\">\"registry\"</span>.equals(property) &amp;&amp; RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) &#123;</span><br><span class=\"line\">                            RegistryConfig registryConfig = <span class=\"keyword\">new</span> RegistryConfig();</span><br><span class=\"line\">                            registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);</span><br><span class=\"line\">                            beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"registry\"</span>.equals(property) &amp;&amp; value.indexOf(<span class=\"string\">','</span>) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                            parseMultiRef(<span class=\"string\">\"registries\"</span>, value, beanDefinition, parserContext);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"provider\"</span>.equals(property) &amp;&amp; value.indexOf(<span class=\"string\">','</span>) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                            parseMultiRef(<span class=\"string\">\"providers\"</span>, value, beanDefinition, parserContext);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"protocol\"</span>.equals(property) &amp;&amp; value.indexOf(<span class=\"string\">','</span>) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                            parseMultiRef(<span class=\"string\">\"protocols\"</span>, value, beanDefinition, parserContext);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            Object reference;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (isPrimitive(type)) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (<span class=\"string\">\"async\"</span>.equals(property) &amp;&amp; <span class=\"string\">\"false\"</span>.equals(value)</span><br><span class=\"line\">                                    || <span class=\"string\">\"timeout\"</span>.equals(property) &amp;&amp; <span class=\"string\">\"0\"</span>.equals(value)</span><br><span class=\"line\">                                    || <span class=\"string\">\"delay\"</span>.equals(property) &amp;&amp; <span class=\"string\">\"0\"</span>.equals(value)</span><br><span class=\"line\">                                    || <span class=\"string\">\"version\"</span>.equals(property) &amp;&amp; <span class=\"string\">\"0.0.0\"</span>.equals(value)</span><br><span class=\"line\">                                    || <span class=\"string\">\"stat\"</span>.equals(property) &amp;&amp; <span class=\"string\">\"-1\"</span>.equals(value)</span><br><span class=\"line\">                                    || <span class=\"string\">\"reliable\"</span>.equals(property) &amp;&amp; <span class=\"string\">\"false\"</span>.equals(value)) &#123;</span><br><span class=\"line\">                                    <span class=\"comment\">// backward compatibility for the default value in old version's xsd</span></span><br><span class=\"line\">                                    value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                reference = value;</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"protocol\"</span>.equals(property)</span><br><span class=\"line\">                                       &amp;&amp; ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(value)</span><br><span class=\"line\">                                       &amp;&amp; (!parserContext.getRegistry().containsBeanDefinition(value)</span><br><span class=\"line\">                                           || !ProtocolConfig.class.getName().equals(parserContext.getRegistry().getBeanDefinition(value).getBeanClassName()))) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (<span class=\"string\">\"dubbo:provider\"</span>.equals(element.getTagName())) &#123;</span><br><span class=\"line\">                                    logger.warn(<span class=\"string\">\"Recommended replace &lt;dubbo:provider protocol=\\\"\"</span> + value + <span class=\"string\">\"\\\" ... /&gt; to &lt;dubbo:protocol name=\\\"\"</span> + value + <span class=\"string\">\"\\\" ... /&gt;\"</span>);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"comment\">// backward compatibility</span></span><br><span class=\"line\">                                ProtocolConfig protocol = <span class=\"keyword\">new</span> ProtocolConfig();</span><br><span class=\"line\">                                protocol.setName(value);</span><br><span class=\"line\">                                reference = protocol;</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"onreturn\"</span>.equals(property)) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> index = value.lastIndexOf(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">                                String returnRef = value.substring(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">                                String returnMethod = value.substring(index + <span class=\"number\">1</span>);</span><br><span class=\"line\">                                reference = <span class=\"keyword\">new</span> RuntimeBeanReference(returnRef);</span><br><span class=\"line\">                                beanDefinition.getPropertyValues().addPropertyValue(<span class=\"string\">\"onreturnMethod\"</span>, returnMethod);</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"onthrow\"</span>.equals(property)) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> index = value.lastIndexOf(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">                                String throwRef = value.substring(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">                                String throwMethod = value.substring(index + <span class=\"number\">1</span>);</span><br><span class=\"line\">                                reference = <span class=\"keyword\">new</span> RuntimeBeanReference(throwRef);</span><br><span class=\"line\">                                beanDefinition.getPropertyValues().addPropertyValue(<span class=\"string\">\"onthrowMethod\"</span>, throwMethod);</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"oninvoke\"</span>.equals(property)) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> index = value.lastIndexOf(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">                                String invokeRef = value.substring(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">                                String invokeRefMethod = value.substring(index + <span class=\"number\">1</span>);</span><br><span class=\"line\">                                reference = <span class=\"keyword\">new</span> RuntimeBeanReference(invokeRef);</span><br><span class=\"line\">                                beanDefinition.getPropertyValues().addPropertyValue(<span class=\"string\">\"oninvokeMethod\"</span>, invokeRefMethod);</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (<span class=\"string\">\"ref\"</span>.equals(property) &amp;&amp; parserContext.getRegistry().containsBeanDefinition(value)) &#123;</span><br><span class=\"line\">                                    BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (!refBean.isSingleton()) &#123;</span><br><span class=\"line\">                                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The exported service ref \"</span> + value + <span class=\"string\">\" must be singleton! Please set the \"</span> + value + <span class=\"string\">\" bean scope to singleton, eg: &lt;bean id=\\\"\"</span> + value + <span class=\"string\">\"\\\" scope=\\\"singleton\\\" ...&gt;\"</span>);</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                reference = <span class=\"keyword\">new</span> RuntimeBeanReference(value);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            beanDefinition.getPropertyValues().addPropertyValue(property, reference);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    NamedNodeMap attributes = element.getAttributes();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = attributes.getLength();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        Node node = attributes.item(i);</span><br><span class=\"line\">        String name = node.getLocalName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!props.contains(name)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parameters == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                parameters = <span class=\"keyword\">new</span> ManagedMap();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String value = node.getNodeValue();</span><br><span class=\"line\">            parameters.put(name, <span class=\"keyword\">new</span> TypedStringValue(value, String.class));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parameters != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        beanDefinition.getPropertyValues().addPropertyValue(<span class=\"string\">\"parameters\"</span>, parameters);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> beanDefinition;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ReferenceBean类\"><a href=\"#ReferenceBean类\" class=\"headerlink\" title=\"ReferenceBean类\"></a>ReferenceBean类</h4><p>ReferenceBean类主要完成早适当的时机（Spring Bean初始化完成或者用户通过Spring容器获取bean）根据服务调用方法配置，生成服务调用代理工作，ReferenceBean类继承如下：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/ReferenceBean.png?raw=true\" alt=\"\"></p>\n<p>可以看到ReferenceBean实现了FactoryBean、ApplicationContextAware、FactoryBean、InitializingBean及DisposableBean四个接口，通过Spring的回调机制，完成Spring容器的传入，获取Bean类型，Bean初始化和Destory定制等操作，ReferenceBean类里的具体实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实现ApplicationContextAware接口的方法，在bean初始化时，回传bean所在容器的引用</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.applicationContext = applicationContext;</span><br><span class=\"line\">    SpringExtensionFactory.addApplicationContext(applicationContext);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现FactoryBean接口的方法，返回一个Bean实例，在使用Spring API从容器中获取一个bean时调用，</span></span><br><span class=\"line\"><span class=\"comment\">//这里返回的是reference的代理的代理类实例</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现FactoryBean接口的方法，返回一个bean的类型</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getInterfaceClass();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现FactoryBean接口的方法，返回一个bean是否是单例</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Parameter</span>(excluded = <span class=\"keyword\">true</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现InitializingBean的接口方法，在bean所有属性都赋值后，由spring回调执行</span></span><br><span class=\"line\"><span class=\"comment\">//这个方法里可以做些初始化定制</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getConsumer() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//BeanFactoryUtils.beansOfTypeIncludingAncestors()是Spring的一个工具类</span></span><br><span class=\"line\">        <span class=\"comment\">//返回指定容器里，ConsumerConfig.class类及其子类的Bean，如果还没初始化，会触发初始化的过程，依赖注入的概念a</span></span><br><span class=\"line\">        Map&lt;String, ConsumerConfig&gt; consumerConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConsumerConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (consumerConfigMap != <span class=\"keyword\">null</span> &amp;&amp; consumerConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ConsumerConfig consumerConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">//遍历map，默认设置ConsumerConfig</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ConsumerConfig config : consumerConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (consumerConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate consumer configs: \"</span> + consumerConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    consumerConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//设置ConsumerConfig</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (consumerConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setConsumer(consumerConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置ApplicationConfig</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getApplication() == <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (getConsumer() == <span class=\"keyword\">null</span> || getConsumer().getApplication() == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (applicationConfigMap != <span class=\"keyword\">null</span> &amp;&amp; applicationConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ApplicationConfig applicationConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ApplicationConfig config : applicationConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (applicationConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate application configs: \"</span> + applicationConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    applicationConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (applicationConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setApplication(applicationConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置ModuleConfig</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getModule() == <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (getConsumer() == <span class=\"keyword\">null</span> || getConsumer().getModule() == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (moduleConfigMap != <span class=\"keyword\">null</span> &amp;&amp; moduleConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ModuleConfig moduleConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ModuleConfig config : moduleConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (moduleConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate module configs: \"</span> + moduleConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    moduleConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (moduleConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setModule(moduleConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置注册中心</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((getRegistries() == <span class=\"keyword\">null</span> || getRegistries().isEmpty())</span><br><span class=\"line\">        &amp;&amp; (getConsumer() == <span class=\"keyword\">null</span> || getConsumer().getRegistries() == <span class=\"keyword\">null</span> || getConsumer().getRegistries().isEmpty())</span><br><span class=\"line\">        &amp;&amp; (getApplication() == <span class=\"keyword\">null</span> || getApplication().getRegistries() == <span class=\"keyword\">null</span> || getApplication().getRegistries().isEmpty())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//多个注册中心</span></span><br><span class=\"line\">        Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registryConfigMap != <span class=\"keyword\">null</span> &amp;&amp; registryConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            List&lt;RegistryConfig&gt; registryConfigs = <span class=\"keyword\">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (RegistryConfig config : registryConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class=\"line\">                    registryConfigs.add(config);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (registryConfigs != <span class=\"keyword\">null</span> &amp;&amp; !registryConfigs.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.setRegistries(registryConfigs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置监控中心</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getMonitor() == <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (getConsumer() == <span class=\"keyword\">null</span> || getConsumer().getMonitor() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        &amp;&amp; (getApplication() == <span class=\"keyword\">null</span> || getApplication().getMonitor() == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (monitorConfigMap != <span class=\"keyword\">null</span> &amp;&amp; monitorConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            MonitorConfig monitorConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (MonitorConfig config : monitorConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (monitorConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate monitor configs: \"</span> + monitorConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    monitorConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (monitorConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setMonitor(monitorConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//是否bean创建后就初始化代理</span></span><br><span class=\"line\">    Boolean b = isInit();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span> &amp;&amp; getConsumer() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        b = getConsumer().isInit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b != <span class=\"keyword\">null</span> &amp;&amp; b.booleanValue()) </span><br><span class=\"line\">        <span class=\"comment\">//立即初始化代理  </span></span><br><span class=\"line\">        getObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//DisposableBean的方法，做销毁处理</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ServiceBean类\"><a href=\"#ServiceBean类\" class=\"headerlink\" title=\"ServiceBean类\"></a>ServiceBean类</h4><p>ServiceBean类主要完成在适当时机（Spring容器初始化完成或者服务实例初始化完成）根据服务提供方的配置暴露发布服务的工作，ServiceBean类继承关系如下：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/ServiceBean.png?raw=true\" alt=\"\"></p>\n<p>可以看到ServiceBean及其基类实现了BeanNameAware、ApplicationContextAware、ApplicationListener、DisposableBean、InitializingBean接口，通过Spring回调机制完成Spring容器引用传入，bean初始化和destory过程定制，以及监听并处理Spring事件的操作，ServiceBean类具体实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传入bean所在容器的引用</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.applicationContext = applicationContext;</span><br><span class=\"line\">    <span class=\"comment\">//把Spring容器传入SpringExtensionFactory</span></span><br><span class=\"line\">    SpringExtensionFactory.addApplicationContext(applicationContext);</span><br><span class=\"line\">    <span class=\"comment\">//获取容易addApplicationListener方法，把当前类加入到容器监听队列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (applicationContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        SPRING_CONTEXT = applicationContext;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Method method = applicationContext.getClass().getMethod(<span class=\"string\">\"addApplicationListener\"</span>, ApplicationListener.class); <span class=\"comment\">// backward compatibility to spring 2.0.1</span></span><br><span class=\"line\">            method.invoke(applicationContext, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">            supportedApplicationListener = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (applicationContext <span class=\"keyword\">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Method method = AbstractApplicationContext.class.getDeclaredMethod(<span class=\"string\">\"addListener\"</span>, ApplicationListener.class); <span class=\"comment\">// backward compatibility to spring 2.0.1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!method.isAccessible()) &#123;</span><br><span class=\"line\">                        method.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    method.invoke(applicationContext, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//设置监听器后设为true</span></span><br><span class=\"line\">                    supportedApplicationListener = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable t2) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//设置beanName值</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setBeanName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.beanName = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Gets associated &#123;<span class=\"doctag\">@link</span> Service&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> associated &#123;<span class=\"doctag\">@link</span> Service&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Service <span class=\"title\">getService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> service;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现ApplicationListener接口方法，接受并处理在容器初始化完成时发布的ContextRefreshedEvent事件</span></span><br><span class=\"line\"><span class=\"comment\">//即容器初始化完成后暴露服务</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEvent</span><span class=\"params\">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"The service ready on spring started. service: \"</span> + getInterface());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//执行暴露过程</span></span><br><span class=\"line\">        export();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//判断是否延迟暴露</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDelay</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Integer delay = getDelay();</span><br><span class=\"line\">    ProviderConfig provider = getProvider();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delay == <span class=\"keyword\">null</span> &amp;&amp; provider != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        delay = provider.getDelay();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> supportedApplicationListener &amp;&amp; (delay == <span class=\"keyword\">null</span> || delay == -<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//InitializinBean接口方法，Bean属性初始化后，操作处理</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"deprecation\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置ProviderConfig</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getProvider() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (providerConfigMap != <span class=\"keyword\">null</span> &amp;&amp; providerConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((protocolConfigMap == <span class=\"keyword\">null</span> || protocolConfigMap.size() == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &amp;&amp; providerConfigMap.size() &gt; <span class=\"number\">1</span>) &#123; <span class=\"comment\">// backward compatibility</span></span><br><span class=\"line\">                List&lt;ProviderConfig&gt; providerConfigs = <span class=\"keyword\">new</span> ArrayList&lt;ProviderConfig&gt;();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (config.isDefault() != <span class=\"keyword\">null</span> &amp;&amp; config.isDefault()) &#123;</span><br><span class=\"line\">                        providerConfigs.add(config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!providerConfigs.isEmpty()) &#123;</span><br><span class=\"line\">                    setProviders(providerConfigs);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ProviderConfig providerConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (providerConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate provider configs: \"</span> + providerConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        providerConfig = config;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (providerConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    setProvider(providerConfig);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置ApplicationConfig</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getApplication() == <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (getProvider() == <span class=\"keyword\">null</span> || getProvider().getApplication() == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (applicationConfigMap != <span class=\"keyword\">null</span> &amp;&amp; applicationConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ApplicationConfig applicationConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ApplicationConfig config : applicationConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (applicationConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate application configs: \"</span> + applicationConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    applicationConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (applicationConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setApplication(applicationConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置模块</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getModule() == <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (getProvider() == <span class=\"keyword\">null</span> || getProvider().getModule() == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (moduleConfigMap != <span class=\"keyword\">null</span> &amp;&amp; moduleConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ModuleConfig moduleConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ModuleConfig config : moduleConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (moduleConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate module configs: \"</span> + moduleConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    moduleConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (moduleConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setModule(moduleConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置注册中心</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((getRegistries() == <span class=\"keyword\">null</span> || getRegistries().isEmpty())</span><br><span class=\"line\">        &amp;&amp; (getProvider() == <span class=\"keyword\">null</span> || getProvider().getRegistries() == <span class=\"keyword\">null</span> || getProvider().getRegistries().isEmpty())</span><br><span class=\"line\">        &amp;&amp; (getApplication() == <span class=\"keyword\">null</span> || getApplication().getRegistries() == <span class=\"keyword\">null</span> || getApplication().getRegistries().isEmpty())) &#123;</span><br><span class=\"line\">        Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registryConfigMap != <span class=\"keyword\">null</span> &amp;&amp; registryConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            List&lt;RegistryConfig&gt; registryConfigs = <span class=\"keyword\">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (RegistryConfig config : registryConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault()) &#123;</span><br><span class=\"line\">                    registryConfigs.add(config);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!registryConfigs.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.setRegistries(registryConfigs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置监控中心</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getMonitor() == <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (getProvider() == <span class=\"keyword\">null</span> || getProvider().getMonitor() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        &amp;&amp; (getApplication() == <span class=\"keyword\">null</span> || getApplication().getMonitor() == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (monitorConfigMap != <span class=\"keyword\">null</span> &amp;&amp; monitorConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            MonitorConfig monitorConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (MonitorConfig config : monitorConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (monitorConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate monitor configs: \"</span> + monitorConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    monitorConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (monitorConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setMonitor(monitorConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//服务协议，可以有多个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((getProtocols() == <span class=\"keyword\">null</span> || getProtocols().isEmpty())</span><br><span class=\"line\">        &amp;&amp; (getProvider() == <span class=\"keyword\">null</span> || getProvider().getProtocols() == <span class=\"keyword\">null</span> || getProvider().getProtocols().isEmpty())) &#123;</span><br><span class=\"line\">        Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (protocolConfigMap != <span class=\"keyword\">null</span> &amp;&amp; protocolConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            List&lt;ProtocolConfig&gt; protocolConfigs = <span class=\"keyword\">new</span> ArrayList&lt;ProtocolConfig&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ProtocolConfig config : protocolConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault()) &#123;</span><br><span class=\"line\">                    protocolConfigs.add(config);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!protocolConfigs.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.setProtocols(protocolConfigs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置服务路径（类全名）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getPath() == <span class=\"keyword\">null</span> || getPath().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (beanName != <span class=\"keyword\">null</span> &amp;&amp; beanName.length() &gt; <span class=\"number\">0</span></span><br><span class=\"line\">            &amp;&amp; getInterface() != <span class=\"keyword\">null</span> &amp;&amp; getInterface().length() &gt; <span class=\"number\">0</span></span><br><span class=\"line\">            &amp;&amp; beanName.startsWith(getInterface())) &#123;</span><br><span class=\"line\">            setPath(beanName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//是否延迟暴露</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDelay()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//暴露服务</span></span><br><span class=\"line\">        export();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"AnnotationBean类\"><a href=\"#AnnotationBean类\" class=\"headerlink\" title=\"AnnotationBean类\"></a>AnnotationBean类</h4><p>这个类使得dubbo具有自动包扫描功能支持dubbo通过注解配置service和Reference bean（有些属性不能注解配置），病完成ServiceBean和ReferenceBean相同的功能，类图如下：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/AnnotationBean.png?raw=true\" alt=\"\"></p>\n<p>可以看到AnnotationBean类实现了接口DisposableBean、BeanFactoryPostProcessor、BeanPostProcessor、ApplicationContextAware，同样用过Spring接口方法回调，实现Bean实例的初始化预处理。</p>\n<p>AnnotationBean类是基于ClassPathBeanDefinationScanner类实现的，看下<code>org.springframework.context.annotation.ClassPathBeanDefinationScanner</code>类官方解释<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ClassPathBeanDefinitionScanner.html\" target=\"_blank\" rel=\"noopener\">ClassPathBeanDefinationScanner</a>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A bean definition scanner that detects bean candidates on the classpath, registering corresponding bean definitions with a given registry (BeanFactory or ApplicationContext).</span><br><span class=\"line\">Candidate classes are detected through configurable type filters. The default filters include classes that are annotated with Spring&apos;s @Component, @Repository, @Service, or @Controller stereotype.</span><br><span class=\"line\"></span><br><span class=\"line\">Also supports Java EE 6&apos;s ManagedBean and JSR-330&apos;s Named annotations, if available.</span><br></pre></td></tr></table></figure>\n<p>大概意思就是，ClassPathBeanDefinitionScanner将会扫描classpath下的bean，并且向注册器注册（BeanFactory或者ApplicationContext）bean definition，通过配置的过滤器检测bean，默认会检测被@Component, @Repository, @Service, or @Controller注解的类。</p>\n<p>下面来分析AnnotationBean类的核心代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置扫描的包名，以逗号分隔包名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPackage</span><span class=\"params\">(String annotationPackage)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.annotationPackage = annotationPackage;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.annotationPackages = (annotationPackage == <span class=\"keyword\">null</span> || annotationPackage.length() == <span class=\"number\">0</span>) ? <span class=\"keyword\">null</span></span><br><span class=\"line\">        : Constants.COMMA_SPLIT_PATTERN.split(annotationPackage);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现Spring回调接口方法，传入容器引用</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.applicationContext = applicationContext;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现BeanFactoryPostProcessor接口，这个方法会在所有的bean definitions已加载，但是还没有实例化之前回调执行</span></span><br><span class=\"line\"><span class=\"comment\">//可以在Bean初始化之前定制化一些操作，这里做的是调用org.springframework.context.annotation.ClassPathBeanDefinitionScanner的scan方法</span></span><br><span class=\"line\"><span class=\"comment\">//扫描注册由Service(Dubbo定义)注解的Bean，都是用反射完成的</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (annotationPackage == <span class=\"keyword\">null</span> || annotationPackage.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanFactory <span class=\"keyword\">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// init scanner</span></span><br><span class=\"line\">            <span class=\"comment\">//利用反射构造ClassPathBeanDefinitionScanner实例，用的这个构造方法，</span></span><br><span class=\"line\">            <span class=\"comment\">// useDefaultFilters=true 默认扫描 spring 4种的注解</span></span><br><span class=\"line\">            <span class=\"comment\">// public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) &#123;</span></span><br><span class=\"line\">            <span class=\"comment\">//\t\tthis(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span></span><br><span class=\"line\">            <span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\">            Class&lt;?&gt; scannerClass = ReflectUtils.forName(<span class=\"string\">\"org.springframework.context.annotation.ClassPathBeanDefinitionScanner\"</span>);</span><br><span class=\"line\">            Object scanner = scannerClass.getConstructor(<span class=\"keyword\">new</span> Class&lt;?&gt;[]&#123;BeanDefinitionRegistry.class, <span class=\"keyword\">boolean</span>.class&#125;).newInstance((BeanDefinitionRegistry) beanFactory, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"comment\">// add filter</span></span><br><span class=\"line\">            <span class=\"comment\">//通过filter 添加新要扫描的注解，也是用的反射 这里是 AnnotationTypeFilte</span></span><br><span class=\"line\">            Class&lt;?&gt; filterClass = ReflectUtils.forName(<span class=\"string\">\"org.springframework.core.type.filter.AnnotationTypeFilter\"</span>);</span><br><span class=\"line\">            Object filter = filterClass.getConstructor(Class.class).newInstance(Service.class);</span><br><span class=\"line\">            <span class=\"comment\">//获取添加filter的方法，并调用</span></span><br><span class=\"line\">            Method addIncludeFilter = scannerClass.getMethod(<span class=\"string\">\"addIncludeFilter\"</span>, ReflectUtils.forName(<span class=\"string\">\"org.springframework.core.type.filter.TypeFilter\"</span>));</span><br><span class=\"line\">            addIncludeFilter.invoke(scanner, filter);</span><br><span class=\"line\">            <span class=\"comment\">// scan packages</span></span><br><span class=\"line\">            <span class=\"comment\">//获取ClassPathBeanDefinitionScanner的scan()方法，开始扫描</span></span><br><span class=\"line\">            String[] packages = Constants.COMMA_SPLIT_PATTERN.split(annotationPackage);</span><br><span class=\"line\">            Method scan = scannerClass.getMethod(<span class=\"string\">\"scan\"</span>, String[].class);</span><br><span class=\"line\">            scan.invoke(scanner, <span class=\"keyword\">new</span> Object[]&#123;packages&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// spring 2.0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现DisposableBean接口，在bean析构时，调用相关方法，释放资源</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  This will only be called for singleton scope bean, and expected to be called by spring shutdown hook when BeanFactory/ApplicationContext destroys.</span></span><br><span class=\"line\">    <span class=\"comment\">//  We will guarantee dubbo related resources being released with dubbo shutdown hook.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  for (ServiceConfig&lt;?&gt; serviceConfig : serviceConfigs) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//      try &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//          serviceConfig.unexport();</span></span><br><span class=\"line\">    <span class=\"comment\">//      &#125; catch (Throwable e) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//          logger.error(e.getMessage(), e);</span></span><br><span class=\"line\">    <span class=\"comment\">//      &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ReferenceConfig&lt;?&gt; referenceConfig : referenceConfigs.values()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            referenceConfig.destroy();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            logger.error(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现BeanPostProcessor接口方法，在Bean初始化之后，比如在afterPropertiesSet后由Spring回调执行</span></span><br><span class=\"line\"><span class=\"comment\">//这个方法完成类似ServiceBean的工作</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//检查是否匹配包名</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isMatchPackage(bean)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//手动创建ServiceBean并暴露服务</span></span><br><span class=\"line\">    Service service = bean.getClass().getAnnotation(Service.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (service != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ServiceBean&lt;Object&gt; serviceConfig = <span class=\"keyword\">new</span> ServiceBean&lt;Object&gt;(service);</span><br><span class=\"line\">        serviceConfig.setRef(bean);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">void</span>.class.equals(service.interfaceClass())</span><br><span class=\"line\">            &amp;&amp; <span class=\"string\">\"\"</span>.equals(service.interfaceName())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bean.getClass().getInterfaces().length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setInterface(bean.getClass().getInterfaces()[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Failed to export remote service class \"</span> + bean.getClass().getName() + <span class=\"string\">\", cause: The @Service undefined interfaceClass or interfaceName, and the service class unimplemented any interfaces.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (applicationContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            serviceConfig.setApplicationContext(applicationContext);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.registry().length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                List&lt;RegistryConfig&gt; registryConfigs = <span class=\"keyword\">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (String registryId : service.registry()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (registryId != <span class=\"keyword\">null</span> &amp;&amp; registryId.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        registryConfigs.add(applicationContext.getBean(registryId, RegistryConfig.class));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                serviceConfig.setRegistries(registryConfigs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.provider().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setProvider(applicationContext.getBean(service.provider(), ProviderConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.monitor().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setMonitor(applicationContext.getBean(service.monitor(), MonitorConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.application().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setApplication(applicationContext.getBean(service.application(), ApplicationConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.<span class=\"keyword\">module</span>().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setModule(applicationContext.getBean(service.<span class=\"keyword\">module</span>(), ModuleConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.provider().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setProvider(applicationContext.getBean(service.provider(), ProviderConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.protocol().length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                List&lt;ProtocolConfig&gt; protocolConfigs = <span class=\"keyword\">new</span> ArrayList&lt;ProtocolConfig&gt;();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (String protocolId : service.protocol()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (protocolId != <span class=\"keyword\">null</span> &amp;&amp; protocolId.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        protocolConfigs.add(applicationContext.getBean(protocolId, ProtocolConfig.class));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                serviceConfig.setProtocols(protocolConfigs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.tag().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setTag(service.tag());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                serviceConfig.afterPropertiesSet();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        serviceConfigs.add(serviceConfig);</span><br><span class=\"line\">        serviceConfig.export();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现BeanPostProcessor接口方法，在Bean初始化前，比如在afterPropertiesSet前，由Spring回调执行</span></span><br><span class=\"line\"><span class=\"comment\">//这个方法完成类似ReferenceBean的工作</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isMatchPackage(bean)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//因为Dubbo Reference注解只能在类的字段或者方法上</span></span><br><span class=\"line\">    <span class=\"comment\">//通过Bean的set方法上找dubbo注解</span></span><br><span class=\"line\">    Method[] methods = bean.getClass().getMethods();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">        String name = method.getName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name.length() &gt; <span class=\"number\">3</span> &amp;&amp; name.startsWith(<span class=\"string\">\"set\"</span>)</span><br><span class=\"line\">            &amp;&amp; method.getParameterTypes().length == <span class=\"number\">1</span></span><br><span class=\"line\">            &amp;&amp; Modifier.isPublic(method.getModifiers())</span><br><span class=\"line\">            &amp;&amp; !Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Reference reference = method.getAnnotation(Reference.class);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (reference != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    Object value = refer(reference, method.getParameterTypes()[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        method.invoke(bean, value);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">\"Failed to init remote service reference at method \"</span> + name + <span class=\"string\">\" in class \"</span> + bean.getClass().getName() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//通过bean的字段上找dubbo注解</span></span><br><span class=\"line\">    Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Field field : fields) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!field.isAccessible()) &#123;</span><br><span class=\"line\">                field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Reference reference = field.getAnnotation(Reference.class);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                Object value = refer(reference, field.getType());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    field.set(bean, value);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"Failed to init remote service reference at filed \"</span> + field.getName() + <span class=\"string\">\" in class \"</span> + bean.getClass().getName() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//通过解析Reference注解里的值，去构造服务调用配置，最后调用创建代理的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">refer</span><span class=\"params\">(Reference reference, Class&lt;?&gt; referenceClass)</span> </span>&#123; <span class=\"comment\">//method.getParameterTypes()[0]</span></span><br><span class=\"line\">    String interfaceName;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"string\">\"\"</span>.equals(reference.interfaceName())) &#123;</span><br><span class=\"line\">        interfaceName = reference.interfaceName();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!<span class=\"keyword\">void</span>.class.equals(reference.interfaceClass())) &#123;</span><br><span class=\"line\">        interfaceName = reference.interfaceClass().getName();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (referenceClass.isInterface()) &#123;</span><br><span class=\"line\">        interfaceName = referenceClass.getName();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The @Reference undefined interfaceClass or interfaceName, and the property type \"</span> + referenceClass.getName() + <span class=\"string\">\" is not a interface.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String key = reference.group() + <span class=\"string\">\"/\"</span> + interfaceName + <span class=\"string\">\":\"</span> + reference.version();</span><br><span class=\"line\">    ReferenceBean&lt;?&gt; referenceConfig = referenceConfigs.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (referenceConfig == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        referenceConfig = <span class=\"keyword\">new</span> ReferenceBean&lt;Object&gt;(reference);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">void</span>.class.equals(reference.interfaceClass())</span><br><span class=\"line\">            &amp;&amp; <span class=\"string\">\"\"</span>.equals(reference.interfaceName())</span><br><span class=\"line\">            &amp;&amp; referenceClass.isInterface()) &#123;</span><br><span class=\"line\">            referenceConfig.setInterface(referenceClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (applicationContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            referenceConfig.setApplicationContext(applicationContext);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference.registry().length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                List&lt;RegistryConfig&gt; registryConfigs = <span class=\"keyword\">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (String registryId : reference.registry()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (registryId != <span class=\"keyword\">null</span> &amp;&amp; registryId.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        registryConfigs.add(applicationContext.getBean(registryId, RegistryConfig.class));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                referenceConfig.setRegistries(registryConfigs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference.consumer().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                referenceConfig.setConsumer(applicationContext.getBean(reference.consumer(), ConsumerConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference.monitor().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                referenceConfig.setMonitor(applicationContext.getBean(reference.monitor(), MonitorConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference.application().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                referenceConfig.setApplication(applicationContext.getBean(reference.application(), ApplicationConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference.<span class=\"keyword\">module</span>().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                referenceConfig.setModule(applicationContext.getBean(reference.<span class=\"keyword\">module</span>(), ModuleConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference.consumer().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                referenceConfig.setConsumer(applicationContext.getBean(reference.consumer(), ConsumerConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                referenceConfig.afterPropertiesSet();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        referenceConfigs.putIfAbsent(key, referenceConfig);</span><br><span class=\"line\">        referenceConfig = referenceConfigs.get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> referenceConfig.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatchPackage</span><span class=\"params\">(Object bean)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (annotationPackages == <span class=\"keyword\">null</span> || annotationPackages.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String beanClassName = bean.getClass().getName();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String pkg : annotationPackages) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (beanClassName.startsWith(pkg)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>从Dubbo 2.7.0的项目依赖来看，依赖的Spring Framework版本是<code>4.3.16.RELEASE</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">spring_version</span>&gt;</span>4.3.16.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">spring_version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-framework-bom<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;spring_version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Dubbo是基于Spring构建和运行的，兼容Spring配置，Dubbo利用了SpringFramework的Extensible XML authoring 特性，扩展了Spring标签，关于如何利用Spring扩展标签，可以参考官方文档<a href=\"https://docs.spring.io/spring/docs/4.3.16.RELEASE/spring-framework-reference/htmlsingle/#xml-custom\" target=\"_blank\" rel=\"noopener\"> 《Extensible XML authoring》</a>：</p>\n<ul>\n<li><p>编写xml，描述需要扩展的标签的配置属性，dubbo实现放在jar包<code>META-INF/dubbo.xsd</code>文件里 同时通过编写<code>META-INF/spring.handlers</code>文件，提供给spring，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http\\://dubbo.apache.org/schema/dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler</span><br><span class=\"line\">http\\://code.alibabatech.com/schema/dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写一个NamespaceHandler接口实现类，dubbo中的实现类是DubboNamespaceHandler，同时通过编写<code>META-INF/spring.schemas</code>文件提供给Spring，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http\\://dubbo.apache.org/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd</span><br><span class=\"line\">http\\://code.alibabatech.com/schema/dubbo/dubbo.xsd=META-INF/compat/dubbo.xsd</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写一个或多个BeanDefinitionParser实现类，用来解析扩展的元素，Dubbo实现类是DubboBeanDefinitionParaser</p>\n</li>\n<li><p>把以上解析组件注册给Spring</p>\n</li>\n</ul>","more":"<h4 id=\"解析DubboNamespaceHandler实现\"><a href=\"#解析DubboNamespaceHandler实现\" class=\"headerlink\" title=\"解析DubboNamespaceHandler实现\"></a>解析DubboNamespaceHandler实现</h4><p>首先来看一下DubboNamespaceHandler类的源代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DubboNamespaceHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注册每个标签对应的解析类</span></span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"application\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"module\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ModuleConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"registry\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"monitor\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(MonitorConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"provider\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"consumer\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"protocol\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"service\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"reference\"</span>, <span class=\"keyword\">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">        registerBeanDefinitionParser(<span class=\"string\">\"annotation\"</span>, <span class=\"keyword\">new</span> AnnotationBeanDefinitionParser());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面提到的10个扩展标签，分别对应10个配置类，类的层次关系如下图(右键–&gt;Open image in new tab)：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/AbstractConfig.png?raw=true\" alt=\"\"></p>\n<p>如上图可以看出，主要基类是AbstractConfig和AbstractMethodConfig，而AbstractConfig又是所有类的基类，这10个配置类中ReferenceBean，ServiceBean，AnnotationBean 3个类又都实现了若干spring接口，这3个类算是利用spring完成dubbo调用的驱动类，后面要分别看源码。</p>\n<h4 id=\"解析DubboBeanDefinitionParser类\"><a href=\"#解析DubboBeanDefinitionParser类\" class=\"headerlink\" title=\"解析DubboBeanDefinitionParser类\"></a>解析DubboBeanDefinitionParser类</h4><p>这个类实现了BeanDefinitionParser接口，这是个Spring的原生接口，里面只有一个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BeanDefinitionParser</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Parse the specified &#123;<span class=\"doctag\">@link</span> Element&#125; and register the resulting</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#123;<span class=\"doctag\">@link</span> BeanDefinition BeanDefinition(s)&#125; with the</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#123;<span class=\"doctag\">@link</span> org.springframework.beans.factory.xml.ParserContext#getRegistry() BeanDefinitionRegistry&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * embedded in the supplied &#123;<span class=\"doctag\">@link</span> ParserContext&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;Implementations must return the primary &#123;<span class=\"doctag\">@link</span> BeanDefinition&#125; that results</span></span><br><span class=\"line\"><span class=\"comment\">\t * from the parse if they will ever be used in a nested fashion (for example as</span></span><br><span class=\"line\"><span class=\"comment\">\t * an inner tag in a &#123;<span class=\"doctag\">@code</span> &lt;property/&gt;&#125; tag). Implementations may return</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#123;<span class=\"doctag\">@code</span> null&#125; if they will &lt;strong&gt;not&lt;/strong&gt; be used in a nested fashion.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> element the element that is to be parsed into one or more &#123;<span class=\"doctag\">@link</span> BeanDefinition BeanDefinitions&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> parserContext the object encapsulating the current state of the parsing process;</span></span><br><span class=\"line\"><span class=\"comment\">\t * provides access to a &#123;<span class=\"doctag\">@link</span> org.springframework.beans.factory.support.BeanDefinitionRegistry&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the primary &#123;<span class=\"doctag\">@link</span> BeanDefinition&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\">BeanDefinition <span class=\"title\">parse</span><span class=\"params\">(Element element, ParserContext parserContext)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据接口的定义，这个方法实现，需要解析Element元素成原生的BeanDefinition类对象，然后利用ParserContext对象的getRegistry()返回的注册器来注册解析后的BeanDefinition类的对象，最后返回这个BeanDefination类对象，下面是Dubbo的实现，主要是完成Spring配置到Spring容器内部BeanDefination转化的过程，下面来分析<code>parse()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> BeanDefinition <span class=\"title\">parse</span><span class=\"params\">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class=\"keyword\">boolean</span> required)</span> </span>&#123;</span><br><span class=\"line\">    RootBeanDefinition beanDefinition = <span class=\"keyword\">new</span> RootBeanDefinition();</span><br><span class=\"line\">    beanDefinition.setBeanClass(beanClass);</span><br><span class=\"line\">    beanDefinition.setLazyInit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    String id = element.getAttribute(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((id == <span class=\"keyword\">null</span> || id.length() == <span class=\"number\">0</span>) &amp;&amp; required) &#123;</span><br><span class=\"line\">        String generatedBeanName = element.getAttribute(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (generatedBeanName == <span class=\"keyword\">null</span> || generatedBeanName.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ProtocolConfig.class.equals(beanClass)) &#123;</span><br><span class=\"line\">                generatedBeanName = <span class=\"string\">\"dubbo\"</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                generatedBeanName = element.getAttribute(<span class=\"string\">\"interface\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (generatedBeanName == <span class=\"keyword\">null</span> || generatedBeanName.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            generatedBeanName = beanClass.getName();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        id = generatedBeanName;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> counter = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class=\"line\">            id = generatedBeanName + (counter++);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (id != <span class=\"keyword\">null</span> &amp;&amp; id.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate spring bean id \"</span> + id);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);</span><br><span class=\"line\">        beanDefinition.getPropertyValues().addPropertyValue(<span class=\"string\">\"id\"</span>, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ProtocolConfig.class.equals(beanClass)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : parserContext.getRegistry().getBeanDefinitionNames()) &#123;</span><br><span class=\"line\">            BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);</span><br><span class=\"line\">            PropertyValue property = definition.getPropertyValues().getPropertyValue(<span class=\"string\">\"protocol\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (property != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                Object value = property.getValue();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) &#123;</span><br><span class=\"line\">                    definition.getPropertyValues().addPropertyValue(<span class=\"string\">\"protocol\"</span>, <span class=\"keyword\">new</span> RuntimeBeanReference(id));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ServiceBean.class.equals(beanClass)) &#123;</span><br><span class=\"line\">        String className = element.getAttribute(<span class=\"string\">\"class\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (className != <span class=\"keyword\">null</span> &amp;&amp; className.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            RootBeanDefinition classDefinition = <span class=\"keyword\">new</span> RootBeanDefinition();</span><br><span class=\"line\">            classDefinition.setBeanClass(ReflectUtils.forName(className));</span><br><span class=\"line\">            classDefinition.setLazyInit(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">            parseProperties(element.getChildNodes(), classDefinition);</span><br><span class=\"line\">            beanDefinition.getPropertyValues().addPropertyValue(<span class=\"string\">\"ref\"</span>, <span class=\"keyword\">new</span> BeanDefinitionHolder(classDefinition, id + <span class=\"string\">\"Impl\"</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ProviderConfig.class.equals(beanClass)) &#123;</span><br><span class=\"line\">        parseNested(element, parserContext, ServiceBean.class, <span class=\"keyword\">true</span>, <span class=\"string\">\"service\"</span>, <span class=\"string\">\"provider\"</span>, id, beanDefinition);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ConsumerConfig.class.equals(beanClass)) &#123;</span><br><span class=\"line\">        parseNested(element, parserContext, ReferenceBean.class, <span class=\"keyword\">false</span>, <span class=\"string\">\"reference\"</span>, <span class=\"string\">\"consumer\"</span>, id, beanDefinition);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Set&lt;String&gt; props = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">    ManagedMap parameters = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method setter : beanClass.getMethods()) &#123;</span><br><span class=\"line\">        String name = setter.getName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name.length() &gt; <span class=\"number\">3</span> &amp;&amp; name.startsWith(<span class=\"string\">\"set\"</span>)</span><br><span class=\"line\">            &amp;&amp; Modifier.isPublic(setter.getModifiers())</span><br><span class=\"line\">            &amp;&amp; setter.getParameterTypes().length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; type = setter.getParameterTypes()[<span class=\"number\">0</span>];</span><br><span class=\"line\">            String property = StringUtils.camelToSplitName(name.substring(<span class=\"number\">3</span>, <span class=\"number\">4</span>).toLowerCase() + name.substring(<span class=\"number\">4</span>), <span class=\"string\">\"-\"</span>);</span><br><span class=\"line\">            props.add(property);</span><br><span class=\"line\">            Method getter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                getter = beanClass.getMethod(<span class=\"string\">\"get\"</span> + name.substring(<span class=\"number\">3</span>), <span class=\"keyword\">new</span> Class&lt;?&gt;[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    getter = beanClass.getMethod(<span class=\"string\">\"is\"</span> + name.substring(<span class=\"number\">3</span>), <span class=\"keyword\">new</span> Class&lt;?&gt;[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e2) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (getter == <span class=\"keyword\">null</span></span><br><span class=\"line\">                || !Modifier.isPublic(getter.getModifiers())</span><br><span class=\"line\">                || !type.equals(getter.getReturnType())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">\"parameters\"</span>.equals(property)) &#123;</span><br><span class=\"line\">                parameters = parseParameters(element.getChildNodes(), beanDefinition);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"methods\"</span>.equals(property)) &#123;</span><br><span class=\"line\">                parseMethods(id, element.getChildNodes(), beanDefinition, parserContext);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"arguments\"</span>.equals(property)) &#123;</span><br><span class=\"line\">                parseArguments(id, element.getChildNodes(), beanDefinition, parserContext);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                String value = element.getAttribute(property);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    value = value.trim();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (value.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (<span class=\"string\">\"registry\"</span>.equals(property) &amp;&amp; RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(value)) &#123;</span><br><span class=\"line\">                            RegistryConfig registryConfig = <span class=\"keyword\">new</span> RegistryConfig();</span><br><span class=\"line\">                            registryConfig.setAddress(RegistryConfig.NO_AVAILABLE);</span><br><span class=\"line\">                            beanDefinition.getPropertyValues().addPropertyValue(property, registryConfig);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"registry\"</span>.equals(property) &amp;&amp; value.indexOf(<span class=\"string\">','</span>) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                            parseMultiRef(<span class=\"string\">\"registries\"</span>, value, beanDefinition, parserContext);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"provider\"</span>.equals(property) &amp;&amp; value.indexOf(<span class=\"string\">','</span>) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                            parseMultiRef(<span class=\"string\">\"providers\"</span>, value, beanDefinition, parserContext);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"protocol\"</span>.equals(property) &amp;&amp; value.indexOf(<span class=\"string\">','</span>) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                            parseMultiRef(<span class=\"string\">\"protocols\"</span>, value, beanDefinition, parserContext);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            Object reference;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (isPrimitive(type)) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (<span class=\"string\">\"async\"</span>.equals(property) &amp;&amp; <span class=\"string\">\"false\"</span>.equals(value)</span><br><span class=\"line\">                                    || <span class=\"string\">\"timeout\"</span>.equals(property) &amp;&amp; <span class=\"string\">\"0\"</span>.equals(value)</span><br><span class=\"line\">                                    || <span class=\"string\">\"delay\"</span>.equals(property) &amp;&amp; <span class=\"string\">\"0\"</span>.equals(value)</span><br><span class=\"line\">                                    || <span class=\"string\">\"version\"</span>.equals(property) &amp;&amp; <span class=\"string\">\"0.0.0\"</span>.equals(value)</span><br><span class=\"line\">                                    || <span class=\"string\">\"stat\"</span>.equals(property) &amp;&amp; <span class=\"string\">\"-1\"</span>.equals(value)</span><br><span class=\"line\">                                    || <span class=\"string\">\"reliable\"</span>.equals(property) &amp;&amp; <span class=\"string\">\"false\"</span>.equals(value)) &#123;</span><br><span class=\"line\">                                    <span class=\"comment\">// backward compatibility for the default value in old version's xsd</span></span><br><span class=\"line\">                                    value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                reference = value;</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"protocol\"</span>.equals(property)</span><br><span class=\"line\">                                       &amp;&amp; ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(value)</span><br><span class=\"line\">                                       &amp;&amp; (!parserContext.getRegistry().containsBeanDefinition(value)</span><br><span class=\"line\">                                           || !ProtocolConfig.class.getName().equals(parserContext.getRegistry().getBeanDefinition(value).getBeanClassName()))) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (<span class=\"string\">\"dubbo:provider\"</span>.equals(element.getTagName())) &#123;</span><br><span class=\"line\">                                    logger.warn(<span class=\"string\">\"Recommended replace &lt;dubbo:provider protocol=\\\"\"</span> + value + <span class=\"string\">\"\\\" ... /&gt; to &lt;dubbo:protocol name=\\\"\"</span> + value + <span class=\"string\">\"\\\" ... /&gt;\"</span>);</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                <span class=\"comment\">// backward compatibility</span></span><br><span class=\"line\">                                ProtocolConfig protocol = <span class=\"keyword\">new</span> ProtocolConfig();</span><br><span class=\"line\">                                protocol.setName(value);</span><br><span class=\"line\">                                reference = protocol;</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"onreturn\"</span>.equals(property)) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> index = value.lastIndexOf(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">                                String returnRef = value.substring(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">                                String returnMethod = value.substring(index + <span class=\"number\">1</span>);</span><br><span class=\"line\">                                reference = <span class=\"keyword\">new</span> RuntimeBeanReference(returnRef);</span><br><span class=\"line\">                                beanDefinition.getPropertyValues().addPropertyValue(<span class=\"string\">\"onreturnMethod\"</span>, returnMethod);</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"onthrow\"</span>.equals(property)) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> index = value.lastIndexOf(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">                                String throwRef = value.substring(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">                                String throwMethod = value.substring(index + <span class=\"number\">1</span>);</span><br><span class=\"line\">                                reference = <span class=\"keyword\">new</span> RuntimeBeanReference(throwRef);</span><br><span class=\"line\">                                beanDefinition.getPropertyValues().addPropertyValue(<span class=\"string\">\"onthrowMethod\"</span>, throwMethod);</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"oninvoke\"</span>.equals(property)) &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">int</span> index = value.lastIndexOf(<span class=\"string\">\".\"</span>);</span><br><span class=\"line\">                                String invokeRef = value.substring(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">                                String invokeRefMethod = value.substring(index + <span class=\"number\">1</span>);</span><br><span class=\"line\">                                reference = <span class=\"keyword\">new</span> RuntimeBeanReference(invokeRef);</span><br><span class=\"line\">                                beanDefinition.getPropertyValues().addPropertyValue(<span class=\"string\">\"oninvokeMethod\"</span>, invokeRefMethod);</span><br><span class=\"line\">                            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (<span class=\"string\">\"ref\"</span>.equals(property) &amp;&amp; parserContext.getRegistry().containsBeanDefinition(value)) &#123;</span><br><span class=\"line\">                                    BeanDefinition refBean = parserContext.getRegistry().getBeanDefinition(value);</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (!refBean.isSingleton()) &#123;</span><br><span class=\"line\">                                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The exported service ref \"</span> + value + <span class=\"string\">\" must be singleton! Please set the \"</span> + value + <span class=\"string\">\" bean scope to singleton, eg: &lt;bean id=\\\"\"</span> + value + <span class=\"string\">\"\\\" scope=\\\"singleton\\\" ...&gt;\"</span>);</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                reference = <span class=\"keyword\">new</span> RuntimeBeanReference(value);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            beanDefinition.getPropertyValues().addPropertyValue(property, reference);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    NamedNodeMap attributes = element.getAttributes();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = attributes.getLength();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        Node node = attributes.item(i);</span><br><span class=\"line\">        String name = node.getLocalName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!props.contains(name)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parameters == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                parameters = <span class=\"keyword\">new</span> ManagedMap();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String value = node.getNodeValue();</span><br><span class=\"line\">            parameters.put(name, <span class=\"keyword\">new</span> TypedStringValue(value, String.class));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parameters != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        beanDefinition.getPropertyValues().addPropertyValue(<span class=\"string\">\"parameters\"</span>, parameters);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> beanDefinition;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ReferenceBean类\"><a href=\"#ReferenceBean类\" class=\"headerlink\" title=\"ReferenceBean类\"></a>ReferenceBean类</h4><p>ReferenceBean类主要完成早适当的时机（Spring Bean初始化完成或者用户通过Spring容器获取bean）根据服务调用方法配置，生成服务调用代理工作，ReferenceBean类继承如下：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/ReferenceBean.png?raw=true\" alt=\"\"></p>\n<p>可以看到ReferenceBean实现了FactoryBean、ApplicationContextAware、FactoryBean、InitializingBean及DisposableBean四个接口，通过Spring的回调机制，完成Spring容器的传入，获取Bean类型，Bean初始化和Destory定制等操作，ReferenceBean类里的具体实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实现ApplicationContextAware接口的方法，在bean初始化时，回传bean所在容器的引用</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.applicationContext = applicationContext;</span><br><span class=\"line\">    SpringExtensionFactory.addApplicationContext(applicationContext);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现FactoryBean接口的方法，返回一个Bean实例，在使用Spring API从容器中获取一个bean时调用，</span></span><br><span class=\"line\"><span class=\"comment\">//这里返回的是reference的代理的代理类实例</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现FactoryBean接口的方法，返回一个bean的类型</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getInterfaceClass();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现FactoryBean接口的方法，返回一个bean是否是单例</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Parameter</span>(excluded = <span class=\"keyword\">true</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSingleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现InitializingBean的接口方法，在bean所有属性都赋值后，由spring回调执行</span></span><br><span class=\"line\"><span class=\"comment\">//这个方法里可以做些初始化定制</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getConsumer() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//BeanFactoryUtils.beansOfTypeIncludingAncestors()是Spring的一个工具类</span></span><br><span class=\"line\">        <span class=\"comment\">//返回指定容器里，ConsumerConfig.class类及其子类的Bean，如果还没初始化，会触发初始化的过程，依赖注入的概念a</span></span><br><span class=\"line\">        Map&lt;String, ConsumerConfig&gt; consumerConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ConsumerConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (consumerConfigMap != <span class=\"keyword\">null</span> &amp;&amp; consumerConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ConsumerConfig consumerConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">//遍历map，默认设置ConsumerConfig</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ConsumerConfig config : consumerConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (consumerConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate consumer configs: \"</span> + consumerConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    consumerConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//设置ConsumerConfig</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (consumerConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setConsumer(consumerConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置ApplicationConfig</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getApplication() == <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (getConsumer() == <span class=\"keyword\">null</span> || getConsumer().getApplication() == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (applicationConfigMap != <span class=\"keyword\">null</span> &amp;&amp; applicationConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ApplicationConfig applicationConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ApplicationConfig config : applicationConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (applicationConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate application configs: \"</span> + applicationConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    applicationConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (applicationConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setApplication(applicationConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置ModuleConfig</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getModule() == <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (getConsumer() == <span class=\"keyword\">null</span> || getConsumer().getModule() == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (moduleConfigMap != <span class=\"keyword\">null</span> &amp;&amp; moduleConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ModuleConfig moduleConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ModuleConfig config : moduleConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (moduleConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate module configs: \"</span> + moduleConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    moduleConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (moduleConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setModule(moduleConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置注册中心</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((getRegistries() == <span class=\"keyword\">null</span> || getRegistries().isEmpty())</span><br><span class=\"line\">        &amp;&amp; (getConsumer() == <span class=\"keyword\">null</span> || getConsumer().getRegistries() == <span class=\"keyword\">null</span> || getConsumer().getRegistries().isEmpty())</span><br><span class=\"line\">        &amp;&amp; (getApplication() == <span class=\"keyword\">null</span> || getApplication().getRegistries() == <span class=\"keyword\">null</span> || getApplication().getRegistries().isEmpty())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//多个注册中心</span></span><br><span class=\"line\">        Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registryConfigMap != <span class=\"keyword\">null</span> &amp;&amp; registryConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            List&lt;RegistryConfig&gt; registryConfigs = <span class=\"keyword\">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (RegistryConfig config : registryConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class=\"line\">                    registryConfigs.add(config);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (registryConfigs != <span class=\"keyword\">null</span> &amp;&amp; !registryConfigs.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.setRegistries(registryConfigs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置监控中心</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getMonitor() == <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (getConsumer() == <span class=\"keyword\">null</span> || getConsumer().getMonitor() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        &amp;&amp; (getApplication() == <span class=\"keyword\">null</span> || getApplication().getMonitor() == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (monitorConfigMap != <span class=\"keyword\">null</span> &amp;&amp; monitorConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            MonitorConfig monitorConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (MonitorConfig config : monitorConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (monitorConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate monitor configs: \"</span> + monitorConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    monitorConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (monitorConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setMonitor(monitorConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//是否bean创建后就初始化代理</span></span><br><span class=\"line\">    Boolean b = isInit();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span> &amp;&amp; getConsumer() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        b = getConsumer().isInit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b != <span class=\"keyword\">null</span> &amp;&amp; b.booleanValue()) </span><br><span class=\"line\">        <span class=\"comment\">//立即初始化代理  </span></span><br><span class=\"line\">        getObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//DisposableBean的方法，做销毁处理</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ServiceBean类\"><a href=\"#ServiceBean类\" class=\"headerlink\" title=\"ServiceBean类\"></a>ServiceBean类</h4><p>ServiceBean类主要完成在适当时机（Spring容器初始化完成或者服务实例初始化完成）根据服务提供方的配置暴露发布服务的工作，ServiceBean类继承关系如下：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/ServiceBean.png?raw=true\" alt=\"\"></p>\n<p>可以看到ServiceBean及其基类实现了BeanNameAware、ApplicationContextAware、ApplicationListener、DisposableBean、InitializingBean接口，通过Spring回调机制完成Spring容器引用传入，bean初始化和destory过程定制，以及监听并处理Spring事件的操作，ServiceBean类具体实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传入bean所在容器的引用</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.applicationContext = applicationContext;</span><br><span class=\"line\">    <span class=\"comment\">//把Spring容器传入SpringExtensionFactory</span></span><br><span class=\"line\">    SpringExtensionFactory.addApplicationContext(applicationContext);</span><br><span class=\"line\">    <span class=\"comment\">//获取容易addApplicationListener方法，把当前类加入到容器监听队列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (applicationContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        SPRING_CONTEXT = applicationContext;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Method method = applicationContext.getClass().getMethod(<span class=\"string\">\"addApplicationListener\"</span>, ApplicationListener.class); <span class=\"comment\">// backward compatibility to spring 2.0.1</span></span><br><span class=\"line\">            method.invoke(applicationContext, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">            supportedApplicationListener = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (applicationContext <span class=\"keyword\">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Method method = AbstractApplicationContext.class.getDeclaredMethod(<span class=\"string\">\"addListener\"</span>, ApplicationListener.class); <span class=\"comment\">// backward compatibility to spring 2.0.1</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!method.isAccessible()) &#123;</span><br><span class=\"line\">                        method.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    method.invoke(applicationContext, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//设置监听器后设为true</span></span><br><span class=\"line\">                    supportedApplicationListener = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable t2) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//设置beanName值</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setBeanName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.beanName = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Gets associated &#123;<span class=\"doctag\">@link</span> Service&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> associated &#123;<span class=\"doctag\">@link</span> Service&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Service <span class=\"title\">getService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> service;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现ApplicationListener接口方法，接受并处理在容器初始化完成时发布的ContextRefreshedEvent事件</span></span><br><span class=\"line\"><span class=\"comment\">//即容器初始化完成后暴露服务</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEvent</span><span class=\"params\">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"The service ready on spring started. service: \"</span> + getInterface());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//执行暴露过程</span></span><br><span class=\"line\">        export();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//判断是否延迟暴露</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDelay</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Integer delay = getDelay();</span><br><span class=\"line\">    ProviderConfig provider = getProvider();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delay == <span class=\"keyword\">null</span> &amp;&amp; provider != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        delay = provider.getDelay();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> supportedApplicationListener &amp;&amp; (delay == <span class=\"keyword\">null</span> || delay == -<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//InitializinBean接口方法，Bean属性初始化后，操作处理</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"deprecation\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置ProviderConfig</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getProvider() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (providerConfigMap != <span class=\"keyword\">null</span> &amp;&amp; providerConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((protocolConfigMap == <span class=\"keyword\">null</span> || protocolConfigMap.size() == <span class=\"number\">0</span>)</span><br><span class=\"line\">                &amp;&amp; providerConfigMap.size() &gt; <span class=\"number\">1</span>) &#123; <span class=\"comment\">// backward compatibility</span></span><br><span class=\"line\">                List&lt;ProviderConfig&gt; providerConfigs = <span class=\"keyword\">new</span> ArrayList&lt;ProviderConfig&gt;();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (config.isDefault() != <span class=\"keyword\">null</span> &amp;&amp; config.isDefault()) &#123;</span><br><span class=\"line\">                        providerConfigs.add(config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!providerConfigs.isEmpty()) &#123;</span><br><span class=\"line\">                    setProviders(providerConfigs);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ProviderConfig providerConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault()) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (providerConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate provider configs: \"</span> + providerConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        providerConfig = config;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (providerConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    setProvider(providerConfig);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置ApplicationConfig</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getApplication() == <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (getProvider() == <span class=\"keyword\">null</span> || getProvider().getApplication() == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (applicationConfigMap != <span class=\"keyword\">null</span> &amp;&amp; applicationConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ApplicationConfig applicationConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ApplicationConfig config : applicationConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (applicationConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate application configs: \"</span> + applicationConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    applicationConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (applicationConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setApplication(applicationConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置模块</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getModule() == <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (getProvider() == <span class=\"keyword\">null</span> || getProvider().getModule() == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (moduleConfigMap != <span class=\"keyword\">null</span> &amp;&amp; moduleConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ModuleConfig moduleConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ModuleConfig config : moduleConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (moduleConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate module configs: \"</span> + moduleConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    moduleConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (moduleConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setModule(moduleConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置注册中心</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((getRegistries() == <span class=\"keyword\">null</span> || getRegistries().isEmpty())</span><br><span class=\"line\">        &amp;&amp; (getProvider() == <span class=\"keyword\">null</span> || getProvider().getRegistries() == <span class=\"keyword\">null</span> || getProvider().getRegistries().isEmpty())</span><br><span class=\"line\">        &amp;&amp; (getApplication() == <span class=\"keyword\">null</span> || getApplication().getRegistries() == <span class=\"keyword\">null</span> || getApplication().getRegistries().isEmpty())) &#123;</span><br><span class=\"line\">        Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registryConfigMap != <span class=\"keyword\">null</span> &amp;&amp; registryConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            List&lt;RegistryConfig&gt; registryConfigs = <span class=\"keyword\">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (RegistryConfig config : registryConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault()) &#123;</span><br><span class=\"line\">                    registryConfigs.add(config);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!registryConfigs.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.setRegistries(registryConfigs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置监控中心</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getMonitor() == <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; (getProvider() == <span class=\"keyword\">null</span> || getProvider().getMonitor() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        &amp;&amp; (getApplication() == <span class=\"keyword\">null</span> || getApplication().getMonitor() == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">        Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (monitorConfigMap != <span class=\"keyword\">null</span> &amp;&amp; monitorConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            MonitorConfig monitorConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (MonitorConfig config : monitorConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (monitorConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate monitor configs: \"</span> + monitorConfig + <span class=\"string\">\" and \"</span> + config);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    monitorConfig = config;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (monitorConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                setMonitor(monitorConfig);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//服务协议，可以有多个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((getProtocols() == <span class=\"keyword\">null</span> || getProtocols().isEmpty())</span><br><span class=\"line\">        &amp;&amp; (getProvider() == <span class=\"keyword\">null</span> || getProvider().getProtocols() == <span class=\"keyword\">null</span> || getProvider().getProtocols().isEmpty())) &#123;</span><br><span class=\"line\">        Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (protocolConfigMap != <span class=\"keyword\">null</span> &amp;&amp; protocolConfigMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            List&lt;ProtocolConfig&gt; protocolConfigs = <span class=\"keyword\">new</span> ArrayList&lt;ProtocolConfig&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ProtocolConfig config : protocolConfigMap.values()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (config.isDefault() == <span class=\"keyword\">null</span> || config.isDefault()) &#123;</span><br><span class=\"line\">                    protocolConfigs.add(config);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!protocolConfigs.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.setProtocols(protocolConfigs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置服务路径（类全名）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getPath() == <span class=\"keyword\">null</span> || getPath().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (beanName != <span class=\"keyword\">null</span> &amp;&amp; beanName.length() &gt; <span class=\"number\">0</span></span><br><span class=\"line\">            &amp;&amp; getInterface() != <span class=\"keyword\">null</span> &amp;&amp; getInterface().length() &gt; <span class=\"number\">0</span></span><br><span class=\"line\">            &amp;&amp; beanName.startsWith(getInterface())) &#123;</span><br><span class=\"line\">            setPath(beanName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//是否延迟暴露</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isDelay()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//暴露服务</span></span><br><span class=\"line\">        export();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"AnnotationBean类\"><a href=\"#AnnotationBean类\" class=\"headerlink\" title=\"AnnotationBean类\"></a>AnnotationBean类</h4><p>这个类使得dubbo具有自动包扫描功能支持dubbo通过注解配置service和Reference bean（有些属性不能注解配置），病完成ServiceBean和ReferenceBean相同的功能，类图如下：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/AnnotationBean.png?raw=true\" alt=\"\"></p>\n<p>可以看到AnnotationBean类实现了接口DisposableBean、BeanFactoryPostProcessor、BeanPostProcessor、ApplicationContextAware，同样用过Spring接口方法回调，实现Bean实例的初始化预处理。</p>\n<p>AnnotationBean类是基于ClassPathBeanDefinationScanner类实现的，看下<code>org.springframework.context.annotation.ClassPathBeanDefinationScanner</code>类官方解释<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ClassPathBeanDefinitionScanner.html\" target=\"_blank\" rel=\"noopener\">ClassPathBeanDefinationScanner</a>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A bean definition scanner that detects bean candidates on the classpath, registering corresponding bean definitions with a given registry (BeanFactory or ApplicationContext).</span><br><span class=\"line\">Candidate classes are detected through configurable type filters. The default filters include classes that are annotated with Spring&apos;s @Component, @Repository, @Service, or @Controller stereotype.</span><br><span class=\"line\"></span><br><span class=\"line\">Also supports Java EE 6&apos;s ManagedBean and JSR-330&apos;s Named annotations, if available.</span><br></pre></td></tr></table></figure>\n<p>大概意思就是，ClassPathBeanDefinitionScanner将会扫描classpath下的bean，并且向注册器注册（BeanFactory或者ApplicationContext）bean definition，通过配置的过滤器检测bean，默认会检测被@Component, @Repository, @Service, or @Controller注解的类。</p>\n<p>下面来分析AnnotationBean类的核心代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置扫描的包名，以逗号分隔包名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPackage</span><span class=\"params\">(String annotationPackage)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.annotationPackage = annotationPackage;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.annotationPackages = (annotationPackage == <span class=\"keyword\">null</span> || annotationPackage.length() == <span class=\"number\">0</span>) ? <span class=\"keyword\">null</span></span><br><span class=\"line\">        : Constants.COMMA_SPLIT_PATTERN.split(annotationPackage);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现Spring回调接口方法，传入容器引用</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.applicationContext = applicationContext;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现BeanFactoryPostProcessor接口，这个方法会在所有的bean definitions已加载，但是还没有实例化之前回调执行</span></span><br><span class=\"line\"><span class=\"comment\">//可以在Bean初始化之前定制化一些操作，这里做的是调用org.springframework.context.annotation.ClassPathBeanDefinitionScanner的scan方法</span></span><br><span class=\"line\"><span class=\"comment\">//扫描注册由Service(Dubbo定义)注解的Bean，都是用反射完成的</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postProcessBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (annotationPackage == <span class=\"keyword\">null</span> || annotationPackage.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (beanFactory <span class=\"keyword\">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// init scanner</span></span><br><span class=\"line\">            <span class=\"comment\">//利用反射构造ClassPathBeanDefinitionScanner实例，用的这个构造方法，</span></span><br><span class=\"line\">            <span class=\"comment\">// useDefaultFilters=true 默认扫描 spring 4种的注解</span></span><br><span class=\"line\">            <span class=\"comment\">// public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) &#123;</span></span><br><span class=\"line\">            <span class=\"comment\">//\t\tthis(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span></span><br><span class=\"line\">            <span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\">            Class&lt;?&gt; scannerClass = ReflectUtils.forName(<span class=\"string\">\"org.springframework.context.annotation.ClassPathBeanDefinitionScanner\"</span>);</span><br><span class=\"line\">            Object scanner = scannerClass.getConstructor(<span class=\"keyword\">new</span> Class&lt;?&gt;[]&#123;BeanDefinitionRegistry.class, <span class=\"keyword\">boolean</span>.class&#125;).newInstance((BeanDefinitionRegistry) beanFactory, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            <span class=\"comment\">// add filter</span></span><br><span class=\"line\">            <span class=\"comment\">//通过filter 添加新要扫描的注解，也是用的反射 这里是 AnnotationTypeFilte</span></span><br><span class=\"line\">            Class&lt;?&gt; filterClass = ReflectUtils.forName(<span class=\"string\">\"org.springframework.core.type.filter.AnnotationTypeFilter\"</span>);</span><br><span class=\"line\">            Object filter = filterClass.getConstructor(Class.class).newInstance(Service.class);</span><br><span class=\"line\">            <span class=\"comment\">//获取添加filter的方法，并调用</span></span><br><span class=\"line\">            Method addIncludeFilter = scannerClass.getMethod(<span class=\"string\">\"addIncludeFilter\"</span>, ReflectUtils.forName(<span class=\"string\">\"org.springframework.core.type.filter.TypeFilter\"</span>));</span><br><span class=\"line\">            addIncludeFilter.invoke(scanner, filter);</span><br><span class=\"line\">            <span class=\"comment\">// scan packages</span></span><br><span class=\"line\">            <span class=\"comment\">//获取ClassPathBeanDefinitionScanner的scan()方法，开始扫描</span></span><br><span class=\"line\">            String[] packages = Constants.COMMA_SPLIT_PATTERN.split(annotationPackage);</span><br><span class=\"line\">            Method scan = scannerClass.getMethod(<span class=\"string\">\"scan\"</span>, String[].class);</span><br><span class=\"line\">            scan.invoke(scanner, <span class=\"keyword\">new</span> Object[]&#123;packages&#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// spring 2.0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现DisposableBean接口，在bean析构时，调用相关方法，释放资源</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  This will only be called for singleton scope bean, and expected to be called by spring shutdown hook when BeanFactory/ApplicationContext destroys.</span></span><br><span class=\"line\">    <span class=\"comment\">//  We will guarantee dubbo related resources being released with dubbo shutdown hook.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  for (ServiceConfig&lt;?&gt; serviceConfig : serviceConfigs) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//      try &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//          serviceConfig.unexport();</span></span><br><span class=\"line\">    <span class=\"comment\">//      &#125; catch (Throwable e) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//          logger.error(e.getMessage(), e);</span></span><br><span class=\"line\">    <span class=\"comment\">//      &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//  &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ReferenceConfig&lt;?&gt; referenceConfig : referenceConfigs.values()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            referenceConfig.destroy();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            logger.error(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现BeanPostProcessor接口方法，在Bean初始化之后，比如在afterPropertiesSet后由Spring回调执行</span></span><br><span class=\"line\"><span class=\"comment\">//这个方法完成类似ServiceBean的工作</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessAfterInitialization</span><span class=\"params\">(Object bean, String beanName)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//检查是否匹配包名</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isMatchPackage(bean)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//手动创建ServiceBean并暴露服务</span></span><br><span class=\"line\">    Service service = bean.getClass().getAnnotation(Service.class);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (service != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ServiceBean&lt;Object&gt; serviceConfig = <span class=\"keyword\">new</span> ServiceBean&lt;Object&gt;(service);</span><br><span class=\"line\">        serviceConfig.setRef(bean);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">void</span>.class.equals(service.interfaceClass())</span><br><span class=\"line\">            &amp;&amp; <span class=\"string\">\"\"</span>.equals(service.interfaceName())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bean.getClass().getInterfaces().length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setInterface(bean.getClass().getInterfaces()[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Failed to export remote service class \"</span> + bean.getClass().getName() + <span class=\"string\">\", cause: The @Service undefined interfaceClass or interfaceName, and the service class unimplemented any interfaces.\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (applicationContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            serviceConfig.setApplicationContext(applicationContext);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.registry().length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                List&lt;RegistryConfig&gt; registryConfigs = <span class=\"keyword\">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (String registryId : service.registry()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (registryId != <span class=\"keyword\">null</span> &amp;&amp; registryId.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        registryConfigs.add(applicationContext.getBean(registryId, RegistryConfig.class));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                serviceConfig.setRegistries(registryConfigs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.provider().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setProvider(applicationContext.getBean(service.provider(), ProviderConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.monitor().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setMonitor(applicationContext.getBean(service.monitor(), MonitorConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.application().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setApplication(applicationContext.getBean(service.application(), ApplicationConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.<span class=\"keyword\">module</span>().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setModule(applicationContext.getBean(service.<span class=\"keyword\">module</span>(), ModuleConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.provider().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setProvider(applicationContext.getBean(service.provider(), ProviderConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.protocol().length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                List&lt;ProtocolConfig&gt; protocolConfigs = <span class=\"keyword\">new</span> ArrayList&lt;ProtocolConfig&gt;();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (String protocolId : service.protocol()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (protocolId != <span class=\"keyword\">null</span> &amp;&amp; protocolId.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        protocolConfigs.add(applicationContext.getBean(protocolId, ProtocolConfig.class));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                serviceConfig.setProtocols(protocolConfigs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service.tag().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                serviceConfig.setTag(service.tag());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                serviceConfig.afterPropertiesSet();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        serviceConfigs.add(serviceConfig);</span><br><span class=\"line\">        serviceConfig.export();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现BeanPostProcessor接口方法，在Bean初始化前，比如在afterPropertiesSet前，由Spring回调执行</span></span><br><span class=\"line\"><span class=\"comment\">//这个方法完成类似ReferenceBean的工作</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">postProcessBeforeInitialization</span><span class=\"params\">(Object bean, String beanName)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isMatchPackage(bean)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//因为Dubbo Reference注解只能在类的字段或者方法上</span></span><br><span class=\"line\">    <span class=\"comment\">//通过Bean的set方法上找dubbo注解</span></span><br><span class=\"line\">    Method[] methods = bean.getClass().getMethods();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Method method : methods) &#123;</span><br><span class=\"line\">        String name = method.getName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name.length() &gt; <span class=\"number\">3</span> &amp;&amp; name.startsWith(<span class=\"string\">\"set\"</span>)</span><br><span class=\"line\">            &amp;&amp; method.getParameterTypes().length == <span class=\"number\">1</span></span><br><span class=\"line\">            &amp;&amp; Modifier.isPublic(method.getModifiers())</span><br><span class=\"line\">            &amp;&amp; !Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Reference reference = method.getAnnotation(Reference.class);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (reference != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    Object value = refer(reference, method.getParameterTypes()[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        method.invoke(bean, value);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">\"Failed to init remote service reference at method \"</span> + name + <span class=\"string\">\" in class \"</span> + bean.getClass().getName() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//通过bean的字段上找dubbo注解</span></span><br><span class=\"line\">    Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Field field : fields) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!field.isAccessible()) &#123;</span><br><span class=\"line\">                field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Reference reference = field.getAnnotation(Reference.class);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                Object value = refer(reference, field.getType());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (value != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    field.set(bean, value);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"Failed to init remote service reference at filed \"</span> + field.getName() + <span class=\"string\">\" in class \"</span> + bean.getClass().getName() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bean;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//通过解析Reference注解里的值，去构造服务调用配置，最后调用创建代理的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">refer</span><span class=\"params\">(Reference reference, Class&lt;?&gt; referenceClass)</span> </span>&#123; <span class=\"comment\">//method.getParameterTypes()[0]</span></span><br><span class=\"line\">    String interfaceName;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"string\">\"\"</span>.equals(reference.interfaceName())) &#123;</span><br><span class=\"line\">        interfaceName = reference.interfaceName();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!<span class=\"keyword\">void</span>.class.equals(reference.interfaceClass())) &#123;</span><br><span class=\"line\">        interfaceName = reference.interfaceClass().getName();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (referenceClass.isInterface()) &#123;</span><br><span class=\"line\">        interfaceName = referenceClass.getName();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The @Reference undefined interfaceClass or interfaceName, and the property type \"</span> + referenceClass.getName() + <span class=\"string\">\" is not a interface.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String key = reference.group() + <span class=\"string\">\"/\"</span> + interfaceName + <span class=\"string\">\":\"</span> + reference.version();</span><br><span class=\"line\">    ReferenceBean&lt;?&gt; referenceConfig = referenceConfigs.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (referenceConfig == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        referenceConfig = <span class=\"keyword\">new</span> ReferenceBean&lt;Object&gt;(reference);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">void</span>.class.equals(reference.interfaceClass())</span><br><span class=\"line\">            &amp;&amp; <span class=\"string\">\"\"</span>.equals(reference.interfaceName())</span><br><span class=\"line\">            &amp;&amp; referenceClass.isInterface()) &#123;</span><br><span class=\"line\">            referenceConfig.setInterface(referenceClass);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (applicationContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            referenceConfig.setApplicationContext(applicationContext);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference.registry().length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                List&lt;RegistryConfig&gt; registryConfigs = <span class=\"keyword\">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (String registryId : reference.registry()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (registryId != <span class=\"keyword\">null</span> &amp;&amp; registryId.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        registryConfigs.add(applicationContext.getBean(registryId, RegistryConfig.class));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                referenceConfig.setRegistries(registryConfigs);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference.consumer().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                referenceConfig.setConsumer(applicationContext.getBean(reference.consumer(), ConsumerConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference.monitor().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                referenceConfig.setMonitor(applicationContext.getBean(reference.monitor(), MonitorConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference.application().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                referenceConfig.setApplication(applicationContext.getBean(reference.application(), ApplicationConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference.<span class=\"keyword\">module</span>().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                referenceConfig.setModule(applicationContext.getBean(reference.<span class=\"keyword\">module</span>(), ModuleConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (reference.consumer().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                referenceConfig.setConsumer(applicationContext.getBean(reference.consumer(), ConsumerConfig.class));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                referenceConfig.afterPropertiesSet();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        referenceConfigs.putIfAbsent(key, referenceConfig);</span><br><span class=\"line\">        referenceConfig = referenceConfigs.get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> referenceConfig.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMatchPackage</span><span class=\"params\">(Object bean)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (annotationPackages == <span class=\"keyword\">null</span> || annotationPackages.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String beanClassName = bean.getClass().getName();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String pkg : annotationPackages) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (beanClassName.startsWith(pkg)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Dubbo集群容错机制","date":"2018-09-18T07:34:45.000Z","_content":"\n在之前一篇文章[《Dubbo消费者调用过程源码分析》](https://shuaijunlan.github.io/2018/08/05/dubbo-consumer-calling-process-source-code-analysis/)讲到，在创建代理的时候会生成调用对象invoker，这个时候就会绑定集群策略，我们来看生成invoker的代码，在类`ReferenceConfig#createProxy(Map<String, String> map)`方法中：\n\n```java\n//直接在配置文件中配置url，实现直接通信（如果既配置了直连地址又配置了注册中心的地址，则自动忽略注册中心的地址）\nif (url != null && url.length() > 0) { // user specified URL, could be peer-to-peer address, or register center's address.\n    String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);\n    if (us != null && us.length > 0) {\n        for (String u : us) {\n            URL url = URL.valueOf(u);\n            if (url.getPath() == null || url.getPath().length() == 0) {\n                url = url.setPath(interfaceName);\n            }\n            if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n                urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n            } else {\n                urls.add(ClusterUtils.mergeUrl(url, map));\n            }\n        }\n    }\n} else { // assemble URL from register center's configuration\n    //获取配置注册中心的url（可以有多个注册中心的url）\n    List<URL> us = loadRegistries(false);\n    if (us != null && !us.isEmpty()) {\n        for (URL u : us) {\n            URL monitorUrl = loadMonitor(u);\n            if (monitorUrl != null) {\n                map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\n            }\n            urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n        }\n    }\n    //如果urls为空，则抛出异常\n    if (urls.isEmpty()) {\n        throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\n    }\n}\n//当urls的长度为一时，可能为服务的直连地址也可能为注册中心的地址\nif (urls.size() == 1) {\n    invoker = refprotocol.refer(interfaceClass, urls.get(0));\n} else {//有多个直连地址，或者多个注册中心的地址\n    List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();\n    URL registryURL = null;\n    for (URL url : urls) {\n        //获取每个url对应的invoker\n        invokers.add(refprotocol.refer(interfaceClass, url));\n        if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n            //获取最后一个注册中心的地址\n            registryURL = url; // use last registry url\n        }\n    }\n    if (registryURL != null) { // registry url is available\n        // use AvailableCluster only when register's cluster is available\n        //当有注册中心的地址时，第一层使用AvailableCluster集群策略，第二层使用默认的集群策略\n        URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n        invoker = cluster.join(new StaticDirectory(u, invokers));\n    } else { // not a registry url\n        //如果没有注册中心地址，则使用默认的集群策略\n        invoker = cluster.join(new StaticDirectory(invokers));\n    }\n}\n```\n\n我们总结出三种生成集群策略的入口，**当urls的长度为1时，此时该url可能为注册中心的地址也可能是服务的直连地址，则进一步执行`invoker = refprotocol.refer(interfaceClass, urls.get(0));`；当urls的长度不为1时，此时可能为多个注册中心的地址或者多个服务直连地址，当为多个注册中心的地址时，会执行：**\n\n```java\nURL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\ninvoker = cluster.join(new StaticDirectory(u, invokers));\n```\n\n**当为多个直连地址时，则执行：`invoker = cluster.join(new StaticDirectory(invokers));`**，下面将对这三种方式进行详细的分析。\n\n<!-- more -->\n\nDubbo中提供了七种集群模式（FailoverCluster、FailfastCluster、FailsafeCluster、FailbackCluster、ForkingCluster、BroadcastCluster、AvailableCluster），来看一下它们的继承关系图：\n\n![Screenshot from 2018-09-18 11-16-13](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Cluster.png?raw=true)\n\n下面将分别对每一种集群模式进行分析。\n\n#### FailoverCluster\n\n```java\n@Override\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    List<Invoker<T>> copyinvokers = invokers;\n    checkInvokers(copyinvokers, invocation);//??\n    String methodName = RpcUtils.getMethodName(invocation);\n    //获取重试次数\n    int len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;\n    if (len <= 0) {\n        len = 1;\n    }\n    // retry loop.\n    RpcException le = null; // last exception.\n    //存放被调用过的invoker\n    List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyinvokers.size()); // invoked invokers.\n    Set<String> providers = new HashSet<String>(len);\n    for (int i = 0; i < len; i++) {\n        //Reselect before retry to avoid a change of candidate `invokers`.\n        //NOTE: if `invokers` changed, then `invoked` also lose accuracy.\n        if (i > 0) {\n            checkWhetherDestroyed();\n            copyinvokers = list(invocation);\n            // check again\n            checkInvokers(copyinvokers, invocation);\n        }\n        //根据负载均衡策略选择一个invoker\n        Invoker<T> invoker = select(loadbalance, invocation, copyinvokers, invoked);\n        invoked.add(invoker);\n        RpcContext.getContext().setInvokers((List) invoked);\n        try {\n            //调用invoke\n            Result result = invoker.invoke(invocation);\n            if (le != null && logger.isWarnEnabled()) {\n                logger.warn(\"Although retry the method \" + methodName\n                            + \" in the service \" + getInterface().getName()\n                            + \" was successful by the provider \" + invoker.getUrl().getAddress()\n                            + \", but there have been failed providers \" + providers\n                            + \" (\" + providers.size() + \"/\" + copyinvokers.size()\n                            + \") from the registry \" + directory.getUrl().getAddress()\n                            + \" on the consumer \" + NetUtils.getLocalHost()\n                            + \" using the dubbo version \" + Version.getVersion() + \". Last error is: \"\n                            + le.getMessage(), le);\n            }\n            return result;\n        } catch (RpcException e) {\n            //捕获到远程调用异常，则直接抛出异常\n            if (e.isBiz()) { // biz exception.\n                throw e;\n            }\n            le = e;\n        } catch (Throwable e) {\n            le = new RpcException(e.getMessage(), e);\n        } finally {\n            providers.add(invoker.getUrl().getAddress());\n        }\n    }\n    throw new RpcException(le.getCode(), \"Failed to invoke the method \"\n                           + methodName + \" in the service \" + getInterface().getName()\n                           + \". Tried \" + len + \" times of the providers \" + providers\n                           + \" (\" + providers.size() + \"/\" + copyinvokers.size()\n                           + \") from the registry \" + directory.getUrl().getAddress()\n                           + \" on the consumer \" + NetUtils.getLocalHost() + \" using the dubbo version \"\n                           + Version.getVersion() + \". Last error is: \"\n                           + le.getMessage(), le.getCause() != null ? le.getCause() : le);\n}\n```\n\nFailover集群容错机制，总的逻辑是，以方法重复次数为限制，每次调用如果失败，\n就利用负责均衡策略获取下一个提供者（invoker）,直到调用成功，或者最后方法超限，抛出异常，\n其中中间如果有业务异常，则不再重试，直接抛出异常。\n\n#### FailfastCluster\n\n```java\n@Override\npublic Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    checkInvokers(invokers, invocation);\n    //通过负载均衡策略选择一个invoker\n    Invoker<T> invoker = select(loadbalance, invocation, invokers, null);\n    try {\n        //只执行一次调用\n        return invoker.invoke(invocation);\n    } catch (Throwable e) {\n        if (e instanceof RpcException && ((RpcException) e).isBiz()) { // biz exception.\n            throw (RpcException) e;\n        }\n        throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0,\n                               \"Failfast invoke providers \" + invoker.getUrl() + \" \" + loadbalance.getClass().getSimpleName()\n                               + \" select from all providers \" + invokers + \" for service \" + getInterface().getName()\n                               + \" method \" + invocation.getMethodName() + \" on consumer \" + NetUtils.getLocalHost()\n                               + \" use dubbo version \" + Version.getVersion()\n                               + \", but no luck to perform the invocation. Last error is: \" + e.getMessage(),\n                               e.getCause() != null ? e.getCause() : e);\n    }\n}\n```\n\n 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n\n#### FailsafeCluster\n\n```java\n@Override\npublic Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    try {\n        checkInvokers(invokers, invocation);\n        //通过负载均衡策略选择一个invoker\n        Invoker<T> invoker = select(loadbalance, invocation, invokers, null);\n        //只执行一次调用\n        return invoker.invoke(invocation);\n    } catch (Throwable e) {\n        logger.error(\"Failsafe ignore exception: \" + e.getMessage(), e);\n        //遇到异常则返回一个RpcResult\n        return new RpcResult(); // ignore\n    }\n}\n```\n\n失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n\n#### FailbackCluster\n\n```java\nprivate void addFailed(Invocation invocation, AbstractClusterInvoker<?> router) {\n    if (retryFuture == null) {\n        synchronized (this) {\n            if (retryFuture == null) {\n                //调度线程池，周期性（5秒一次）的调用retryFailed方法\n                retryFuture = scheduledExecutorService.scheduleWithFixedDelay(new Runnable() {\n\n                    @Override\n                    public void run() {\n                        // collect retry statistics\n                        try {\n                            //执行之前异常方法的调用\n                            retryFailed();\n                        } catch (Throwable t) { // Defensive fault tolerance\n                            logger.error(\"Unexpected error occur at collect statistic\", t);\n                        }\n                    }\n                }, RETRY_FAILED_PERIOD, RETRY_FAILED_PERIOD, TimeUnit.MILLISECONDS);\n            }\n        }\n    }\n    //放入map\n    failed.put(invocation, router);\n}\n\nvoid retryFailed() {\n    if (failed.size() == 0) {\n        return;\n    }\n    //遍历所有的失败执行\n    for (Map.Entry<Invocation, AbstractClusterInvoker<?>> entry : new HashMap<>(failed).entrySet()) {\n        Invocation invocation = entry.getKey();\n        Invoker<?> invoker = entry.getValue();\n        try {\n            //发起调用\n            invoker.invoke(invocation);\n            //调用成功则从failed中删除\n            failed.remove(invocation);\n        } catch (Throwable e) {\n            logger.error(\"Failed retry to invoke method \" + invocation.getMethodName() + \", waiting again.\", e);\n        }\n    }\n}\n\n@Override\nprotected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    try {\n        checkInvokers(invokers, invocation);\n        //通过负载均衡策略选择一个invoker\n        Invoker<T> invoker = select(loadbalance, invocation, invokers, null);\n        return invoker.invoke(invocation);\n    } catch (Throwable e) {\n        //失败后，记录日志，不抛出异常\n        logger.error(\"Failback to invoke method \" + invocation.getMethodName() + \", wait for retry in background. Ignored exception: \"\n                     + e.getMessage() + \", \", e);\n        //记录异常信息，key为调用的方法信息，value为invoker本身\n        addFailed(invocation, this);\n        return new RpcResult(); // ignore\n    }\n}\n```\n\n 此策略失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n\n#### ForkingCluster\n\n```java\n@Override\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    try {\n        checkInvokers(invokers, invocation);\n        final List<Invoker<T>> selected;\n        //获取并行调用的个数\n        final int forks = getUrl().getParameter(Constants.FORKS_KEY, Constants.DEFAULT_FORKS);\n        //超时时间\n        final int timeout = getUrl().getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n        if (forks <= 0 || forks >= invokers.size()) {\n            selected = invokers;\n        } else {\n            selected = new ArrayList<>();\n            //通过负载均衡策略，选出要并行调用的invoker，放入selected列表中\n            for (int i = 0; i < forks; i++) {\n                // TODO. Add some comment here, refer chinese version for more details.\n                Invoker<T> invoker = select(loadbalance, invocation, invokers, selected);\n                if (!selected.contains(invoker)) {//防止重复添加\n                    //Avoid add the same invoker several times.\n                    selected.add(invoker);\n                }\n            }\n        }\n        RpcContext.getContext().setInvokers((List) selected);\n        final AtomicInteger count = new AtomicInteger();\n        final BlockingQueue<Object> ref = new LinkedBlockingQueue<>();\n        //遍历selected列表，通过线程池并发调用\n        for (final Invoker<T> invoker : selected) {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Result result = invoker.invoke(invocation);\n                        //把结果放入阻塞队列\n                        ref.offer(result);\n                    } catch (Throwable e) {\n                        int value = count.incrementAndGet();\n                        //表示所有并发调用都抛出异常，才把异常加入阻塞队列尾部\n                        //这就保证了，只要有一个调用成功，ref.poll()方法就能从队列头部取到返回结果  \n                        if (value >= selected.size()) {\n                            ref.offer(e);\n                        }\n                    }\n                }\n            });\n        }\n        try {\n            //设定阻塞时间，从阻塞队列头部获取返回结果，如果是异常则抛出异常\n            Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);\n            if (ret instanceof Throwable) {\n                Throwable e = (Throwable) ret;\n                throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0, \"Failed to forking invoke provider \" + selected + \", but no luck to perform the invocation. Last error is: \" + e.getMessage(), e.getCause() != null ? e.getCause() : e);\n            }\n            return (Result) ret;\n        } catch (InterruptedException e) {\n            throw new RpcException(\"Failed to forking invoke provider \" + selected + \", but no luck to perform the invocation. Last error is: \" + e.getMessage(), e);\n        }\n    } finally {\n        // clear attachments which is binding to current thread.\n        RpcContext.getContext().clearAttachments();\n    }\n}\n```\n\n并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。\n\n#### BroadcastCluster\n\n```java\n@Override\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    checkInvokers(invokers, invocation);\n    RpcContext.getContext().setInvokers((List) invokers);\n    RpcException exception = null;\n    Result result = null;\n    //遍历调用所有的服务列表，并把结果覆盖以前的\n    for (Invoker<T> invoker : invokers) {\n        try {\n            result = invoker.invoke(invocation);\n        } catch (RpcException e) {\n            exception = e;\n            logger.warn(e.getMessage(), e);\n        } catch (Throwable e) {\n            exception = new RpcException(e.getMessage(), e);\n            logger.warn(e.getMessage(), e);\n        }\n    }\n    //其中有一个失败，则直接抛异常\n    if (exception != null) {\n        throw exception;\n    }\n    return result;\n}\n```\n\n这个策略通常用于通知所有提供者更新缓存或日志等本地资源信息。\n\n#### AvailableCluster\n\nAvailable集群容错机制，主要逻辑是，简单的调用第一个可到达的服务，如果都不可达，则抛出异常：\n\n```java\n@Override\npublic <T> Invoker<T> join(Directory<T> directory) throws RpcException {\n\t//没有通过继承AbstractClusterInvoker抽象类，而是直接实现它，也没有使用负载均衡策略，而是简单的选择一个可达的服务\n    return new AbstractClusterInvoker<T>(directory) {\n        @Override\n        public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n            for (Invoker<T> invoker : invokers) {\n                if (invoker.isAvailable()) {//获取第一个可达的服务提供方\n                    return invoker.invoke(invocation);\n                }\n            }\n            throw new RpcException(\"No provider available in \" + invokers);\n        }\n    };\n\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/dubbo-cluster-fault-tolerance.md","raw":"---\ntitle: Dubbo集群容错机制\ndate: 2018-09-18 15:34:45\ntags:\n    - dubbo\n---\n\n在之前一篇文章[《Dubbo消费者调用过程源码分析》](https://shuaijunlan.github.io/2018/08/05/dubbo-consumer-calling-process-source-code-analysis/)讲到，在创建代理的时候会生成调用对象invoker，这个时候就会绑定集群策略，我们来看生成invoker的代码，在类`ReferenceConfig#createProxy(Map<String, String> map)`方法中：\n\n```java\n//直接在配置文件中配置url，实现直接通信（如果既配置了直连地址又配置了注册中心的地址，则自动忽略注册中心的地址）\nif (url != null && url.length() > 0) { // user specified URL, could be peer-to-peer address, or register center's address.\n    String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);\n    if (us != null && us.length > 0) {\n        for (String u : us) {\n            URL url = URL.valueOf(u);\n            if (url.getPath() == null || url.getPath().length() == 0) {\n                url = url.setPath(interfaceName);\n            }\n            if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n                urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n            } else {\n                urls.add(ClusterUtils.mergeUrl(url, map));\n            }\n        }\n    }\n} else { // assemble URL from register center's configuration\n    //获取配置注册中心的url（可以有多个注册中心的url）\n    List<URL> us = loadRegistries(false);\n    if (us != null && !us.isEmpty()) {\n        for (URL u : us) {\n            URL monitorUrl = loadMonitor(u);\n            if (monitorUrl != null) {\n                map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\n            }\n            urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n        }\n    }\n    //如果urls为空，则抛出异常\n    if (urls.isEmpty()) {\n        throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\n    }\n}\n//当urls的长度为一时，可能为服务的直连地址也可能为注册中心的地址\nif (urls.size() == 1) {\n    invoker = refprotocol.refer(interfaceClass, urls.get(0));\n} else {//有多个直连地址，或者多个注册中心的地址\n    List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();\n    URL registryURL = null;\n    for (URL url : urls) {\n        //获取每个url对应的invoker\n        invokers.add(refprotocol.refer(interfaceClass, url));\n        if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n            //获取最后一个注册中心的地址\n            registryURL = url; // use last registry url\n        }\n    }\n    if (registryURL != null) { // registry url is available\n        // use AvailableCluster only when register's cluster is available\n        //当有注册中心的地址时，第一层使用AvailableCluster集群策略，第二层使用默认的集群策略\n        URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n        invoker = cluster.join(new StaticDirectory(u, invokers));\n    } else { // not a registry url\n        //如果没有注册中心地址，则使用默认的集群策略\n        invoker = cluster.join(new StaticDirectory(invokers));\n    }\n}\n```\n\n我们总结出三种生成集群策略的入口，**当urls的长度为1时，此时该url可能为注册中心的地址也可能是服务的直连地址，则进一步执行`invoker = refprotocol.refer(interfaceClass, urls.get(0));`；当urls的长度不为1时，此时可能为多个注册中心的地址或者多个服务直连地址，当为多个注册中心的地址时，会执行：**\n\n```java\nURL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\ninvoker = cluster.join(new StaticDirectory(u, invokers));\n```\n\n**当为多个直连地址时，则执行：`invoker = cluster.join(new StaticDirectory(invokers));`**，下面将对这三种方式进行详细的分析。\n\n<!-- more -->\n\nDubbo中提供了七种集群模式（FailoverCluster、FailfastCluster、FailsafeCluster、FailbackCluster、ForkingCluster、BroadcastCluster、AvailableCluster），来看一下它们的继承关系图：\n\n![Screenshot from 2018-09-18 11-16-13](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Cluster.png?raw=true)\n\n下面将分别对每一种集群模式进行分析。\n\n#### FailoverCluster\n\n```java\n@Override\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    List<Invoker<T>> copyinvokers = invokers;\n    checkInvokers(copyinvokers, invocation);//??\n    String methodName = RpcUtils.getMethodName(invocation);\n    //获取重试次数\n    int len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;\n    if (len <= 0) {\n        len = 1;\n    }\n    // retry loop.\n    RpcException le = null; // last exception.\n    //存放被调用过的invoker\n    List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyinvokers.size()); // invoked invokers.\n    Set<String> providers = new HashSet<String>(len);\n    for (int i = 0; i < len; i++) {\n        //Reselect before retry to avoid a change of candidate `invokers`.\n        //NOTE: if `invokers` changed, then `invoked` also lose accuracy.\n        if (i > 0) {\n            checkWhetherDestroyed();\n            copyinvokers = list(invocation);\n            // check again\n            checkInvokers(copyinvokers, invocation);\n        }\n        //根据负载均衡策略选择一个invoker\n        Invoker<T> invoker = select(loadbalance, invocation, copyinvokers, invoked);\n        invoked.add(invoker);\n        RpcContext.getContext().setInvokers((List) invoked);\n        try {\n            //调用invoke\n            Result result = invoker.invoke(invocation);\n            if (le != null && logger.isWarnEnabled()) {\n                logger.warn(\"Although retry the method \" + methodName\n                            + \" in the service \" + getInterface().getName()\n                            + \" was successful by the provider \" + invoker.getUrl().getAddress()\n                            + \", but there have been failed providers \" + providers\n                            + \" (\" + providers.size() + \"/\" + copyinvokers.size()\n                            + \") from the registry \" + directory.getUrl().getAddress()\n                            + \" on the consumer \" + NetUtils.getLocalHost()\n                            + \" using the dubbo version \" + Version.getVersion() + \". Last error is: \"\n                            + le.getMessage(), le);\n            }\n            return result;\n        } catch (RpcException e) {\n            //捕获到远程调用异常，则直接抛出异常\n            if (e.isBiz()) { // biz exception.\n                throw e;\n            }\n            le = e;\n        } catch (Throwable e) {\n            le = new RpcException(e.getMessage(), e);\n        } finally {\n            providers.add(invoker.getUrl().getAddress());\n        }\n    }\n    throw new RpcException(le.getCode(), \"Failed to invoke the method \"\n                           + methodName + \" in the service \" + getInterface().getName()\n                           + \". Tried \" + len + \" times of the providers \" + providers\n                           + \" (\" + providers.size() + \"/\" + copyinvokers.size()\n                           + \") from the registry \" + directory.getUrl().getAddress()\n                           + \" on the consumer \" + NetUtils.getLocalHost() + \" using the dubbo version \"\n                           + Version.getVersion() + \". Last error is: \"\n                           + le.getMessage(), le.getCause() != null ? le.getCause() : le);\n}\n```\n\nFailover集群容错机制，总的逻辑是，以方法重复次数为限制，每次调用如果失败，\n就利用负责均衡策略获取下一个提供者（invoker）,直到调用成功，或者最后方法超限，抛出异常，\n其中中间如果有业务异常，则不再重试，直接抛出异常。\n\n#### FailfastCluster\n\n```java\n@Override\npublic Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    checkInvokers(invokers, invocation);\n    //通过负载均衡策略选择一个invoker\n    Invoker<T> invoker = select(loadbalance, invocation, invokers, null);\n    try {\n        //只执行一次调用\n        return invoker.invoke(invocation);\n    } catch (Throwable e) {\n        if (e instanceof RpcException && ((RpcException) e).isBiz()) { // biz exception.\n            throw (RpcException) e;\n        }\n        throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0,\n                               \"Failfast invoke providers \" + invoker.getUrl() + \" \" + loadbalance.getClass().getSimpleName()\n                               + \" select from all providers \" + invokers + \" for service \" + getInterface().getName()\n                               + \" method \" + invocation.getMethodName() + \" on consumer \" + NetUtils.getLocalHost()\n                               + \" use dubbo version \" + Version.getVersion()\n                               + \", but no luck to perform the invocation. Last error is: \" + e.getMessage(),\n                               e.getCause() != null ? e.getCause() : e);\n    }\n}\n```\n\n 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。\n\n#### FailsafeCluster\n\n```java\n@Override\npublic Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    try {\n        checkInvokers(invokers, invocation);\n        //通过负载均衡策略选择一个invoker\n        Invoker<T> invoker = select(loadbalance, invocation, invokers, null);\n        //只执行一次调用\n        return invoker.invoke(invocation);\n    } catch (Throwable e) {\n        logger.error(\"Failsafe ignore exception: \" + e.getMessage(), e);\n        //遇到异常则返回一个RpcResult\n        return new RpcResult(); // ignore\n    }\n}\n```\n\n失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。\n\n#### FailbackCluster\n\n```java\nprivate void addFailed(Invocation invocation, AbstractClusterInvoker<?> router) {\n    if (retryFuture == null) {\n        synchronized (this) {\n            if (retryFuture == null) {\n                //调度线程池，周期性（5秒一次）的调用retryFailed方法\n                retryFuture = scheduledExecutorService.scheduleWithFixedDelay(new Runnable() {\n\n                    @Override\n                    public void run() {\n                        // collect retry statistics\n                        try {\n                            //执行之前异常方法的调用\n                            retryFailed();\n                        } catch (Throwable t) { // Defensive fault tolerance\n                            logger.error(\"Unexpected error occur at collect statistic\", t);\n                        }\n                    }\n                }, RETRY_FAILED_PERIOD, RETRY_FAILED_PERIOD, TimeUnit.MILLISECONDS);\n            }\n        }\n    }\n    //放入map\n    failed.put(invocation, router);\n}\n\nvoid retryFailed() {\n    if (failed.size() == 0) {\n        return;\n    }\n    //遍历所有的失败执行\n    for (Map.Entry<Invocation, AbstractClusterInvoker<?>> entry : new HashMap<>(failed).entrySet()) {\n        Invocation invocation = entry.getKey();\n        Invoker<?> invoker = entry.getValue();\n        try {\n            //发起调用\n            invoker.invoke(invocation);\n            //调用成功则从failed中删除\n            failed.remove(invocation);\n        } catch (Throwable e) {\n            logger.error(\"Failed retry to invoke method \" + invocation.getMethodName() + \", waiting again.\", e);\n        }\n    }\n}\n\n@Override\nprotected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    try {\n        checkInvokers(invokers, invocation);\n        //通过负载均衡策略选择一个invoker\n        Invoker<T> invoker = select(loadbalance, invocation, invokers, null);\n        return invoker.invoke(invocation);\n    } catch (Throwable e) {\n        //失败后，记录日志，不抛出异常\n        logger.error(\"Failback to invoke method \" + invocation.getMethodName() + \", wait for retry in background. Ignored exception: \"\n                     + e.getMessage() + \", \", e);\n        //记录异常信息，key为调用的方法信息，value为invoker本身\n        addFailed(invocation, this);\n        return new RpcResult(); // ignore\n    }\n}\n```\n\n 此策略失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。\n\n#### ForkingCluster\n\n```java\n@Override\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    try {\n        checkInvokers(invokers, invocation);\n        final List<Invoker<T>> selected;\n        //获取并行调用的个数\n        final int forks = getUrl().getParameter(Constants.FORKS_KEY, Constants.DEFAULT_FORKS);\n        //超时时间\n        final int timeout = getUrl().getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n        if (forks <= 0 || forks >= invokers.size()) {\n            selected = invokers;\n        } else {\n            selected = new ArrayList<>();\n            //通过负载均衡策略，选出要并行调用的invoker，放入selected列表中\n            for (int i = 0; i < forks; i++) {\n                // TODO. Add some comment here, refer chinese version for more details.\n                Invoker<T> invoker = select(loadbalance, invocation, invokers, selected);\n                if (!selected.contains(invoker)) {//防止重复添加\n                    //Avoid add the same invoker several times.\n                    selected.add(invoker);\n                }\n            }\n        }\n        RpcContext.getContext().setInvokers((List) selected);\n        final AtomicInteger count = new AtomicInteger();\n        final BlockingQueue<Object> ref = new LinkedBlockingQueue<>();\n        //遍历selected列表，通过线程池并发调用\n        for (final Invoker<T> invoker : selected) {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        Result result = invoker.invoke(invocation);\n                        //把结果放入阻塞队列\n                        ref.offer(result);\n                    } catch (Throwable e) {\n                        int value = count.incrementAndGet();\n                        //表示所有并发调用都抛出异常，才把异常加入阻塞队列尾部\n                        //这就保证了，只要有一个调用成功，ref.poll()方法就能从队列头部取到返回结果  \n                        if (value >= selected.size()) {\n                            ref.offer(e);\n                        }\n                    }\n                }\n            });\n        }\n        try {\n            //设定阻塞时间，从阻塞队列头部获取返回结果，如果是异常则抛出异常\n            Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);\n            if (ret instanceof Throwable) {\n                Throwable e = (Throwable) ret;\n                throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0, \"Failed to forking invoke provider \" + selected + \", but no luck to perform the invocation. Last error is: \" + e.getMessage(), e.getCause() != null ? e.getCause() : e);\n            }\n            return (Result) ret;\n        } catch (InterruptedException e) {\n            throw new RpcException(\"Failed to forking invoke provider \" + selected + \", but no luck to perform the invocation. Last error is: \" + e.getMessage(), e);\n        }\n    } finally {\n        // clear attachments which is binding to current thread.\n        RpcContext.getContext().clearAttachments();\n    }\n}\n```\n\n并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=\"2\" 来设置最大并行数。\n\n#### BroadcastCluster\n\n```java\n@Override\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    checkInvokers(invokers, invocation);\n    RpcContext.getContext().setInvokers((List) invokers);\n    RpcException exception = null;\n    Result result = null;\n    //遍历调用所有的服务列表，并把结果覆盖以前的\n    for (Invoker<T> invoker : invokers) {\n        try {\n            result = invoker.invoke(invocation);\n        } catch (RpcException e) {\n            exception = e;\n            logger.warn(e.getMessage(), e);\n        } catch (Throwable e) {\n            exception = new RpcException(e.getMessage(), e);\n            logger.warn(e.getMessage(), e);\n        }\n    }\n    //其中有一个失败，则直接抛异常\n    if (exception != null) {\n        throw exception;\n    }\n    return result;\n}\n```\n\n这个策略通常用于通知所有提供者更新缓存或日志等本地资源信息。\n\n#### AvailableCluster\n\nAvailable集群容错机制，主要逻辑是，简单的调用第一个可到达的服务，如果都不可达，则抛出异常：\n\n```java\n@Override\npublic <T> Invoker<T> join(Directory<T> directory) throws RpcException {\n\t//没有通过继承AbstractClusterInvoker抽象类，而是直接实现它，也没有使用负载均衡策略，而是简单的选择一个可达的服务\n    return new AbstractClusterInvoker<T>(directory) {\n        @Override\n        public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n            for (Invoker<T> invoker : invokers) {\n                if (invoker.isAvailable()) {//获取第一个可达的服务提供方\n                    return invoker.invoke(invocation);\n                }\n            }\n            throw new RpcException(\"No provider available in \" + invokers);\n        }\n    };\n\n}\n```\n\n\n\n\n\n\n\n","slug":"dubbo-cluster-fault-tolerance","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4t000wzjiap06t7nq9","content":"<p>在之前一篇文章<a href=\"https://shuaijunlan.github.io/2018/08/05/dubbo-consumer-calling-process-source-code-analysis/\">《Dubbo消费者调用过程源码分析》</a>讲到，在创建代理的时候会生成调用对象invoker，这个时候就会绑定集群策略，我们来看生成invoker的代码，在类<code>ReferenceConfig#createProxy(Map&lt;String, String&gt; map)</code>方法中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//直接在配置文件中配置url，实现直接通信（如果既配置了直连地址又配置了注册中心的地址，则自动忽略注册中心的地址）</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (url != <span class=\"keyword\">null</span> &amp;&amp; url.length() &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// user specified URL, could be peer-to-peer address, or register center's address.</span></span><br><span class=\"line\">    String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (us != <span class=\"keyword\">null</span> &amp;&amp; us.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String u : us) &#123;</span><br><span class=\"line\">            URL url = URL.valueOf(u);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (url.getPath() == <span class=\"keyword\">null</span> || url.getPath().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                url = url.setPath(interfaceName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">                urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// assemble URL from register center's configuration</span></span><br><span class=\"line\">    <span class=\"comment\">//获取配置注册中心的url（可以有多个注册中心的url）</span></span><br><span class=\"line\">    List&lt;URL&gt; us = loadRegistries(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (us != <span class=\"keyword\">null</span> &amp;&amp; !us.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (URL u : us) &#123;</span><br><span class=\"line\">            URL monitorUrl = loadMonitor(u);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (monitorUrl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果urls为空，则抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"No such any registry to reference \"</span> + interfaceName + <span class=\"string\">\" on the consumer \"</span> + NetUtils.getLocalHost() + <span class=\"string\">\" use dubbo version \"</span> + Version.getVersion() + <span class=\"string\">\", please config &lt;dubbo:registry address=\\\"...\\\" /&gt; to your spring config.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//当urls的长度为一时，可能为服务的直连地址也可能为注册中心的地址</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (urls.size() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    invoker = refprotocol.refer(interfaceClass, urls.get(<span class=\"number\">0</span>));</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//有多个直连地址，或者多个注册中心的地址</span></span><br><span class=\"line\">    List&lt;Invoker&lt;?&gt;&gt; invokers = <span class=\"keyword\">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class=\"line\">    URL registryURL = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (URL url : urls) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取每个url对应的invoker</span></span><br><span class=\"line\">        invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取最后一个注册中心的地址</span></span><br><span class=\"line\">            registryURL = url; <span class=\"comment\">// use last registry url</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (registryURL != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// registry url is available</span></span><br><span class=\"line\">        <span class=\"comment\">// use AvailableCluster only when register's cluster is available</span></span><br><span class=\"line\">        <span class=\"comment\">//当有注册中心的地址时，第一层使用AvailableCluster集群策略，第二层使用默认的集群策略</span></span><br><span class=\"line\">        URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);</span><br><span class=\"line\">        invoker = cluster.join(<span class=\"keyword\">new</span> StaticDirectory(u, invokers));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// not a registry url</span></span><br><span class=\"line\">        <span class=\"comment\">//如果没有注册中心地址，则使用默认的集群策略</span></span><br><span class=\"line\">        invoker = cluster.join(<span class=\"keyword\">new</span> StaticDirectory(invokers));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们总结出三种生成集群策略的入口，<strong>当urls的长度为1时，此时该url可能为注册中心的地址也可能是服务的直连地址，则进一步执行<code>invoker = refprotocol.refer(interfaceClass, urls.get(0));</code>；当urls的长度不为1时，此时可能为多个注册中心的地址或者多个服务直连地址，当为多个注册中心的地址时，会执行：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);</span><br><span class=\"line\">invoker = cluster.join(<span class=\"keyword\">new</span> StaticDirectory(u, invokers));</span><br></pre></td></tr></table></figure>\n<p><strong>当为多个直连地址时，则执行：<code>invoker = cluster.join(new StaticDirectory(invokers));</code></strong>，下面将对这三种方式进行详细的分析。</p>\n<a id=\"more\"></a>\n<p>Dubbo中提供了七种集群模式（FailoverCluster、FailfastCluster、FailsafeCluster、FailbackCluster、ForkingCluster、BroadcastCluster、AvailableCluster），来看一下它们的继承关系图：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Cluster.png?raw=true\" alt=\"Screenshot from 2018-09-18 11-16-13\"></p>\n<p>下面将分别对每一种集群模式进行分析。</p>\n<h4 id=\"FailoverCluster\"><a href=\"#FailoverCluster\" class=\"headerlink\" title=\"FailoverCluster\"></a>FailoverCluster</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation, <span class=\"keyword\">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers;</span><br><span class=\"line\">    checkInvokers(copyinvokers, invocation);<span class=\"comment\">//??</span></span><br><span class=\"line\">    String methodName = RpcUtils.getMethodName(invocation);</span><br><span class=\"line\">    <span class=\"comment\">//获取重试次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        len = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// retry loop.</span></span><br><span class=\"line\">    RpcException le = <span class=\"keyword\">null</span>; <span class=\"comment\">// last exception.</span></span><br><span class=\"line\">    <span class=\"comment\">//存放被调用过的invoker</span></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invoked = <span class=\"keyword\">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size()); <span class=\"comment\">// invoked invokers.</span></span><br><span class=\"line\">    Set&lt;String&gt; providers = <span class=\"keyword\">new</span> HashSet&lt;String&gt;(len);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Reselect before retry to avoid a change of candidate `invokers`.</span></span><br><span class=\"line\">        <span class=\"comment\">//<span class=\"doctag\">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            checkWhetherDestroyed();</span><br><span class=\"line\">            copyinvokers = list(invocation);</span><br><span class=\"line\">            <span class=\"comment\">// check again</span></span><br><span class=\"line\">            checkInvokers(copyinvokers, invocation);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//根据负载均衡策略选择一个invoker</span></span><br><span class=\"line\">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);</span><br><span class=\"line\">        invoked.add(invoker);</span><br><span class=\"line\">        RpcContext.getContext().setInvokers((List) invoked);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//调用invoke</span></span><br><span class=\"line\">            Result result = invoker.invoke(invocation);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (le != <span class=\"keyword\">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"Although retry the method \"</span> + methodName</span><br><span class=\"line\">                            + <span class=\"string\">\" in the service \"</span> + getInterface().getName()</span><br><span class=\"line\">                            + <span class=\"string\">\" was successful by the provider \"</span> + invoker.getUrl().getAddress()</span><br><span class=\"line\">                            + <span class=\"string\">\", but there have been failed providers \"</span> + providers</span><br><span class=\"line\">                            + <span class=\"string\">\" (\"</span> + providers.size() + <span class=\"string\">\"/\"</span> + copyinvokers.size()</span><br><span class=\"line\">                            + <span class=\"string\">\") from the registry \"</span> + directory.getUrl().getAddress()</span><br><span class=\"line\">                            + <span class=\"string\">\" on the consumer \"</span> + NetUtils.getLocalHost()</span><br><span class=\"line\">                            + <span class=\"string\">\" using the dubbo version \"</span> + Version.getVersion() + <span class=\"string\">\". Last error is: \"</span></span><br><span class=\"line\">                            + le.getMessage(), le);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RpcException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//捕获到远程调用异常，则直接抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.isBiz()) &#123; <span class=\"comment\">// biz exception.</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            le = e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            le = <span class=\"keyword\">new</span> RpcException(e.getMessage(), e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            providers.add(invoker.getUrl().getAddress());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(le.getCode(), <span class=\"string\">\"Failed to invoke the method \"</span></span><br><span class=\"line\">                           + methodName + <span class=\"string\">\" in the service \"</span> + getInterface().getName()</span><br><span class=\"line\">                           + <span class=\"string\">\". Tried \"</span> + len + <span class=\"string\">\" times of the providers \"</span> + providers</span><br><span class=\"line\">                           + <span class=\"string\">\" (\"</span> + providers.size() + <span class=\"string\">\"/\"</span> + copyinvokers.size()</span><br><span class=\"line\">                           + <span class=\"string\">\") from the registry \"</span> + directory.getUrl().getAddress()</span><br><span class=\"line\">                           + <span class=\"string\">\" on the consumer \"</span> + NetUtils.getLocalHost() + <span class=\"string\">\" using the dubbo version \"</span></span><br><span class=\"line\">                           + Version.getVersion() + <span class=\"string\">\". Last error is: \"</span></span><br><span class=\"line\">                           + le.getMessage(), le.getCause() != <span class=\"keyword\">null</span> ? le.getCause() : le);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Failover集群容错机制，总的逻辑是，以方法重复次数为限制，每次调用如果失败，<br>就利用负责均衡策略获取下一个提供者（invoker）,直到调用成功，或者最后方法超限，抛出异常，<br>其中中间如果有业务异常，则不再重试，直接抛出异常。</p>\n<h4 id=\"FailfastCluster\"><a href=\"#FailfastCluster\" class=\"headerlink\" title=\"FailfastCluster\"></a>FailfastCluster</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    checkInvokers(invokers, invocation);</span><br><span class=\"line\">    <span class=\"comment\">//通过负载均衡策略选择一个invoker</span></span><br><span class=\"line\">    Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//只执行一次调用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoker.invoke(invocation);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> RpcException &amp;&amp; ((RpcException) e).isBiz()) &#123; <span class=\"comment\">// biz exception.</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> (RpcException) e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(e <span class=\"keyword\">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class=\"number\">0</span>,</span><br><span class=\"line\">                               <span class=\"string\">\"Failfast invoke providers \"</span> + invoker.getUrl() + <span class=\"string\">\" \"</span> + loadbalance.getClass().getSimpleName()</span><br><span class=\"line\">                               + <span class=\"string\">\" select from all providers \"</span> + invokers + <span class=\"string\">\" for service \"</span> + getInterface().getName()</span><br><span class=\"line\">                               + <span class=\"string\">\" method \"</span> + invocation.getMethodName() + <span class=\"string\">\" on consumer \"</span> + NetUtils.getLocalHost()</span><br><span class=\"line\">                               + <span class=\"string\">\" use dubbo version \"</span> + Version.getVersion()</span><br><span class=\"line\">                               + <span class=\"string\">\", but no luck to perform the invocation. Last error is: \"</span> + e.getMessage(),</span><br><span class=\"line\">                               e.getCause() != <span class=\"keyword\">null</span> ? e.getCause() : e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>\n<h4 id=\"FailsafeCluster\"><a href=\"#FailsafeCluster\" class=\"headerlink\" title=\"FailsafeCluster\"></a>FailsafeCluster</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkInvokers(invokers, invocation);</span><br><span class=\"line\">        <span class=\"comment\">//通过负载均衡策略选择一个invoker</span></span><br><span class=\"line\">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//只执行一次调用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoker.invoke(invocation);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        logger.error(<span class=\"string\">\"Failsafe ignore exception: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"comment\">//遇到异常则返回一个RpcResult</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult(); <span class=\"comment\">// ignore</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>\n<h4 id=\"FailbackCluster\"><a href=\"#FailbackCluster\" class=\"headerlink\" title=\"FailbackCluster\"></a>FailbackCluster</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addFailed</span><span class=\"params\">(Invocation invocation, AbstractClusterInvoker&lt;?&gt; router)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retryFuture == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (retryFuture == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//调度线程池，周期性（5秒一次）的调用retryFailed方法</span></span><br><span class=\"line\">                retryFuture = scheduledExecutorService.scheduleWithFixedDelay(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// collect retry statistics</span></span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//执行之前异常方法的调用</span></span><br><span class=\"line\">                            retryFailed();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123; <span class=\"comment\">// Defensive fault tolerance</span></span><br><span class=\"line\">                            logger.error(<span class=\"string\">\"Unexpected error occur at collect statistic\"</span>, t);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;, RETRY_FAILED_PERIOD, RETRY_FAILED_PERIOD, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//放入map</span></span><br><span class=\"line\">    failed.put(invocation, router);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">retryFailed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (failed.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//遍历所有的失败执行</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;Invocation, AbstractClusterInvoker&lt;?&gt;&gt; entry : <span class=\"keyword\">new</span> HashMap&lt;&gt;(failed).entrySet()) &#123;</span><br><span class=\"line\">        Invocation invocation = entry.getKey();</span><br><span class=\"line\">        Invoker&lt;?&gt; invoker = entry.getValue();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//发起调用</span></span><br><span class=\"line\">            invoker.invoke(invocation);</span><br><span class=\"line\">            <span class=\"comment\">//调用成功则从failed中删除</span></span><br><span class=\"line\">            failed.remove(invocation);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"Failed retry to invoke method \"</span> + invocation.getMethodName() + <span class=\"string\">\", waiting again.\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkInvokers(invokers, invocation);</span><br><span class=\"line\">        <span class=\"comment\">//通过负载均衡策略选择一个invoker</span></span><br><span class=\"line\">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoker.invoke(invocation);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//失败后，记录日志，不抛出异常</span></span><br><span class=\"line\">        logger.error(<span class=\"string\">\"Failback to invoke method \"</span> + invocation.getMethodName() + <span class=\"string\">\", wait for retry in background. Ignored exception: \"</span></span><br><span class=\"line\">                     + e.getMessage() + <span class=\"string\">\", \"</span>, e);</span><br><span class=\"line\">        <span class=\"comment\">//记录异常信息，key为调用的方法信息，value为invoker本身</span></span><br><span class=\"line\">        addFailed(invocation, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult(); <span class=\"comment\">// ignore</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 此策略失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>\n<h4 id=\"ForkingCluster\"><a href=\"#ForkingCluster\" class=\"headerlink\" title=\"ForkingCluster\"></a>ForkingCluster</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(<span class=\"keyword\">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkInvokers(invokers, invocation);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;Invoker&lt;T&gt;&gt; selected;</span><br><span class=\"line\">        <span class=\"comment\">//获取并行调用的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> forks = getUrl().getParameter(Constants.FORKS_KEY, Constants.DEFAULT_FORKS);</span><br><span class=\"line\">        <span class=\"comment\">//超时时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> timeout = getUrl().getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (forks &lt;= <span class=\"number\">0</span> || forks &gt;= invokers.size()) &#123;</span><br><span class=\"line\">            selected = invokers;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            selected = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            <span class=\"comment\">//通过负载均衡策略，选出要并行调用的invoker，放入selected列表中</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; forks; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODO. Add some comment here, refer chinese version for more details.</span></span><br><span class=\"line\">                Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, selected);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!selected.contains(invoker)) &#123;<span class=\"comment\">//防止重复添加</span></span><br><span class=\"line\">                    <span class=\"comment\">//Avoid add the same invoker several times.</span></span><br><span class=\"line\">                    selected.add(invoker);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        RpcContext.getContext().setInvokers((List) selected);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AtomicInteger count = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BlockingQueue&lt;Object&gt; ref = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//遍历selected列表，通过线程池并发调用</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class=\"line\">            executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        Result result = invoker.invoke(invocation);</span><br><span class=\"line\">                        <span class=\"comment\">//把结果放入阻塞队列</span></span><br><span class=\"line\">                        ref.offer(result);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> value = count.incrementAndGet();</span><br><span class=\"line\">                        <span class=\"comment\">//表示所有并发调用都抛出异常，才把异常加入阻塞队列尾部</span></span><br><span class=\"line\">                        <span class=\"comment\">//这就保证了，只要有一个调用成功，ref.poll()方法就能从队列头部取到返回结果  </span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (value &gt;= selected.size()) &#123;</span><br><span class=\"line\">                            ref.offer(e);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//设定阻塞时间，从阻塞队列头部获取返回结果，如果是异常则抛出异常</span></span><br><span class=\"line\">            Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ret <span class=\"keyword\">instanceof</span> Throwable) &#123;</span><br><span class=\"line\">                Throwable e = (Throwable) ret;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(e <span class=\"keyword\">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class=\"number\">0</span>, <span class=\"string\">\"Failed to forking invoke provider \"</span> + selected + <span class=\"string\">\", but no luck to perform the invocation. Last error is: \"</span> + e.getMessage(), e.getCause() != <span class=\"keyword\">null</span> ? e.getCause() : e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Result) ret;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Failed to forking invoke provider \"</span> + selected + <span class=\"string\">\", but no luck to perform the invocation. Last error is: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// clear attachments which is binding to current thread.</span></span><br><span class=\"line\">        RpcContext.getContext().clearAttachments();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</p>\n<h4 id=\"BroadcastCluster\"><a href=\"#BroadcastCluster\" class=\"headerlink\" title=\"BroadcastCluster\"></a>BroadcastCluster</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(<span class=\"keyword\">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    checkInvokers(invokers, invocation);</span><br><span class=\"line\">    RpcContext.getContext().setInvokers((List) invokers);</span><br><span class=\"line\">    RpcException exception = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Result result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//遍历调用所有的服务列表，并把结果覆盖以前的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            result = invoker.invoke(invocation);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RpcException e) &#123;</span><br><span class=\"line\">            exception = e;</span><br><span class=\"line\">            logger.warn(e.getMessage(), e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            exception = <span class=\"keyword\">new</span> RpcException(e.getMessage(), e);</span><br><span class=\"line\">            logger.warn(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//其中有一个失败，则直接抛异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> exception;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个策略通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>\n<h4 id=\"AvailableCluster\"><a href=\"#AvailableCluster\" class=\"headerlink\" title=\"AvailableCluster\"></a>AvailableCluster</h4><p>Available集群容错机制，主要逻辑是，简单的调用第一个可到达的服务，如果都不可达，则抛出异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">join</span><span class=\"params\">(Directory&lt;T&gt; directory)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//没有通过继承AbstractClusterInvoker抽象类，而是直接实现它，也没有使用负载均衡策略，而是简单的选择一个可达的服务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AbstractClusterInvoker&lt;T&gt;(directory) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (invoker.isAvailable()) &#123;<span class=\"comment\">//获取第一个可达的服务提供方</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invoker.invoke(invocation);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"No provider available in \"</span> + invokers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>在之前一篇文章<a href=\"https://shuaijunlan.github.io/2018/08/05/dubbo-consumer-calling-process-source-code-analysis/\">《Dubbo消费者调用过程源码分析》</a>讲到，在创建代理的时候会生成调用对象invoker，这个时候就会绑定集群策略，我们来看生成invoker的代码，在类<code>ReferenceConfig#createProxy(Map&lt;String, String&gt; map)</code>方法中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//直接在配置文件中配置url，实现直接通信（如果既配置了直连地址又配置了注册中心的地址，则自动忽略注册中心的地址）</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (url != <span class=\"keyword\">null</span> &amp;&amp; url.length() &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// user specified URL, could be peer-to-peer address, or register center's address.</span></span><br><span class=\"line\">    String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (us != <span class=\"keyword\">null</span> &amp;&amp; us.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String u : us) &#123;</span><br><span class=\"line\">            URL url = URL.valueOf(u);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (url.getPath() == <span class=\"keyword\">null</span> || url.getPath().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                url = url.setPath(interfaceName);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">                urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// assemble URL from register center's configuration</span></span><br><span class=\"line\">    <span class=\"comment\">//获取配置注册中心的url（可以有多个注册中心的url）</span></span><br><span class=\"line\">    List&lt;URL&gt; us = loadRegistries(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (us != <span class=\"keyword\">null</span> &amp;&amp; !us.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (URL u : us) &#123;</span><br><span class=\"line\">            URL monitorUrl = loadMonitor(u);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (monitorUrl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//如果urls为空，则抛出异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"No such any registry to reference \"</span> + interfaceName + <span class=\"string\">\" on the consumer \"</span> + NetUtils.getLocalHost() + <span class=\"string\">\" use dubbo version \"</span> + Version.getVersion() + <span class=\"string\">\", please config &lt;dubbo:registry address=\\\"...\\\" /&gt; to your spring config.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//当urls的长度为一时，可能为服务的直连地址也可能为注册中心的地址</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (urls.size() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    invoker = refprotocol.refer(interfaceClass, urls.get(<span class=\"number\">0</span>));</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//有多个直连地址，或者多个注册中心的地址</span></span><br><span class=\"line\">    List&lt;Invoker&lt;?&gt;&gt; invokers = <span class=\"keyword\">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class=\"line\">    URL registryURL = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (URL url : urls) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取每个url对应的invoker</span></span><br><span class=\"line\">        invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取最后一个注册中心的地址</span></span><br><span class=\"line\">            registryURL = url; <span class=\"comment\">// use last registry url</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (registryURL != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// registry url is available</span></span><br><span class=\"line\">        <span class=\"comment\">// use AvailableCluster only when register's cluster is available</span></span><br><span class=\"line\">        <span class=\"comment\">//当有注册中心的地址时，第一层使用AvailableCluster集群策略，第二层使用默认的集群策略</span></span><br><span class=\"line\">        URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);</span><br><span class=\"line\">        invoker = cluster.join(<span class=\"keyword\">new</span> StaticDirectory(u, invokers));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// not a registry url</span></span><br><span class=\"line\">        <span class=\"comment\">//如果没有注册中心地址，则使用默认的集群策略</span></span><br><span class=\"line\">        invoker = cluster.join(<span class=\"keyword\">new</span> StaticDirectory(invokers));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们总结出三种生成集群策略的入口，<strong>当urls的长度为1时，此时该url可能为注册中心的地址也可能是服务的直连地址，则进一步执行<code>invoker = refprotocol.refer(interfaceClass, urls.get(0));</code>；当urls的长度不为1时，此时可能为多个注册中心的地址或者多个服务直连地址，当为多个注册中心的地址时，会执行：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);</span><br><span class=\"line\">invoker = cluster.join(<span class=\"keyword\">new</span> StaticDirectory(u, invokers));</span><br></pre></td></tr></table></figure>\n<p><strong>当为多个直连地址时，则执行：<code>invoker = cluster.join(new StaticDirectory(invokers));</code></strong>，下面将对这三种方式进行详细的分析。</p>","more":"<p>Dubbo中提供了七种集群模式（FailoverCluster、FailfastCluster、FailsafeCluster、FailbackCluster、ForkingCluster、BroadcastCluster、AvailableCluster），来看一下它们的继承关系图：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Cluster.png?raw=true\" alt=\"Screenshot from 2018-09-18 11-16-13\"></p>\n<p>下面将分别对每一种集群模式进行分析。</p>\n<h4 id=\"FailoverCluster\"><a href=\"#FailoverCluster\" class=\"headerlink\" title=\"FailoverCluster\"></a>FailoverCluster</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation, <span class=\"keyword\">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers;</span><br><span class=\"line\">    checkInvokers(copyinvokers, invocation);<span class=\"comment\">//??</span></span><br><span class=\"line\">    String methodName = RpcUtils.getMethodName(invocation);</span><br><span class=\"line\">    <span class=\"comment\">//获取重试次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        len = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// retry loop.</span></span><br><span class=\"line\">    RpcException le = <span class=\"keyword\">null</span>; <span class=\"comment\">// last exception.</span></span><br><span class=\"line\">    <span class=\"comment\">//存放被调用过的invoker</span></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invoked = <span class=\"keyword\">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size()); <span class=\"comment\">// invoked invokers.</span></span><br><span class=\"line\">    Set&lt;String&gt; providers = <span class=\"keyword\">new</span> HashSet&lt;String&gt;(len);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Reselect before retry to avoid a change of candidate `invokers`.</span></span><br><span class=\"line\">        <span class=\"comment\">//<span class=\"doctag\">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            checkWhetherDestroyed();</span><br><span class=\"line\">            copyinvokers = list(invocation);</span><br><span class=\"line\">            <span class=\"comment\">// check again</span></span><br><span class=\"line\">            checkInvokers(copyinvokers, invocation);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//根据负载均衡策略选择一个invoker</span></span><br><span class=\"line\">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);</span><br><span class=\"line\">        invoked.add(invoker);</span><br><span class=\"line\">        RpcContext.getContext().setInvokers((List) invoked);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//调用invoke</span></span><br><span class=\"line\">            Result result = invoker.invoke(invocation);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (le != <span class=\"keyword\">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"Although retry the method \"</span> + methodName</span><br><span class=\"line\">                            + <span class=\"string\">\" in the service \"</span> + getInterface().getName()</span><br><span class=\"line\">                            + <span class=\"string\">\" was successful by the provider \"</span> + invoker.getUrl().getAddress()</span><br><span class=\"line\">                            + <span class=\"string\">\", but there have been failed providers \"</span> + providers</span><br><span class=\"line\">                            + <span class=\"string\">\" (\"</span> + providers.size() + <span class=\"string\">\"/\"</span> + copyinvokers.size()</span><br><span class=\"line\">                            + <span class=\"string\">\") from the registry \"</span> + directory.getUrl().getAddress()</span><br><span class=\"line\">                            + <span class=\"string\">\" on the consumer \"</span> + NetUtils.getLocalHost()</span><br><span class=\"line\">                            + <span class=\"string\">\" using the dubbo version \"</span> + Version.getVersion() + <span class=\"string\">\". Last error is: \"</span></span><br><span class=\"line\">                            + le.getMessage(), le);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RpcException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//捕获到远程调用异常，则直接抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.isBiz()) &#123; <span class=\"comment\">// biz exception.</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            le = e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            le = <span class=\"keyword\">new</span> RpcException(e.getMessage(), e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            providers.add(invoker.getUrl().getAddress());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(le.getCode(), <span class=\"string\">\"Failed to invoke the method \"</span></span><br><span class=\"line\">                           + methodName + <span class=\"string\">\" in the service \"</span> + getInterface().getName()</span><br><span class=\"line\">                           + <span class=\"string\">\". Tried \"</span> + len + <span class=\"string\">\" times of the providers \"</span> + providers</span><br><span class=\"line\">                           + <span class=\"string\">\" (\"</span> + providers.size() + <span class=\"string\">\"/\"</span> + copyinvokers.size()</span><br><span class=\"line\">                           + <span class=\"string\">\") from the registry \"</span> + directory.getUrl().getAddress()</span><br><span class=\"line\">                           + <span class=\"string\">\" on the consumer \"</span> + NetUtils.getLocalHost() + <span class=\"string\">\" using the dubbo version \"</span></span><br><span class=\"line\">                           + Version.getVersion() + <span class=\"string\">\". Last error is: \"</span></span><br><span class=\"line\">                           + le.getMessage(), le.getCause() != <span class=\"keyword\">null</span> ? le.getCause() : le);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Failover集群容错机制，总的逻辑是，以方法重复次数为限制，每次调用如果失败，<br>就利用负责均衡策略获取下一个提供者（invoker）,直到调用成功，或者最后方法超限，抛出异常，<br>其中中间如果有业务异常，则不再重试，直接抛出异常。</p>\n<h4 id=\"FailfastCluster\"><a href=\"#FailfastCluster\" class=\"headerlink\" title=\"FailfastCluster\"></a>FailfastCluster</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    checkInvokers(invokers, invocation);</span><br><span class=\"line\">    <span class=\"comment\">//通过负载均衡策略选择一个invoker</span></span><br><span class=\"line\">    Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//只执行一次调用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoker.invoke(invocation);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> RpcException &amp;&amp; ((RpcException) e).isBiz()) &#123; <span class=\"comment\">// biz exception.</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> (RpcException) e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(e <span class=\"keyword\">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class=\"number\">0</span>,</span><br><span class=\"line\">                               <span class=\"string\">\"Failfast invoke providers \"</span> + invoker.getUrl() + <span class=\"string\">\" \"</span> + loadbalance.getClass().getSimpleName()</span><br><span class=\"line\">                               + <span class=\"string\">\" select from all providers \"</span> + invokers + <span class=\"string\">\" for service \"</span> + getInterface().getName()</span><br><span class=\"line\">                               + <span class=\"string\">\" method \"</span> + invocation.getMethodName() + <span class=\"string\">\" on consumer \"</span> + NetUtils.getLocalHost()</span><br><span class=\"line\">                               + <span class=\"string\">\" use dubbo version \"</span> + Version.getVersion()</span><br><span class=\"line\">                               + <span class=\"string\">\", but no luck to perform the invocation. Last error is: \"</span> + e.getMessage(),</span><br><span class=\"line\">                               e.getCause() != <span class=\"keyword\">null</span> ? e.getCause() : e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>\n<h4 id=\"FailsafeCluster\"><a href=\"#FailsafeCluster\" class=\"headerlink\" title=\"FailsafeCluster\"></a>FailsafeCluster</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkInvokers(invokers, invocation);</span><br><span class=\"line\">        <span class=\"comment\">//通过负载均衡策略选择一个invoker</span></span><br><span class=\"line\">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">//只执行一次调用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoker.invoke(invocation);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        logger.error(<span class=\"string\">\"Failsafe ignore exception: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">        <span class=\"comment\">//遇到异常则返回一个RpcResult</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult(); <span class=\"comment\">// ignore</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>\n<h4 id=\"FailbackCluster\"><a href=\"#FailbackCluster\" class=\"headerlink\" title=\"FailbackCluster\"></a>FailbackCluster</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addFailed</span><span class=\"params\">(Invocation invocation, AbstractClusterInvoker&lt;?&gt; router)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retryFuture == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (retryFuture == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//调度线程池，周期性（5秒一次）的调用retryFailed方法</span></span><br><span class=\"line\">                retryFuture = scheduledExecutorService.scheduleWithFixedDelay(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// collect retry statistics</span></span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//执行之前异常方法的调用</span></span><br><span class=\"line\">                            retryFailed();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123; <span class=\"comment\">// Defensive fault tolerance</span></span><br><span class=\"line\">                            logger.error(<span class=\"string\">\"Unexpected error occur at collect statistic\"</span>, t);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;, RETRY_FAILED_PERIOD, RETRY_FAILED_PERIOD, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//放入map</span></span><br><span class=\"line\">    failed.put(invocation, router);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">retryFailed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (failed.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//遍历所有的失败执行</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;Invocation, AbstractClusterInvoker&lt;?&gt;&gt; entry : <span class=\"keyword\">new</span> HashMap&lt;&gt;(failed).entrySet()) &#123;</span><br><span class=\"line\">        Invocation invocation = entry.getKey();</span><br><span class=\"line\">        Invoker&lt;?&gt; invoker = entry.getValue();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//发起调用</span></span><br><span class=\"line\">            invoker.invoke(invocation);</span><br><span class=\"line\">            <span class=\"comment\">//调用成功则从failed中删除</span></span><br><span class=\"line\">            failed.remove(invocation);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"Failed retry to invoke method \"</span> + invocation.getMethodName() + <span class=\"string\">\", waiting again.\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkInvokers(invokers, invocation);</span><br><span class=\"line\">        <span class=\"comment\">//通过负载均衡策略选择一个invoker</span></span><br><span class=\"line\">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoker.invoke(invocation);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//失败后，记录日志，不抛出异常</span></span><br><span class=\"line\">        logger.error(<span class=\"string\">\"Failback to invoke method \"</span> + invocation.getMethodName() + <span class=\"string\">\", wait for retry in background. Ignored exception: \"</span></span><br><span class=\"line\">                     + e.getMessage() + <span class=\"string\">\", \"</span>, e);</span><br><span class=\"line\">        <span class=\"comment\">//记录异常信息，key为调用的方法信息，value为invoker本身</span></span><br><span class=\"line\">        addFailed(invocation, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult(); <span class=\"comment\">// ignore</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 此策略失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>\n<h4 id=\"ForkingCluster\"><a href=\"#ForkingCluster\" class=\"headerlink\" title=\"ForkingCluster\"></a>ForkingCluster</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(<span class=\"keyword\">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkInvokers(invokers, invocation);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;Invoker&lt;T&gt;&gt; selected;</span><br><span class=\"line\">        <span class=\"comment\">//获取并行调用的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> forks = getUrl().getParameter(Constants.FORKS_KEY, Constants.DEFAULT_FORKS);</span><br><span class=\"line\">        <span class=\"comment\">//超时时间</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> timeout = getUrl().getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (forks &lt;= <span class=\"number\">0</span> || forks &gt;= invokers.size()) &#123;</span><br><span class=\"line\">            selected = invokers;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            selected = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            <span class=\"comment\">//通过负载均衡策略，选出要并行调用的invoker，放入selected列表中</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; forks; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// TODO. Add some comment here, refer chinese version for more details.</span></span><br><span class=\"line\">                Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, selected);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!selected.contains(invoker)) &#123;<span class=\"comment\">//防止重复添加</span></span><br><span class=\"line\">                    <span class=\"comment\">//Avoid add the same invoker several times.</span></span><br><span class=\"line\">                    selected.add(invoker);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        RpcContext.getContext().setInvokers((List) selected);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> AtomicInteger count = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> BlockingQueue&lt;Object&gt; ref = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//遍历selected列表，通过线程池并发调用</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">final</span> Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class=\"line\">            executor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        Result result = invoker.invoke(invocation);</span><br><span class=\"line\">                        <span class=\"comment\">//把结果放入阻塞队列</span></span><br><span class=\"line\">                        ref.offer(result);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> value = count.incrementAndGet();</span><br><span class=\"line\">                        <span class=\"comment\">//表示所有并发调用都抛出异常，才把异常加入阻塞队列尾部</span></span><br><span class=\"line\">                        <span class=\"comment\">//这就保证了，只要有一个调用成功，ref.poll()方法就能从队列头部取到返回结果  </span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (value &gt;= selected.size()) &#123;</span><br><span class=\"line\">                            ref.offer(e);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//设定阻塞时间，从阻塞队列头部获取返回结果，如果是异常则抛出异常</span></span><br><span class=\"line\">            Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ret <span class=\"keyword\">instanceof</span> Throwable) &#123;</span><br><span class=\"line\">                Throwable e = (Throwable) ret;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(e <span class=\"keyword\">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class=\"number\">0</span>, <span class=\"string\">\"Failed to forking invoke provider \"</span> + selected + <span class=\"string\">\", but no luck to perform the invocation. Last error is: \"</span> + e.getMessage(), e.getCause() != <span class=\"keyword\">null</span> ? e.getCause() : e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Result) ret;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Failed to forking invoke provider \"</span> + selected + <span class=\"string\">\", but no luck to perform the invocation. Last error is: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// clear attachments which is binding to current thread.</span></span><br><span class=\"line\">        RpcContext.getContext().clearAttachments();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</p>\n<h4 id=\"BroadcastCluster\"><a href=\"#BroadcastCluster\" class=\"headerlink\" title=\"BroadcastCluster\"></a>BroadcastCluster</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(<span class=\"keyword\">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    checkInvokers(invokers, invocation);</span><br><span class=\"line\">    RpcContext.getContext().setInvokers((List) invokers);</span><br><span class=\"line\">    RpcException exception = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Result result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//遍历调用所有的服务列表，并把结果覆盖以前的</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            result = invoker.invoke(invocation);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RpcException e) &#123;</span><br><span class=\"line\">            exception = e;</span><br><span class=\"line\">            logger.warn(e.getMessage(), e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            exception = <span class=\"keyword\">new</span> RpcException(e.getMessage(), e);</span><br><span class=\"line\">            logger.warn(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//其中有一个失败，则直接抛异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exception != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> exception;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个策略通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>\n<h4 id=\"AvailableCluster\"><a href=\"#AvailableCluster\" class=\"headerlink\" title=\"AvailableCluster\"></a>AvailableCluster</h4><p>Available集群容错机制，主要逻辑是，简单的调用第一个可到达的服务，如果都不可达，则抛出异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">join</span><span class=\"params\">(Directory&lt;T&gt; directory)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//没有通过继承AbstractClusterInvoker抽象类，而是直接实现它，也没有使用负载均衡策略，而是简单的选择一个可达的服务</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AbstractClusterInvoker&lt;T&gt;(directory) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (invoker.isAvailable()) &#123;<span class=\"comment\">//获取第一个可达的服务提供方</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invoker.invoke(invocation);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"No provider available in \"</span> + invokers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Dubbo Gracefully Shutdown机制分析","date":"2018-09-22T08:13:34.000Z","_content":"\n","source":"_posts/dubbo-gracefully-shutdown.md","raw":"---\ntitle: Dubbo Gracefully Shutdown机制分析\ndate: 2018-09-22 16:13:34\ntags:\n    - dubbo\n---\n\n","slug":"dubbo-gracefully-shutdown","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4t000yzjias7dgn4gm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Dubbo负载均衡策略分析","date":"2018-09-10T12:12:04.000Z","_content":"\nDubbo提供了四种负载均衡策略：Random LoadBalance（加权随机负载均衡）、RoundRobin LoadBalance（加权轮询负载均衡）、LeastActive LoadBalance（最少活跃数负载均衡）、ConsistentHash LoadBalance（一致性hash负载均衡），下面将分别分析这四种负载均衡策略的源码。\n\n#### Random LoadBalance\n\n先来看一下RandomLoadBalance类的源码：\n\n```java\npublic class RandomLoadBalance extends AbstractLoadBalance {\n\n    public static final String NAME = \"random\";\n\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        int length = invokers.size(); // Number of invokers\n        int totalWeight = 0; // The sum of weights\n        boolean sameWeight = true; // Every invoker has the same weight?\n        for (int i = 0; i < length; i++) {\n            //获取权重\n            int weight = getWeight(invokers.get(i), invocation);\n            //权重累积和\n            totalWeight += weight; // Sum\n        \t//记录所有的invokers的weight是否是一样的\n            if (sameWeight && i > 0\n                    && weight != getWeight(invokers.get(i - 1), invocation)) {\n                sameWeight = false;\n            }\n        }\n        //如果不是所有的invoker权重都一样\n        if (totalWeight > 0 && !sameWeight) {\n            // If (not every invoker has the same weight & at least one invoker's weight>0), select randomly based on totalWeight.\n            //获取随机数的范围是[0, totalWeight)\n            int offset = ThreadLocalRandom.current().nextInt(totalWeight);\n            // Return a invoker based on the random value.\n            for (int i = 0; i < length; i++) {\n                offset -= getWeight(invokers.get(i), invocation);\n                if (offset < 0) {\n                    //返回invoker\n                    return invokers.get(i);\n                }\n            }\n        }\n        //如果所有的invoker都是一样的weight，则直接获取随机数，并返回\n        //这里使用了ThreadLocalRandom做了优化\n        // If all invokers have the same weight value or totalWeight=0, return evenly.\n        return invokers.get(ThreadLocalRandom.current().nextInt(length));\n    }\n\n}\n```\n\n随机加权轮询算法还是比较容易理解的，下面继续分析RoundRobin LoadBalance。\n\n<!-- more -->\n\n#### RoundRobin LoadBalance\n\n在理解加权轮询算法源码之前，我们先通过一个简单的示例来表达加权轮询算法的工作原理，如下图所示\n\n![Screenshot from 2018-09-18 11-16-13](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-09-18 11-16-13.png?raw=true)\n\n* 假设某个服务有五个提供者，分别为A、B、C、D、E，他们的weight分别为5/3/6/1/4；\n* 因此他们的weight总和sumWeight为19，maxWeight为6，minWeight为1；\n* 设置一个sequence表示第几次调用这个服务，sequence从0开始，每次调用完对sequence进行加1；\n* currentSequence表示当前的调用时sequence的值；\n* 通过mod=currentSequence%sumWeight得到的值，对服务进行循环，每次循环，当mod为零时则表示选中当前服务并返回，如果mod不为零则对当前服务的weight减1，并且mod也减1，直到mod为零退出循环；\n* 因此，通过上面的步骤，我们可以得出结论，当对服务进行19次调用时，提供者提供的顺序为：A、B、C、D、E、A、B、C、E、A、B、C、E、A、C、E、A、C、C；\n\nRoundRobinLoadBalance类源码：\n\n```java\npublic class RoundRobinLoadBalance extends AbstractLoadBalance {\n\n    public static final String NAME = \"roundrobin\";\n\n    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();\n\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n        int length = invokers.size(); // Number of invokers\n        int maxWeight = 0; // The maximum weight\n        int minWeight = Integer.MAX_VALUE; // The minimum weight\n        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();\n        int weightSum = 0;\n        for (int i = 0; i < length; i++) {\n            int weight = getWeight(invokers.get(i), invocation);\n            //选择一个最大的权重\n            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight\n            //选择一个最小的权重\n            minWeight = Math.min(minWeight, weight); // Choose the minimum weight\n            if (weight > 0) {\n                //形成一个invoker：weight的map\n                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));\n                //总的weight\n                weightSum += weight;\n            }\n        }\n        //为当前的key设置一个sequence\n        AtomicPositiveInteger sequence = sequences.get(key);\n        if (sequence == null) {\n            sequences.putIfAbsent(key, new AtomicPositiveInteger());\n            sequence = sequences.get(key);\n        }\n        //获取当前的sequence\n        int currentSequence = sequence.getAndIncrement();\n        if (maxWeight > 0 && minWeight < maxWeight) {\n            int mod = currentSequence % weightSum;\n            for (int i = 0; i < maxWeight; i++) {\n                for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) {\n                    final Invoker<T> k = each.getKey();\n                    final IntegerWrapper v = each.getValue();\n                    if (mod == 0 && v.getValue() > 0) {\n                        return k;\n                    }\n                    if (v.getValue() > 0) {\n                        v.decrement();\n                        mod--;\n                    }\n                }\n            }\n        }\n        // Round robin\n        return invokers.get(currentSequence % length);\n    }\n\t//自定义IntegerWrapper包装类\n    private static final class IntegerWrapper {\n        private int value;\n\n        public IntegerWrapper(int value) {\n            this.value = value;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        public void setValue(int value) {\n            this.value = value;\n        }\n\n        public void decrement() {\n            this.value--;\n        }\n    }\n\n}\n```\n\n####  LeastActive LoadBalance\n\n看一下LeastActiveLoadBalance类的源码：\n\n```java\npublic class LeastActiveLoadBalance extends AbstractLoadBalance {\n\n    public static final String NAME = \"leastactive\";\n\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        int length = invokers.size(); // Number of invokers\n        int leastActive = -1; // The least active value of all invokers\n        int leastCount = 0; // The number of invokers having the same least active value (leastActive)\n        int[] leastIndexs = new int[length]; // The index of invokers having the same least active value (leastActive)\n        int totalWeight = 0; // The sum of weights\n        int firstWeight = 0; // Initial value, used for comparision\n        boolean sameWeight = true; // Every invoker has the same weight value?\n        for (int i = 0; i < length; i++) {\n            Invoker<T> invoker = invokers.get(i);\n            int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // Active number\n            int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); // Weight\n            if (leastActive == -1 || active < leastActive) { // Restart, when find a invoker having smaller least active value.\n                leastActive = active; // Record the current least active value\n                leastCount = 1; // Reset leastCount, count again based on current leastCount\n                leastIndexs[0] = i; // Reset\n                totalWeight = weight; // Reset\n                firstWeight = weight; // Record the weight the first invoker\n                sameWeight = true; // Reset, every invoker has the same weight value?\n            } else if (active == leastActive) { // If current invoker's active value equals with leaseActive, then accumulating.\n                leastIndexs[leastCount++] = i; // Record index number of this invoker\n                totalWeight += weight; // Add this invoker's weight to totalWeight.\n                // If every invoker has the same weight?\n                if (sameWeight && i > 0\n                        && weight != firstWeight) {\n                    sameWeight = false;\n                }\n            }\n        }\n        // assert(leastCount > 0)\n        if (leastCount == 1) {\n            // If we got exactly one invoker having the least active value, return this invoker directly.\n            return invokers.get(leastIndexs[0]);\n        }\n        if (!sameWeight && totalWeight > 0) {\n            // If (not every invoker has the same weight & at least one invoker's weight>0), select randomly based on totalWeight.\n            int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);\n            // Return a invoker based on the random value.\n            for (int i = 0; i < leastCount; i++) {\n                int leastIndex = leastIndexs[i];\n                offsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n                if (offsetWeight <= 0)\n                    return invokers.get(leastIndex);\n            }\n        }\n        // If all invokers have the same weight value or totalWeight=0, return evenly.\n        return invokers.get(leastIndexs[ThreadLocalRandom.current().nextInt(leastCount)]);\n    }\n}\n```\n\n\n\n#### ConsistentHash LoadBalance\n\n看一下ConsistentHasLoadBalance类的源码：\n\n```java\npublic class ConsistentHashLoadBalance extends AbstractLoadBalance {\n    public static final String NAME = \"consistenthash\";\n\n    private final ConcurrentMap<String, ConsistentHashSelector<?>> selectors = new ConcurrentHashMap<String, ConsistentHashSelector<?>>();\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        String methodName = RpcUtils.getMethodName(invocation);\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + methodName;\n        int identityHashCode = System.identityHashCode(invokers);\n        ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.get(key);\n        if (selector == null || selector.identityHashCode != identityHashCode) {\n            selectors.put(key, new ConsistentHashSelector<T>(invokers, methodName, identityHashCode));\n            selector = (ConsistentHashSelector<T>) selectors.get(key);\n        }\n        return selector.select(invocation);\n    }\n\n    private static final class ConsistentHashSelector<T> {\n\n        private final TreeMap<Long, Invoker<T>> virtualInvokers;\n\n        private final int replicaNumber;\n\n        private final int identityHashCode;\n\n        private final int[] argumentIndex;\n\n        ConsistentHashSelector(List<Invoker<T>> invokers, String methodName, int identityHashCode) {\n            this.virtualInvokers = new TreeMap<Long, Invoker<T>>();\n            this.identityHashCode = identityHashCode;\n            URL url = invokers.get(0).getUrl();\n            this.replicaNumber = url.getMethodParameter(methodName, \"hash.nodes\", 160);\n            String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, \"hash.arguments\", \"0\"));\n            argumentIndex = new int[index.length];\n            for (int i = 0; i < index.length; i++) {\n                argumentIndex[i] = Integer.parseInt(index[i]);\n            }\n            for (Invoker<T> invoker : invokers) {\n                String address = invoker.getUrl().getAddress();\n                for (int i = 0; i < replicaNumber / 4; i++) {\n                    byte[] digest = md5(address + i);\n                    for (int h = 0; h < 4; h++) {\n                        long m = hash(digest, h);\n                        virtualInvokers.put(m, invoker);\n                    }\n                }\n            }\n        }\n\n        public Invoker<T> select(Invocation invocation) {\n            String key = toKey(invocation.getArguments());\n            byte[] digest = md5(key);\n            return selectForKey(hash(digest, 0));\n        }\n\n        private String toKey(Object[] args) {\n            StringBuilder buf = new StringBuilder();\n            for (int i : argumentIndex) {\n                if (i >= 0 && i < args.length) {\n                    buf.append(args[i]);\n                }\n            }\n            return buf.toString();\n        }\n\n        private Invoker<T> selectForKey(long hash) {\n            Map.Entry<Long, Invoker<T>> entry = virtualInvokers.ceilingEntry(hash);\n            if (entry == null) {\n                entry = virtualInvokers.firstEntry();\n            }\n            return entry.getValue();\n        }\n\n        private long hash(byte[] digest, int number) {\n            return (((long) (digest[3 + number * 4] & 0xFF) << 24)\n                    | ((long) (digest[2 + number * 4] & 0xFF) << 16)\n                    | ((long) (digest[1 + number * 4] & 0xFF) << 8)\n                    | (digest[number * 4] & 0xFF))\n                    & 0xFFFFFFFFL;\n        }\n\n        private byte[] md5(String value) {\n            MessageDigest md5;\n            try {\n                md5 = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n            md5.reset();\n            byte[] bytes;\n            try {\n                bytes = value.getBytes(\"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n            md5.update(bytes);\n            return md5.digest();\n        }\n\n    }\n\n}\n```\n\n#### 更新（2018/10/12）\n\n因为之前的RoundRobin LoadBalance算法存在性能问题，参考ISSUE[https://github.com/apache/incubator-dubbo/issues/2578](https://github.com/apache/incubator-dubbo/issues/2578)。现在最新版本对其进行了优化，优化思路如下：\n\n```java\npublic class RoundRobinLoadBalance extends AbstractLoadBalance {\n\n    public static final String NAME = \"roundrobin\";\n\n    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();\n\n    private final ConcurrentMap<String, AtomicPositiveInteger> indexSeqs = new ConcurrentHashMap<String, AtomicPositiveInteger>();\n\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n        int length = invokers.size(); // Number of invokers\n        int maxWeight = 0; // The maximum weight\n        int minWeight = Integer.MAX_VALUE; // The minimum weight\n        final List<Invoker<T>> nonZeroWeightedInvokers = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            int weight = getWeight(invokers.get(i), invocation);\n            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight\n            minWeight = Math.min(minWeight, weight); // Choose the minimum weight\n            if (weight > 0) {\n                nonZeroWeightedInvokers.add(invokers.get(i));\n            }\n        }\n        AtomicPositiveInteger sequence = sequences.get(key);\n        if (sequence == null) {\n            sequences.putIfAbsent(key, new AtomicPositiveInteger());\n            sequence = sequences.get(key);\n        }\n\n        if (maxWeight > 0 && minWeight < maxWeight) {\n            AtomicPositiveInteger indexSeq = indexSeqs.get(key);\n            if (indexSeq == null) {\n                indexSeqs.putIfAbsent(key, new AtomicPositiveInteger(-1));\n                indexSeq = indexSeqs.get(key);\n            }\n            length = nonZeroWeightedInvokers.size();\n            while (true) {\n                int index = indexSeq.incrementAndGet() % length;\n                int currentWeight;\n                if (index == 0) {\n                    currentWeight = sequence.incrementAndGet() % maxWeight;\n                } else {\n                    currentWeight = sequence.get() % maxWeight;\n                }\n                if (getWeight(nonZeroWeightedInvokers.get(index), invocation) > currentWeight) {\n                    return nonZeroWeightedInvokers.get(index);\n                }\n            }\n        }\n        // Round robin\n        return invokers.get(sequence.getAndIncrement() % length);\n    }\n}\n```\n\nhttps://colobu.com/2016/12/04/smooth-weighted-round-robin-algorithm/\n\n\n","source":"_posts/dubbo-loadbalance-strategy.md","raw":"---\ntitle: Dubbo负载均衡策略分析\ndate: 2018-09-10 20:12:04\ntags:\n    - dubbo\n---\n\nDubbo提供了四种负载均衡策略：Random LoadBalance（加权随机负载均衡）、RoundRobin LoadBalance（加权轮询负载均衡）、LeastActive LoadBalance（最少活跃数负载均衡）、ConsistentHash LoadBalance（一致性hash负载均衡），下面将分别分析这四种负载均衡策略的源码。\n\n#### Random LoadBalance\n\n先来看一下RandomLoadBalance类的源码：\n\n```java\npublic class RandomLoadBalance extends AbstractLoadBalance {\n\n    public static final String NAME = \"random\";\n\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        int length = invokers.size(); // Number of invokers\n        int totalWeight = 0; // The sum of weights\n        boolean sameWeight = true; // Every invoker has the same weight?\n        for (int i = 0; i < length; i++) {\n            //获取权重\n            int weight = getWeight(invokers.get(i), invocation);\n            //权重累积和\n            totalWeight += weight; // Sum\n        \t//记录所有的invokers的weight是否是一样的\n            if (sameWeight && i > 0\n                    && weight != getWeight(invokers.get(i - 1), invocation)) {\n                sameWeight = false;\n            }\n        }\n        //如果不是所有的invoker权重都一样\n        if (totalWeight > 0 && !sameWeight) {\n            // If (not every invoker has the same weight & at least one invoker's weight>0), select randomly based on totalWeight.\n            //获取随机数的范围是[0, totalWeight)\n            int offset = ThreadLocalRandom.current().nextInt(totalWeight);\n            // Return a invoker based on the random value.\n            for (int i = 0; i < length; i++) {\n                offset -= getWeight(invokers.get(i), invocation);\n                if (offset < 0) {\n                    //返回invoker\n                    return invokers.get(i);\n                }\n            }\n        }\n        //如果所有的invoker都是一样的weight，则直接获取随机数，并返回\n        //这里使用了ThreadLocalRandom做了优化\n        // If all invokers have the same weight value or totalWeight=0, return evenly.\n        return invokers.get(ThreadLocalRandom.current().nextInt(length));\n    }\n\n}\n```\n\n随机加权轮询算法还是比较容易理解的，下面继续分析RoundRobin LoadBalance。\n\n<!-- more -->\n\n#### RoundRobin LoadBalance\n\n在理解加权轮询算法源码之前，我们先通过一个简单的示例来表达加权轮询算法的工作原理，如下图所示\n\n![Screenshot from 2018-09-18 11-16-13](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-09-18 11-16-13.png?raw=true)\n\n* 假设某个服务有五个提供者，分别为A、B、C、D、E，他们的weight分别为5/3/6/1/4；\n* 因此他们的weight总和sumWeight为19，maxWeight为6，minWeight为1；\n* 设置一个sequence表示第几次调用这个服务，sequence从0开始，每次调用完对sequence进行加1；\n* currentSequence表示当前的调用时sequence的值；\n* 通过mod=currentSequence%sumWeight得到的值，对服务进行循环，每次循环，当mod为零时则表示选中当前服务并返回，如果mod不为零则对当前服务的weight减1，并且mod也减1，直到mod为零退出循环；\n* 因此，通过上面的步骤，我们可以得出结论，当对服务进行19次调用时，提供者提供的顺序为：A、B、C、D、E、A、B、C、E、A、B、C、E、A、C、E、A、C、C；\n\nRoundRobinLoadBalance类源码：\n\n```java\npublic class RoundRobinLoadBalance extends AbstractLoadBalance {\n\n    public static final String NAME = \"roundrobin\";\n\n    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();\n\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n        int length = invokers.size(); // Number of invokers\n        int maxWeight = 0; // The maximum weight\n        int minWeight = Integer.MAX_VALUE; // The minimum weight\n        final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();\n        int weightSum = 0;\n        for (int i = 0; i < length; i++) {\n            int weight = getWeight(invokers.get(i), invocation);\n            //选择一个最大的权重\n            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight\n            //选择一个最小的权重\n            minWeight = Math.min(minWeight, weight); // Choose the minimum weight\n            if (weight > 0) {\n                //形成一个invoker：weight的map\n                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));\n                //总的weight\n                weightSum += weight;\n            }\n        }\n        //为当前的key设置一个sequence\n        AtomicPositiveInteger sequence = sequences.get(key);\n        if (sequence == null) {\n            sequences.putIfAbsent(key, new AtomicPositiveInteger());\n            sequence = sequences.get(key);\n        }\n        //获取当前的sequence\n        int currentSequence = sequence.getAndIncrement();\n        if (maxWeight > 0 && minWeight < maxWeight) {\n            int mod = currentSequence % weightSum;\n            for (int i = 0; i < maxWeight; i++) {\n                for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) {\n                    final Invoker<T> k = each.getKey();\n                    final IntegerWrapper v = each.getValue();\n                    if (mod == 0 && v.getValue() > 0) {\n                        return k;\n                    }\n                    if (v.getValue() > 0) {\n                        v.decrement();\n                        mod--;\n                    }\n                }\n            }\n        }\n        // Round robin\n        return invokers.get(currentSequence % length);\n    }\n\t//自定义IntegerWrapper包装类\n    private static final class IntegerWrapper {\n        private int value;\n\n        public IntegerWrapper(int value) {\n            this.value = value;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        public void setValue(int value) {\n            this.value = value;\n        }\n\n        public void decrement() {\n            this.value--;\n        }\n    }\n\n}\n```\n\n####  LeastActive LoadBalance\n\n看一下LeastActiveLoadBalance类的源码：\n\n```java\npublic class LeastActiveLoadBalance extends AbstractLoadBalance {\n\n    public static final String NAME = \"leastactive\";\n\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        int length = invokers.size(); // Number of invokers\n        int leastActive = -1; // The least active value of all invokers\n        int leastCount = 0; // The number of invokers having the same least active value (leastActive)\n        int[] leastIndexs = new int[length]; // The index of invokers having the same least active value (leastActive)\n        int totalWeight = 0; // The sum of weights\n        int firstWeight = 0; // Initial value, used for comparision\n        boolean sameWeight = true; // Every invoker has the same weight value?\n        for (int i = 0; i < length; i++) {\n            Invoker<T> invoker = invokers.get(i);\n            int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // Active number\n            int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); // Weight\n            if (leastActive == -1 || active < leastActive) { // Restart, when find a invoker having smaller least active value.\n                leastActive = active; // Record the current least active value\n                leastCount = 1; // Reset leastCount, count again based on current leastCount\n                leastIndexs[0] = i; // Reset\n                totalWeight = weight; // Reset\n                firstWeight = weight; // Record the weight the first invoker\n                sameWeight = true; // Reset, every invoker has the same weight value?\n            } else if (active == leastActive) { // If current invoker's active value equals with leaseActive, then accumulating.\n                leastIndexs[leastCount++] = i; // Record index number of this invoker\n                totalWeight += weight; // Add this invoker's weight to totalWeight.\n                // If every invoker has the same weight?\n                if (sameWeight && i > 0\n                        && weight != firstWeight) {\n                    sameWeight = false;\n                }\n            }\n        }\n        // assert(leastCount > 0)\n        if (leastCount == 1) {\n            // If we got exactly one invoker having the least active value, return this invoker directly.\n            return invokers.get(leastIndexs[0]);\n        }\n        if (!sameWeight && totalWeight > 0) {\n            // If (not every invoker has the same weight & at least one invoker's weight>0), select randomly based on totalWeight.\n            int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);\n            // Return a invoker based on the random value.\n            for (int i = 0; i < leastCount; i++) {\n                int leastIndex = leastIndexs[i];\n                offsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n                if (offsetWeight <= 0)\n                    return invokers.get(leastIndex);\n            }\n        }\n        // If all invokers have the same weight value or totalWeight=0, return evenly.\n        return invokers.get(leastIndexs[ThreadLocalRandom.current().nextInt(leastCount)]);\n    }\n}\n```\n\n\n\n#### ConsistentHash LoadBalance\n\n看一下ConsistentHasLoadBalance类的源码：\n\n```java\npublic class ConsistentHashLoadBalance extends AbstractLoadBalance {\n    public static final String NAME = \"consistenthash\";\n\n    private final ConcurrentMap<String, ConsistentHashSelector<?>> selectors = new ConcurrentHashMap<String, ConsistentHashSelector<?>>();\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        String methodName = RpcUtils.getMethodName(invocation);\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + methodName;\n        int identityHashCode = System.identityHashCode(invokers);\n        ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.get(key);\n        if (selector == null || selector.identityHashCode != identityHashCode) {\n            selectors.put(key, new ConsistentHashSelector<T>(invokers, methodName, identityHashCode));\n            selector = (ConsistentHashSelector<T>) selectors.get(key);\n        }\n        return selector.select(invocation);\n    }\n\n    private static final class ConsistentHashSelector<T> {\n\n        private final TreeMap<Long, Invoker<T>> virtualInvokers;\n\n        private final int replicaNumber;\n\n        private final int identityHashCode;\n\n        private final int[] argumentIndex;\n\n        ConsistentHashSelector(List<Invoker<T>> invokers, String methodName, int identityHashCode) {\n            this.virtualInvokers = new TreeMap<Long, Invoker<T>>();\n            this.identityHashCode = identityHashCode;\n            URL url = invokers.get(0).getUrl();\n            this.replicaNumber = url.getMethodParameter(methodName, \"hash.nodes\", 160);\n            String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, \"hash.arguments\", \"0\"));\n            argumentIndex = new int[index.length];\n            for (int i = 0; i < index.length; i++) {\n                argumentIndex[i] = Integer.parseInt(index[i]);\n            }\n            for (Invoker<T> invoker : invokers) {\n                String address = invoker.getUrl().getAddress();\n                for (int i = 0; i < replicaNumber / 4; i++) {\n                    byte[] digest = md5(address + i);\n                    for (int h = 0; h < 4; h++) {\n                        long m = hash(digest, h);\n                        virtualInvokers.put(m, invoker);\n                    }\n                }\n            }\n        }\n\n        public Invoker<T> select(Invocation invocation) {\n            String key = toKey(invocation.getArguments());\n            byte[] digest = md5(key);\n            return selectForKey(hash(digest, 0));\n        }\n\n        private String toKey(Object[] args) {\n            StringBuilder buf = new StringBuilder();\n            for (int i : argumentIndex) {\n                if (i >= 0 && i < args.length) {\n                    buf.append(args[i]);\n                }\n            }\n            return buf.toString();\n        }\n\n        private Invoker<T> selectForKey(long hash) {\n            Map.Entry<Long, Invoker<T>> entry = virtualInvokers.ceilingEntry(hash);\n            if (entry == null) {\n                entry = virtualInvokers.firstEntry();\n            }\n            return entry.getValue();\n        }\n\n        private long hash(byte[] digest, int number) {\n            return (((long) (digest[3 + number * 4] & 0xFF) << 24)\n                    | ((long) (digest[2 + number * 4] & 0xFF) << 16)\n                    | ((long) (digest[1 + number * 4] & 0xFF) << 8)\n                    | (digest[number * 4] & 0xFF))\n                    & 0xFFFFFFFFL;\n        }\n\n        private byte[] md5(String value) {\n            MessageDigest md5;\n            try {\n                md5 = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n            md5.reset();\n            byte[] bytes;\n            try {\n                bytes = value.getBytes(\"UTF-8\");\n            } catch (UnsupportedEncodingException e) {\n                throw new IllegalStateException(e.getMessage(), e);\n            }\n            md5.update(bytes);\n            return md5.digest();\n        }\n\n    }\n\n}\n```\n\n#### 更新（2018/10/12）\n\n因为之前的RoundRobin LoadBalance算法存在性能问题，参考ISSUE[https://github.com/apache/incubator-dubbo/issues/2578](https://github.com/apache/incubator-dubbo/issues/2578)。现在最新版本对其进行了优化，优化思路如下：\n\n```java\npublic class RoundRobinLoadBalance extends AbstractLoadBalance {\n\n    public static final String NAME = \"roundrobin\";\n\n    private final ConcurrentMap<String, AtomicPositiveInteger> sequences = new ConcurrentHashMap<String, AtomicPositiveInteger>();\n\n    private final ConcurrentMap<String, AtomicPositiveInteger> indexSeqs = new ConcurrentHashMap<String, AtomicPositiveInteger>();\n\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n        int length = invokers.size(); // Number of invokers\n        int maxWeight = 0; // The maximum weight\n        int minWeight = Integer.MAX_VALUE; // The minimum weight\n        final List<Invoker<T>> nonZeroWeightedInvokers = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            int weight = getWeight(invokers.get(i), invocation);\n            maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight\n            minWeight = Math.min(minWeight, weight); // Choose the minimum weight\n            if (weight > 0) {\n                nonZeroWeightedInvokers.add(invokers.get(i));\n            }\n        }\n        AtomicPositiveInteger sequence = sequences.get(key);\n        if (sequence == null) {\n            sequences.putIfAbsent(key, new AtomicPositiveInteger());\n            sequence = sequences.get(key);\n        }\n\n        if (maxWeight > 0 && minWeight < maxWeight) {\n            AtomicPositiveInteger indexSeq = indexSeqs.get(key);\n            if (indexSeq == null) {\n                indexSeqs.putIfAbsent(key, new AtomicPositiveInteger(-1));\n                indexSeq = indexSeqs.get(key);\n            }\n            length = nonZeroWeightedInvokers.size();\n            while (true) {\n                int index = indexSeq.incrementAndGet() % length;\n                int currentWeight;\n                if (index == 0) {\n                    currentWeight = sequence.incrementAndGet() % maxWeight;\n                } else {\n                    currentWeight = sequence.get() % maxWeight;\n                }\n                if (getWeight(nonZeroWeightedInvokers.get(index), invocation) > currentWeight) {\n                    return nonZeroWeightedInvokers.get(index);\n                }\n            }\n        }\n        // Round robin\n        return invokers.get(sequence.getAndIncrement() % length);\n    }\n}\n```\n\nhttps://colobu.com/2016/12/04/smooth-weighted-round-robin-algorithm/\n\n\n","slug":"dubbo-loadbalance-strategy","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4u0012zjiazz9m4jmr","content":"<p>Dubbo提供了四种负载均衡策略：Random LoadBalance（加权随机负载均衡）、RoundRobin LoadBalance（加权轮询负载均衡）、LeastActive LoadBalance（最少活跃数负载均衡）、ConsistentHash LoadBalance（一致性hash负载均衡），下面将分别分析这四种负载均衡策略的源码。</p>\n<h4 id=\"Random-LoadBalance\"><a href=\"#Random-LoadBalance\" class=\"headerlink\" title=\"Random LoadBalance\"></a>Random LoadBalance</h4><p>先来看一下RandomLoadBalance类的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomLoadBalance</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLoadBalance</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"random\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">// Number of invokers</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalWeight = <span class=\"number\">0</span>; <span class=\"comment\">// The sum of weights</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> sameWeight = <span class=\"keyword\">true</span>; <span class=\"comment\">// Every invoker has the same weight?</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取权重</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">            <span class=\"comment\">//权重累积和</span></span><br><span class=\"line\">            totalWeight += weight; <span class=\"comment\">// Sum</span></span><br><span class=\"line\">        \t<span class=\"comment\">//记录所有的invokers的weight是否是一样的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sameWeight &amp;&amp; i &gt; <span class=\"number\">0</span></span><br><span class=\"line\">                    &amp;&amp; weight != getWeight(invokers.get(i - <span class=\"number\">1</span>), invocation)) &#123;</span><br><span class=\"line\">                sameWeight = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果不是所有的invoker权重都一样</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (totalWeight &gt; <span class=\"number\">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on totalWeight.</span></span><br><span class=\"line\">            <span class=\"comment\">//获取随机数的范围是[0, totalWeight)</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class=\"line\">            <span class=\"comment\">// Return a invoker based on the random value.</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">                offset -= getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (offset &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//返回invoker</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invokers.get(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果所有的invoker都是一样的weight，则直接获取随机数，并返回</span></span><br><span class=\"line\">        <span class=\"comment\">//这里使用了ThreadLocalRandom做了优化</span></span><br><span class=\"line\">        <span class=\"comment\">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>随机加权轮询算法还是比较容易理解的，下面继续分析RoundRobin LoadBalance。</p>\n<a id=\"more\"></a>\n<h4 id=\"RoundRobin-LoadBalance\"><a href=\"#RoundRobin-LoadBalance\" class=\"headerlink\" title=\"RoundRobin LoadBalance\"></a>RoundRobin LoadBalance</h4><p>在理解加权轮询算法源码之前，我们先通过一个简单的示例来表达加权轮询算法的工作原理，如下图所示</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-09-18 11-16-13.png?raw=true\" alt=\"Screenshot from 2018-09-18 11-16-13\"></p>\n<ul>\n<li>假设某个服务有五个提供者，分别为A、B、C、D、E，他们的weight分别为5/3/6/1/4；</li>\n<li>因此他们的weight总和sumWeight为19，maxWeight为6，minWeight为1；</li>\n<li>设置一个sequence表示第几次调用这个服务，sequence从0开始，每次调用完对sequence进行加1；</li>\n<li>currentSequence表示当前的调用时sequence的值；</li>\n<li>通过mod=currentSequence%sumWeight得到的值，对服务进行循环，每次循环，当mod为零时则表示选中当前服务并返回，如果mod不为零则对当前服务的weight减1，并且mod也减1，直到mod为零退出循环；</li>\n<li>因此，通过上面的步骤，我们可以得出结论，当对服务进行19次调用时，提供者提供的顺序为：A、B、C、D、E、A、B、C、E、A、B、C、E、A、C、E、A、C、C；</li>\n</ul>\n<p>RoundRobinLoadBalance类源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RoundRobinLoadBalance</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLoadBalance</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"roundrobin\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;String, AtomicPositiveInteger&gt; sequences = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">        String key = invokers.get(<span class=\"number\">0</span>).getUrl().getServiceKey() + <span class=\"string\">\".\"</span> + invocation.getMethodName();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">// Number of invokers</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxWeight = <span class=\"number\">0</span>; <span class=\"comment\">// The maximum weight</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> minWeight = Integer.MAX_VALUE; <span class=\"comment\">// The minimum weight</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; invokerToWeightMap = <span class=\"keyword\">new</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> weightSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">            <span class=\"comment\">//选择一个最大的权重</span></span><br><span class=\"line\">            maxWeight = Math.max(maxWeight, weight); <span class=\"comment\">// Choose the maximum weight</span></span><br><span class=\"line\">            <span class=\"comment\">//选择一个最小的权重</span></span><br><span class=\"line\">            minWeight = Math.min(minWeight, weight); <span class=\"comment\">// Choose the minimum weight</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (weight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//形成一个invoker：weight的map</span></span><br><span class=\"line\">                invokerToWeightMap.put(invokers.get(i), <span class=\"keyword\">new</span> IntegerWrapper(weight));</span><br><span class=\"line\">                <span class=\"comment\">//总的weight</span></span><br><span class=\"line\">                weightSum += weight;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//为当前的key设置一个sequence</span></span><br><span class=\"line\">        AtomicPositiveInteger sequence = sequences.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sequence == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            sequences.putIfAbsent(key, <span class=\"keyword\">new</span> AtomicPositiveInteger());</span><br><span class=\"line\">            sequence = sequences.get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前的sequence</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentSequence = sequence.getAndIncrement();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxWeight &gt; <span class=\"number\">0</span> &amp;&amp; minWeight &lt; maxWeight) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mod = currentSequence % weightSum;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxWeight; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; each : invokerToWeightMap.entrySet()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">final</span> Invoker&lt;T&gt; k = each.getKey();</span><br><span class=\"line\">                    <span class=\"keyword\">final</span> IntegerWrapper v = each.getValue();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mod == <span class=\"number\">0</span> &amp;&amp; v.getValue() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (v.getValue() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        v.decrement();</span><br><span class=\"line\">                        mod--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Round robin</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(currentSequence % length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//自定义IntegerWrapper包装类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerWrapper</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IntegerWrapper</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">decrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"LeastActive-LoadBalance\"><a href=\"#LeastActive-LoadBalance\" class=\"headerlink\" title=\"LeastActive LoadBalance\"></a>LeastActive LoadBalance</h4><p>看一下LeastActiveLoadBalance类的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeastActiveLoadBalance</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLoadBalance</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"leastactive\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">// Number of invokers</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> leastActive = -<span class=\"number\">1</span>; <span class=\"comment\">// The least active value of all invokers</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> leastCount = <span class=\"number\">0</span>; <span class=\"comment\">// The number of invokers having the same least active value (leastActive)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] leastIndexs = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length]; <span class=\"comment\">// The index of invokers having the same least active value (leastActive)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalWeight = <span class=\"number\">0</span>; <span class=\"comment\">// The sum of weights</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> firstWeight = <span class=\"number\">0</span>; <span class=\"comment\">// Initial value, used for comparision</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> sameWeight = <span class=\"keyword\">true</span>; <span class=\"comment\">// Every invoker has the same weight value?</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); <span class=\"comment\">// Active number</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); <span class=\"comment\">// Weight</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leastActive == -<span class=\"number\">1</span> || active &lt; leastActive) &#123; <span class=\"comment\">// Restart, when find a invoker having smaller least active value.</span></span><br><span class=\"line\">                leastActive = active; <span class=\"comment\">// Record the current least active value</span></span><br><span class=\"line\">                leastCount = <span class=\"number\">1</span>; <span class=\"comment\">// Reset leastCount, count again based on current leastCount</span></span><br><span class=\"line\">                leastIndexs[<span class=\"number\">0</span>] = i; <span class=\"comment\">// Reset</span></span><br><span class=\"line\">                totalWeight = weight; <span class=\"comment\">// Reset</span></span><br><span class=\"line\">                firstWeight = weight; <span class=\"comment\">// Record the weight the first invoker</span></span><br><span class=\"line\">                sameWeight = <span class=\"keyword\">true</span>; <span class=\"comment\">// Reset, every invoker has the same weight value?</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (active == leastActive) &#123; <span class=\"comment\">// If current invoker's active value equals with leaseActive, then accumulating.</span></span><br><span class=\"line\">                leastIndexs[leastCount++] = i; <span class=\"comment\">// Record index number of this invoker</span></span><br><span class=\"line\">                totalWeight += weight; <span class=\"comment\">// Add this invoker's weight to totalWeight.</span></span><br><span class=\"line\">                <span class=\"comment\">// If every invoker has the same weight?</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sameWeight &amp;&amp; i &gt; <span class=\"number\">0</span></span><br><span class=\"line\">                        &amp;&amp; weight != firstWeight) &#123;</span><br><span class=\"line\">                    sameWeight = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// assert(leastCount &gt; 0)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leastCount == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If we got exactly one invoker having the least active value, return this invoker directly.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> invokers.get(leastIndexs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on totalWeight.</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class=\"line\">            <span class=\"comment\">// Return a invoker based on the random value.</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> leastIndex = leastIndexs[i];</span><br><span class=\"line\">                offsetWeight -= getWeight(invokers.get(leastIndex), invocation);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (offsetWeight &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invokers.get(leastIndex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(leastIndexs[ThreadLocalRandom.current().nextInt(leastCount)]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ConsistentHash-LoadBalance\"><a href=\"#ConsistentHash-LoadBalance\" class=\"headerlink\" title=\"ConsistentHash LoadBalance\"></a>ConsistentHash LoadBalance</h4><p>看一下ConsistentHasLoadBalance类的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsistentHashLoadBalance</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLoadBalance</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"consistenthash\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class=\"line\">        String key = invokers.get(<span class=\"number\">0</span>).getUrl().getServiceKey() + <span class=\"string\">\".\"</span> + methodName;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> identityHashCode = System.identityHashCode(invokers);</span><br><span class=\"line\">        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector == <span class=\"keyword\">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class=\"line\">            selectors.put(key, <span class=\"keyword\">new</span> ConsistentHashSelector&lt;T&gt;(invokers, methodName, identityHashCode));</span><br><span class=\"line\">            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> selector.select(invocation);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsistentHashSelector</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> replicaNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> identityHashCode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] argumentIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">        ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class=\"keyword\">int</span> identityHashCode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.virtualInvokers = <span class=\"keyword\">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.identityHashCode = identityHashCode;</span><br><span class=\"line\">            URL url = invokers.get(<span class=\"number\">0</span>).getUrl();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.replicaNumber = url.getMethodParameter(methodName, <span class=\"string\">\"hash.nodes\"</span>, <span class=\"number\">160</span>);</span><br><span class=\"line\">            String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, <span class=\"string\">\"hash.arguments\"</span>, <span class=\"string\">\"0\"</span>));</span><br><span class=\"line\">            argumentIndex = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[index.length];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index.length; i++) &#123;</span><br><span class=\"line\">                argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class=\"line\">                String address = invoker.getUrl().getAddress();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; replicaNumber / <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] digest = md5(address + i);</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> h = <span class=\"number\">0</span>; h &lt; <span class=\"number\">4</span>; h++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">long</span> m = hash(digest, h);</span><br><span class=\"line\">                        virtualInvokers.put(m, invoker);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Invoker&lt;T&gt; <span class=\"title\">select</span><span class=\"params\">(Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">            String key = toKey(invocation.getArguments());</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] digest = md5(key);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> selectForKey(hash(digest, <span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">toKey</span><span class=\"params\">(Object[] args)</span> </span>&#123;</span><br><span class=\"line\">            StringBuilder buf = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : argumentIndex) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span> &amp;&amp; i &lt; args.length) &#123;</span><br><span class=\"line\">                    buf.append(args[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> buf.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> Invoker&lt;T&gt; <span class=\"title\">selectForKey</span><span class=\"params\">(<span class=\"keyword\">long</span> hash)</span> </span>&#123;</span><br><span class=\"line\">            Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.ceilingEntry(hash);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entry == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                entry = virtualInvokers.firstEntry();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> entry.getValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] digest, <span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (((<span class=\"keyword\">long</span>) (digest[<span class=\"number\">3</span> + number * <span class=\"number\">4</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">24</span>)</span><br><span class=\"line\">                    | ((<span class=\"keyword\">long</span>) (digest[<span class=\"number\">2</span> + number * <span class=\"number\">4</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">16</span>)</span><br><span class=\"line\">                    | ((<span class=\"keyword\">long</span>) (digest[<span class=\"number\">1</span> + number * <span class=\"number\">4</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">8</span>)</span><br><span class=\"line\">                    | (digest[number * <span class=\"number\">4</span>] &amp; <span class=\"number\">0xFF</span>))</span><br><span class=\"line\">                    &amp; <span class=\"number\">0xFFFFFFFFL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] md5(String value) &#123;</span><br><span class=\"line\">            MessageDigest md5;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                md5 = MessageDigest.getInstance(<span class=\"string\">\"MD5\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            md5.reset();</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                bytes = value.getBytes(<span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            md5.update(bytes);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> md5.digest();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"更新（2018-10-12）\"><a href=\"#更新（2018-10-12）\" class=\"headerlink\" title=\"更新（2018/10/12）\"></a>更新（2018/10/12）</h4><p>因为之前的RoundRobin LoadBalance算法存在性能问题，参考ISSUE<a href=\"https://github.com/apache/incubator-dubbo/issues/2578\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-dubbo/issues/2578</a>。现在最新版本对其进行了优化，优化思路如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RoundRobinLoadBalance</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLoadBalance</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"roundrobin\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;String, AtomicPositiveInteger&gt; sequences = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;String, AtomicPositiveInteger&gt; indexSeqs = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">        String key = invokers.get(<span class=\"number\">0</span>).getUrl().getServiceKey() + <span class=\"string\">\".\"</span> + invocation.getMethodName();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">// Number of invokers</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxWeight = <span class=\"number\">0</span>; <span class=\"comment\">// The maximum weight</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> minWeight = Integer.MAX_VALUE; <span class=\"comment\">// The minimum weight</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;Invoker&lt;T&gt;&gt; nonZeroWeightedInvokers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">            maxWeight = Math.max(maxWeight, weight); <span class=\"comment\">// Choose the maximum weight</span></span><br><span class=\"line\">            minWeight = Math.min(minWeight, weight); <span class=\"comment\">// Choose the minimum weight</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (weight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                nonZeroWeightedInvokers.add(invokers.get(i));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        AtomicPositiveInteger sequence = sequences.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sequence == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            sequences.putIfAbsent(key, <span class=\"keyword\">new</span> AtomicPositiveInteger());</span><br><span class=\"line\">            sequence = sequences.get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxWeight &gt; <span class=\"number\">0</span> &amp;&amp; minWeight &lt; maxWeight) &#123;</span><br><span class=\"line\">            AtomicPositiveInteger indexSeq = indexSeqs.get(key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (indexSeq == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                indexSeqs.putIfAbsent(key, <span class=\"keyword\">new</span> AtomicPositiveInteger(-<span class=\"number\">1</span>));</span><br><span class=\"line\">                indexSeq = indexSeqs.get(key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            length = nonZeroWeightedInvokers.size();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> index = indexSeq.incrementAndGet() % length;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> currentWeight;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    currentWeight = sequence.incrementAndGet() % maxWeight;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    currentWeight = sequence.get() % maxWeight;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (getWeight(nonZeroWeightedInvokers.get(index), invocation) &gt; currentWeight) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> nonZeroWeightedInvokers.get(index);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Round robin</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(sequence.getAndIncrement() % length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://colobu.com/2016/12/04/smooth-weighted-round-robin-algorithm/\" target=\"_blank\" rel=\"noopener\">https://colobu.com/2016/12/04/smooth-weighted-round-robin-algorithm/</a></p>\n","site":{"data":{}},"excerpt":"<p>Dubbo提供了四种负载均衡策略：Random LoadBalance（加权随机负载均衡）、RoundRobin LoadBalance（加权轮询负载均衡）、LeastActive LoadBalance（最少活跃数负载均衡）、ConsistentHash LoadBalance（一致性hash负载均衡），下面将分别分析这四种负载均衡策略的源码。</p>\n<h4 id=\"Random-LoadBalance\"><a href=\"#Random-LoadBalance\" class=\"headerlink\" title=\"Random LoadBalance\"></a>Random LoadBalance</h4><p>先来看一下RandomLoadBalance类的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomLoadBalance</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLoadBalance</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"random\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">// Number of invokers</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalWeight = <span class=\"number\">0</span>; <span class=\"comment\">// The sum of weights</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> sameWeight = <span class=\"keyword\">true</span>; <span class=\"comment\">// Every invoker has the same weight?</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取权重</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">            <span class=\"comment\">//权重累积和</span></span><br><span class=\"line\">            totalWeight += weight; <span class=\"comment\">// Sum</span></span><br><span class=\"line\">        \t<span class=\"comment\">//记录所有的invokers的weight是否是一样的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sameWeight &amp;&amp; i &gt; <span class=\"number\">0</span></span><br><span class=\"line\">                    &amp;&amp; weight != getWeight(invokers.get(i - <span class=\"number\">1</span>), invocation)) &#123;</span><br><span class=\"line\">                sameWeight = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果不是所有的invoker权重都一样</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (totalWeight &gt; <span class=\"number\">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on totalWeight.</span></span><br><span class=\"line\">            <span class=\"comment\">//获取随机数的范围是[0, totalWeight)</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class=\"line\">            <span class=\"comment\">// Return a invoker based on the random value.</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">                offset -= getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (offset &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//返回invoker</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invokers.get(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果所有的invoker都是一样的weight，则直接获取随机数，并返回</span></span><br><span class=\"line\">        <span class=\"comment\">//这里使用了ThreadLocalRandom做了优化</span></span><br><span class=\"line\">        <span class=\"comment\">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>随机加权轮询算法还是比较容易理解的，下面继续分析RoundRobin LoadBalance。</p>","more":"<h4 id=\"RoundRobin-LoadBalance\"><a href=\"#RoundRobin-LoadBalance\" class=\"headerlink\" title=\"RoundRobin LoadBalance\"></a>RoundRobin LoadBalance</h4><p>在理解加权轮询算法源码之前，我们先通过一个简单的示例来表达加权轮询算法的工作原理，如下图所示</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-09-18 11-16-13.png?raw=true\" alt=\"Screenshot from 2018-09-18 11-16-13\"></p>\n<ul>\n<li>假设某个服务有五个提供者，分别为A、B、C、D、E，他们的weight分别为5/3/6/1/4；</li>\n<li>因此他们的weight总和sumWeight为19，maxWeight为6，minWeight为1；</li>\n<li>设置一个sequence表示第几次调用这个服务，sequence从0开始，每次调用完对sequence进行加1；</li>\n<li>currentSequence表示当前的调用时sequence的值；</li>\n<li>通过mod=currentSequence%sumWeight得到的值，对服务进行循环，每次循环，当mod为零时则表示选中当前服务并返回，如果mod不为零则对当前服务的weight减1，并且mod也减1，直到mod为零退出循环；</li>\n<li>因此，通过上面的步骤，我们可以得出结论，当对服务进行19次调用时，提供者提供的顺序为：A、B、C、D、E、A、B、C、E、A、B、C、E、A、C、E、A、C、C；</li>\n</ul>\n<p>RoundRobinLoadBalance类源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RoundRobinLoadBalance</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLoadBalance</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"roundrobin\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;String, AtomicPositiveInteger&gt; sequences = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">        String key = invokers.get(<span class=\"number\">0</span>).getUrl().getServiceKey() + <span class=\"string\">\".\"</span> + invocation.getMethodName();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">// Number of invokers</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxWeight = <span class=\"number\">0</span>; <span class=\"comment\">// The maximum weight</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> minWeight = Integer.MAX_VALUE; <span class=\"comment\">// The minimum weight</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; invokerToWeightMap = <span class=\"keyword\">new</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> weightSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">            <span class=\"comment\">//选择一个最大的权重</span></span><br><span class=\"line\">            maxWeight = Math.max(maxWeight, weight); <span class=\"comment\">// Choose the maximum weight</span></span><br><span class=\"line\">            <span class=\"comment\">//选择一个最小的权重</span></span><br><span class=\"line\">            minWeight = Math.min(minWeight, weight); <span class=\"comment\">// Choose the minimum weight</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (weight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//形成一个invoker：weight的map</span></span><br><span class=\"line\">                invokerToWeightMap.put(invokers.get(i), <span class=\"keyword\">new</span> IntegerWrapper(weight));</span><br><span class=\"line\">                <span class=\"comment\">//总的weight</span></span><br><span class=\"line\">                weightSum += weight;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//为当前的key设置一个sequence</span></span><br><span class=\"line\">        AtomicPositiveInteger sequence = sequences.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sequence == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            sequences.putIfAbsent(key, <span class=\"keyword\">new</span> AtomicPositiveInteger());</span><br><span class=\"line\">            sequence = sequences.get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前的sequence</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> currentSequence = sequence.getAndIncrement();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxWeight &gt; <span class=\"number\">0</span> &amp;&amp; minWeight &lt; maxWeight) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mod = currentSequence % weightSum;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxWeight; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Map.Entry&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; each : invokerToWeightMap.entrySet()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">final</span> Invoker&lt;T&gt; k = each.getKey();</span><br><span class=\"line\">                    <span class=\"keyword\">final</span> IntegerWrapper v = each.getValue();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mod == <span class=\"number\">0</span> &amp;&amp; v.getValue() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (v.getValue() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        v.decrement();</span><br><span class=\"line\">                        mod--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Round robin</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(currentSequence % length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//自定义IntegerWrapper包装类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntegerWrapper</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IntegerWrapper</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">decrement</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"LeastActive-LoadBalance\"><a href=\"#LeastActive-LoadBalance\" class=\"headerlink\" title=\"LeastActive LoadBalance\"></a>LeastActive LoadBalance</h4><p>看一下LeastActiveLoadBalance类的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LeastActiveLoadBalance</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLoadBalance</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"leastactive\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">// Number of invokers</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> leastActive = -<span class=\"number\">1</span>; <span class=\"comment\">// The least active value of all invokers</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> leastCount = <span class=\"number\">0</span>; <span class=\"comment\">// The number of invokers having the same least active value (leastActive)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] leastIndexs = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length]; <span class=\"comment\">// The index of invokers having the same least active value (leastActive)</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> totalWeight = <span class=\"number\">0</span>; <span class=\"comment\">// The sum of weights</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> firstWeight = <span class=\"number\">0</span>; <span class=\"comment\">// Initial value, used for comparision</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> sameWeight = <span class=\"keyword\">true</span>; <span class=\"comment\">// Every invoker has the same weight value?</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); <span class=\"comment\">// Active number</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); <span class=\"comment\">// Weight</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (leastActive == -<span class=\"number\">1</span> || active &lt; leastActive) &#123; <span class=\"comment\">// Restart, when find a invoker having smaller least active value.</span></span><br><span class=\"line\">                leastActive = active; <span class=\"comment\">// Record the current least active value</span></span><br><span class=\"line\">                leastCount = <span class=\"number\">1</span>; <span class=\"comment\">// Reset leastCount, count again based on current leastCount</span></span><br><span class=\"line\">                leastIndexs[<span class=\"number\">0</span>] = i; <span class=\"comment\">// Reset</span></span><br><span class=\"line\">                totalWeight = weight; <span class=\"comment\">// Reset</span></span><br><span class=\"line\">                firstWeight = weight; <span class=\"comment\">// Record the weight the first invoker</span></span><br><span class=\"line\">                sameWeight = <span class=\"keyword\">true</span>; <span class=\"comment\">// Reset, every invoker has the same weight value?</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (active == leastActive) &#123; <span class=\"comment\">// If current invoker's active value equals with leaseActive, then accumulating.</span></span><br><span class=\"line\">                leastIndexs[leastCount++] = i; <span class=\"comment\">// Record index number of this invoker</span></span><br><span class=\"line\">                totalWeight += weight; <span class=\"comment\">// Add this invoker's weight to totalWeight.</span></span><br><span class=\"line\">                <span class=\"comment\">// If every invoker has the same weight?</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sameWeight &amp;&amp; i &gt; <span class=\"number\">0</span></span><br><span class=\"line\">                        &amp;&amp; weight != firstWeight) &#123;</span><br><span class=\"line\">                    sameWeight = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// assert(leastCount &gt; 0)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leastCount == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If we got exactly one invoker having the least active value, return this invoker directly.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> invokers.get(leastIndexs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on totalWeight.</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class=\"line\">            <span class=\"comment\">// Return a invoker based on the random value.</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> leastIndex = leastIndexs[i];</span><br><span class=\"line\">                offsetWeight -= getWeight(invokers.get(leastIndex), invocation);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (offsetWeight &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invokers.get(leastIndex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// If all invokers have the same weight value or totalWeight=0, return evenly.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(leastIndexs[ThreadLocalRandom.current().nextInt(leastCount)]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ConsistentHash-LoadBalance\"><a href=\"#ConsistentHash-LoadBalance\" class=\"headerlink\" title=\"ConsistentHash LoadBalance\"></a>ConsistentHash LoadBalance</h4><p>看一下ConsistentHasLoadBalance类的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsistentHashLoadBalance</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLoadBalance</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"consistenthash\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class=\"line\">        String key = invokers.get(<span class=\"number\">0</span>).getUrl().getServiceKey() + <span class=\"string\">\".\"</span> + methodName;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> identityHashCode = System.identityHashCode(invokers);</span><br><span class=\"line\">        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selector == <span class=\"keyword\">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class=\"line\">            selectors.put(key, <span class=\"keyword\">new</span> ConsistentHashSelector&lt;T&gt;(invokers, methodName, identityHashCode));</span><br><span class=\"line\">            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> selector.select(invocation);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsistentHashSelector</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> replicaNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> identityHashCode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] argumentIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">        ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class=\"keyword\">int</span> identityHashCode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.virtualInvokers = <span class=\"keyword\">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.identityHashCode = identityHashCode;</span><br><span class=\"line\">            URL url = invokers.get(<span class=\"number\">0</span>).getUrl();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.replicaNumber = url.getMethodParameter(methodName, <span class=\"string\">\"hash.nodes\"</span>, <span class=\"number\">160</span>);</span><br><span class=\"line\">            String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, <span class=\"string\">\"hash.arguments\"</span>, <span class=\"string\">\"0\"</span>));</span><br><span class=\"line\">            argumentIndex = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[index.length];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index.length; i++) &#123;</span><br><span class=\"line\">                argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class=\"line\">                String address = invoker.getUrl().getAddress();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; replicaNumber / <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">byte</span>[] digest = md5(address + i);</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> h = <span class=\"number\">0</span>; h &lt; <span class=\"number\">4</span>; h++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">long</span> m = hash(digest, h);</span><br><span class=\"line\">                        virtualInvokers.put(m, invoker);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Invoker&lt;T&gt; <span class=\"title\">select</span><span class=\"params\">(Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">            String key = toKey(invocation.getArguments());</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] digest = md5(key);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> selectForKey(hash(digest, <span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">toKey</span><span class=\"params\">(Object[] args)</span> </span>&#123;</span><br><span class=\"line\">            StringBuilder buf = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : argumentIndex) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span> &amp;&amp; i &lt; args.length) &#123;</span><br><span class=\"line\">                    buf.append(args[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> buf.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> Invoker&lt;T&gt; <span class=\"title\">selectForKey</span><span class=\"params\">(<span class=\"keyword\">long</span> hash)</span> </span>&#123;</span><br><span class=\"line\">            Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.ceilingEntry(hash);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (entry == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                entry = virtualInvokers.firstEntry();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> entry.getValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">hash</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] digest, <span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (((<span class=\"keyword\">long</span>) (digest[<span class=\"number\">3</span> + number * <span class=\"number\">4</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">24</span>)</span><br><span class=\"line\">                    | ((<span class=\"keyword\">long</span>) (digest[<span class=\"number\">2</span> + number * <span class=\"number\">4</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">16</span>)</span><br><span class=\"line\">                    | ((<span class=\"keyword\">long</span>) (digest[<span class=\"number\">1</span> + number * <span class=\"number\">4</span>] &amp; <span class=\"number\">0xFF</span>) &lt;&lt; <span class=\"number\">8</span>)</span><br><span class=\"line\">                    | (digest[number * <span class=\"number\">4</span>] &amp; <span class=\"number\">0xFF</span>))</span><br><span class=\"line\">                    &amp; <span class=\"number\">0xFFFFFFFFL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] md5(String value) &#123;</span><br><span class=\"line\">            MessageDigest md5;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                md5 = MessageDigest.getInstance(<span class=\"string\">\"MD5\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            md5.reset();</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] bytes;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                bytes = value.getBytes(<span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            md5.update(bytes);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> md5.digest();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"更新（2018-10-12）\"><a href=\"#更新（2018-10-12）\" class=\"headerlink\" title=\"更新（2018/10/12）\"></a>更新（2018/10/12）</h4><p>因为之前的RoundRobin LoadBalance算法存在性能问题，参考ISSUE<a href=\"https://github.com/apache/incubator-dubbo/issues/2578\" target=\"_blank\" rel=\"noopener\">https://github.com/apache/incubator-dubbo/issues/2578</a>。现在最新版本对其进行了优化，优化思路如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RoundRobinLoadBalance</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractLoadBalance</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String NAME = <span class=\"string\">\"roundrobin\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;String, AtomicPositiveInteger&gt; sequences = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;String, AtomicPositiveInteger&gt; indexSeqs = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">        String key = invokers.get(<span class=\"number\">0</span>).getUrl().getServiceKey() + <span class=\"string\">\".\"</span> + invocation.getMethodName();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">// Number of invokers</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxWeight = <span class=\"number\">0</span>; <span class=\"comment\">// The maximum weight</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> minWeight = Integer.MAX_VALUE; <span class=\"comment\">// The minimum weight</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;Invoker&lt;T&gt;&gt; nonZeroWeightedInvokers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">            maxWeight = Math.max(maxWeight, weight); <span class=\"comment\">// Choose the maximum weight</span></span><br><span class=\"line\">            minWeight = Math.min(minWeight, weight); <span class=\"comment\">// Choose the minimum weight</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (weight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                nonZeroWeightedInvokers.add(invokers.get(i));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        AtomicPositiveInteger sequence = sequences.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sequence == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            sequences.putIfAbsent(key, <span class=\"keyword\">new</span> AtomicPositiveInteger());</span><br><span class=\"line\">            sequence = sequences.get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxWeight &gt; <span class=\"number\">0</span> &amp;&amp; minWeight &lt; maxWeight) &#123;</span><br><span class=\"line\">            AtomicPositiveInteger indexSeq = indexSeqs.get(key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (indexSeq == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                indexSeqs.putIfAbsent(key, <span class=\"keyword\">new</span> AtomicPositiveInteger(-<span class=\"number\">1</span>));</span><br><span class=\"line\">                indexSeq = indexSeqs.get(key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            length = nonZeroWeightedInvokers.size();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> index = indexSeq.incrementAndGet() % length;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> currentWeight;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    currentWeight = sequence.incrementAndGet() % maxWeight;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    currentWeight = sequence.get() % maxWeight;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (getWeight(nonZeroWeightedInvokers.get(index), invocation) &gt; currentWeight) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> nonZeroWeightedInvokers.get(index);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Round robin</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(sequence.getAndIncrement() % length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://colobu.com/2016/12/04/smooth-weighted-round-robin-algorithm/\" target=\"_blank\" rel=\"noopener\">https://colobu.com/2016/12/04/smooth-weighted-round-robin-algorithm/</a></p>"},{"title":"Dubbo服务提供者发布及注册过程源码分析","date":"2018-09-09T12:24:34.000Z","_content":"\nDubbo服务端在启动服务时会经历怎样的调用过程？在收到消费者发送的请求后会经历怎样的调用过程？这篇文章主要针对以上两个调用过程并结合Dubbo源码进行分析。\n\n我们采用的是[**Consumer-Provider的Demo**](https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo)提供的示例，并按照[《Dubbo消费者调用过程源码分析》](https://shuaijunlan.github.io/2018/08/05/dubbo-consumer-calling-process-source-code-analysis/)中的分析思路，下面将对两种过程进行进一步分析，先来看一张服务发布过程的时序图(图片太大建议在新的窗口打开查看)，对服务发布与注册有个大致的了解：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/dubbo-provider.png?raw=true)\n\n<!-- more -->\n\n### Dubbo服务发布过程\n\n首先来看一下服务发布过程调用栈，我们将围绕这个调用栈一步步进行分析：\n\n```\n\"main@1\" prio=5 tid=0x1 nid=NA runnable\n  java.lang.Thread.State: RUNNABLE\n\t  at org.apache.dubbo.remoting.transport.netty4.NettyServer.doOpen(NettyServer.java:97)\n\t  at org.apache.dubbo.remoting.transport.AbstractServer.<init>(AbstractServer.java:63)\n\t  at org.apache.dubbo.remoting.transport.netty4.NettyServer.<init>(NettyServer.java:65)\n\t  at org.apache.dubbo.remoting.transport.netty4.NettyTransporter.bind(NettyTransporter.java:32)\n\t  at org.apache.dubbo.remoting.Transporter$Adaptive.bind(Transporter$Adaptive.java:-1)\n\t  at org.apache.dubbo.remoting.Transporters.bind(Transporters.java:56)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger.bind(HeaderExchanger.java:44)\n\t  at org.apache.dubbo.remoting.exchange.Exchangers.bind(Exchangers.java:70)\n\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.createServer(DubboProtocol.java:306)\n\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.openServer(DubboProtocol.java:283)\n\t  - locked <0x9ee> (a org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol)\n\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.export(DubboProtocol.java:267)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:57)\n\t  at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:63)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:100)\n\t  at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)\n\t  at org.apache.dubbo.registry.integration.RegistryProtocol.doLocalExport(RegistryProtocol.java:170)\n\t  - locked <0x9e2> (a java.util.concurrent.ConcurrentHashMap)\n\t  at org.apache.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:133)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)\n\t  at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:61)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)\n\t  at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)\n\t  at org.apache.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)\n\t  at org.apache.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)\n\t  at org.apache.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)\n\t  - locked <0x848> (a org.apache.dubbo.config.spring.ServiceBean)\n\t  at org.apache.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)\n\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:123)\n\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:49)\n\t  at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)\n\t  at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)\n\t  at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)\n\t  at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:393)\n\t  at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:347)\n\t  at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:883)\n\t  at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:546)\n\t  - locked <0xab7> (a java.lang.Object)\n\t  at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:139)\n\t  at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:83)\n\t  at cn.shuaijunlan.dubbo.learning.main.Main.main(Main.java:13)\n```\n\n关于Dubbo是如何基于Spring解析xml文件中配置的ServiceBean这里不再赘述，可以参考我之前写的文章[《基于Spring构建Dubbo源码分析》](https://shuaijunlan.github.io/2018/08/13/dubbo-basing-on-spring-framework-analysis/)，这里将从发布服务的起始点开始将其，我们来看下ServiceBean类的部分函数实现：\n\n```java\n//这个函数是实现了ApplicationListener接口的onApplicationEvent(E event)函数\n//\n@Override\npublic void onApplicationEvent(ContextRefreshedEvent event) {\n    if (isDelay() && !isExported() && !isUnexported()) {\n        if (logger.isInfoEnabled()) {\n            logger.info(\"The service ready on spring started. service: \" + getInterface());\n        }\n        //发布服务的起始点\n        export();\n    }\n}\n```\n\n上面调用的export()函数的实现在其子类ServiceConfig中：\n\n```java\n//这是一个同步方法，保证了多线程环境下的安全性\npublic synchronized void export() {\n    //获取export和delay属性\n    if (provider != null) {\n        if (export == null) {\n            export = provider.getExport();\n        }\n        if (delay == null) {\n            delay = provider.getDelay();\n        }\n    }\n    if (export != null && !export) {\n        return;\n    }\n\t//判断是否延迟发布\n    if (delay != null && delay > 0) {\n        //延迟delay时间后执行\n        delayExportExecutor.schedule(new Runnable() {\n            @Override\n            public void run() {\n                doExport();\n            }\n        }, delay, TimeUnit.MILLISECONDS);\n    } else {\n        //发布服务\n        doExport();\n    }\n}\n//使用synchonized进行同步，保证了线程安全性\nprotected synchronized void doExport() {\n    if (unexported) {\n        throw new IllegalStateException(\"Already unexported!\");\n    }\n    if (exported) {\n        return;\n    }\n    //将exported状态改为true\n    exported = true;\n    if (interfaceName == null || interfaceName.length() == 0) {\n        throw new IllegalStateException(\"<dubbo:service interface=\\\"\\\" /> interface not allow null!\");\n    }\n    checkDefault();\n    if (provider != null) {\n        if (application == null) {\n            application = provider.getApplication();\n        }\n        if (module == null) {\n            module = provider.getModule();\n        }\n        if (registries == null) {\n            registries = provider.getRegistries();\n        }\n        if (monitor == null) {\n            monitor = provider.getMonitor();\n        }\n        if (protocols == null) {\n            protocols = provider.getProtocols();\n        }\n    }\n    if (module != null) {\n        if (registries == null) {\n            registries = module.getRegistries();\n        }\n        if (monitor == null) {\n            monitor = module.getMonitor();\n        }\n    }\n    if (application != null) {\n        if (registries == null) {\n            registries = application.getRegistries();\n        }\n        if (monitor == null) {\n            monitor = application.getMonitor();\n        }\n    }\n    if (ref instanceof GenericService) {\n        interfaceClass = GenericService.class;\n        if (StringUtils.isEmpty(generic)) {\n            generic = Boolean.TRUE.toString();\n        }\n    } else {\n        try {\n            interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n                                           .getContextClassLoader());\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n        checkInterfaceAndMethods(interfaceClass, methods);\n        checkRef();\n        generic = Boolean.FALSE.toString();\n    }\n    if (local != null) {\n        if (\"true\".equals(local)) {\n            local = interfaceName + \"Local\";\n        }\n        Class<?> localClass;\n        try {\n            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n        if (!interfaceClass.isAssignableFrom(localClass)) {\n            throw new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceName);\n        }\n    }\n    if (stub != null) {\n        if (\"true\".equals(stub)) {\n            stub = interfaceName + \"Stub\";\n        }\n        Class<?> stubClass;\n        try {\n            stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n        if (!interfaceClass.isAssignableFrom(stubClass)) {\n            throw new IllegalStateException(\"The stub implementation class \" + stubClass.getName() + \" not implement interface \" + interfaceName);\n        }\n    }\n    checkApplication();\n    checkRegistry();\n    checkProtocol();\n    appendProperties(this);\n    checkStubAndMock(interfaceClass);\n    if (path == null || path.length() == 0) {\n        path = interfaceName;\n    }\n    doExportUrls();\n    ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref);\n    ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);\n}\n```\n\n在doExport()函数中调用了doExportUrls()方法，我们将进一步分析doExportUrls()方法：\n\n```java\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nprivate void doExportUrls() {\n    //支持多个注册中心\n    List<URL> registryURLs = loadRegistries(true);\n    for (ProtocolConfig protocolConfig : protocols) {\n        //执行doExportUrlsFor1Protocol方法\n        doExportUrlsFor1Protocol(protocolConfig, registryURLs);\n    }\n}\n\nprivate void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {\n    String name = protocolConfig.getName();\n    if (name == null || name.length() == 0) {\n        name = \"dubbo\";\n    }\n\n    Map<String, String> map = new HashMap<String, String>();\n    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);\n    map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());\n    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n    if (ConfigUtils.getPid() > 0) {\n        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n    }\n    appendParameters(map, application);\n    appendParameters(map, module);\n    appendParameters(map, provider, Constants.DEFAULT_KEY);\n    appendParameters(map, protocolConfig);\n    appendParameters(map, this);\n    if (methods != null && !methods.isEmpty()) {\n        for (MethodConfig method : methods) {\n            appendParameters(map, method, method.getName());\n            String retryKey = method.getName() + \".retry\";\n            if (map.containsKey(retryKey)) {\n                String retryValue = map.remove(retryKey);\n                if (\"false\".equals(retryValue)) {\n                    map.put(method.getName() + \".retries\", \"0\");\n                }\n            }\n            List<ArgumentConfig> arguments = method.getArguments();\n            if (arguments != null && !arguments.isEmpty()) {\n                for (ArgumentConfig argument : arguments) {\n                    // convert argument type\n                    if (argument.getType() != null && argument.getType().length() > 0) {\n                        Method[] methods = interfaceClass.getMethods();\n                        // visit all methods\n                        if (methods != null && methods.length > 0) {\n                            for (int i = 0; i < methods.length; i++) {\n                                String methodName = methods[i].getName();\n                                // target the method, and get its signature\n                                if (methodName.equals(method.getName())) {\n                                    Class<?>[] argtypes = methods[i].getParameterTypes();\n                                    // one callback in the method\n                                    if (argument.getIndex() != -1) {\n                                        if (argtypes[argument.getIndex()].getName().equals(argument.getType())) {\n                                            appendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n                                        } else {\n                                            throw new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n                                        }\n                                    } else {\n                                        // multiple callbacks in the method\n                                        for (int j = 0; j < argtypes.length; j++) {\n                                            Class<?> argclazz = argtypes[j];\n                                            if (argclazz.getName().equals(argument.getType())) {\n                                                appendParameters(map, argument, method.getName() + \".\" + j);\n                                                if (argument.getIndex() != -1 && argument.getIndex() != j) {\n                                                    throw new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else if (argument.getIndex() != -1) {\n                        appendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n                    } else {\n                        throw new IllegalArgumentException(\"argument config must set index or type attribute.eg: <dubbo:argument index='0' .../> or <dubbo:argument type=xxx .../>\");\n                    }\n\n                }\n            }\n        } // end of methods for\n    }\n\n    if (ProtocolUtils.isGeneric(generic)) {\n        map.put(Constants.GENERIC_KEY, generic);\n        map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n    } else {\n        String revision = Version.getVersion(interfaceClass, version);\n        if (revision != null && revision.length() > 0) {\n            map.put(\"revision\", revision);\n        }\n\n        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n        if (methods.length == 0) {\n            logger.warn(\"NO method found in service interface \" + interfaceClass.getName());\n            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n        } else {\n            map.put(Constants.METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), \",\"));\n        }\n    }\n    if (!ConfigUtils.isEmpty(token)) {\n        if (ConfigUtils.isDefault(token)) {\n            map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());\n        } else {\n            map.put(Constants.TOKEN_KEY, token);\n        }\n    }\n    if (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) {\n        protocolConfig.setRegister(false);\n        map.put(\"notify\", \"false\");\n    }\n    // export service\n    String contextPath = protocolConfig.getContextpath();\n    if ((contextPath == null || contextPath.length() == 0) && provider != null) {\n        contextPath = provider.getContextpath();\n    }\n\n    String host = this.findConfigedHosts(protocolConfig, registryURLs, map);\n    Integer port = this.findConfigedPorts(protocolConfig, name, map);\n    URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? \"\" : contextPath + \"/\") + path, map);\n\n    if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)\n        .hasExtension(url.getProtocol())) {\n        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)\n            .getExtension(url.getProtocol()).getConfigurator(url).configure(url);\n    }\n\n    String scope = url.getParameter(Constants.SCOPE_KEY);\n    // don't export when none is configured\n    if (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) {\n\n        // export to local if the config is not remote (export to remote only when config is remote)\n        if (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) {\n            //本地暴露（分析1）\n            exportLocal(url);\n        }\n        // export to remote if the config is not local (export to local only when config is local)\n        //如果配置不是local则暴露为远程服务\n        if (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url);\n            }\n            if (registryURLs != null && !registryURLs.isEmpty()) {\n                //多个注册中心\n                for (URL registryURL : registryURLs) {\n                    url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));\n                    URL monitorUrl = loadMonitor(registryURL);\n                    if (monitorUrl != null) {\n                        url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());\n                    }\n                    if (logger.isInfoEnabled()) {\n                        logger.info(\"Register dubbo service \" + interfaceClass.getName() + \" url \" + url + \" to registry \" + registryURL);\n                    }\n\n                    // For providers, this is used to enable custom proxy to generate invoker\n                    String proxy = url.getParameter(Constants.PROXY_KEY);\n                    if (StringUtils.isNotEmpty(proxy)) {\n                        registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);\n                    }\n\t\t\t\t\t//根据Java SPI机制得到ProxyFactory$Adaptive类的实例proxyFactory\n                    Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n                    //获取包装类??\n                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\t\t\t\t\t//调用Protocol$Adaptive的export()方法\n                    Exporter<?> exporter = protocol.export(wrapperInvoker);\n                    exporters.add(exporter);\n                }\n            } else {\n                //没有注册中心，只在本机IP打开服务端口生成服务代理，并不注册到注册中心\n                Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);\n                DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n                Exporter<?> exporter = protocol.export(wrapperInvoker);\n                exporters.add(exporter);\n            }\n        }\n    }\n    this.urls.add(url);\n}\n```\n\n#### 本地服务发布过程\n\n首先是进入exportLocal()函数：\n\n```java\nprivate void exportLocal(URL url) {\n    if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {\n        URL local = URL.valueOf(url.toFullString())\n            .setProtocol(Constants.LOCAL_PROTOCOL)\n            .setHost(LOCALHOST)\n            .setPort(0);\n        ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));\n        //这是核心步骤，先是执行proxyFactory.getInvoker()方法生成invoker，然后是执行protocol.export()方法暴露服务，下面将会分别介绍\n        Exporter<?> exporter = protocol.export(\n            proxyFactory.getInvoker(ref, (Class) interfaceClass, local));\n        exporters.add(exporter);\n        logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to local registry\");\n    }\n}\n```\n\n##### 分析proxyFactory.getInvoker()过程\n\n通过Dubbo SPI机制（详见[《Dubbo SPI机制源码分析》](https://shuaijunlan.github.io/2018/08/09/dubbo-spi-analysis/)），proxyFactory是ProxyFactory$Adaptive类的实例，我们来看它的getInvoker()方法：\n\n```java\n//传入三个参数，分别是ref、interfaceClass和url\npublic org.apache.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2) throws org.apache.dubbo.rpc.RpcException {\n    if (arg2 == null) throw new IllegalArgumentException(\"url == null\");\n    org.apache.dubbo.common.URL url = arg2;\n    //默认是使用Javassist生成代理\n    String extName = url.getParameter(\"proxy\", \"javassist\");\n    if (extName == null)\n        throw new IllegalStateException(\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n    //根据Dubbo SPI机制得到JavassistProxyFactory扩展类\n    org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n    return extension.getInvoker(arg0, arg1, arg2);\n}\n```\n\n然后调用extension.getInvoker()方法，这里的extension，默认是JavassistProxyFactory类的实例（也是基于Java SPI机制），然后调用它的getInvoker()方法：\n\n```java\n@Override\npublic <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n    // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'\n    //获取包装类,具体代码是怎样的？\n    final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n    return new AbstractProxyInvoker<T>(proxy, type, url) {\n        @Override\n        protected Object doInvoke(T proxy, String methodName,\n                                  Class<?>[] parameterTypes,\n                                  Object[] arguments) throws Throwable {\n            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n        }\n    };\n}\n```\n\n这里以文章开头的Demo为例，通过Wrapper.getWrapper()返回的类代码，这里需要代码hack：\n\n```java\npackage com.alibaba.dubbo.common.bytecode;\n\nimport com.alibaba.dubbo.common.DemoService;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Map;\n\npublic class Wrapper0 extends Wrapper\n  implements ClassGenerator.DC\n{\n  public static String[] pns;\n  public static Map pts;\n  public static String[] mns;\n  public static String[] dmns;\n  public static Class[] mts0;\n\n  public String[] getPropertyNames()\n  {\n    return pns;\n  }\n\n  public boolean hasProperty(String paramString)\n  {\n    return pts.containsKey(paramString);\n  }\n\n  public Class getPropertyType(String paramString)\n  {\n    return (Class)pts.get(paramString);\n  }\n\n  public String[] getMethodNames()\n  {\n    return mns;\n  }\n\n  public String[] getDeclaredMethodNames()\n  {\n    return dmns;\n  }\n\n  public void setPropertyValue(Object paramObject1, String paramString, Object paramObject2)\n  {\n    try\n    {\n      DemoService localDemoService = (DemoService)paramObject1;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new IllegalArgumentException(localThrowable);\n    }\n    throw new NoSuchPropertyException(\"Not found property \\\"\" + paramString + \"\\\" filed or setter method in class com.alibaba.dubbo.common.DemoService.\");\n  }\n\n  public Object getPropertyValue(Object paramObject, String paramString)\n  {\n    try\n    {\n      DemoService localDemoService = (DemoService)paramObject;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new IllegalArgumentException(localThrowable);\n    }\n    throw new NoSuchPropertyException(\"Not found property \\\"\" + paramString + \"\\\" filed or setter method in class com.alibaba.dubbo.common.DemoService.\");\n  }\n   \n  //(**看这里，关键方法实现****)\n  public Object invokeMethod(Object paramObject, String paramString, Class[] paramArrayOfClass, Object[] paramArrayOfObject)\n    throws InvocationTargetException\n  {\n    DemoService localDemoService;\n    try\n    {\n    //赋值执行实例，这里是接口实现类，DemoServiceImpl对象\n      localDemoService = (DemoService)paramObject;\n    }\n    catch (Throwable localThrowable1)\n    {\n      throw new IllegalArgumentException(localThrowable1);\n    }\n    try\n    {\n    //根据传入的要调用的方法名paramString,方法参数值，调用执行实例方法\n      if ((\"sayHello\".equals(paramString)) || (paramArrayOfClass.length == 1))\n        return localDemoService.sayHello((String)paramArrayOfObject[0]);\n    }\n    catch (Throwable localThrowable2)\n    {\n      throw new InvocationTargetException(localThrowable2);\n    }\n    throw new NoSuchMethodException(\"Not found method \\\"\" + paramString + \"\\\" in class com.alibaba.dubbo.common.DemoService.\");\n  }\n}\n```\n\n到这就比较清楚了解具体的代理的过程了。\n\n##### 分析protocol.export()过程\n\n上面的过程已经生成好了invoker对象，接下来就要通过Protocol$Adaptive的export()方法暴露服务：\n\n```java\npublic org.apache.dubbo.rpc.Exporter export(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException {\n    if (arg0 == null) throw new IllegalArgumentException(\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument == null\");\n    if (arg0.getUrl() == null)\n        throw new IllegalArgumentException(\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument getUrl() == null\");\n    org.apache.dubbo.common.URL url = arg0.getUrl();\n    String extName = (url.getProtocol() == null ? \"MEAT-INF.dubbo\" : url.getProtocol());\n    if (extName == null)\n        throw new IllegalStateException(\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n    //因为这是本地服务发布，因此protocol为injvm\n    //所以这里会走到InjvmProtocol的export()方法\n    org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n    return extension.export(arg0);\n}\n```\n\n看下InjvmProtocol的export()方法\n\n```java\n@Override\npublic <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n    //返回InjvmExporter对象\n    return new InjvmExporter<T>(invoker, invoker.getUrl().getServiceKey(), exporterMap);\n}\n```\n\nInjvmExporter的构造函数：\n\n```java\nInjvmExporter(Invoker<T> invoker, String key, Map<String, Exporter<?>> exporterMap) {\n    super(invoker);\n    this.key = key;\n    this.exporterMap = exporterMap;\n    //存的形式，serviceKey:自身(exporter) put到map关联起来，这样可以通过servciekey找到exporterMap然后找到invoker\n    exporterMap.put(key, this);\n}\n```\n\n这里的exporterMap是由InjvmProtocol实例拥有，而InjvmProtocol又是单例的，因为InjvmProtocol类有如下实例和方法：\n\n```java\n//静态自身成员变量\nprivate static InjvmProtocol INSTANCE;\n//构造方法，把自己赋值给INSTANCE对象\npublic InjvmProtocol() {\n    INSTANCE = this;\n}\n```\n\n所以exporterMap对象也是单例的，同时这里顺便看下InjvmProtocol的refer()方法，本地服务的引用查找也是通过自身的exporterMap对象：\n\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {\n    //把exporterMap对象赋值给InjvmInvoker\n    return new InjvmInvoker<T>(serviceType, url, url.getServiceKey(), exporterMap);\n}\n//具体查找过程\n@Override\npublic Result doInvoke(Invocation invocation) throws Throwable {\n    //通过exporterMap获取exporter\n    Exporter<?> exporter = InjvmProtocol.getExporter(exporterMap, getUrl());\n    if (exporter == null) {\n        throw new RpcException(\"Service [\" + key + \"] not found.\");\n    }\n    RpcContext.getContext().setRemoteAddress(NetUtils.LOCALHOST, 0);\n    return exporter.getInvoker().invoke(invocation);\n}\n```\n\n以上的所有步骤就是本地服务的发布和引用过程。\n\n#### 远程服务发布\n\n上面调用了proFactory的getInvoker()方法，我们来看一下`ProxyFactory$Adaptive.getInvoker()`的代码：\n\n```java\n//传入三个参数，分别是ref、interfaceClass和url\npublic org.apache.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2) throws org.apache.dubbo.rpc.RpcException {\n    if (arg2 == null) throw new IllegalArgumentException(\"url == null\");\n    org.apache.dubbo.common.URL url = arg2;\n    //默认是使用Javassist生成代理\n    String extName = url.getParameter(\"proxy\", \"javassist\");\n    if (extName == null)\n        throw new IllegalStateException(\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n    //根据Dubbo SPI机制得到JavassistProxyFactory扩展类\n    org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n    return extension.getInvoker(arg0, arg1, arg2);\n}\n```\n\n再来看一下`JavassistProxyFactory.getInvoker()`方法：\n\n```java\n@Override\npublic <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n    // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'\n    //获取包装类,具体代码是怎样的？\n    final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n    return new AbstractProxyInvoker<T>(proxy, type, url) {\n        @Override\n        protected Object doInvoke(T proxy, String methodName,\n                                  Class<?>[] parameterTypes,\n                                  Object[] arguments) throws Throwable {\n            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n        }\n    };\n}\n```\n\n在doExportUrlsFor1Protocol()方法中还调用了`Protocol$Adaptive.export()`方法：\n\n```java\npublic org.apache.dubbo.rpc.Exporter export(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException {\n    if (arg0 == null) throw new IllegalArgumentException(\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument == null\");\n    if (arg0.getUrl() == null)\n        throw new IllegalArgumentException(\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument getUrl() == null\");\n    org.apache.dubbo.common.URL url = arg0.getUrl();\n    String extName = (url.getProtocol() == null ? \"MEAT-INF.dubbo\" : url.getProtocol());\n    if (extName == null)\n        throw new IllegalStateException(\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n    org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n    return extension.export(arg0);\n}\n```\n\n根据Dubbo SPI机制可以看出调用`RegistryProtocol.export()`方法，Protocol还定义了ProtocolFilterWrapper、QosProtocolWrapper和ProtocolListenerWrapper三个Wrapper扩展点，根据ExtensionLoader的加载规则，他会返回`ProtocolFilterWrapper->QosProtocolWrapper->ProtocolListenerWrapper->RegistryProtocol`（对象链调用顺序还待进一步求证）对象链：\n\n```java\n@Override\npublic <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {\n    //export invoker\n    //暴露invoker（暴露服务过程从这里开始，看doLocalExport()）\n    final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);\n\t\n    URL registryUrl = getRegistryUrl(originInvoker);\n\n    //registry provider\n    //获取对应注册中心操作对象\n    final Registry registry = getRegistry(originInvoker);\n    //获取要注册到注册中心的地址\n    final URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);\n\n    //to judge to delay publish whether or not\n    boolean register = registeredProviderUrl.getParameter(\"register\", true);\n\n    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);\n\t//判断是否注册服务\n    if (register) {\n        //执行注册(服务注册过程从这里开始)\n        register(registryUrl, registeredProviderUrl);\n        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);\n    }\n\n    // Subscribe the override data\n    // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.\n    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);\n    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);\n    //Ensure that a new exporter instance is returned every time export\n    //保证每次export都返回一个新的exporter实例\n    return new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);\n}\n```\n\n因此有如下的调用栈：\n\n```\nat org.apache.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:133)\nat org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)\nat org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:61)\nat org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)\nat org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)\n```\n\n继续看执行服务暴露的函数`doLocalExport()`:\n\n```java\n@SuppressWarnings(\"unchecked\")\nprivate <T> ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker) {\n    //通过原始originInvoker构造缓存key\n    String key = getCacheKey(originInvoker);\n    ExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n    //没有缓存，走具体暴露流程\n    if (exporter == null) {\n        synchronized (bounds) {\n            exporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n            if (exporter == null) {\n                //InvokerDelegete是RegistryProtocol类的静态内部类，继承自InvokerWrapper，\n\t\t    \t//通过构造器赋值持有代理originInvoker和服务暴露协议url对象,算是包装一层\n                //而url 是通过getProviderUrl(originInvoker)返回的，此时url的协议已是dubbo，即服务暴露的协议\n                final Invoker<?> invokerDelegete = new InvokerDelegete<T>(originInvoker, getProviderUrl(originInvoker));\n                \n                //ExporterChangeableWrapper是RegistryProtocol的私有内部类实现了Exporter接口。\n                //通过调用它的构造方法(Exporter<T> exporter, Invoker<T> originInvoker)构造exporterWrapper实例\n\t\t    \t//而这里传入的exporter是通过(Exporter<T>) protocol.export(invokerDelegete)语句创建\n\t\t    \t//由上一步知道，这里的invokerDelegete里url属性的protocol协议已经是dubbo\n                //下面具体看下protocol.export(invokerDelegete)方法。\n                exporter = new ExporterChangeableWrapper<T>((Exporter<T>) protocol.export(invokerDelegete), originInvoker);\n                bounds.put(key, exporter);\n            }\n        }\n    }\n    return exporter;\n}\n```\n\n再继续往下看，通过调用Protocol$Adaptive类的export()方法，然后再调用DubboProtocol的export()方法，同理在这里也会生成`ProtocolFilterWrapper->QosProtocolWrapper->ProtocolListenerWrapper->DubboProtocol`对象链：\n\n```java\n@Override\npublic <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n    URL url = invoker.getUrl();\n\n    // export service.\n    //获取service key\n    //key的组成group/service:version:port\n    String key = serviceKey(url);\n    //构造服务的exporter\n    //如同InjvmProtocol一样，DubboProtocol也是单例的，所以这里exporterMap也是单例的\n    DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);\n    //通过key放入exporterMap，把持有invoker的exporter 和serviceKey关联\n    //这个在后面服务调用时，可以通过key找到对应的exporter进而找到invoker提供服务\n    exporterMap.put(key, exporter);\n\n    //export an stub service for dispatching event\n    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);\n    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false);\n    if (isStubSupportEvent && !isCallbackservice) {\n        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);\n        if (stubServiceMethods == null || stubServiceMethods.length() == 0) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(new IllegalStateException(\"consumer [\" + url.getParameter(Constants.INTERFACE_KEY) +\n                                                      \"], has set stubproxy support event ,but no stub methods founded.\"));\n            }\n        } else {\n            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);\n        }\n    }\n\t//根据url开启一个服务，比如绑定端口，开始接受请求\n    openServer(url);\n    optimizeSerialization(url);\n    return exporter;\n}\n```\n\n到这里就可以对应下面的调用栈：\n\n```\nat org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.export(DubboProtocol.java:267)\nat org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:57)\nat org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:63)\nat org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:100)\nat org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)\nat org.apache.dubbo.registry.integration.RegistryProtocol.doLocalExport(RegistryProtocol.java:170)\n```\n\n再继续看openServer()方法\n\n```java\nprivate void openServer(URL url) {\n    // find server.\n    //key=host:port 用于定位server\n    String key = url.getAddress();\n    //client can export a service which's only for server to invoke\n    //client也可以暴露一个只有server可以调用的服务\n    boolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);\n    if (isServer) {\n        //服务实例放到serverMap中，key是host:port\n        //这里serverMap也是单例的\n        ExchangeServer server = serverMap.get(key);\n        if (server == null) {\n            synchronized (this) {\n                server = serverMap.get(key);\n                if (server == null) {\n                    //通过createServer(url)方法获取server\n                    serverMap.put(key, createServer(url));\n                }\n            }\n        } else {\n            // server supports reset, use together with override\n            //server支持reset，配合override使用\n            server.reset(url);\n        }\n    }\n}\n```\n\n再继续看createServer()代码：\n\n```java\nprivate ExchangeServer createServer(URL url) {\n    // send readonly event when server closes, it's enabled by default\n    //默认开启server关闭时关闭readonly事件\n    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());\n    // enable heartbeat by default\n    //默认开启heartbeat\n    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));\n    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);\n\t//通过server key检查是否是dubbo目前spi扩展支持的传输框架，默认是netty\n    if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))\n        throw new RpcException(\"Unsupported server type: \" + str + \", url: \" + url);\n\t//通过codec key获取编码方法，默认是dubbo\n    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);\n    ExchangeServer server;\n    try {\n        //构造具体服务实例，\n\t    //Exchangers是门面类，里面封装了具体交换层实现，并调用它的bind方法\n        server = Exchangers.bind(url, requestHandler);\n    } catch (RemotingException e) {\n        throw new RpcException(\"Fail to start server(url: \" + url + \") \" + e.getMessage(), e);\n    }\n    //这里会验证一下客户端传输实现\n    //如果没有对应的实现，会抛出异常\n    str = url.getParameter(Constants.CLIENT_KEY);\n    if (str != null && str.length() > 0) {\n        Set<String> supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();\n        if (!supportedTypes.contains(str)) {\n            throw new RpcException(\"Unsupported client type: \" + str);\n        }\n    }\n    return server;\n}\n```\n\n继续看Exchanges类的bind()方法：\n\n```java\npublic static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {\n    if (url == null) {\n        throw new IllegalArgumentException(\"url == null\");\n    }\n    if (handler == null) {\n        throw new IllegalArgumentException(\"handler == null\");\n    }\n    url = url.addParameterIfAbsent(Constants.CODEC_KEY, \"exchange\");\n    return getExchanger(url).bind(url, handler);\n}\n\npublic static Exchanger getExchanger(URL url) {\n    String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);\n    return getExchanger(type);\n}\n\npublic static Exchanger getExchanger(String type) {\n    return ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);\n}\n\n//HeaderExchanger类的bind()方法\n@Override\npublic ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {\n    return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));\n}\n```\n\n继续跟进Transporters.bind()方法：\n\n```java\npublic static Server bind(URL url, ChannelHandler... handlers) throws RemotingException {\n    if (url == null) {\n        throw new IllegalArgumentException(\"url == null\");\n    }\n    if (handlers == null || handlers.length == 0) {\n        throw new IllegalArgumentException(\"handlers == null\");\n    }\n    ChannelHandler handler;\n    if (handlers.length == 1) {\n        handler = handlers[0];\n    } else {\n        handler = new ChannelHandlerDispatcher(handlers);\n    }\n    //根据Dubbo SPI机制，这里走NettyTransporter.bind()方法\n    return getTransporter().bind(url, handler);\n}\npublic static Transporter getTransporter() {\n    return ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();\n}\n\n//NettyTransporter的bind方法\npublic Server bind(URL url, ChannelHandler listener) throws RemotingException {\n    //可以看到这里是NettyServer实例\n    return new NettyServer(url, listener);\n}\n\n//NettyServer构造器\npublic NettyServer(URL url, ChannelHandler handler) throws RemotingException {\n    //调用父类AbstractServer构造器\n    //注意下这里的ChannelHandlers.wrap()方法，生成MultiMessageHandler->HeartbeatHandler->AllChannelHandler的调用链\n    super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));\n}\n```\n\n看一下父类AbstractServer()的构造函数：\n\n```java\npublic AbstractServer(URL url, ChannelHandler handler) throws RemotingException {\n    super(url, handler);\n    localAddress = getUrl().toInetSocketAddress();\n\n    String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());\n    int bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());\n    if (url.getParameter(Constants.ANYHOST_KEY, false) || NetUtils.isInvalidLocalHost(bindIp)) {\n        bindIp = NetUtils.ANYHOST;\n    }\n    bindAddress = new InetSocketAddress(bindIp, bindPort);\n    this.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);\n    this.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);\n    try {\n        //打开端口，启动服务\n        doOpen();\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Start \" + getClass().getSimpleName() + \" bind \" + getBindAddress() + \", export \" + getLocalAddress());\n        }\n    } catch (Throwable t) {\n        throw new RemotingException(url.toInetSocketAddress(), null, \"Failed to bind \" + getClass().getSimpleName()\n                                    + \" on \" + getLocalAddress() + \", cause: \" + t.getMessage(), t);\n    }\n    //fixme replace this with better method\n    DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();\n    executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));\n}\n```\n\n再来看NettyServer的doOpen()方法：\n\n```java\n@Override\nprotected void doOpen() throws Throwable {\n    bootstrap = new ServerBootstrap();\n\n    bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory(\"NettyServerBoss\", true));\n    workerGroup = new NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),\n                                        new DefaultThreadFactory(\"NettyServerWorker\", true));\n\n    final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this);\n    channels = nettyServerHandler.getChannels();\n\n    bootstrap.group(bossGroup, workerGroup)\n        .channel(NioServerSocketChannel.class)\n        .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)\n        .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)\n        .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n        .childHandler(new ChannelInitializer<NioSocketChannel>() {\n            @Override\n            protected void initChannel(NioSocketChannel ch) throws Exception {\n                NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);\n                ch.pipeline()//.addLast(\"logging\",new LoggingHandler(LogLevel.INFO))//for debug\n                    .addLast(\"decoder\", adapter.getDecoder())\n                    .addLast(\"encoder\", adapter.getEncoder())\n                    .addLast(\"handler\", nettyServerHandler);\n            }\n        });\n    // bind\n    //bind地址，开启端口\n    ChannelFuture channelFuture = bootstrap.bind(getBindAddress());\n    channelFuture.syncUninterruptibly();\n    channel = channelFuture.channel();\n\n}\n```\n\n分析到这里可以对应如下的调用栈：\n\n```java\nat org.apache.dubbo.remoting.transport.netty4.NettyServer.doOpen(NettyServer.java:97)\n    at org.apache.dubbo.remoting.transport.AbstractServer.<init>(AbstractServer.java:63)\n    at org.apache.dubbo.remoting.transport.netty4.NettyServer.<init>(NettyServer.java:65)\n    at org.apache.dubbo.remoting.transport.netty4.NettyTransporter.bind(NettyTransporter.java:32)\n    at org.apache.dubbo.remoting.Transporter$Adaptive.bind(Transporter$Adaptive.java:-1)\n    at org.apache.dubbo.remoting.Transporters.bind(Transporters.java:56)\n    at org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger.bind(HeaderExchanger.java:44)\n    at org.apache.dubbo.remoting.exchange.Exchangers.bind(Exchangers.java:70)\n    at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.createServer(DubboProtocol.java:306)\n    at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.openServer(DubboProtocol.java:283)\n```\n\n分析到这里Dubbo服务提供者服务发布过程源码分析已经完成了，下面将继续分析服务注册过程。\n\n### Dubbo服务注册过程\n\n在之前的分析中，我们知道注册服务的过程是从RegistryProtocol的export()方法开始的，我们来看一下export()方法：\n\n```java\n@Override\npublic <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {\n    //export invoker\n    final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);\n\n    URL registryUrl = getRegistryUrl(originInvoker);\n\n    //registry provider\n    final Registry registry = getRegistry(originInvoker);\n    final URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);\n\n    //to judge to delay publish whether or not\n    boolean register = registeredProviderUrl.getParameter(\"register\", true);\n\n    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);\n\n    if (register) {\n        //注册服务从这里开始\n        register(registryUrl, registeredProviderUrl);\n        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);\n    }\n\n    // Subscribe the override data\n    // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.\n    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);\n    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);\n    //Ensure that a new exporter instance is returned every time export\n    return new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);\n}\n```\n\n我们再继续看register()方法：\n\n```java\npublic void register(URL registryUrl, URL registedProviderUrl) {\n    //registryFactory是由Dubbo SPI机制生成的RegistryFactory$Adaptive的实例\n    //调用其的getRegistry()方法获得registry\n    Registry registry = registryFactory.getRegistry(registryUrl);\n    registry.register(registedProviderUrl);\n}\n```\n\n我们来看一下RegistryFactory$Adaptive类的getRegistry()方法：\n\n```java\npublic org.apache.dubbo.registry.Registry getRegistry(org.apache.dubbo.common.URL arg0) {\n    if (arg0 == null) throw new IllegalArgumentException(\"url == null\");\n    org.apache.dubbo.common.URL url = arg0;\n    String extName = (url.getProtocol() == null ? \"dubbo\" : url.getProtocol());\n    if (extName == null)\n        throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.registry.RegistryFactory) name from url(\" + url.toString() + \") use keys([protocol])\");\n    org.apache.dubbo.registry.RegistryFactory extension = null;\n    try {\n\t\t//得到ZookeeperRegistryFactory的实例extension\n        extension = (org.apache.dubbo.registry.RegistryFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.registry.RegistryFactory.class).getExtension(extName);\n    } catch (Exception e) {\n        if (count.incrementAndGet() == 1) {\n            logger.warn(\"Failed to find extension named \" + extName + \" for type org.apache.dubbo.registry.RegistryFactory, will use default extension dubbo instead.\", e);\n        }\n        extension = (org.apache.dubbo.registry.RegistryFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.registry.RegistryFactory.class).getExtension(\"dubbo\");\n    }\n    return extension.getRegistry(arg0);\n}\n```\n\n先调用ZookeeperRegister的父类FailbackRegistry的register()方法：\n\n```java\n@Override\npublic void register(URL url) {\n    super.register(url);\n    failedRegistered.remove(url);\n    failedUnregistered.remove(url);\n    try {\n        // Sending a registration request to the server side\n        doRegister(url);\n    } catch (Exception e) {\n        Throwable t = e;\n\n        // If the startup detection is opened, the Exception is thrown directly.\n        boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n            && url.getParameter(Constants.CHECK_KEY, true)\n            && !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());\n        boolean skipFailback = t instanceof SkipFailbackWrapperException;\n        if (check || skipFailback) {\n            if (skipFailback) {\n                t = t.getCause();\n            }\n            throw new IllegalStateException(\"Failed to register \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t);\n        } else {\n            logger.error(\"Failed to register \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n        }\n\n        // Record a failed registration request to a failed list, retry regularly\n        failedRegistered.add(url);\n    }\n}\n```\n\n最后执行ZookeeperRegistry的doRegister()方法，向服务端发送注册请求：\n\n```java\n@Override\nprotected void doRegister(URL url) {\n    try {\n        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));\n    } catch (Throwable e) {\n        throw new RpcException(\"Failed to register \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n    }\n}\n```\n\n服务注册调用栈：\n\n```\n\"main@1\" prio=5 tid=0x1 nid=NA runnable\n  java.lang.Thread.State: RUNNABLE\n\t  at org.apache.dubbo.registry.zookeeper.ZookeeperRegistry.doRegister(ZookeeperRegistry.java:114)\n\t  at org.apache.dubbo.registry.support.FailbackRegistry.register(FailbackRegistry.java:137)\n\t  at org.apache.dubbo.registry.integration.RegistryProtocol.register(RegistryProtocol.java:127)\n\t  at org.apache.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:147)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)\n\t  at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:61)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)\n\t  at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)\n\t  at org.apache.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)\n\t  at org.apache.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)\n\t  at org.apache.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)\n\t  - locked <0x9bb> (a org.apache.dubbo.config.spring.ServiceBean)\n\t  at org.apache.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)\n\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:123)\n\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:49)\n```\n\n\n","source":"_posts/dubbo-provider-calling-process-source-code-analysis.md","raw":"---\ntitle: Dubbo服务提供者发布及注册过程源码分析\ndate: 2018-09-09 20:24:34\ntags:\n    - dubbo\n---\n\nDubbo服务端在启动服务时会经历怎样的调用过程？在收到消费者发送的请求后会经历怎样的调用过程？这篇文章主要针对以上两个调用过程并结合Dubbo源码进行分析。\n\n我们采用的是[**Consumer-Provider的Demo**](https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo)提供的示例，并按照[《Dubbo消费者调用过程源码分析》](https://shuaijunlan.github.io/2018/08/05/dubbo-consumer-calling-process-source-code-analysis/)中的分析思路，下面将对两种过程进行进一步分析，先来看一张服务发布过程的时序图(图片太大建议在新的窗口打开查看)，对服务发布与注册有个大致的了解：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/dubbo-provider.png?raw=true)\n\n<!-- more -->\n\n### Dubbo服务发布过程\n\n首先来看一下服务发布过程调用栈，我们将围绕这个调用栈一步步进行分析：\n\n```\n\"main@1\" prio=5 tid=0x1 nid=NA runnable\n  java.lang.Thread.State: RUNNABLE\n\t  at org.apache.dubbo.remoting.transport.netty4.NettyServer.doOpen(NettyServer.java:97)\n\t  at org.apache.dubbo.remoting.transport.AbstractServer.<init>(AbstractServer.java:63)\n\t  at org.apache.dubbo.remoting.transport.netty4.NettyServer.<init>(NettyServer.java:65)\n\t  at org.apache.dubbo.remoting.transport.netty4.NettyTransporter.bind(NettyTransporter.java:32)\n\t  at org.apache.dubbo.remoting.Transporter$Adaptive.bind(Transporter$Adaptive.java:-1)\n\t  at org.apache.dubbo.remoting.Transporters.bind(Transporters.java:56)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger.bind(HeaderExchanger.java:44)\n\t  at org.apache.dubbo.remoting.exchange.Exchangers.bind(Exchangers.java:70)\n\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.createServer(DubboProtocol.java:306)\n\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.openServer(DubboProtocol.java:283)\n\t  - locked <0x9ee> (a org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol)\n\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.export(DubboProtocol.java:267)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:57)\n\t  at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:63)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:100)\n\t  at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)\n\t  at org.apache.dubbo.registry.integration.RegistryProtocol.doLocalExport(RegistryProtocol.java:170)\n\t  - locked <0x9e2> (a java.util.concurrent.ConcurrentHashMap)\n\t  at org.apache.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:133)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)\n\t  at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:61)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)\n\t  at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)\n\t  at org.apache.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)\n\t  at org.apache.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)\n\t  at org.apache.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)\n\t  - locked <0x848> (a org.apache.dubbo.config.spring.ServiceBean)\n\t  at org.apache.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)\n\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:123)\n\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:49)\n\t  at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)\n\t  at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)\n\t  at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)\n\t  at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:393)\n\t  at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:347)\n\t  at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:883)\n\t  at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:546)\n\t  - locked <0xab7> (a java.lang.Object)\n\t  at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:139)\n\t  at org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:83)\n\t  at cn.shuaijunlan.dubbo.learning.main.Main.main(Main.java:13)\n```\n\n关于Dubbo是如何基于Spring解析xml文件中配置的ServiceBean这里不再赘述，可以参考我之前写的文章[《基于Spring构建Dubbo源码分析》](https://shuaijunlan.github.io/2018/08/13/dubbo-basing-on-spring-framework-analysis/)，这里将从发布服务的起始点开始将其，我们来看下ServiceBean类的部分函数实现：\n\n```java\n//这个函数是实现了ApplicationListener接口的onApplicationEvent(E event)函数\n//\n@Override\npublic void onApplicationEvent(ContextRefreshedEvent event) {\n    if (isDelay() && !isExported() && !isUnexported()) {\n        if (logger.isInfoEnabled()) {\n            logger.info(\"The service ready on spring started. service: \" + getInterface());\n        }\n        //发布服务的起始点\n        export();\n    }\n}\n```\n\n上面调用的export()函数的实现在其子类ServiceConfig中：\n\n```java\n//这是一个同步方法，保证了多线程环境下的安全性\npublic synchronized void export() {\n    //获取export和delay属性\n    if (provider != null) {\n        if (export == null) {\n            export = provider.getExport();\n        }\n        if (delay == null) {\n            delay = provider.getDelay();\n        }\n    }\n    if (export != null && !export) {\n        return;\n    }\n\t//判断是否延迟发布\n    if (delay != null && delay > 0) {\n        //延迟delay时间后执行\n        delayExportExecutor.schedule(new Runnable() {\n            @Override\n            public void run() {\n                doExport();\n            }\n        }, delay, TimeUnit.MILLISECONDS);\n    } else {\n        //发布服务\n        doExport();\n    }\n}\n//使用synchonized进行同步，保证了线程安全性\nprotected synchronized void doExport() {\n    if (unexported) {\n        throw new IllegalStateException(\"Already unexported!\");\n    }\n    if (exported) {\n        return;\n    }\n    //将exported状态改为true\n    exported = true;\n    if (interfaceName == null || interfaceName.length() == 0) {\n        throw new IllegalStateException(\"<dubbo:service interface=\\\"\\\" /> interface not allow null!\");\n    }\n    checkDefault();\n    if (provider != null) {\n        if (application == null) {\n            application = provider.getApplication();\n        }\n        if (module == null) {\n            module = provider.getModule();\n        }\n        if (registries == null) {\n            registries = provider.getRegistries();\n        }\n        if (monitor == null) {\n            monitor = provider.getMonitor();\n        }\n        if (protocols == null) {\n            protocols = provider.getProtocols();\n        }\n    }\n    if (module != null) {\n        if (registries == null) {\n            registries = module.getRegistries();\n        }\n        if (monitor == null) {\n            monitor = module.getMonitor();\n        }\n    }\n    if (application != null) {\n        if (registries == null) {\n            registries = application.getRegistries();\n        }\n        if (monitor == null) {\n            monitor = application.getMonitor();\n        }\n    }\n    if (ref instanceof GenericService) {\n        interfaceClass = GenericService.class;\n        if (StringUtils.isEmpty(generic)) {\n            generic = Boolean.TRUE.toString();\n        }\n    } else {\n        try {\n            interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n                                           .getContextClassLoader());\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n        checkInterfaceAndMethods(interfaceClass, methods);\n        checkRef();\n        generic = Boolean.FALSE.toString();\n    }\n    if (local != null) {\n        if (\"true\".equals(local)) {\n            local = interfaceName + \"Local\";\n        }\n        Class<?> localClass;\n        try {\n            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n        if (!interfaceClass.isAssignableFrom(localClass)) {\n            throw new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceName);\n        }\n    }\n    if (stub != null) {\n        if (\"true\".equals(stub)) {\n            stub = interfaceName + \"Stub\";\n        }\n        Class<?> stubClass;\n        try {\n            stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n        if (!interfaceClass.isAssignableFrom(stubClass)) {\n            throw new IllegalStateException(\"The stub implementation class \" + stubClass.getName() + \" not implement interface \" + interfaceName);\n        }\n    }\n    checkApplication();\n    checkRegistry();\n    checkProtocol();\n    appendProperties(this);\n    checkStubAndMock(interfaceClass);\n    if (path == null || path.length() == 0) {\n        path = interfaceName;\n    }\n    doExportUrls();\n    ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref);\n    ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);\n}\n```\n\n在doExport()函数中调用了doExportUrls()方法，我们将进一步分析doExportUrls()方法：\n\n```java\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nprivate void doExportUrls() {\n    //支持多个注册中心\n    List<URL> registryURLs = loadRegistries(true);\n    for (ProtocolConfig protocolConfig : protocols) {\n        //执行doExportUrlsFor1Protocol方法\n        doExportUrlsFor1Protocol(protocolConfig, registryURLs);\n    }\n}\n\nprivate void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {\n    String name = protocolConfig.getName();\n    if (name == null || name.length() == 0) {\n        name = \"dubbo\";\n    }\n\n    Map<String, String> map = new HashMap<String, String>();\n    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);\n    map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());\n    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n    if (ConfigUtils.getPid() > 0) {\n        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n    }\n    appendParameters(map, application);\n    appendParameters(map, module);\n    appendParameters(map, provider, Constants.DEFAULT_KEY);\n    appendParameters(map, protocolConfig);\n    appendParameters(map, this);\n    if (methods != null && !methods.isEmpty()) {\n        for (MethodConfig method : methods) {\n            appendParameters(map, method, method.getName());\n            String retryKey = method.getName() + \".retry\";\n            if (map.containsKey(retryKey)) {\n                String retryValue = map.remove(retryKey);\n                if (\"false\".equals(retryValue)) {\n                    map.put(method.getName() + \".retries\", \"0\");\n                }\n            }\n            List<ArgumentConfig> arguments = method.getArguments();\n            if (arguments != null && !arguments.isEmpty()) {\n                for (ArgumentConfig argument : arguments) {\n                    // convert argument type\n                    if (argument.getType() != null && argument.getType().length() > 0) {\n                        Method[] methods = interfaceClass.getMethods();\n                        // visit all methods\n                        if (methods != null && methods.length > 0) {\n                            for (int i = 0; i < methods.length; i++) {\n                                String methodName = methods[i].getName();\n                                // target the method, and get its signature\n                                if (methodName.equals(method.getName())) {\n                                    Class<?>[] argtypes = methods[i].getParameterTypes();\n                                    // one callback in the method\n                                    if (argument.getIndex() != -1) {\n                                        if (argtypes[argument.getIndex()].getName().equals(argument.getType())) {\n                                            appendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n                                        } else {\n                                            throw new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n                                        }\n                                    } else {\n                                        // multiple callbacks in the method\n                                        for (int j = 0; j < argtypes.length; j++) {\n                                            Class<?> argclazz = argtypes[j];\n                                            if (argclazz.getName().equals(argument.getType())) {\n                                                appendParameters(map, argument, method.getName() + \".\" + j);\n                                                if (argument.getIndex() != -1 && argument.getIndex() != j) {\n                                                    throw new IllegalArgumentException(\"argument config error : the index attribute and type attribute not match :index :\" + argument.getIndex() + \", type:\" + argument.getType());\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else if (argument.getIndex() != -1) {\n                        appendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n                    } else {\n                        throw new IllegalArgumentException(\"argument config must set index or type attribute.eg: <dubbo:argument index='0' .../> or <dubbo:argument type=xxx .../>\");\n                    }\n\n                }\n            }\n        } // end of methods for\n    }\n\n    if (ProtocolUtils.isGeneric(generic)) {\n        map.put(Constants.GENERIC_KEY, generic);\n        map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n    } else {\n        String revision = Version.getVersion(interfaceClass, version);\n        if (revision != null && revision.length() > 0) {\n            map.put(\"revision\", revision);\n        }\n\n        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n        if (methods.length == 0) {\n            logger.warn(\"NO method found in service interface \" + interfaceClass.getName());\n            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n        } else {\n            map.put(Constants.METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), \",\"));\n        }\n    }\n    if (!ConfigUtils.isEmpty(token)) {\n        if (ConfigUtils.isDefault(token)) {\n            map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());\n        } else {\n            map.put(Constants.TOKEN_KEY, token);\n        }\n    }\n    if (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) {\n        protocolConfig.setRegister(false);\n        map.put(\"notify\", \"false\");\n    }\n    // export service\n    String contextPath = protocolConfig.getContextpath();\n    if ((contextPath == null || contextPath.length() == 0) && provider != null) {\n        contextPath = provider.getContextpath();\n    }\n\n    String host = this.findConfigedHosts(protocolConfig, registryURLs, map);\n    Integer port = this.findConfigedPorts(protocolConfig, name, map);\n    URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? \"\" : contextPath + \"/\") + path, map);\n\n    if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)\n        .hasExtension(url.getProtocol())) {\n        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)\n            .getExtension(url.getProtocol()).getConfigurator(url).configure(url);\n    }\n\n    String scope = url.getParameter(Constants.SCOPE_KEY);\n    // don't export when none is configured\n    if (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) {\n\n        // export to local if the config is not remote (export to remote only when config is remote)\n        if (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) {\n            //本地暴露（分析1）\n            exportLocal(url);\n        }\n        // export to remote if the config is not local (export to local only when config is local)\n        //如果配置不是local则暴露为远程服务\n        if (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) {\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url);\n            }\n            if (registryURLs != null && !registryURLs.isEmpty()) {\n                //多个注册中心\n                for (URL registryURL : registryURLs) {\n                    url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));\n                    URL monitorUrl = loadMonitor(registryURL);\n                    if (monitorUrl != null) {\n                        url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());\n                    }\n                    if (logger.isInfoEnabled()) {\n                        logger.info(\"Register dubbo service \" + interfaceClass.getName() + \" url \" + url + \" to registry \" + registryURL);\n                    }\n\n                    // For providers, this is used to enable custom proxy to generate invoker\n                    String proxy = url.getParameter(Constants.PROXY_KEY);\n                    if (StringUtils.isNotEmpty(proxy)) {\n                        registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);\n                    }\n\t\t\t\t\t//根据Java SPI机制得到ProxyFactory$Adaptive类的实例proxyFactory\n                    Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n                    //获取包装类??\n                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\t\t\t\t\t//调用Protocol$Adaptive的export()方法\n                    Exporter<?> exporter = protocol.export(wrapperInvoker);\n                    exporters.add(exporter);\n                }\n            } else {\n                //没有注册中心，只在本机IP打开服务端口生成服务代理，并不注册到注册中心\n                Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);\n                DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n                Exporter<?> exporter = protocol.export(wrapperInvoker);\n                exporters.add(exporter);\n            }\n        }\n    }\n    this.urls.add(url);\n}\n```\n\n#### 本地服务发布过程\n\n首先是进入exportLocal()函数：\n\n```java\nprivate void exportLocal(URL url) {\n    if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {\n        URL local = URL.valueOf(url.toFullString())\n            .setProtocol(Constants.LOCAL_PROTOCOL)\n            .setHost(LOCALHOST)\n            .setPort(0);\n        ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));\n        //这是核心步骤，先是执行proxyFactory.getInvoker()方法生成invoker，然后是执行protocol.export()方法暴露服务，下面将会分别介绍\n        Exporter<?> exporter = protocol.export(\n            proxyFactory.getInvoker(ref, (Class) interfaceClass, local));\n        exporters.add(exporter);\n        logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to local registry\");\n    }\n}\n```\n\n##### 分析proxyFactory.getInvoker()过程\n\n通过Dubbo SPI机制（详见[《Dubbo SPI机制源码分析》](https://shuaijunlan.github.io/2018/08/09/dubbo-spi-analysis/)），proxyFactory是ProxyFactory$Adaptive类的实例，我们来看它的getInvoker()方法：\n\n```java\n//传入三个参数，分别是ref、interfaceClass和url\npublic org.apache.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2) throws org.apache.dubbo.rpc.RpcException {\n    if (arg2 == null) throw new IllegalArgumentException(\"url == null\");\n    org.apache.dubbo.common.URL url = arg2;\n    //默认是使用Javassist生成代理\n    String extName = url.getParameter(\"proxy\", \"javassist\");\n    if (extName == null)\n        throw new IllegalStateException(\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n    //根据Dubbo SPI机制得到JavassistProxyFactory扩展类\n    org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n    return extension.getInvoker(arg0, arg1, arg2);\n}\n```\n\n然后调用extension.getInvoker()方法，这里的extension，默认是JavassistProxyFactory类的实例（也是基于Java SPI机制），然后调用它的getInvoker()方法：\n\n```java\n@Override\npublic <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n    // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'\n    //获取包装类,具体代码是怎样的？\n    final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n    return new AbstractProxyInvoker<T>(proxy, type, url) {\n        @Override\n        protected Object doInvoke(T proxy, String methodName,\n                                  Class<?>[] parameterTypes,\n                                  Object[] arguments) throws Throwable {\n            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n        }\n    };\n}\n```\n\n这里以文章开头的Demo为例，通过Wrapper.getWrapper()返回的类代码，这里需要代码hack：\n\n```java\npackage com.alibaba.dubbo.common.bytecode;\n\nimport com.alibaba.dubbo.common.DemoService;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Map;\n\npublic class Wrapper0 extends Wrapper\n  implements ClassGenerator.DC\n{\n  public static String[] pns;\n  public static Map pts;\n  public static String[] mns;\n  public static String[] dmns;\n  public static Class[] mts0;\n\n  public String[] getPropertyNames()\n  {\n    return pns;\n  }\n\n  public boolean hasProperty(String paramString)\n  {\n    return pts.containsKey(paramString);\n  }\n\n  public Class getPropertyType(String paramString)\n  {\n    return (Class)pts.get(paramString);\n  }\n\n  public String[] getMethodNames()\n  {\n    return mns;\n  }\n\n  public String[] getDeclaredMethodNames()\n  {\n    return dmns;\n  }\n\n  public void setPropertyValue(Object paramObject1, String paramString, Object paramObject2)\n  {\n    try\n    {\n      DemoService localDemoService = (DemoService)paramObject1;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new IllegalArgumentException(localThrowable);\n    }\n    throw new NoSuchPropertyException(\"Not found property \\\"\" + paramString + \"\\\" filed or setter method in class com.alibaba.dubbo.common.DemoService.\");\n  }\n\n  public Object getPropertyValue(Object paramObject, String paramString)\n  {\n    try\n    {\n      DemoService localDemoService = (DemoService)paramObject;\n    }\n    catch (Throwable localThrowable)\n    {\n      throw new IllegalArgumentException(localThrowable);\n    }\n    throw new NoSuchPropertyException(\"Not found property \\\"\" + paramString + \"\\\" filed or setter method in class com.alibaba.dubbo.common.DemoService.\");\n  }\n   \n  //(**看这里，关键方法实现****)\n  public Object invokeMethod(Object paramObject, String paramString, Class[] paramArrayOfClass, Object[] paramArrayOfObject)\n    throws InvocationTargetException\n  {\n    DemoService localDemoService;\n    try\n    {\n    //赋值执行实例，这里是接口实现类，DemoServiceImpl对象\n      localDemoService = (DemoService)paramObject;\n    }\n    catch (Throwable localThrowable1)\n    {\n      throw new IllegalArgumentException(localThrowable1);\n    }\n    try\n    {\n    //根据传入的要调用的方法名paramString,方法参数值，调用执行实例方法\n      if ((\"sayHello\".equals(paramString)) || (paramArrayOfClass.length == 1))\n        return localDemoService.sayHello((String)paramArrayOfObject[0]);\n    }\n    catch (Throwable localThrowable2)\n    {\n      throw new InvocationTargetException(localThrowable2);\n    }\n    throw new NoSuchMethodException(\"Not found method \\\"\" + paramString + \"\\\" in class com.alibaba.dubbo.common.DemoService.\");\n  }\n}\n```\n\n到这就比较清楚了解具体的代理的过程了。\n\n##### 分析protocol.export()过程\n\n上面的过程已经生成好了invoker对象，接下来就要通过Protocol$Adaptive的export()方法暴露服务：\n\n```java\npublic org.apache.dubbo.rpc.Exporter export(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException {\n    if (arg0 == null) throw new IllegalArgumentException(\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument == null\");\n    if (arg0.getUrl() == null)\n        throw new IllegalArgumentException(\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument getUrl() == null\");\n    org.apache.dubbo.common.URL url = arg0.getUrl();\n    String extName = (url.getProtocol() == null ? \"MEAT-INF.dubbo\" : url.getProtocol());\n    if (extName == null)\n        throw new IllegalStateException(\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n    //因为这是本地服务发布，因此protocol为injvm\n    //所以这里会走到InjvmProtocol的export()方法\n    org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n    return extension.export(arg0);\n}\n```\n\n看下InjvmProtocol的export()方法\n\n```java\n@Override\npublic <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n    //返回InjvmExporter对象\n    return new InjvmExporter<T>(invoker, invoker.getUrl().getServiceKey(), exporterMap);\n}\n```\n\nInjvmExporter的构造函数：\n\n```java\nInjvmExporter(Invoker<T> invoker, String key, Map<String, Exporter<?>> exporterMap) {\n    super(invoker);\n    this.key = key;\n    this.exporterMap = exporterMap;\n    //存的形式，serviceKey:自身(exporter) put到map关联起来，这样可以通过servciekey找到exporterMap然后找到invoker\n    exporterMap.put(key, this);\n}\n```\n\n这里的exporterMap是由InjvmProtocol实例拥有，而InjvmProtocol又是单例的，因为InjvmProtocol类有如下实例和方法：\n\n```java\n//静态自身成员变量\nprivate static InjvmProtocol INSTANCE;\n//构造方法，把自己赋值给INSTANCE对象\npublic InjvmProtocol() {\n    INSTANCE = this;\n}\n```\n\n所以exporterMap对象也是单例的，同时这里顺便看下InjvmProtocol的refer()方法，本地服务的引用查找也是通过自身的exporterMap对象：\n\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {\n    //把exporterMap对象赋值给InjvmInvoker\n    return new InjvmInvoker<T>(serviceType, url, url.getServiceKey(), exporterMap);\n}\n//具体查找过程\n@Override\npublic Result doInvoke(Invocation invocation) throws Throwable {\n    //通过exporterMap获取exporter\n    Exporter<?> exporter = InjvmProtocol.getExporter(exporterMap, getUrl());\n    if (exporter == null) {\n        throw new RpcException(\"Service [\" + key + \"] not found.\");\n    }\n    RpcContext.getContext().setRemoteAddress(NetUtils.LOCALHOST, 0);\n    return exporter.getInvoker().invoke(invocation);\n}\n```\n\n以上的所有步骤就是本地服务的发布和引用过程。\n\n#### 远程服务发布\n\n上面调用了proFactory的getInvoker()方法，我们来看一下`ProxyFactory$Adaptive.getInvoker()`的代码：\n\n```java\n//传入三个参数，分别是ref、interfaceClass和url\npublic org.apache.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2) throws org.apache.dubbo.rpc.RpcException {\n    if (arg2 == null) throw new IllegalArgumentException(\"url == null\");\n    org.apache.dubbo.common.URL url = arg2;\n    //默认是使用Javassist生成代理\n    String extName = url.getParameter(\"proxy\", \"javassist\");\n    if (extName == null)\n        throw new IllegalStateException(\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n    //根据Dubbo SPI机制得到JavassistProxyFactory扩展类\n    org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n    return extension.getInvoker(arg0, arg1, arg2);\n}\n```\n\n再来看一下`JavassistProxyFactory.getInvoker()`方法：\n\n```java\n@Override\npublic <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {\n    // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'\n    //获取包装类,具体代码是怎样的？\n    final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);\n    return new AbstractProxyInvoker<T>(proxy, type, url) {\n        @Override\n        protected Object doInvoke(T proxy, String methodName,\n                                  Class<?>[] parameterTypes,\n                                  Object[] arguments) throws Throwable {\n            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n        }\n    };\n}\n```\n\n在doExportUrlsFor1Protocol()方法中还调用了`Protocol$Adaptive.export()`方法：\n\n```java\npublic org.apache.dubbo.rpc.Exporter export(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException {\n    if (arg0 == null) throw new IllegalArgumentException(\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument == null\");\n    if (arg0.getUrl() == null)\n        throw new IllegalArgumentException(\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument getUrl() == null\");\n    org.apache.dubbo.common.URL url = arg0.getUrl();\n    String extName = (url.getProtocol() == null ? \"MEAT-INF.dubbo\" : url.getProtocol());\n    if (extName == null)\n        throw new IllegalStateException(\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n    org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n    return extension.export(arg0);\n}\n```\n\n根据Dubbo SPI机制可以看出调用`RegistryProtocol.export()`方法，Protocol还定义了ProtocolFilterWrapper、QosProtocolWrapper和ProtocolListenerWrapper三个Wrapper扩展点，根据ExtensionLoader的加载规则，他会返回`ProtocolFilterWrapper->QosProtocolWrapper->ProtocolListenerWrapper->RegistryProtocol`（对象链调用顺序还待进一步求证）对象链：\n\n```java\n@Override\npublic <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {\n    //export invoker\n    //暴露invoker（暴露服务过程从这里开始，看doLocalExport()）\n    final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);\n\t\n    URL registryUrl = getRegistryUrl(originInvoker);\n\n    //registry provider\n    //获取对应注册中心操作对象\n    final Registry registry = getRegistry(originInvoker);\n    //获取要注册到注册中心的地址\n    final URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);\n\n    //to judge to delay publish whether or not\n    boolean register = registeredProviderUrl.getParameter(\"register\", true);\n\n    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);\n\t//判断是否注册服务\n    if (register) {\n        //执行注册(服务注册过程从这里开始)\n        register(registryUrl, registeredProviderUrl);\n        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);\n    }\n\n    // Subscribe the override data\n    // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.\n    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);\n    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);\n    //Ensure that a new exporter instance is returned every time export\n    //保证每次export都返回一个新的exporter实例\n    return new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);\n}\n```\n\n因此有如下的调用栈：\n\n```\nat org.apache.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:133)\nat org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)\nat org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:61)\nat org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)\nat org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)\n```\n\n继续看执行服务暴露的函数`doLocalExport()`:\n\n```java\n@SuppressWarnings(\"unchecked\")\nprivate <T> ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker) {\n    //通过原始originInvoker构造缓存key\n    String key = getCacheKey(originInvoker);\n    ExporterChangeableWrapper<T> exporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n    //没有缓存，走具体暴露流程\n    if (exporter == null) {\n        synchronized (bounds) {\n            exporter = (ExporterChangeableWrapper<T>) bounds.get(key);\n            if (exporter == null) {\n                //InvokerDelegete是RegistryProtocol类的静态内部类，继承自InvokerWrapper，\n\t\t    \t//通过构造器赋值持有代理originInvoker和服务暴露协议url对象,算是包装一层\n                //而url 是通过getProviderUrl(originInvoker)返回的，此时url的协议已是dubbo，即服务暴露的协议\n                final Invoker<?> invokerDelegete = new InvokerDelegete<T>(originInvoker, getProviderUrl(originInvoker));\n                \n                //ExporterChangeableWrapper是RegistryProtocol的私有内部类实现了Exporter接口。\n                //通过调用它的构造方法(Exporter<T> exporter, Invoker<T> originInvoker)构造exporterWrapper实例\n\t\t    \t//而这里传入的exporter是通过(Exporter<T>) protocol.export(invokerDelegete)语句创建\n\t\t    \t//由上一步知道，这里的invokerDelegete里url属性的protocol协议已经是dubbo\n                //下面具体看下protocol.export(invokerDelegete)方法。\n                exporter = new ExporterChangeableWrapper<T>((Exporter<T>) protocol.export(invokerDelegete), originInvoker);\n                bounds.put(key, exporter);\n            }\n        }\n    }\n    return exporter;\n}\n```\n\n再继续往下看，通过调用Protocol$Adaptive类的export()方法，然后再调用DubboProtocol的export()方法，同理在这里也会生成`ProtocolFilterWrapper->QosProtocolWrapper->ProtocolListenerWrapper->DubboProtocol`对象链：\n\n```java\n@Override\npublic <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n    URL url = invoker.getUrl();\n\n    // export service.\n    //获取service key\n    //key的组成group/service:version:port\n    String key = serviceKey(url);\n    //构造服务的exporter\n    //如同InjvmProtocol一样，DubboProtocol也是单例的，所以这里exporterMap也是单例的\n    DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);\n    //通过key放入exporterMap，把持有invoker的exporter 和serviceKey关联\n    //这个在后面服务调用时，可以通过key找到对应的exporter进而找到invoker提供服务\n    exporterMap.put(key, exporter);\n\n    //export an stub service for dispatching event\n    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);\n    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false);\n    if (isStubSupportEvent && !isCallbackservice) {\n        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);\n        if (stubServiceMethods == null || stubServiceMethods.length() == 0) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(new IllegalStateException(\"consumer [\" + url.getParameter(Constants.INTERFACE_KEY) +\n                                                      \"], has set stubproxy support event ,but no stub methods founded.\"));\n            }\n        } else {\n            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);\n        }\n    }\n\t//根据url开启一个服务，比如绑定端口，开始接受请求\n    openServer(url);\n    optimizeSerialization(url);\n    return exporter;\n}\n```\n\n到这里就可以对应下面的调用栈：\n\n```\nat org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.export(DubboProtocol.java:267)\nat org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:57)\nat org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:63)\nat org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:100)\nat org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)\nat org.apache.dubbo.registry.integration.RegistryProtocol.doLocalExport(RegistryProtocol.java:170)\n```\n\n再继续看openServer()方法\n\n```java\nprivate void openServer(URL url) {\n    // find server.\n    //key=host:port 用于定位server\n    String key = url.getAddress();\n    //client can export a service which's only for server to invoke\n    //client也可以暴露一个只有server可以调用的服务\n    boolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);\n    if (isServer) {\n        //服务实例放到serverMap中，key是host:port\n        //这里serverMap也是单例的\n        ExchangeServer server = serverMap.get(key);\n        if (server == null) {\n            synchronized (this) {\n                server = serverMap.get(key);\n                if (server == null) {\n                    //通过createServer(url)方法获取server\n                    serverMap.put(key, createServer(url));\n                }\n            }\n        } else {\n            // server supports reset, use together with override\n            //server支持reset，配合override使用\n            server.reset(url);\n        }\n    }\n}\n```\n\n再继续看createServer()代码：\n\n```java\nprivate ExchangeServer createServer(URL url) {\n    // send readonly event when server closes, it's enabled by default\n    //默认开启server关闭时关闭readonly事件\n    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());\n    // enable heartbeat by default\n    //默认开启heartbeat\n    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));\n    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);\n\t//通过server key检查是否是dubbo目前spi扩展支持的传输框架，默认是netty\n    if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))\n        throw new RpcException(\"Unsupported server type: \" + str + \", url: \" + url);\n\t//通过codec key获取编码方法，默认是dubbo\n    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);\n    ExchangeServer server;\n    try {\n        //构造具体服务实例，\n\t    //Exchangers是门面类，里面封装了具体交换层实现，并调用它的bind方法\n        server = Exchangers.bind(url, requestHandler);\n    } catch (RemotingException e) {\n        throw new RpcException(\"Fail to start server(url: \" + url + \") \" + e.getMessage(), e);\n    }\n    //这里会验证一下客户端传输实现\n    //如果没有对应的实现，会抛出异常\n    str = url.getParameter(Constants.CLIENT_KEY);\n    if (str != null && str.length() > 0) {\n        Set<String> supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();\n        if (!supportedTypes.contains(str)) {\n            throw new RpcException(\"Unsupported client type: \" + str);\n        }\n    }\n    return server;\n}\n```\n\n继续看Exchanges类的bind()方法：\n\n```java\npublic static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {\n    if (url == null) {\n        throw new IllegalArgumentException(\"url == null\");\n    }\n    if (handler == null) {\n        throw new IllegalArgumentException(\"handler == null\");\n    }\n    url = url.addParameterIfAbsent(Constants.CODEC_KEY, \"exchange\");\n    return getExchanger(url).bind(url, handler);\n}\n\npublic static Exchanger getExchanger(URL url) {\n    String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);\n    return getExchanger(type);\n}\n\npublic static Exchanger getExchanger(String type) {\n    return ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);\n}\n\n//HeaderExchanger类的bind()方法\n@Override\npublic ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {\n    return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));\n}\n```\n\n继续跟进Transporters.bind()方法：\n\n```java\npublic static Server bind(URL url, ChannelHandler... handlers) throws RemotingException {\n    if (url == null) {\n        throw new IllegalArgumentException(\"url == null\");\n    }\n    if (handlers == null || handlers.length == 0) {\n        throw new IllegalArgumentException(\"handlers == null\");\n    }\n    ChannelHandler handler;\n    if (handlers.length == 1) {\n        handler = handlers[0];\n    } else {\n        handler = new ChannelHandlerDispatcher(handlers);\n    }\n    //根据Dubbo SPI机制，这里走NettyTransporter.bind()方法\n    return getTransporter().bind(url, handler);\n}\npublic static Transporter getTransporter() {\n    return ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();\n}\n\n//NettyTransporter的bind方法\npublic Server bind(URL url, ChannelHandler listener) throws RemotingException {\n    //可以看到这里是NettyServer实例\n    return new NettyServer(url, listener);\n}\n\n//NettyServer构造器\npublic NettyServer(URL url, ChannelHandler handler) throws RemotingException {\n    //调用父类AbstractServer构造器\n    //注意下这里的ChannelHandlers.wrap()方法，生成MultiMessageHandler->HeartbeatHandler->AllChannelHandler的调用链\n    super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));\n}\n```\n\n看一下父类AbstractServer()的构造函数：\n\n```java\npublic AbstractServer(URL url, ChannelHandler handler) throws RemotingException {\n    super(url, handler);\n    localAddress = getUrl().toInetSocketAddress();\n\n    String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());\n    int bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());\n    if (url.getParameter(Constants.ANYHOST_KEY, false) || NetUtils.isInvalidLocalHost(bindIp)) {\n        bindIp = NetUtils.ANYHOST;\n    }\n    bindAddress = new InetSocketAddress(bindIp, bindPort);\n    this.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);\n    this.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);\n    try {\n        //打开端口，启动服务\n        doOpen();\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Start \" + getClass().getSimpleName() + \" bind \" + getBindAddress() + \", export \" + getLocalAddress());\n        }\n    } catch (Throwable t) {\n        throw new RemotingException(url.toInetSocketAddress(), null, \"Failed to bind \" + getClass().getSimpleName()\n                                    + \" on \" + getLocalAddress() + \", cause: \" + t.getMessage(), t);\n    }\n    //fixme replace this with better method\n    DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();\n    executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));\n}\n```\n\n再来看NettyServer的doOpen()方法：\n\n```java\n@Override\nprotected void doOpen() throws Throwable {\n    bootstrap = new ServerBootstrap();\n\n    bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory(\"NettyServerBoss\", true));\n    workerGroup = new NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),\n                                        new DefaultThreadFactory(\"NettyServerWorker\", true));\n\n    final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this);\n    channels = nettyServerHandler.getChannels();\n\n    bootstrap.group(bossGroup, workerGroup)\n        .channel(NioServerSocketChannel.class)\n        .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)\n        .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)\n        .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n        .childHandler(new ChannelInitializer<NioSocketChannel>() {\n            @Override\n            protected void initChannel(NioSocketChannel ch) throws Exception {\n                NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);\n                ch.pipeline()//.addLast(\"logging\",new LoggingHandler(LogLevel.INFO))//for debug\n                    .addLast(\"decoder\", adapter.getDecoder())\n                    .addLast(\"encoder\", adapter.getEncoder())\n                    .addLast(\"handler\", nettyServerHandler);\n            }\n        });\n    // bind\n    //bind地址，开启端口\n    ChannelFuture channelFuture = bootstrap.bind(getBindAddress());\n    channelFuture.syncUninterruptibly();\n    channel = channelFuture.channel();\n\n}\n```\n\n分析到这里可以对应如下的调用栈：\n\n```java\nat org.apache.dubbo.remoting.transport.netty4.NettyServer.doOpen(NettyServer.java:97)\n    at org.apache.dubbo.remoting.transport.AbstractServer.<init>(AbstractServer.java:63)\n    at org.apache.dubbo.remoting.transport.netty4.NettyServer.<init>(NettyServer.java:65)\n    at org.apache.dubbo.remoting.transport.netty4.NettyTransporter.bind(NettyTransporter.java:32)\n    at org.apache.dubbo.remoting.Transporter$Adaptive.bind(Transporter$Adaptive.java:-1)\n    at org.apache.dubbo.remoting.Transporters.bind(Transporters.java:56)\n    at org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger.bind(HeaderExchanger.java:44)\n    at org.apache.dubbo.remoting.exchange.Exchangers.bind(Exchangers.java:70)\n    at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.createServer(DubboProtocol.java:306)\n    at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.openServer(DubboProtocol.java:283)\n```\n\n分析到这里Dubbo服务提供者服务发布过程源码分析已经完成了，下面将继续分析服务注册过程。\n\n### Dubbo服务注册过程\n\n在之前的分析中，我们知道注册服务的过程是从RegistryProtocol的export()方法开始的，我们来看一下export()方法：\n\n```java\n@Override\npublic <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {\n    //export invoker\n    final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker);\n\n    URL registryUrl = getRegistryUrl(originInvoker);\n\n    //registry provider\n    final Registry registry = getRegistry(originInvoker);\n    final URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);\n\n    //to judge to delay publish whether or not\n    boolean register = registeredProviderUrl.getParameter(\"register\", true);\n\n    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);\n\n    if (register) {\n        //注册服务从这里开始\n        register(registryUrl, registeredProviderUrl);\n        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);\n    }\n\n    // Subscribe the override data\n    // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.\n    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);\n    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);\n    //Ensure that a new exporter instance is returned every time export\n    return new DestroyableExporter<T>(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);\n}\n```\n\n我们再继续看register()方法：\n\n```java\npublic void register(URL registryUrl, URL registedProviderUrl) {\n    //registryFactory是由Dubbo SPI机制生成的RegistryFactory$Adaptive的实例\n    //调用其的getRegistry()方法获得registry\n    Registry registry = registryFactory.getRegistry(registryUrl);\n    registry.register(registedProviderUrl);\n}\n```\n\n我们来看一下RegistryFactory$Adaptive类的getRegistry()方法：\n\n```java\npublic org.apache.dubbo.registry.Registry getRegistry(org.apache.dubbo.common.URL arg0) {\n    if (arg0 == null) throw new IllegalArgumentException(\"url == null\");\n    org.apache.dubbo.common.URL url = arg0;\n    String extName = (url.getProtocol() == null ? \"dubbo\" : url.getProtocol());\n    if (extName == null)\n        throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.registry.RegistryFactory) name from url(\" + url.toString() + \") use keys([protocol])\");\n    org.apache.dubbo.registry.RegistryFactory extension = null;\n    try {\n\t\t//得到ZookeeperRegistryFactory的实例extension\n        extension = (org.apache.dubbo.registry.RegistryFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.registry.RegistryFactory.class).getExtension(extName);\n    } catch (Exception e) {\n        if (count.incrementAndGet() == 1) {\n            logger.warn(\"Failed to find extension named \" + extName + \" for type org.apache.dubbo.registry.RegistryFactory, will use default extension dubbo instead.\", e);\n        }\n        extension = (org.apache.dubbo.registry.RegistryFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.registry.RegistryFactory.class).getExtension(\"dubbo\");\n    }\n    return extension.getRegistry(arg0);\n}\n```\n\n先调用ZookeeperRegister的父类FailbackRegistry的register()方法：\n\n```java\n@Override\npublic void register(URL url) {\n    super.register(url);\n    failedRegistered.remove(url);\n    failedUnregistered.remove(url);\n    try {\n        // Sending a registration request to the server side\n        doRegister(url);\n    } catch (Exception e) {\n        Throwable t = e;\n\n        // If the startup detection is opened, the Exception is thrown directly.\n        boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n            && url.getParameter(Constants.CHECK_KEY, true)\n            && !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());\n        boolean skipFailback = t instanceof SkipFailbackWrapperException;\n        if (check || skipFailback) {\n            if (skipFailback) {\n                t = t.getCause();\n            }\n            throw new IllegalStateException(\"Failed to register \" + url + \" to registry \" + getUrl().getAddress() + \", cause: \" + t.getMessage(), t);\n        } else {\n            logger.error(\"Failed to register \" + url + \", waiting for retry, cause: \" + t.getMessage(), t);\n        }\n\n        // Record a failed registration request to a failed list, retry regularly\n        failedRegistered.add(url);\n    }\n}\n```\n\n最后执行ZookeeperRegistry的doRegister()方法，向服务端发送注册请求：\n\n```java\n@Override\nprotected void doRegister(URL url) {\n    try {\n        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));\n    } catch (Throwable e) {\n        throw new RpcException(\"Failed to register \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e);\n    }\n}\n```\n\n服务注册调用栈：\n\n```\n\"main@1\" prio=5 tid=0x1 nid=NA runnable\n  java.lang.Thread.State: RUNNABLE\n\t  at org.apache.dubbo.registry.zookeeper.ZookeeperRegistry.doRegister(ZookeeperRegistry.java:114)\n\t  at org.apache.dubbo.registry.support.FailbackRegistry.register(FailbackRegistry.java:137)\n\t  at org.apache.dubbo.registry.integration.RegistryProtocol.register(RegistryProtocol.java:127)\n\t  at org.apache.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:147)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)\n\t  at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:61)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)\n\t  at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)\n\t  at org.apache.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)\n\t  at org.apache.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)\n\t  at org.apache.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)\n\t  - locked <0x9bb> (a org.apache.dubbo.config.spring.ServiceBean)\n\t  at org.apache.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)\n\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:123)\n\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:49)\n```\n\n\n","slug":"dubbo-provider-calling-process-source-code-analysis","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4v0014zjiav7pc3l8p","content":"<p>Dubbo服务端在启动服务时会经历怎样的调用过程？在收到消费者发送的请求后会经历怎样的调用过程？这篇文章主要针对以上两个调用过程并结合Dubbo源码进行分析。</p>\n<p>我们采用的是<a href=\"https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo\" target=\"_blank\" rel=\"noopener\"><strong>Consumer-Provider的Demo</strong></a>提供的示例，并按照<a href=\"https://shuaijunlan.github.io/2018/08/05/dubbo-consumer-calling-process-source-code-analysis/\">《Dubbo消费者调用过程源码分析》</a>中的分析思路，下面将对两种过程进行进一步分析，先来看一张服务发布过程的时序图(图片太大建议在新的窗口打开查看)，对服务发布与注册有个大致的了解：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/dubbo-provider.png?raw=true\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"Dubbo服务发布过程\"><a href=\"#Dubbo服务发布过程\" class=\"headerlink\" title=\"Dubbo服务发布过程\"></a>Dubbo服务发布过程</h3><p>首先来看一下服务发布过程调用栈，我们将围绕这个调用栈一步步进行分析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main@1&quot; prio=5 tid=0x1 nid=NA runnable</span><br><span class=\"line\">  java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.netty4.NettyServer.doOpen(NettyServer.java:97)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.AbstractServer.&lt;init&gt;(AbstractServer.java:63)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.netty4.NettyServer.&lt;init&gt;(NettyServer.java:65)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.netty4.NettyTransporter.bind(NettyTransporter.java:32)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.Transporter$Adaptive.bind(Transporter$Adaptive.java:-1)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.Transporters.bind(Transporters.java:56)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger.bind(HeaderExchanger.java:44)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.Exchangers.bind(Exchangers.java:70)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.createServer(DubboProtocol.java:306)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.openServer(DubboProtocol.java:283)</span><br><span class=\"line\">\t  - locked &lt;0x9ee&gt; (a org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.export(DubboProtocol.java:267)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:57)</span><br><span class=\"line\">\t  at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:63)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:100)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)</span><br><span class=\"line\">\t  at org.apache.dubbo.registry.integration.RegistryProtocol.doLocalExport(RegistryProtocol.java:170)</span><br><span class=\"line\">\t  - locked &lt;0x9e2&gt; (a java.util.concurrent.ConcurrentHashMap)</span><br><span class=\"line\">\t  at org.apache.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:133)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)</span><br><span class=\"line\">\t  at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:61)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)</span><br><span class=\"line\">\t  - locked &lt;0x848&gt; (a org.apache.dubbo.config.spring.ServiceBean)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:123)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:49)</span><br><span class=\"line\">\t  at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)</span><br><span class=\"line\">\t  at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)</span><br><span class=\"line\">\t  at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)</span><br><span class=\"line\">\t  at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:393)</span><br><span class=\"line\">\t  at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:347)</span><br><span class=\"line\">\t  at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:883)</span><br><span class=\"line\">\t  at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:546)</span><br><span class=\"line\">\t  - locked &lt;0xab7&gt; (a java.lang.Object)</span><br><span class=\"line\">\t  at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139)</span><br><span class=\"line\">\t  at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:83)</span><br><span class=\"line\">\t  at cn.shuaijunlan.dubbo.learning.main.Main.main(Main.java:13)</span><br></pre></td></tr></table></figure>\n<p>关于Dubbo是如何基于Spring解析xml文件中配置的ServiceBean这里不再赘述，可以参考我之前写的文章<a href=\"https://shuaijunlan.github.io/2018/08/13/dubbo-basing-on-spring-framework-analysis/\">《基于Spring构建Dubbo源码分析》</a>，这里将从发布服务的起始点开始将其，我们来看下ServiceBean类的部分函数实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个函数是实现了ApplicationListener接口的onApplicationEvent(E event)函数</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEvent</span><span class=\"params\">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"The service ready on spring started. service: \"</span> + getInterface());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//发布服务的起始点</span></span><br><span class=\"line\">        export();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面调用的export()函数的实现在其子类ServiceConfig中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是一个同步方法，保证了多线程环境下的安全性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">export</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取export和delay属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (provider != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (export == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            export = provider.getExport();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delay == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            delay = provider.getDelay();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (export != <span class=\"keyword\">null</span> &amp;&amp; !export) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//判断是否延迟发布</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delay != <span class=\"keyword\">null</span> &amp;&amp; delay &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//延迟delay时间后执行</span></span><br><span class=\"line\">        delayExportExecutor.schedule(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                doExport();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//发布服务</span></span><br><span class=\"line\">        doExport();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用synchonized进行同步，保证了线程安全性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">doExport</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (unexported) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already unexported!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exported) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将exported状态改为true</span></span><br><span class=\"line\">    exported = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interfaceName == <span class=\"keyword\">null</span> || interfaceName.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"&lt;dubbo:service interface=\\\"\\\" /&gt; interface not allow null!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    checkDefault();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (provider != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (application == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            application = provider.getApplication();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">module</span> == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">module</span> = provider.getModule();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registries == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            registries = provider.getRegistries();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (monitor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            monitor = provider.getMonitor();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (protocols == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            protocols = provider.getProtocols();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">module</span> != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registries == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            registries = <span class=\"keyword\">module</span>.getRegistries();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (monitor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            monitor = <span class=\"keyword\">module</span>.getMonitor();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (application != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registries == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            registries = application.getRegistries();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (monitor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            monitor = application.getMonitor();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ref <span class=\"keyword\">instanceof</span> GenericService) &#123;</span><br><span class=\"line\">        interfaceClass = GenericService.class;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(generic)) &#123;</span><br><span class=\"line\">            generic = Boolean.TRUE.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            interfaceClass = Class.forName(interfaceName, <span class=\"keyword\">true</span>, Thread.currentThread()</span><br><span class=\"line\">                                           .getContextClassLoader());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class=\"line\">        checkRef();</span><br><span class=\"line\">        generic = Boolean.FALSE.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (local != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"true\"</span>.equals(local)) &#123;</span><br><span class=\"line\">            local = interfaceName + <span class=\"string\">\"Local\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Class&lt;?&gt; localClass;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The local implementation class \"</span> + localClass.getName() + <span class=\"string\">\" not implement interface \"</span> + interfaceName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stub != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"true\"</span>.equals(stub)) &#123;</span><br><span class=\"line\">            stub = interfaceName + <span class=\"string\">\"Stub\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Class&lt;?&gt; stubClass;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!interfaceClass.isAssignableFrom(stubClass)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The stub implementation class \"</span> + stubClass.getName() + <span class=\"string\">\" not implement interface \"</span> + interfaceName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    checkApplication();</span><br><span class=\"line\">    checkRegistry();</span><br><span class=\"line\">    checkProtocol();</span><br><span class=\"line\">    appendProperties(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    checkStubAndMock(interfaceClass);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"keyword\">null</span> || path.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        path = interfaceName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doExportUrls();</span><br><span class=\"line\">    ProviderModel providerModel = <span class=\"keyword\">new</span> ProviderModel(getUniqueServiceName(), <span class=\"keyword\">this</span>, ref);</span><br><span class=\"line\">    ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在doExport()函数中调用了doExportUrls()方法，我们将进一步分析doExportUrls()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doExportUrls</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//支持多个注册中心</span></span><br><span class=\"line\">    List&lt;URL&gt; registryURLs = loadRegistries(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行doExportUrlsFor1Protocol方法</span></span><br><span class=\"line\">        doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doExportUrlsFor1Protocol</span><span class=\"params\">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class=\"line\">    String name = protocolConfig.getName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span> || name.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        name = <span class=\"string\">\"dubbo\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class=\"line\">    map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());</span><br><span class=\"line\">    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ConfigUtils.getPid() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    appendParameters(map, application);</span><br><span class=\"line\">    appendParameters(map, <span class=\"keyword\">module</span>);</span><br><span class=\"line\">    appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class=\"line\">    appendParameters(map, protocolConfig);</span><br><span class=\"line\">    appendParameters(map, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (methods != <span class=\"keyword\">null</span> &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (MethodConfig method : methods) &#123;</span><br><span class=\"line\">            appendParameters(map, method, method.getName());</span><br><span class=\"line\">            String retryKey = method.getName() + <span class=\"string\">\".retry\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class=\"line\">                String retryValue = map.remove(retryKey);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">\"false\"</span>.equals(retryValue)) &#123;</span><br><span class=\"line\">                    map.put(method.getName() + <span class=\"string\">\".retries\"</span>, <span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            List&lt;ArgumentConfig&gt; arguments = method.getArguments();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arguments != <span class=\"keyword\">null</span> &amp;&amp; !arguments.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (ArgumentConfig argument : arguments) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// convert argument type</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (argument.getType() != <span class=\"keyword\">null</span> &amp;&amp; argument.getType().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        Method[] methods = interfaceClass.getMethods();</span><br><span class=\"line\">                        <span class=\"comment\">// visit all methods</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (methods != <span class=\"keyword\">null</span> &amp;&amp; methods.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class=\"line\">                                String methodName = methods[i].getName();</span><br><span class=\"line\">                                <span class=\"comment\">// target the method, and get its signature</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class=\"line\">                                    Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();</span><br><span class=\"line\">                                    <span class=\"comment\">// one callback in the method</span></span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (argument.getIndex() != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                        <span class=\"keyword\">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class=\"line\">                                            appendParameters(map, argument, method.getName() + <span class=\"string\">\".\"</span> + argument.getIndex());</span><br><span class=\"line\">                                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"argument config error : the index attribute and type attribute not match :index :\"</span> + argument.getIndex() + <span class=\"string\">\", type:\"</span> + argument.getType());</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                        <span class=\"comment\">// multiple callbacks in the method</span></span><br><span class=\"line\">                                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; argtypes.length; j++) &#123;</span><br><span class=\"line\">                                            Class&lt;?&gt; argclazz = argtypes[j];</span><br><span class=\"line\">                                            <span class=\"keyword\">if</span> (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class=\"line\">                                                appendParameters(map, argument, method.getName() + <span class=\"string\">\".\"</span> + j);</span><br><span class=\"line\">                                                <span class=\"keyword\">if</span> (argument.getIndex() != -<span class=\"number\">1</span> &amp;&amp; argument.getIndex() != j) &#123;</span><br><span class=\"line\">                                                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"argument config error : the index attribute and type attribute not match :index :\"</span> + argument.getIndex() + <span class=\"string\">\", type:\"</span> + argument.getType());</span><br><span class=\"line\">                                                &#125;</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (argument.getIndex() != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        appendParameters(map, argument, method.getName() + <span class=\"string\">\".\"</span> + argument.getIndex());</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"argument config must set index or type attribute.eg: &lt;dubbo:argument index='0' .../&gt; or &lt;dubbo:argument type=xxx .../&gt;\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// end of methods for</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class=\"line\">        map.put(Constants.GENERIC_KEY, generic);</span><br><span class=\"line\">        map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        String revision = Version.getVersion(interfaceClass, version);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (revision != <span class=\"keyword\">null</span> &amp;&amp; revision.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            map.put(<span class=\"string\">\"revision\"</span>, revision);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (methods.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"NO method found in service interface \"</span> + interfaceClass.getName());</span><br><span class=\"line\">            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            map.put(Constants.METHODS_KEY, StringUtils.join(<span class=\"keyword\">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class=\"string\">\",\"</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class=\"line\">            map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            map.put(Constants.TOKEN_KEY, token);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123;</span><br><span class=\"line\">        protocolConfig.setRegister(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"notify\"</span>, <span class=\"string\">\"false\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// export service</span></span><br><span class=\"line\">    String contextPath = protocolConfig.getContextpath();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((contextPath == <span class=\"keyword\">null</span> || contextPath.length() == <span class=\"number\">0</span>) &amp;&amp; provider != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        contextPath = provider.getContextpath();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    String host = <span class=\"keyword\">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class=\"line\">    Integer port = <span class=\"keyword\">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class=\"line\">    URL url = <span class=\"keyword\">new</span> URL(name, host, port, (contextPath == <span class=\"keyword\">null</span> || contextPath.length() == <span class=\"number\">0</span> ? <span class=\"string\">\"\"</span> : contextPath + <span class=\"string\">\"/\"</span>) + path, map);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class=\"line\">        .hasExtension(url.getProtocol())) &#123;</span><br><span class=\"line\">        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class=\"line\">            .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class=\"line\">    <span class=\"comment\">// don't export when none is configured</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// export to local if the config is not remote (export to remote only when config is remote)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//本地暴露（分析1）</span></span><br><span class=\"line\">            exportLocal(url);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// export to remote if the config is not local (export to local only when config is local)</span></span><br><span class=\"line\">        <span class=\"comment\">//如果配置不是local则暴露为远程服务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"Export dubbo service \"</span> + interfaceClass.getName() + <span class=\"string\">\" to url \"</span> + url);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (registryURLs != <span class=\"keyword\">null</span> &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多个注册中心</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class=\"line\">                    url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class=\"line\">                    URL monitorUrl = loadMonitor(registryURL);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (monitorUrl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">                        logger.info(<span class=\"string\">\"Register dubbo service \"</span> + interfaceClass.getName() + <span class=\"string\">\" url \"</span> + url + <span class=\"string\">\" to registry \"</span> + registryURL);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class=\"line\">                    String proxy = url.getParameter(Constants.PROXY_KEY);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class=\"line\">                        registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//根据Java SPI机制得到ProxyFactory$Adaptive类的实例proxyFactory</span></span><br><span class=\"line\">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class=\"line\">                    <span class=\"comment\">//获取包装类??</span></span><br><span class=\"line\">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class=\"keyword\">new</span> DelegateProviderMetaDataInvoker(invoker, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//调用Protocol$Adaptive的export()方法</span></span><br><span class=\"line\">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class=\"line\">                    exporters.add(exporter);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//没有注册中心，只在本机IP打开服务端口生成服务代理，并不注册到注册中心</span></span><br><span class=\"line\">                Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class=\"line\">                DelegateProviderMetaDataInvoker wrapperInvoker = <span class=\"keyword\">new</span> DelegateProviderMetaDataInvoker(invoker, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class=\"line\">                exporters.add(exporter);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.urls.add(url);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"本地服务发布过程\"><a href=\"#本地服务发布过程\" class=\"headerlink\" title=\"本地服务发布过程\"></a>本地服务发布过程</h4><p>首先是进入exportLocal()函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">exportLocal</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class=\"line\">        URL local = URL.valueOf(url.toFullString())</span><br><span class=\"line\">            .setProtocol(Constants.LOCAL_PROTOCOL)</span><br><span class=\"line\">            .setHost(LOCALHOST)</span><br><span class=\"line\">            .setPort(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));</span><br><span class=\"line\">        <span class=\"comment\">//这是核心步骤，先是执行proxyFactory.getInvoker()方法生成invoker，然后是执行protocol.export()方法暴露服务，下面将会分别介绍</span></span><br><span class=\"line\">        Exporter&lt;?&gt; exporter = protocol.export(</span><br><span class=\"line\">            proxyFactory.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class=\"line\">        exporters.add(exporter);</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"Export dubbo service \"</span> + interfaceClass.getName() + <span class=\"string\">\" to local registry\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析proxyFactory-getInvoker-过程\"><a href=\"#分析proxyFactory-getInvoker-过程\" class=\"headerlink\" title=\"分析proxyFactory.getInvoker()过程\"></a>分析proxyFactory.getInvoker()过程</h5><p>通过Dubbo SPI机制（详见<a href=\"https://shuaijunlan.github.io/2018/08/09/dubbo-spi-analysis/\">《Dubbo SPI机制源码分析》</a>），proxyFactory是ProxyFactory$Adaptive类的实例，我们来看它的getInvoker()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传入三个参数，分别是ref、interfaceClass和url</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Invoker <span class=\"title\">getInvoker</span><span class=\"params\">(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.common.URL url = arg2;</span><br><span class=\"line\">    <span class=\"comment\">//默认是使用Javassist生成代理</span></span><br><span class=\"line\">    String extName = url.getParameter(<span class=\"string\">\"proxy\"</span>, <span class=\"string\">\"javassist\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.ProxyFactory) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([proxy])\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//根据Dubbo SPI机制得到JavassistProxyFactory扩展类</span></span><br><span class=\"line\">    org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extension.getInvoker(arg0, arg1, arg2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后调用extension.getInvoker()方法，这里的extension，默认是JavassistProxyFactory类的实例（也是基于Java SPI机制），然后调用它的getInvoker()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">getInvoker</span><span class=\"params\">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'</span></span><br><span class=\"line\">    <span class=\"comment\">//获取包装类,具体代码是怎样的？</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class=\"string\">'$'</span>) &lt; <span class=\"number\">0</span> ? proxy.getClass() : type);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">doInvoke</span><span class=\"params\">(T proxy, String methodName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  Object[] arguments)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里以文章开头的Demo为例，通过Wrapper.getWrapper()返回的类代码，这里需要代码hack：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.common.DemoService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapper0</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wrapper</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">ClassGenerator</span>.<span class=\"title\">DC</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String[] pns;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map pts;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String[] mns;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String[] dmns;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Class[] mts0;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String[] getPropertyNames()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pns;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasProperty</span><span class=\"params\">(String paramString)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pts.containsKey(paramString);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Class <span class=\"title\">getPropertyType</span><span class=\"params\">(String paramString)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Class)pts.get(paramString);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String[] getMethodNames()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mns;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String[] getDeclaredMethodNames()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dmns;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPropertyValue</span><span class=\"params\">(Object paramObject1, String paramString, Object paramObject2)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      DemoService localDemoService = (DemoService)paramObject1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable localThrowable)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(localThrowable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchPropertyException(<span class=\"string\">\"Not found property \\\"\"</span> + paramString + <span class=\"string\">\"\\\" filed or setter method in class com.alibaba.dubbo.common.DemoService.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getPropertyValue</span><span class=\"params\">(Object paramObject, String paramString)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      DemoService localDemoService = (DemoService)paramObject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable localThrowable)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(localThrowable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchPropertyException(<span class=\"string\">\"Not found property \\\"\"</span> + paramString + <span class=\"string\">\"\\\" filed or setter method in class com.alibaba.dubbo.common.DemoService.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">  <span class=\"comment\">//(**看这里，关键方法实现****)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invokeMethod</span><span class=\"params\">(Object paramObject, String paramString, Class[] paramArrayOfClass, Object[] paramArrayOfObject)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InvocationTargetException</span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    DemoService localDemoService;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"comment\">//赋值执行实例，这里是接口实现类，DemoServiceImpl对象</span></span><br><span class=\"line\">      localDemoService = (DemoService)paramObject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable localThrowable1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(localThrowable1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"comment\">//根据传入的要调用的方法名paramString,方法参数值，调用执行实例方法</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((<span class=\"string\">\"sayHello\"</span>.equals(paramString)) || (paramArrayOfClass.length == <span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> localDemoService.sayHello((String)paramArrayOfObject[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable localThrowable2)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvocationTargetException(localThrowable2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchMethodException(<span class=\"string\">\"Not found method \\\"\"</span> + paramString + <span class=\"string\">\"\\\" in class com.alibaba.dubbo.common.DemoService.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这就比较清楚了解具体的代理的过程了。</p>\n<h5 id=\"分析protocol-export-过程\"><a href=\"#分析protocol-export-过程\" class=\"headerlink\" title=\"分析protocol.export()过程\"></a>分析protocol.export()过程</h5><p>上面的过程已经生成好了invoker对象，接下来就要通过Protocol$Adaptive的export()方法暴露服务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Exporter <span class=\"title\">export</span><span class=\"params\">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument == null\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg0.getUrl() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument getUrl() == null\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class=\"line\">    String extName = (url.getProtocol() == <span class=\"keyword\">null</span> ? <span class=\"string\">\"MEAT-INF.dubbo\"</span> : url.getProtocol());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([protocol])\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//因为这是本地服务发布，因此protocol为injvm</span></span><br><span class=\"line\">    <span class=\"comment\">//所以这里会走到InjvmProtocol的export()方法</span></span><br><span class=\"line\">    org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extension.export(arg0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看下InjvmProtocol的export()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//返回InjvmExporter对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InjvmExporter的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(invoker);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.exporterMap = exporterMap;</span><br><span class=\"line\">    <span class=\"comment\">//存的形式，serviceKey:自身(exporter) put到map关联起来，这样可以通过servciekey找到exporterMap然后找到invoker</span></span><br><span class=\"line\">    exporterMap.put(key, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的exporterMap是由InjvmProtocol实例拥有，而InjvmProtocol又是单例的，因为InjvmProtocol类有如下实例和方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//静态自身成员变量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> InjvmProtocol INSTANCE;</span><br><span class=\"line\"><span class=\"comment\">//构造方法，把自己赋值给INSTANCE对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InjvmProtocol</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    INSTANCE = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以exporterMap对象也是单例的，同时这里顺便看下InjvmProtocol的refer()方法，本地服务的引用查找也是通过自身的exporterMap对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; serviceType, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//把exporterMap对象赋值给InjvmInvoker</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InjvmInvoker&lt;T&gt;(serviceType, url, url.getServiceKey(), exporterMap);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//具体查找过程</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过exporterMap获取exporter</span></span><br><span class=\"line\">    Exporter&lt;?&gt; exporter = InjvmProtocol.getExporter(exporterMap, getUrl());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exporter == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Service [\"</span> + key + <span class=\"string\">\"] not found.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RpcContext.getContext().setRemoteAddress(NetUtils.LOCALHOST, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exporter.getInvoker().invoke(invocation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上的所有步骤就是本地服务的发布和引用过程。</p>\n<h4 id=\"远程服务发布\"><a href=\"#远程服务发布\" class=\"headerlink\" title=\"远程服务发布\"></a>远程服务发布</h4><p>上面调用了proFactory的getInvoker()方法，我们来看一下<code>ProxyFactory$Adaptive.getInvoker()</code>的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传入三个参数，分别是ref、interfaceClass和url</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Invoker <span class=\"title\">getInvoker</span><span class=\"params\">(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.common.URL url = arg2;</span><br><span class=\"line\">    <span class=\"comment\">//默认是使用Javassist生成代理</span></span><br><span class=\"line\">    String extName = url.getParameter(<span class=\"string\">\"proxy\"</span>, <span class=\"string\">\"javassist\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.ProxyFactory) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([proxy])\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//根据Dubbo SPI机制得到JavassistProxyFactory扩展类</span></span><br><span class=\"line\">    org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extension.getInvoker(arg0, arg1, arg2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看一下<code>JavassistProxyFactory.getInvoker()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">getInvoker</span><span class=\"params\">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'</span></span><br><span class=\"line\">    <span class=\"comment\">//获取包装类,具体代码是怎样的？</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class=\"string\">'$'</span>) &lt; <span class=\"number\">0</span> ? proxy.getClass() : type);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">doInvoke</span><span class=\"params\">(T proxy, String methodName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  Object[] arguments)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在doExportUrlsFor1Protocol()方法中还调用了<code>Protocol$Adaptive.export()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Exporter <span class=\"title\">export</span><span class=\"params\">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument == null\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg0.getUrl() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument getUrl() == null\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class=\"line\">    String extName = (url.getProtocol() == <span class=\"keyword\">null</span> ? <span class=\"string\">\"MEAT-INF.dubbo\"</span> : url.getProtocol());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([protocol])\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extension.export(arg0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据Dubbo SPI机制可以看出调用<code>RegistryProtocol.export()</code>方法，Protocol还定义了ProtocolFilterWrapper、QosProtocolWrapper和ProtocolListenerWrapper三个Wrapper扩展点，根据ExtensionLoader的加载规则，他会返回<code>ProtocolFilterWrapper-&gt;QosProtocolWrapper-&gt;ProtocolListenerWrapper-&gt;RegistryProtocol</code>（对象链调用顺序还待进一步求证）对象链：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(<span class=\"keyword\">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//export invoker</span></span><br><span class=\"line\">    <span class=\"comment\">//暴露invoker（暴露服务过程从这里开始，看doLocalExport()）</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//registry provider</span></span><br><span class=\"line\">    <span class=\"comment\">//获取对应注册中心操作对象</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class=\"line\">    <span class=\"comment\">//获取要注册到注册中心的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//to judge to delay publish whether or not</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> register = registeredProviderUrl.getParameter(<span class=\"string\">\"register\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);</span><br><span class=\"line\">\t<span class=\"comment\">//判断是否注册服务</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (register) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行注册(服务注册过程从这里开始)</span></span><br><span class=\"line\">        register(registryUrl, registeredProviderUrl);</span><br><span class=\"line\">        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Subscribe the override data</span></span><br><span class=\"line\">    <span class=\"comment\">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> OverrideListener overrideSubscribeListener = <span class=\"keyword\">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class=\"line\">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class=\"line\">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class=\"line\">    <span class=\"comment\">//Ensure that a new exporter instance is returned every time export</span></span><br><span class=\"line\">    <span class=\"comment\">//保证每次export都返回一个新的exporter实例</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此有如下的调用栈：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:133)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)</span><br><span class=\"line\">at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:61)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)</span><br><span class=\"line\">at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)</span><br></pre></td></tr></table></figure>\n<p>继续看执行服务暴露的函数<code>doLocalExport()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">ExporterChangeableWrapper&lt;T&gt; <span class=\"title\">doLocalExport</span><span class=\"params\">(<span class=\"keyword\">final</span> Invoker&lt;T&gt; originInvoker)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过原始originInvoker构造缓存key</span></span><br><span class=\"line\">    String key = getCacheKey(originInvoker);</span><br><span class=\"line\">    ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class=\"line\">    <span class=\"comment\">//没有缓存，走具体暴露流程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exporter == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (bounds) &#123;</span><br><span class=\"line\">            exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (exporter == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//InvokerDelegete是RegistryProtocol类的静态内部类，继承自InvokerWrapper，</span></span><br><span class=\"line\">\t\t    \t<span class=\"comment\">//通过构造器赋值持有代理originInvoker和服务暴露协议url对象,算是包装一层</span></span><br><span class=\"line\">                <span class=\"comment\">//而url 是通过getProviderUrl(originInvoker)返回的，此时url的协议已是dubbo，即服务暴露的协议</span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> Invoker&lt;?&gt; invokerDelegete = <span class=\"keyword\">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//ExporterChangeableWrapper是RegistryProtocol的私有内部类实现了Exporter接口。</span></span><br><span class=\"line\">                <span class=\"comment\">//通过调用它的构造方法(Exporter&lt;T&gt; exporter, Invoker&lt;T&gt; originInvoker)构造exporterWrapper实例</span></span><br><span class=\"line\">\t\t    \t<span class=\"comment\">//而这里传入的exporter是通过(Exporter&lt;T&gt;) protocol.export(invokerDelegete)语句创建</span></span><br><span class=\"line\">\t\t    \t<span class=\"comment\">//由上一步知道，这里的invokerDelegete里url属性的protocol协议已经是dubbo</span></span><br><span class=\"line\">                <span class=\"comment\">//下面具体看下protocol.export(invokerDelegete)方法。</span></span><br><span class=\"line\">                exporter = <span class=\"keyword\">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);</span><br><span class=\"line\">                bounds.put(key, exporter);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exporter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再继续往下看，通过调用Protocol$Adaptive类的export()方法，然后再调用DubboProtocol的export()方法，同理在这里也会生成<code>ProtocolFilterWrapper-&gt;QosProtocolWrapper-&gt;ProtocolListenerWrapper-&gt;DubboProtocol</code>对象链：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    URL url = invoker.getUrl();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// export service.</span></span><br><span class=\"line\">    <span class=\"comment\">//获取service key</span></span><br><span class=\"line\">    <span class=\"comment\">//key的组成group/service:version:port</span></span><br><span class=\"line\">    String key = serviceKey(url);</span><br><span class=\"line\">    <span class=\"comment\">//构造服务的exporter</span></span><br><span class=\"line\">    <span class=\"comment\">//如同InjvmProtocol一样，DubboProtocol也是单例的，所以这里exporterMap也是单例的</span></span><br><span class=\"line\">    DubboExporter&lt;T&gt; exporter = <span class=\"keyword\">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class=\"line\">    <span class=\"comment\">//通过key放入exporterMap，把持有invoker的exporter 和serviceKey关联</span></span><br><span class=\"line\">    <span class=\"comment\">//这个在后面服务调用时，可以通过key找到对应的exporter进而找到invoker提供服务</span></span><br><span class=\"line\">    exporterMap.put(key, exporter);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//export an stub service for dispatching event</span></span><br><span class=\"line\">    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class=\"line\">    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class=\"line\">        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stubServiceMethods == <span class=\"keyword\">null</span> || stubServiceMethods.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"consumer [\"</span> + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class=\"line\">                                                      <span class=\"string\">\"], has set stubproxy support event ,but no stub methods founded.\"</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//根据url开启一个服务，比如绑定端口，开始接受请求</span></span><br><span class=\"line\">    openServer(url);</span><br><span class=\"line\">    optimizeSerialization(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exporter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里就可以对应下面的调用栈：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.export(DubboProtocol.java:267)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:57)</span><br><span class=\"line\">at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:63)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:100)</span><br><span class=\"line\">at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)</span><br><span class=\"line\">at org.apache.dubbo.registry.integration.RegistryProtocol.doLocalExport(RegistryProtocol.java:170)</span><br></pre></td></tr></table></figure>\n<p>再继续看openServer()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">openServer</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// find server.</span></span><br><span class=\"line\">    <span class=\"comment\">//key=host:port 用于定位server</span></span><br><span class=\"line\">    String key = url.getAddress();</span><br><span class=\"line\">    <span class=\"comment\">//client can export a service which's only for server to invoke</span></span><br><span class=\"line\">    <span class=\"comment\">//client也可以暴露一个只有server可以调用的服务</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isServer) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//服务实例放到serverMap中，key是host:port</span></span><br><span class=\"line\">        <span class=\"comment\">//这里serverMap也是单例的</span></span><br><span class=\"line\">        ExchangeServer server = serverMap.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (server == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                server = serverMap.get(key);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (server == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//通过createServer(url)方法获取server</span></span><br><span class=\"line\">                    serverMap.put(key, createServer(url));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// server supports reset, use together with override</span></span><br><span class=\"line\">            <span class=\"comment\">//server支持reset，配合override使用</span></span><br><span class=\"line\">            server.reset(url);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再继续看createServer()代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ExchangeServer <span class=\"title\">createServer</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// send readonly event when server closes, it's enabled by default</span></span><br><span class=\"line\">    <span class=\"comment\">//默认开启server关闭时关闭readonly事件</span></span><br><span class=\"line\">    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());</span><br><span class=\"line\">    <span class=\"comment\">// enable heartbeat by default</span></span><br><span class=\"line\">    <span class=\"comment\">//默认开启heartbeat</span></span><br><span class=\"line\">    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class=\"line\">    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class=\"line\">\t<span class=\"comment\">//通过server key检查是否是dubbo目前spi扩展支持的传输框架，默认是netty</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str != <span class=\"keyword\">null</span> &amp;&amp; str.length() &gt; <span class=\"number\">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Unsupported server type: \"</span> + str + <span class=\"string\">\", url: \"</span> + url);</span><br><span class=\"line\">\t<span class=\"comment\">//通过codec key获取编码方法，默认是dubbo</span></span><br><span class=\"line\">    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class=\"line\">    ExchangeServer server;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//构造具体服务实例，</span></span><br><span class=\"line\">\t    <span class=\"comment\">//Exchangers是门面类，里面封装了具体交换层实现，并调用它的bind方法</span></span><br><span class=\"line\">        server = Exchangers.bind(url, requestHandler);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Fail to start server(url: \"</span> + url + <span class=\"string\">\") \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//这里会验证一下客户端传输实现</span></span><br><span class=\"line\">    <span class=\"comment\">//如果没有对应的实现，会抛出异常</span></span><br><span class=\"line\">    str = url.getParameter(Constants.CLIENT_KEY);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str != <span class=\"keyword\">null</span> &amp;&amp; str.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Unsupported client type: \"</span> + str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续看Exchanges类的bind()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExchangeServer <span class=\"title\">bind</span><span class=\"params\">(URL url, ExchangeHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"handler == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class=\"string\">\"exchange\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getExchanger(url).bind(url, handler);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Exchanger <span class=\"title\">getExchanger</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getExchanger(type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Exchanger <span class=\"title\">getExchanger</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//HeaderExchanger类的bind()方法</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ExchangeServer <span class=\"title\">bind</span><span class=\"params\">(URL url, ExchangeHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HeaderExchangeServer(Transporters.bind(url, <span class=\"keyword\">new</span> DecodeHandler(<span class=\"keyword\">new</span> HeaderExchangeHandler(handler))));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续跟进Transporters.bind()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Server <span class=\"title\">bind</span><span class=\"params\">(URL url, ChannelHandler... handlers)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handlers == <span class=\"keyword\">null</span> || handlers.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"handlers == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ChannelHandler handler;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handlers.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        handler = handlers[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        handler = <span class=\"keyword\">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//根据Dubbo SPI机制，这里走NettyTransporter.bind()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getTransporter().bind(url, handler);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Transporter <span class=\"title\">getTransporter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NettyTransporter的bind方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Server <span class=\"title\">bind</span><span class=\"params\">(URL url, ChannelHandler listener)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//可以看到这里是NettyServer实例</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NettyServer(url, listener);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NettyServer构造器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NettyServer</span><span class=\"params\">(URL url, ChannelHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用父类AbstractServer构造器</span></span><br><span class=\"line\">    <span class=\"comment\">//注意下这里的ChannelHandlers.wrap()方法，生成MultiMessageHandler-&gt;HeartbeatHandler-&gt;AllChannelHandler的调用链</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看一下父类AbstractServer()的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AbstractServer</span><span class=\"params\">(URL url, ChannelHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(url, handler);</span><br><span class=\"line\">    localAddress = getUrl().toInetSocketAddress();</span><br><span class=\"line\"></span><br><span class=\"line\">    String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url.getParameter(Constants.ANYHOST_KEY, <span class=\"keyword\">false</span>) || NetUtils.isInvalidLocalHost(bindIp)) &#123;</span><br><span class=\"line\">        bindIp = NetUtils.ANYHOST;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bindAddress = <span class=\"keyword\">new</span> InetSocketAddress(bindIp, bindPort);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//打开端口，启动服务</span></span><br><span class=\"line\">        doOpen();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"Start \"</span> + getClass().getSimpleName() + <span class=\"string\">\" bind \"</span> + getBindAddress() + <span class=\"string\">\", export \"</span> + getLocalAddress());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(url.toInetSocketAddress(), <span class=\"keyword\">null</span>, <span class=\"string\">\"Failed to bind \"</span> + getClass().getSimpleName()</span><br><span class=\"line\">                                    + <span class=\"string\">\" on \"</span> + getLocalAddress() + <span class=\"string\">\", cause: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//fixme replace this with better method</span></span><br><span class=\"line\">    DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();</span><br><span class=\"line\">    executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看NettyServer的doOpen()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doOpen</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    bootstrap = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\"></span><br><span class=\"line\">    bossGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> DefaultThreadFactory(<span class=\"string\">\"NettyServerBoss\"</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">    workerGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),</span><br><span class=\"line\">                                        <span class=\"keyword\">new</span> DefaultThreadFactory(<span class=\"string\">\"NettyServerWorker\"</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> NettyServerHandler nettyServerHandler = <span class=\"keyword\">new</span> NettyServerHandler(getUrl(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    channels = nettyServerHandler.getChannels();</span><br><span class=\"line\"></span><br><span class=\"line\">    bootstrap.group(bossGroup, workerGroup)</span><br><span class=\"line\">        .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">        .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)</span><br><span class=\"line\">        .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</span><br><span class=\"line\">        .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class=\"line\">        .childHandler(<span class=\"keyword\">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                NettyCodecAdapter adapter = <span class=\"keyword\">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                ch.pipeline()<span class=\"comment\">//.addLast(\"logging\",new LoggingHandler(LogLevel.INFO))//for debug</span></span><br><span class=\"line\">                    .addLast(<span class=\"string\">\"decoder\"</span>, adapter.getDecoder())</span><br><span class=\"line\">                    .addLast(<span class=\"string\">\"encoder\"</span>, adapter.getEncoder())</span><br><span class=\"line\">                    .addLast(<span class=\"string\">\"handler\"</span>, nettyServerHandler);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// bind</span></span><br><span class=\"line\">    <span class=\"comment\">//bind地址，开启端口</span></span><br><span class=\"line\">    ChannelFuture channelFuture = bootstrap.bind(getBindAddress());</span><br><span class=\"line\">    channelFuture.syncUninterruptibly();</span><br><span class=\"line\">    channel = channelFuture.channel();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析到这里可以对应如下的调用栈：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.remoting.transport.netty4.NettyServer.doOpen(NettyServer.java:<span class=\"number\">97</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.transport.AbstractServer.&lt;init&gt;(AbstractServer.java:<span class=\"number\">63</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.transport.netty4.NettyServer.&lt;init&gt;(NettyServer.java:<span class=\"number\">65</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.transport.netty4.NettyTransporter.bind(NettyTransporter.java:<span class=\"number\">32</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.Transporter$Adaptive.bind(Transporter$Adaptive.java:-<span class=\"number\">1</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.Transporters.bind(Transporters.java:<span class=\"number\">56</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger.bind(HeaderExchanger.java:<span class=\"number\">44</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.exchange.Exchangers.bind(Exchangers.java:<span class=\"number\">70</span>)</span><br><span class=\"line\">    at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.createServer(DubboProtocol.java:<span class=\"number\">306</span>)</span><br><span class=\"line\">    at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.openServer(DubboProtocol.java:<span class=\"number\">283</span>)</span><br></pre></td></tr></table></figure>\n<p>分析到这里Dubbo服务提供者服务发布过程源码分析已经完成了，下面将继续分析服务注册过程。</p>\n<h3 id=\"Dubbo服务注册过程\"><a href=\"#Dubbo服务注册过程\" class=\"headerlink\" title=\"Dubbo服务注册过程\"></a>Dubbo服务注册过程</h3><p>在之前的分析中，我们知道注册服务的过程是从RegistryProtocol的export()方法开始的，我们来看一下export()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(<span class=\"keyword\">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//export invoker</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class=\"line\"></span><br><span class=\"line\">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//registry provider</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//to judge to delay publish whether or not</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> register = registeredProviderUrl.getParameter(<span class=\"string\">\"register\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (register) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//注册服务从这里开始</span></span><br><span class=\"line\">        register(registryUrl, registeredProviderUrl);</span><br><span class=\"line\">        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Subscribe the override data</span></span><br><span class=\"line\">    <span class=\"comment\">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> OverrideListener overrideSubscribeListener = <span class=\"keyword\">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class=\"line\">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class=\"line\">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class=\"line\">    <span class=\"comment\">//Ensure that a new exporter instance is returned every time export</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们再继续看register()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(URL registryUrl, URL registedProviderUrl)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//registryFactory是由Dubbo SPI机制生成的RegistryFactory$Adaptive的实例</span></span><br><span class=\"line\">    <span class=\"comment\">//调用其的getRegistry()方法获得registry</span></span><br><span class=\"line\">    Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class=\"line\">    registry.register(registedProviderUrl);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来看一下RegistryFactory$Adaptive类的getRegistry()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> org.apache.dubbo.registry.<span class=\"function\">Registry <span class=\"title\">getRegistry</span><span class=\"params\">(org.apache.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.common.URL url = arg0;</span><br><span class=\"line\">    String extName = (url.getProtocol() == <span class=\"keyword\">null</span> ? <span class=\"string\">\"dubbo\"</span> : url.getProtocol());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.registry.RegistryFactory) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([protocol])\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.registry.RegistryFactory extension = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//得到ZookeeperRegistryFactory的实例extension</span></span><br><span class=\"line\">        extension = (org.apache.dubbo.registry.RegistryFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.registry.RegistryFactory.class).getExtension(extName);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count.incrementAndGet() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"Failed to find extension named \"</span> + extName + <span class=\"string\">\" for type org.apache.dubbo.registry.RegistryFactory, will use default extension dubbo instead.\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        extension = (org.apache.dubbo.registry.RegistryFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.registry.RegistryFactory.class).getExtension(<span class=\"string\">\"dubbo\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extension.getRegistry(arg0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先调用ZookeeperRegister的父类FailbackRegistry的register()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.register(url);</span><br><span class=\"line\">    failedRegistered.remove(url);</span><br><span class=\"line\">    failedUnregistered.remove(url);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Sending a registration request to the server side</span></span><br><span class=\"line\">        doRegister(url);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        Throwable t = e;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">            &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">            &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> skipFailback = t <span class=\"keyword\">instanceof</span> SkipFailbackWrapperException;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (check || skipFailback) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (skipFailback) &#123;</span><br><span class=\"line\">                t = t.getCause();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Failed to register \"</span> + url + <span class=\"string\">\" to registry \"</span> + getUrl().getAddress() + <span class=\"string\">\", cause: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"Failed to register \"</span> + url + <span class=\"string\">\", waiting for retry, cause: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class=\"line\">        failedRegistered.add(url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后执行ZookeeperRegistry的doRegister()方法，向服务端发送注册请求：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doRegister</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Failed to register \"</span> + url + <span class=\"string\">\" to zookeeper \"</span> + getUrl() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务注册调用栈：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main@1&quot; prio=5 tid=0x1 nid=NA runnable</span><br><span class=\"line\">  java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\t  at org.apache.dubbo.registry.zookeeper.ZookeeperRegistry.doRegister(ZookeeperRegistry.java:114)</span><br><span class=\"line\">\t  at org.apache.dubbo.registry.support.FailbackRegistry.register(FailbackRegistry.java:137)</span><br><span class=\"line\">\t  at org.apache.dubbo.registry.integration.RegistryProtocol.register(RegistryProtocol.java:127)</span><br><span class=\"line\">\t  at org.apache.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:147)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)</span><br><span class=\"line\">\t  at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:61)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)</span><br><span class=\"line\">\t  - locked &lt;0x9bb&gt; (a org.apache.dubbo.config.spring.ServiceBean)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:123)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:49)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Dubbo服务端在启动服务时会经历怎样的调用过程？在收到消费者发送的请求后会经历怎样的调用过程？这篇文章主要针对以上两个调用过程并结合Dubbo源码进行分析。</p>\n<p>我们采用的是<a href=\"https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo\" target=\"_blank\" rel=\"noopener\"><strong>Consumer-Provider的Demo</strong></a>提供的示例，并按照<a href=\"https://shuaijunlan.github.io/2018/08/05/dubbo-consumer-calling-process-source-code-analysis/\">《Dubbo消费者调用过程源码分析》</a>中的分析思路，下面将对两种过程进行进一步分析，先来看一张服务发布过程的时序图(图片太大建议在新的窗口打开查看)，对服务发布与注册有个大致的了解：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/dubbo-provider.png?raw=true\" alt=\"\"></p>","more":"<h3 id=\"Dubbo服务发布过程\"><a href=\"#Dubbo服务发布过程\" class=\"headerlink\" title=\"Dubbo服务发布过程\"></a>Dubbo服务发布过程</h3><p>首先来看一下服务发布过程调用栈，我们将围绕这个调用栈一步步进行分析：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main@1&quot; prio=5 tid=0x1 nid=NA runnable</span><br><span class=\"line\">  java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.netty4.NettyServer.doOpen(NettyServer.java:97)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.AbstractServer.&lt;init&gt;(AbstractServer.java:63)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.netty4.NettyServer.&lt;init&gt;(NettyServer.java:65)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.netty4.NettyTransporter.bind(NettyTransporter.java:32)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.Transporter$Adaptive.bind(Transporter$Adaptive.java:-1)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.Transporters.bind(Transporters.java:56)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger.bind(HeaderExchanger.java:44)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.Exchangers.bind(Exchangers.java:70)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.createServer(DubboProtocol.java:306)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.openServer(DubboProtocol.java:283)</span><br><span class=\"line\">\t  - locked &lt;0x9ee&gt; (a org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.export(DubboProtocol.java:267)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:57)</span><br><span class=\"line\">\t  at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:63)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:100)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)</span><br><span class=\"line\">\t  at org.apache.dubbo.registry.integration.RegistryProtocol.doLocalExport(RegistryProtocol.java:170)</span><br><span class=\"line\">\t  - locked &lt;0x9e2&gt; (a java.util.concurrent.ConcurrentHashMap)</span><br><span class=\"line\">\t  at org.apache.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:133)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)</span><br><span class=\"line\">\t  at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:61)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)</span><br><span class=\"line\">\t  - locked &lt;0x848&gt; (a org.apache.dubbo.config.spring.ServiceBean)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:123)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:49)</span><br><span class=\"line\">\t  at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)</span><br><span class=\"line\">\t  at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)</span><br><span class=\"line\">\t  at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)</span><br><span class=\"line\">\t  at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:393)</span><br><span class=\"line\">\t  at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:347)</span><br><span class=\"line\">\t  at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:883)</span><br><span class=\"line\">\t  at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:546)</span><br><span class=\"line\">\t  - locked &lt;0xab7&gt; (a java.lang.Object)</span><br><span class=\"line\">\t  at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139)</span><br><span class=\"line\">\t  at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:83)</span><br><span class=\"line\">\t  at cn.shuaijunlan.dubbo.learning.main.Main.main(Main.java:13)</span><br></pre></td></tr></table></figure>\n<p>关于Dubbo是如何基于Spring解析xml文件中配置的ServiceBean这里不再赘述，可以参考我之前写的文章<a href=\"https://shuaijunlan.github.io/2018/08/13/dubbo-basing-on-spring-framework-analysis/\">《基于Spring构建Dubbo源码分析》</a>，这里将从发布服务的起始点开始将其，我们来看下ServiceBean类的部分函数实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个函数是实现了ApplicationListener接口的onApplicationEvent(E event)函数</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onApplicationEvent</span><span class=\"params\">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"The service ready on spring started. service: \"</span> + getInterface());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//发布服务的起始点</span></span><br><span class=\"line\">        export();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面调用的export()函数的实现在其子类ServiceConfig中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是一个同步方法，保证了多线程环境下的安全性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">export</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取export和delay属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (provider != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (export == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            export = provider.getExport();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delay == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            delay = provider.getDelay();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (export != <span class=\"keyword\">null</span> &amp;&amp; !export) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//判断是否延迟发布</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (delay != <span class=\"keyword\">null</span> &amp;&amp; delay &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//延迟delay时间后执行</span></span><br><span class=\"line\">        delayExportExecutor.schedule(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                doExport();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//发布服务</span></span><br><span class=\"line\">        doExport();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用synchonized进行同步，保证了线程安全性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">doExport</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (unexported) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already unexported!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exported) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将exported状态改为true</span></span><br><span class=\"line\">    exported = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interfaceName == <span class=\"keyword\">null</span> || interfaceName.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"&lt;dubbo:service interface=\\\"\\\" /&gt; interface not allow null!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    checkDefault();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (provider != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (application == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            application = provider.getApplication();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">module</span> == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">module</span> = provider.getModule();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registries == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            registries = provider.getRegistries();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (monitor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            monitor = provider.getMonitor();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (protocols == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            protocols = provider.getProtocols();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">module</span> != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registries == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            registries = <span class=\"keyword\">module</span>.getRegistries();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (monitor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            monitor = <span class=\"keyword\">module</span>.getMonitor();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (application != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registries == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            registries = application.getRegistries();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (monitor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            monitor = application.getMonitor();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ref <span class=\"keyword\">instanceof</span> GenericService) &#123;</span><br><span class=\"line\">        interfaceClass = GenericService.class;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isEmpty(generic)) &#123;</span><br><span class=\"line\">            generic = Boolean.TRUE.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            interfaceClass = Class.forName(interfaceName, <span class=\"keyword\">true</span>, Thread.currentThread()</span><br><span class=\"line\">                                           .getContextClassLoader());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class=\"line\">        checkRef();</span><br><span class=\"line\">        generic = Boolean.FALSE.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (local != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"true\"</span>.equals(local)) &#123;</span><br><span class=\"line\">            local = interfaceName + <span class=\"string\">\"Local\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Class&lt;?&gt; localClass;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The local implementation class \"</span> + localClass.getName() + <span class=\"string\">\" not implement interface \"</span> + interfaceName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (stub != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"true\"</span>.equals(stub)) &#123;</span><br><span class=\"line\">            stub = interfaceName + <span class=\"string\">\"Stub\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Class&lt;?&gt; stubClass;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!interfaceClass.isAssignableFrom(stubClass)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The stub implementation class \"</span> + stubClass.getName() + <span class=\"string\">\" not implement interface \"</span> + interfaceName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    checkApplication();</span><br><span class=\"line\">    checkRegistry();</span><br><span class=\"line\">    checkProtocol();</span><br><span class=\"line\">    appendProperties(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    checkStubAndMock(interfaceClass);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path == <span class=\"keyword\">null</span> || path.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        path = interfaceName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doExportUrls();</span><br><span class=\"line\">    ProviderModel providerModel = <span class=\"keyword\">new</span> ProviderModel(getUniqueServiceName(), <span class=\"keyword\">this</span>, ref);</span><br><span class=\"line\">    ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在doExport()函数中调用了doExportUrls()方法，我们将进一步分析doExportUrls()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doExportUrls</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//支持多个注册中心</span></span><br><span class=\"line\">    List&lt;URL&gt; registryURLs = loadRegistries(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行doExportUrlsFor1Protocol方法</span></span><br><span class=\"line\">        doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doExportUrlsFor1Protocol</span><span class=\"params\">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class=\"line\">    String name = protocolConfig.getName();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span> || name.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        name = <span class=\"string\">\"dubbo\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;();</span><br><span class=\"line\">    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class=\"line\">    map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());</span><br><span class=\"line\">    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ConfigUtils.getPid() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    appendParameters(map, application);</span><br><span class=\"line\">    appendParameters(map, <span class=\"keyword\">module</span>);</span><br><span class=\"line\">    appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class=\"line\">    appendParameters(map, protocolConfig);</span><br><span class=\"line\">    appendParameters(map, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (methods != <span class=\"keyword\">null</span> &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (MethodConfig method : methods) &#123;</span><br><span class=\"line\">            appendParameters(map, method, method.getName());</span><br><span class=\"line\">            String retryKey = method.getName() + <span class=\"string\">\".retry\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class=\"line\">                String retryValue = map.remove(retryKey);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">\"false\"</span>.equals(retryValue)) &#123;</span><br><span class=\"line\">                    map.put(method.getName() + <span class=\"string\">\".retries\"</span>, <span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            List&lt;ArgumentConfig&gt; arguments = method.getArguments();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arguments != <span class=\"keyword\">null</span> &amp;&amp; !arguments.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (ArgumentConfig argument : arguments) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// convert argument type</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (argument.getType() != <span class=\"keyword\">null</span> &amp;&amp; argument.getType().length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        Method[] methods = interfaceClass.getMethods();</span><br><span class=\"line\">                        <span class=\"comment\">// visit all methods</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (methods != <span class=\"keyword\">null</span> &amp;&amp; methods.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class=\"line\">                                String methodName = methods[i].getName();</span><br><span class=\"line\">                                <span class=\"comment\">// target the method, and get its signature</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class=\"line\">                                    Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();</span><br><span class=\"line\">                                    <span class=\"comment\">// one callback in the method</span></span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (argument.getIndex() != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                                        <span class=\"keyword\">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class=\"line\">                                            appendParameters(map, argument, method.getName() + <span class=\"string\">\".\"</span> + argument.getIndex());</span><br><span class=\"line\">                                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"argument config error : the index attribute and type attribute not match :index :\"</span> + argument.getIndex() + <span class=\"string\">\", type:\"</span> + argument.getType());</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                                        <span class=\"comment\">// multiple callbacks in the method</span></span><br><span class=\"line\">                                        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; argtypes.length; j++) &#123;</span><br><span class=\"line\">                                            Class&lt;?&gt; argclazz = argtypes[j];</span><br><span class=\"line\">                                            <span class=\"keyword\">if</span> (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class=\"line\">                                                appendParameters(map, argument, method.getName() + <span class=\"string\">\".\"</span> + j);</span><br><span class=\"line\">                                                <span class=\"keyword\">if</span> (argument.getIndex() != -<span class=\"number\">1</span> &amp;&amp; argument.getIndex() != j) &#123;</span><br><span class=\"line\">                                                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"argument config error : the index attribute and type attribute not match :index :\"</span> + argument.getIndex() + <span class=\"string\">\", type:\"</span> + argument.getType());</span><br><span class=\"line\">                                                &#125;</span><br><span class=\"line\">                                            &#125;</span><br><span class=\"line\">                                        &#125;</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (argument.getIndex() != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        appendParameters(map, argument, method.getName() + <span class=\"string\">\".\"</span> + argument.getIndex());</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"argument config must set index or type attribute.eg: &lt;dubbo:argument index='0' .../&gt; or &lt;dubbo:argument type=xxx .../&gt;\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// end of methods for</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class=\"line\">        map.put(Constants.GENERIC_KEY, generic);</span><br><span class=\"line\">        map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        String revision = Version.getVersion(interfaceClass, version);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (revision != <span class=\"keyword\">null</span> &amp;&amp; revision.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            map.put(<span class=\"string\">\"revision\"</span>, revision);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (methods.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"NO method found in service interface \"</span> + interfaceClass.getName());</span><br><span class=\"line\">            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            map.put(Constants.METHODS_KEY, StringUtils.join(<span class=\"keyword\">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class=\"string\">\",\"</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class=\"line\">            map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            map.put(Constants.TOKEN_KEY, token);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123;</span><br><span class=\"line\">        protocolConfig.setRegister(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">\"notify\"</span>, <span class=\"string\">\"false\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// export service</span></span><br><span class=\"line\">    String contextPath = protocolConfig.getContextpath();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((contextPath == <span class=\"keyword\">null</span> || contextPath.length() == <span class=\"number\">0</span>) &amp;&amp; provider != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        contextPath = provider.getContextpath();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    String host = <span class=\"keyword\">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class=\"line\">    Integer port = <span class=\"keyword\">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class=\"line\">    URL url = <span class=\"keyword\">new</span> URL(name, host, port, (contextPath == <span class=\"keyword\">null</span> || contextPath.length() == <span class=\"number\">0</span> ? <span class=\"string\">\"\"</span> : contextPath + <span class=\"string\">\"/\"</span>) + path, map);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class=\"line\">        .hasExtension(url.getProtocol())) &#123;</span><br><span class=\"line\">        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class=\"line\">            .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class=\"line\">    <span class=\"comment\">// don't export when none is configured</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// export to local if the config is not remote (export to remote only when config is remote)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//本地暴露（分析1）</span></span><br><span class=\"line\">            exportLocal(url);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// export to remote if the config is not local (export to local only when config is local)</span></span><br><span class=\"line\">        <span class=\"comment\">//如果配置不是local则暴露为远程服务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"Export dubbo service \"</span> + interfaceClass.getName() + <span class=\"string\">\" to url \"</span> + url);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (registryURLs != <span class=\"keyword\">null</span> &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//多个注册中心</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class=\"line\">                    url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class=\"line\">                    URL monitorUrl = loadMonitor(registryURL);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (monitorUrl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">                        logger.info(<span class=\"string\">\"Register dubbo service \"</span> + interfaceClass.getName() + <span class=\"string\">\" url \"</span> + url + <span class=\"string\">\" to registry \"</span> + registryURL);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class=\"line\">                    String proxy = url.getParameter(Constants.PROXY_KEY);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class=\"line\">                        registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//根据Java SPI机制得到ProxyFactory$Adaptive类的实例proxyFactory</span></span><br><span class=\"line\">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class=\"line\">                    <span class=\"comment\">//获取包装类??</span></span><br><span class=\"line\">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class=\"keyword\">new</span> DelegateProviderMetaDataInvoker(invoker, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//调用Protocol$Adaptive的export()方法</span></span><br><span class=\"line\">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class=\"line\">                    exporters.add(exporter);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//没有注册中心，只在本机IP打开服务端口生成服务代理，并不注册到注册中心</span></span><br><span class=\"line\">                Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class=\"line\">                DelegateProviderMetaDataInvoker wrapperInvoker = <span class=\"keyword\">new</span> DelegateProviderMetaDataInvoker(invoker, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">                Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class=\"line\">                exporters.add(exporter);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.urls.add(url);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"本地服务发布过程\"><a href=\"#本地服务发布过程\" class=\"headerlink\" title=\"本地服务发布过程\"></a>本地服务发布过程</h4><p>首先是进入exportLocal()函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">exportLocal</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class=\"line\">        URL local = URL.valueOf(url.toFullString())</span><br><span class=\"line\">            .setProtocol(Constants.LOCAL_PROTOCOL)</span><br><span class=\"line\">            .setHost(LOCALHOST)</span><br><span class=\"line\">            .setPort(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));</span><br><span class=\"line\">        <span class=\"comment\">//这是核心步骤，先是执行proxyFactory.getInvoker()方法生成invoker，然后是执行protocol.export()方法暴露服务，下面将会分别介绍</span></span><br><span class=\"line\">        Exporter&lt;?&gt; exporter = protocol.export(</span><br><span class=\"line\">            proxyFactory.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class=\"line\">        exporters.add(exporter);</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"Export dubbo service \"</span> + interfaceClass.getName() + <span class=\"string\">\" to local registry\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"分析proxyFactory-getInvoker-过程\"><a href=\"#分析proxyFactory-getInvoker-过程\" class=\"headerlink\" title=\"分析proxyFactory.getInvoker()过程\"></a>分析proxyFactory.getInvoker()过程</h5><p>通过Dubbo SPI机制（详见<a href=\"https://shuaijunlan.github.io/2018/08/09/dubbo-spi-analysis/\">《Dubbo SPI机制源码分析》</a>），proxyFactory是ProxyFactory$Adaptive类的实例，我们来看它的getInvoker()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传入三个参数，分别是ref、interfaceClass和url</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Invoker <span class=\"title\">getInvoker</span><span class=\"params\">(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.common.URL url = arg2;</span><br><span class=\"line\">    <span class=\"comment\">//默认是使用Javassist生成代理</span></span><br><span class=\"line\">    String extName = url.getParameter(<span class=\"string\">\"proxy\"</span>, <span class=\"string\">\"javassist\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.ProxyFactory) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([proxy])\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//根据Dubbo SPI机制得到JavassistProxyFactory扩展类</span></span><br><span class=\"line\">    org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extension.getInvoker(arg0, arg1, arg2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后调用extension.getInvoker()方法，这里的extension，默认是JavassistProxyFactory类的实例（也是基于Java SPI机制），然后调用它的getInvoker()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">getInvoker</span><span class=\"params\">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'</span></span><br><span class=\"line\">    <span class=\"comment\">//获取包装类,具体代码是怎样的？</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class=\"string\">'$'</span>) &lt; <span class=\"number\">0</span> ? proxy.getClass() : type);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">doInvoke</span><span class=\"params\">(T proxy, String methodName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  Object[] arguments)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里以文章开头的Demo为例，通过Wrapper.getWrapper()返回的类代码，这里需要代码hack：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.common.DemoService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapper0</span> <span class=\"keyword\">extends</span> <span class=\"title\">Wrapper</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">ClassGenerator</span>.<span class=\"title\">DC</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String[] pns;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Map pts;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String[] mns;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String[] dmns;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Class[] mts0;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String[] getPropertyNames()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pns;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasProperty</span><span class=\"params\">(String paramString)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pts.containsKey(paramString);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Class <span class=\"title\">getPropertyType</span><span class=\"params\">(String paramString)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Class)pts.get(paramString);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String[] getMethodNames()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mns;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> String[] getDeclaredMethodNames()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dmns;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setPropertyValue</span><span class=\"params\">(Object paramObject1, String paramString, Object paramObject2)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      DemoService localDemoService = (DemoService)paramObject1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable localThrowable)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(localThrowable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchPropertyException(<span class=\"string\">\"Not found property \\\"\"</span> + paramString + <span class=\"string\">\"\\\" filed or setter method in class com.alibaba.dubbo.common.DemoService.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getPropertyValue</span><span class=\"params\">(Object paramObject, String paramString)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      DemoService localDemoService = (DemoService)paramObject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable localThrowable)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(localThrowable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchPropertyException(<span class=\"string\">\"Not found property \\\"\"</span> + paramString + <span class=\"string\">\"\\\" filed or setter method in class com.alibaba.dubbo.common.DemoService.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">  <span class=\"comment\">//(**看这里，关键方法实现****)</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invokeMethod</span><span class=\"params\">(Object paramObject, String paramString, Class[] paramArrayOfClass, Object[] paramArrayOfObject)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InvocationTargetException</span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    DemoService localDemoService;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"comment\">//赋值执行实例，这里是接口实现类，DemoServiceImpl对象</span></span><br><span class=\"line\">      localDemoService = (DemoService)paramObject;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable localThrowable1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(localThrowable1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"comment\">//根据传入的要调用的方法名paramString,方法参数值，调用执行实例方法</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((<span class=\"string\">\"sayHello\"</span>.equals(paramString)) || (paramArrayOfClass.length == <span class=\"number\">1</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> localDemoService.sayHello((String)paramArrayOfObject[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (Throwable localThrowable2)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InvocationTargetException(localThrowable2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchMethodException(<span class=\"string\">\"Not found method \\\"\"</span> + paramString + <span class=\"string\">\"\\\" in class com.alibaba.dubbo.common.DemoService.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这就比较清楚了解具体的代理的过程了。</p>\n<h5 id=\"分析protocol-export-过程\"><a href=\"#分析protocol-export-过程\" class=\"headerlink\" title=\"分析protocol.export()过程\"></a>分析protocol.export()过程</h5><p>上面的过程已经生成好了invoker对象，接下来就要通过Protocol$Adaptive的export()方法暴露服务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Exporter <span class=\"title\">export</span><span class=\"params\">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument == null\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg0.getUrl() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument getUrl() == null\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class=\"line\">    String extName = (url.getProtocol() == <span class=\"keyword\">null</span> ? <span class=\"string\">\"MEAT-INF.dubbo\"</span> : url.getProtocol());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([protocol])\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//因为这是本地服务发布，因此protocol为injvm</span></span><br><span class=\"line\">    <span class=\"comment\">//所以这里会走到InjvmProtocol的export()方法</span></span><br><span class=\"line\">    org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extension.export(arg0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看下InjvmProtocol的export()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//返回InjvmExporter对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>InjvmExporter的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(invoker);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.exporterMap = exporterMap;</span><br><span class=\"line\">    <span class=\"comment\">//存的形式，serviceKey:自身(exporter) put到map关联起来，这样可以通过servciekey找到exporterMap然后找到invoker</span></span><br><span class=\"line\">    exporterMap.put(key, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的exporterMap是由InjvmProtocol实例拥有，而InjvmProtocol又是单例的，因为InjvmProtocol类有如下实例和方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//静态自身成员变量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> InjvmProtocol INSTANCE;</span><br><span class=\"line\"><span class=\"comment\">//构造方法，把自己赋值给INSTANCE对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InjvmProtocol</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    INSTANCE = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以exporterMap对象也是单例的，同时这里顺便看下InjvmProtocol的refer()方法，本地服务的引用查找也是通过自身的exporterMap对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; serviceType, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//把exporterMap对象赋值给InjvmInvoker</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InjvmInvoker&lt;T&gt;(serviceType, url, url.getServiceKey(), exporterMap);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//具体查找过程</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过exporterMap获取exporter</span></span><br><span class=\"line\">    Exporter&lt;?&gt; exporter = InjvmProtocol.getExporter(exporterMap, getUrl());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exporter == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Service [\"</span> + key + <span class=\"string\">\"] not found.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RpcContext.getContext().setRemoteAddress(NetUtils.LOCALHOST, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exporter.getInvoker().invoke(invocation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上的所有步骤就是本地服务的发布和引用过程。</p>\n<h4 id=\"远程服务发布\"><a href=\"#远程服务发布\" class=\"headerlink\" title=\"远程服务发布\"></a>远程服务发布</h4><p>上面调用了proFactory的getInvoker()方法，我们来看一下<code>ProxyFactory$Adaptive.getInvoker()</code>的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传入三个参数，分别是ref、interfaceClass和url</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Invoker <span class=\"title\">getInvoker</span><span class=\"params\">(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.common.URL url = arg2;</span><br><span class=\"line\">    <span class=\"comment\">//默认是使用Javassist生成代理</span></span><br><span class=\"line\">    String extName = url.getParameter(<span class=\"string\">\"proxy\"</span>, <span class=\"string\">\"javassist\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.ProxyFactory) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([proxy])\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//根据Dubbo SPI机制得到JavassistProxyFactory扩展类</span></span><br><span class=\"line\">    org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extension.getInvoker(arg0, arg1, arg2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看一下<code>JavassistProxyFactory.getInvoker()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">getInvoker</span><span class=\"params\">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'</span></span><br><span class=\"line\">    <span class=\"comment\">//获取包装类,具体代码是怎样的？</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class=\"string\">'$'</span>) &lt; <span class=\"number\">0</span> ? proxy.getClass() : type);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">doInvoke</span><span class=\"params\">(T proxy, String methodName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  Object[] arguments)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在doExportUrlsFor1Protocol()方法中还调用了<code>Protocol$Adaptive.export()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Exporter <span class=\"title\">export</span><span class=\"params\">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument == null\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg0.getUrl() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.MEAT-INF.dubbo.rpc.Invoker argument getUrl() == null\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class=\"line\">    String extName = (url.getProtocol() == <span class=\"keyword\">null</span> ? <span class=\"string\">\"MEAT-INF.dubbo\"</span> : url.getProtocol());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([protocol])\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extension.export(arg0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据Dubbo SPI机制可以看出调用<code>RegistryProtocol.export()</code>方法，Protocol还定义了ProtocolFilterWrapper、QosProtocolWrapper和ProtocolListenerWrapper三个Wrapper扩展点，根据ExtensionLoader的加载规则，他会返回<code>ProtocolFilterWrapper-&gt;QosProtocolWrapper-&gt;ProtocolListenerWrapper-&gt;RegistryProtocol</code>（对象链调用顺序还待进一步求证）对象链：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(<span class=\"keyword\">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//export invoker</span></span><br><span class=\"line\">    <span class=\"comment\">//暴露invoker（暴露服务过程从这里开始，看doLocalExport()）</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//registry provider</span></span><br><span class=\"line\">    <span class=\"comment\">//获取对应注册中心操作对象</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class=\"line\">    <span class=\"comment\">//获取要注册到注册中心的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//to judge to delay publish whether or not</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> register = registeredProviderUrl.getParameter(<span class=\"string\">\"register\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);</span><br><span class=\"line\">\t<span class=\"comment\">//判断是否注册服务</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (register) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行注册(服务注册过程从这里开始)</span></span><br><span class=\"line\">        register(registryUrl, registeredProviderUrl);</span><br><span class=\"line\">        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Subscribe the override data</span></span><br><span class=\"line\">    <span class=\"comment\">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> OverrideListener overrideSubscribeListener = <span class=\"keyword\">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class=\"line\">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class=\"line\">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class=\"line\">    <span class=\"comment\">//Ensure that a new exporter instance is returned every time export</span></span><br><span class=\"line\">    <span class=\"comment\">//保证每次export都返回一个新的exporter实例</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此有如下的调用栈：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:133)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)</span><br><span class=\"line\">at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:61)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)</span><br><span class=\"line\">at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)</span><br></pre></td></tr></table></figure>\n<p>继续看执行服务暴露的函数<code>doLocalExport()</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">ExporterChangeableWrapper&lt;T&gt; <span class=\"title\">doLocalExport</span><span class=\"params\">(<span class=\"keyword\">final</span> Invoker&lt;T&gt; originInvoker)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过原始originInvoker构造缓存key</span></span><br><span class=\"line\">    String key = getCacheKey(originInvoker);</span><br><span class=\"line\">    ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class=\"line\">    <span class=\"comment\">//没有缓存，走具体暴露流程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exporter == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (bounds) &#123;</span><br><span class=\"line\">            exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (exporter == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//InvokerDelegete是RegistryProtocol类的静态内部类，继承自InvokerWrapper，</span></span><br><span class=\"line\">\t\t    \t<span class=\"comment\">//通过构造器赋值持有代理originInvoker和服务暴露协议url对象,算是包装一层</span></span><br><span class=\"line\">                <span class=\"comment\">//而url 是通过getProviderUrl(originInvoker)返回的，此时url的协议已是dubbo，即服务暴露的协议</span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> Invoker&lt;?&gt; invokerDelegete = <span class=\"keyword\">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//ExporterChangeableWrapper是RegistryProtocol的私有内部类实现了Exporter接口。</span></span><br><span class=\"line\">                <span class=\"comment\">//通过调用它的构造方法(Exporter&lt;T&gt; exporter, Invoker&lt;T&gt; originInvoker)构造exporterWrapper实例</span></span><br><span class=\"line\">\t\t    \t<span class=\"comment\">//而这里传入的exporter是通过(Exporter&lt;T&gt;) protocol.export(invokerDelegete)语句创建</span></span><br><span class=\"line\">\t\t    \t<span class=\"comment\">//由上一步知道，这里的invokerDelegete里url属性的protocol协议已经是dubbo</span></span><br><span class=\"line\">                <span class=\"comment\">//下面具体看下protocol.export(invokerDelegete)方法。</span></span><br><span class=\"line\">                exporter = <span class=\"keyword\">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);</span><br><span class=\"line\">                bounds.put(key, exporter);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exporter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再继续往下看，通过调用Protocol$Adaptive类的export()方法，然后再调用DubboProtocol的export()方法，同理在这里也会生成<code>ProtocolFilterWrapper-&gt;QosProtocolWrapper-&gt;ProtocolListenerWrapper-&gt;DubboProtocol</code>对象链：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    URL url = invoker.getUrl();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// export service.</span></span><br><span class=\"line\">    <span class=\"comment\">//获取service key</span></span><br><span class=\"line\">    <span class=\"comment\">//key的组成group/service:version:port</span></span><br><span class=\"line\">    String key = serviceKey(url);</span><br><span class=\"line\">    <span class=\"comment\">//构造服务的exporter</span></span><br><span class=\"line\">    <span class=\"comment\">//如同InjvmProtocol一样，DubboProtocol也是单例的，所以这里exporterMap也是单例的</span></span><br><span class=\"line\">    DubboExporter&lt;T&gt; exporter = <span class=\"keyword\">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class=\"line\">    <span class=\"comment\">//通过key放入exporterMap，把持有invoker的exporter 和serviceKey关联</span></span><br><span class=\"line\">    <span class=\"comment\">//这个在后面服务调用时，可以通过key找到对应的exporter进而找到invoker提供服务</span></span><br><span class=\"line\">    exporterMap.put(key, exporter);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//export an stub service for dispatching event</span></span><br><span class=\"line\">    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class=\"line\">    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class=\"line\">        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stubServiceMethods == <span class=\"keyword\">null</span> || stubServiceMethods.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"consumer [\"</span> + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class=\"line\">                                                      <span class=\"string\">\"], has set stubproxy support event ,but no stub methods founded.\"</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//根据url开启一个服务，比如绑定端口，开始接受请求</span></span><br><span class=\"line\">    openServer(url);</span><br><span class=\"line\">    optimizeSerialization(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> exporter;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里就可以对应下面的调用栈：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.export(DubboProtocol.java:267)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:57)</span><br><span class=\"line\">at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:63)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:100)</span><br><span class=\"line\">at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)</span><br><span class=\"line\">at org.apache.dubbo.registry.integration.RegistryProtocol.doLocalExport(RegistryProtocol.java:170)</span><br></pre></td></tr></table></figure>\n<p>再继续看openServer()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">openServer</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// find server.</span></span><br><span class=\"line\">    <span class=\"comment\">//key=host:port 用于定位server</span></span><br><span class=\"line\">    String key = url.getAddress();</span><br><span class=\"line\">    <span class=\"comment\">//client can export a service which's only for server to invoke</span></span><br><span class=\"line\">    <span class=\"comment\">//client也可以暴露一个只有server可以调用的服务</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isServer) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//服务实例放到serverMap中，key是host:port</span></span><br><span class=\"line\">        <span class=\"comment\">//这里serverMap也是单例的</span></span><br><span class=\"line\">        ExchangeServer server = serverMap.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (server == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                server = serverMap.get(key);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (server == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//通过createServer(url)方法获取server</span></span><br><span class=\"line\">                    serverMap.put(key, createServer(url));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// server supports reset, use together with override</span></span><br><span class=\"line\">            <span class=\"comment\">//server支持reset，配合override使用</span></span><br><span class=\"line\">            server.reset(url);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再继续看createServer()代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ExchangeServer <span class=\"title\">createServer</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// send readonly event when server closes, it's enabled by default</span></span><br><span class=\"line\">    <span class=\"comment\">//默认开启server关闭时关闭readonly事件</span></span><br><span class=\"line\">    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());</span><br><span class=\"line\">    <span class=\"comment\">// enable heartbeat by default</span></span><br><span class=\"line\">    <span class=\"comment\">//默认开启heartbeat</span></span><br><span class=\"line\">    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class=\"line\">    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class=\"line\">\t<span class=\"comment\">//通过server key检查是否是dubbo目前spi扩展支持的传输框架，默认是netty</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str != <span class=\"keyword\">null</span> &amp;&amp; str.length() &gt; <span class=\"number\">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Unsupported server type: \"</span> + str + <span class=\"string\">\", url: \"</span> + url);</span><br><span class=\"line\">\t<span class=\"comment\">//通过codec key获取编码方法，默认是dubbo</span></span><br><span class=\"line\">    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class=\"line\">    ExchangeServer server;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//构造具体服务实例，</span></span><br><span class=\"line\">\t    <span class=\"comment\">//Exchangers是门面类，里面封装了具体交换层实现，并调用它的bind方法</span></span><br><span class=\"line\">        server = Exchangers.bind(url, requestHandler);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Fail to start server(url: \"</span> + url + <span class=\"string\">\") \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//这里会验证一下客户端传输实现</span></span><br><span class=\"line\">    <span class=\"comment\">//如果没有对应的实现，会抛出异常</span></span><br><span class=\"line\">    str = url.getParameter(Constants.CLIENT_KEY);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str != <span class=\"keyword\">null</span> &amp;&amp; str.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Unsupported client type: \"</span> + str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续看Exchanges类的bind()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExchangeServer <span class=\"title\">bind</span><span class=\"params\">(URL url, ExchangeHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"handler == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class=\"string\">\"exchange\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getExchanger(url).bind(url, handler);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Exchanger <span class=\"title\">getExchanger</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getExchanger(type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Exchanger <span class=\"title\">getExchanger</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//HeaderExchanger类的bind()方法</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ExchangeServer <span class=\"title\">bind</span><span class=\"params\">(URL url, ExchangeHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HeaderExchangeServer(Transporters.bind(url, <span class=\"keyword\">new</span> DecodeHandler(<span class=\"keyword\">new</span> HeaderExchangeHandler(handler))));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续跟进Transporters.bind()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Server <span class=\"title\">bind</span><span class=\"params\">(URL url, ChannelHandler... handlers)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handlers == <span class=\"keyword\">null</span> || handlers.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"handlers == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ChannelHandler handler;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handlers.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        handler = handlers[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        handler = <span class=\"keyword\">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//根据Dubbo SPI机制，这里走NettyTransporter.bind()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getTransporter().bind(url, handler);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Transporter <span class=\"title\">getTransporter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NettyTransporter的bind方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Server <span class=\"title\">bind</span><span class=\"params\">(URL url, ChannelHandler listener)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//可以看到这里是NettyServer实例</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NettyServer(url, listener);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//NettyServer构造器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NettyServer</span><span class=\"params\">(URL url, ChannelHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用父类AbstractServer构造器</span></span><br><span class=\"line\">    <span class=\"comment\">//注意下这里的ChannelHandlers.wrap()方法，生成MultiMessageHandler-&gt;HeartbeatHandler-&gt;AllChannelHandler的调用链</span></span><br><span class=\"line\">    <span class=\"keyword\">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看一下父类AbstractServer()的构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AbstractServer</span><span class=\"params\">(URL url, ChannelHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(url, handler);</span><br><span class=\"line\">    localAddress = getUrl().toInetSocketAddress();</span><br><span class=\"line\"></span><br><span class=\"line\">    String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url.getParameter(Constants.ANYHOST_KEY, <span class=\"keyword\">false</span>) || NetUtils.isInvalidLocalHost(bindIp)) &#123;</span><br><span class=\"line\">        bindIp = NetUtils.ANYHOST;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bindAddress = <span class=\"keyword\">new</span> InetSocketAddress(bindIp, bindPort);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//打开端口，启动服务</span></span><br><span class=\"line\">        doOpen();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"Start \"</span> + getClass().getSimpleName() + <span class=\"string\">\" bind \"</span> + getBindAddress() + <span class=\"string\">\", export \"</span> + getLocalAddress());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(url.toInetSocketAddress(), <span class=\"keyword\">null</span>, <span class=\"string\">\"Failed to bind \"</span> + getClass().getSimpleName()</span><br><span class=\"line\">                                    + <span class=\"string\">\" on \"</span> + getLocalAddress() + <span class=\"string\">\", cause: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//fixme replace this with better method</span></span><br><span class=\"line\">    DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();</span><br><span class=\"line\">    executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看NettyServer的doOpen()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doOpen</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    bootstrap = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\"></span><br><span class=\"line\">    bossGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> DefaultThreadFactory(<span class=\"string\">\"NettyServerBoss\"</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">    workerGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),</span><br><span class=\"line\">                                        <span class=\"keyword\">new</span> DefaultThreadFactory(<span class=\"string\">\"NettyServerWorker\"</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> NettyServerHandler nettyServerHandler = <span class=\"keyword\">new</span> NettyServerHandler(getUrl(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    channels = nettyServerHandler.getChannels();</span><br><span class=\"line\"></span><br><span class=\"line\">    bootstrap.group(bossGroup, workerGroup)</span><br><span class=\"line\">        .channel(NioServerSocketChannel.class)</span><br><span class=\"line\">        .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)</span><br><span class=\"line\">        .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</span><br><span class=\"line\">        .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class=\"line\">        .childHandler(<span class=\"keyword\">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(NioSocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                NettyCodecAdapter adapter = <span class=\"keyword\">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                ch.pipeline()<span class=\"comment\">//.addLast(\"logging\",new LoggingHandler(LogLevel.INFO))//for debug</span></span><br><span class=\"line\">                    .addLast(<span class=\"string\">\"decoder\"</span>, adapter.getDecoder())</span><br><span class=\"line\">                    .addLast(<span class=\"string\">\"encoder\"</span>, adapter.getEncoder())</span><br><span class=\"line\">                    .addLast(<span class=\"string\">\"handler\"</span>, nettyServerHandler);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// bind</span></span><br><span class=\"line\">    <span class=\"comment\">//bind地址，开启端口</span></span><br><span class=\"line\">    ChannelFuture channelFuture = bootstrap.bind(getBindAddress());</span><br><span class=\"line\">    channelFuture.syncUninterruptibly();</span><br><span class=\"line\">    channel = channelFuture.channel();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析到这里可以对应如下的调用栈：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.remoting.transport.netty4.NettyServer.doOpen(NettyServer.java:<span class=\"number\">97</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.transport.AbstractServer.&lt;init&gt;(AbstractServer.java:<span class=\"number\">63</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.transport.netty4.NettyServer.&lt;init&gt;(NettyServer.java:<span class=\"number\">65</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.transport.netty4.NettyTransporter.bind(NettyTransporter.java:<span class=\"number\">32</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.Transporter$Adaptive.bind(Transporter$Adaptive.java:-<span class=\"number\">1</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.Transporters.bind(Transporters.java:<span class=\"number\">56</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.exchange.support.header.HeaderExchanger.bind(HeaderExchanger.java:<span class=\"number\">44</span>)</span><br><span class=\"line\">    at org.apache.dubbo.remoting.exchange.Exchangers.bind(Exchangers.java:<span class=\"number\">70</span>)</span><br><span class=\"line\">    at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.createServer(DubboProtocol.java:<span class=\"number\">306</span>)</span><br><span class=\"line\">    at org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.openServer(DubboProtocol.java:<span class=\"number\">283</span>)</span><br></pre></td></tr></table></figure>\n<p>分析到这里Dubbo服务提供者服务发布过程源码分析已经完成了，下面将继续分析服务注册过程。</p>\n<h3 id=\"Dubbo服务注册过程\"><a href=\"#Dubbo服务注册过程\" class=\"headerlink\" title=\"Dubbo服务注册过程\"></a>Dubbo服务注册过程</h3><p>在之前的分析中，我们知道注册服务的过程是从RegistryProtocol的export()方法开始的，我们来看一下export()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(<span class=\"keyword\">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//export invoker</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class=\"line\"></span><br><span class=\"line\">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//registry provider</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//to judge to delay publish whether or not</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> register = registeredProviderUrl.getParameter(<span class=\"string\">\"register\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (register) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//注册服务从这里开始</span></span><br><span class=\"line\">        register(registryUrl, registeredProviderUrl);</span><br><span class=\"line\">        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Subscribe the override data</span></span><br><span class=\"line\">    <span class=\"comment\">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> OverrideListener overrideSubscribeListener = <span class=\"keyword\">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class=\"line\">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class=\"line\">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class=\"line\">    <span class=\"comment\">//Ensure that a new exporter instance is returned every time export</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们再继续看register()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(URL registryUrl, URL registedProviderUrl)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//registryFactory是由Dubbo SPI机制生成的RegistryFactory$Adaptive的实例</span></span><br><span class=\"line\">    <span class=\"comment\">//调用其的getRegistry()方法获得registry</span></span><br><span class=\"line\">    Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class=\"line\">    registry.register(registedProviderUrl);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来看一下RegistryFactory$Adaptive类的getRegistry()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> org.apache.dubbo.registry.<span class=\"function\">Registry <span class=\"title\">getRegistry</span><span class=\"params\">(org.apache.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.common.URL url = arg0;</span><br><span class=\"line\">    String extName = (url.getProtocol() == <span class=\"keyword\">null</span> ? <span class=\"string\">\"dubbo\"</span> : url.getProtocol());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.registry.RegistryFactory) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([protocol])\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.registry.RegistryFactory extension = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//得到ZookeeperRegistryFactory的实例extension</span></span><br><span class=\"line\">        extension = (org.apache.dubbo.registry.RegistryFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.registry.RegistryFactory.class).getExtension(extName);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count.incrementAndGet() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"Failed to find extension named \"</span> + extName + <span class=\"string\">\" for type org.apache.dubbo.registry.RegistryFactory, will use default extension dubbo instead.\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        extension = (org.apache.dubbo.registry.RegistryFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.registry.RegistryFactory.class).getExtension(<span class=\"string\">\"dubbo\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extension.getRegistry(arg0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先调用ZookeeperRegister的父类FailbackRegistry的register()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">register</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.register(url);</span><br><span class=\"line\">    failedRegistered.remove(url);</span><br><span class=\"line\">    failedUnregistered.remove(url);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Sending a registration request to the server side</span></span><br><span class=\"line\">        doRegister(url);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        Throwable t = e;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">            &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">            &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> skipFailback = t <span class=\"keyword\">instanceof</span> SkipFailbackWrapperException;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (check || skipFailback) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (skipFailback) &#123;</span><br><span class=\"line\">                t = t.getCause();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Failed to register \"</span> + url + <span class=\"string\">\" to registry \"</span> + getUrl().getAddress() + <span class=\"string\">\", cause: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"Failed to register \"</span> + url + <span class=\"string\">\", waiting for retry, cause: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class=\"line\">        failedRegistered.add(url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后执行ZookeeperRegistry的doRegister()方法，向服务端发送注册请求：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doRegister</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class=\"keyword\">true</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Failed to register \"</span> + url + <span class=\"string\">\" to zookeeper \"</span> + getUrl() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务注册调用栈：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main@1&quot; prio=5 tid=0x1 nid=NA runnable</span><br><span class=\"line\">  java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\t  at org.apache.dubbo.registry.zookeeper.ZookeeperRegistry.doRegister(ZookeeperRegistry.java:114)</span><br><span class=\"line\">\t  at org.apache.dubbo.registry.support.FailbackRegistry.register(FailbackRegistry.java:137)</span><br><span class=\"line\">\t  at org.apache.dubbo.registry.integration.RegistryProtocol.register(RegistryProtocol.java:127)</span><br><span class=\"line\">\t  at org.apache.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:147)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)</span><br><span class=\"line\">\t  at org.apache.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:61)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java:-1)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)</span><br><span class=\"line\">\t  - locked &lt;0x9bb&gt; (a org.apache.dubbo.config.spring.ServiceBean)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:123)</span><br><span class=\"line\">\t  at org.apache.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:49)</span><br></pre></td></tr></table></figure>"},{"title":"Dubbo服务端接收请求及响应请求原理分析","date":"2018-09-24T02:57:36.000Z","_content":"\n之前一篇文章[《Dubbo服务提供者发布及注册过程源码分析》](https://shuaijunlan.github.io/2018/09/09/dubbo-provider-calling-process-source-code-analysis/)已经介绍了Dubbo服务端的服务注册及发布过程，这篇文章将会介绍Dubbo服务端是如何接受请求以及响应请求的。\n\n本文还是以[**Consumer-Provider的Demo**](https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo)为例，分析接收请求及响应请求的具体流程，在Dubbo服务端发布服务之后，它将会监听一个端口等待接收客户端的请求，当接收到请求后，会经过入站处理器进行处理，我们知道在发布服务的时候设置了`NettyServerHandler`入站处理器，接收到请求之后，会经过`NettyServerHandler#channelRead()`方法来获取请求的消息，我们来看一下它的实现：\n\n```java\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n    //以ctx.channel()为key，以NettyChannel为value，存储在ConcurrentHashMap中\n    NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n    try {\n        handler.received(channel, msg);\n    } finally {\n        NettyChannel.removeChannelIfDisconnected(ctx.channel());\n    }\n}\n```\n\n<!-- more -->\n\n下面先来看一张整个接收请求和处理请求的流程图，下面将会围绕这张图进行详细的分析：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-10-02 15-49-47.png?raw=true)![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-10-02 15-50-13.png?raw=true)\n\n来看一下`HeaderExchangeHandler#received()`方法：\n\n```java\n@Override\npublic void received(Channel channel, Object message) throws RemotingException {\n    channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());\n    final ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);\n    try {\n        if (message instanceof Request) {//如果是你Request类型的消息\n            // handle request.\n            Request request = (Request) message;\n            if (request.isEvent()) {//事件类型的消息\n                handlerEvent(channel, request);\n            } else {\n                if (request.isTwoWay()) {//请求，需返回：第一种情况，使用handleRequest()处理\n                    handleRequest(exchangeChannel, request);\n                } else {//请求，不需返回：第二种情况，处理请求不需要响应\n                    handler.received(exchangeChannel, request.getData());\n                }\n            }\n        } else if (message instanceof Response) {//如果是Response类型的消息：第三种情况\n            handleResponse(channel, (Response) message);\n        } else if (message instanceof String) {//如果是String类型的消息\n            if (isClientSide(channel)) {\n                Exception e = new Exception(\"Dubbo client can not supported string message: \" + message + \" in channel: \" + channel + \", url: \" + channel.getUrl());\n                logger.error(e.getMessage(), e);\n            } else {//响应回显请求\n                String echo = handler.telnet(channel, (String) message);\n                if (echo != null && echo.length() > 0) {\n                    channel.send(echo);\n                }\n            }\n        } else {//其他情况\n            handler.received(exchangeChannel, message);\n        }\n    } finally {\n        HeaderExchangeChannel.removeChannelIfDisconnected(channel);\n    }\n}\n```\n\n下面我们来分析request-response的模式，也是就分析handleRequest()方法：\n\n```java\nvoid handleRequest(final ExchangeChannel channel, Request req) throws RemotingException {\n    //创建一个Response对象\n    Response res = new Response(req.getId(), req.getVersion());\n    //isBroken？是什么意思？，待进一步探究\n    if (req.isBroken()) {\n        Object data = req.getData();\n\n        String msg;\n        if (data == null) msg = null;\n        else if (data instanceof Throwable) msg = StringUtils.toString((Throwable) data);\n        else msg = data.toString();\n        res.setErrorMessage(\"Fail to decode request due to: \" + msg);\n        res.setStatus(Response.BAD_REQUEST);\n\n        channel.send(res);\n        return;\n    }\n    // find handler by message class.\n    Object msg = req.getData();\n    try {\n        // handle data.\n        //异步处理请求，使用CompletableFuture接收结果\n        //handler实例是在DubboProtocol类中通过匿名内部类实例化传递进来的，可以查看DubboProtocol的77行代码\n        CompletableFuture<Object> future = handler.reply(channel, msg);\n        //执行完成，获取结果\n        if (future.isDone()) {\n            res.setStatus(Response.OK);\n            res.setResult(future.get());\n            //返回结果\n            channel.send(res);\n            return;\n        }\n        //基于通知机制，获取结果\n        future.whenComplete((result, t) -> {\n            try {\n                if (t == null) {\n                    res.setStatus(Response.OK);\n                    res.setResult(result);\n                } else {\n                    res.setStatus(Response.SERVICE_ERROR);\n                    res.setErrorMessage(StringUtils.toString(t));\n                }\n                //返回结果\n                channel.send(res);\n            } catch (RemotingException e) {\n                logger.warn(\"Send result to consumer failed, channel is \" + channel + \", msg is \" + e);\n            } finally {\n                // HeaderExchangeChannel.removeChannelIfDisconnected(channel);\n            }\n        });\n    } catch (Throwable e) {\n        //处理异常，返回结果\n        res.setStatus(Response.SERVICE_ERROR);\n        res.setErrorMessage(StringUtils.toString(e));\n        channel.send(res);\n    }\n}\n```\n\n继续看DubboProtocol类中匿名内部类`ExchangeHandlerAdapter#reply()`方法：\n\n```java\n@Override\npublic CompletableFuture<Object> reply(ExchangeChannel channel, Object message) throws RemotingException {\n    if (message instanceof Invocation) {\n        Invocation inv = (Invocation) message;\n        //获取调用者\n        Invoker<?> invoker = getInvoker(channel, inv);\n        // need to consider backward-compatibility if it's a callback\n        if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {\n            String methodsStr = invoker.getUrl().getParameters().get(\"methods\");\n            boolean hasMethod = false;\n            if (methodsStr == null || !methodsStr.contains(\",\")) {\n                hasMethod = inv.getMethodName().equals(methodsStr);\n            } else {\n                String[] methods = methodsStr.split(\",\");\n                for (String method : methods) {\n                    if (inv.getMethodName().equals(method)) {\n                        hasMethod = true;\n                        break;\n                    }\n                }\n            }\n            if (!hasMethod) {\n                logger.warn(new IllegalStateException(\"The methodName \" + inv.getMethodName()\n                                                      + \" not found in callback service interface ,invoke will be ignored.\"\n                                                      + \" please update the api interface. url is:\"\n                                                      + invoker.getUrl()) + \" ,invocation is :\" + inv);\n                return null;\n            }\n        }\n        //获取调用的上下文，底层使用ThreadLocal实现\n        RpcContext rpcContext = RpcContext.getContext();\n        boolean supportServerAsync = invoker.getUrl().getMethodParameter(inv.getMethodName(), Constants.ASYNC_KEY, false);\n        if (supportServerAsync) {\n            CompletableFuture<Object> future = new CompletableFuture<>();\n            rpcContext.setAsyncContext(new AsyncContextImpl(future));\n        }\n        rpcContext.setRemoteAddress(channel.getRemoteAddress());\n        //发起调用\n        Result result = invoker.invoke(inv);\n\n        if (result instanceof AsyncRpcResult) {\n            return ((AsyncRpcResult) result).getResultFuture().thenApply(r -> (Object) r);\n        } else {\n            return CompletableFuture.completedFuture(result);\n        }\n    }\n    throw new RemotingException(channel, \"Unsupported request: \"\n                                + (message == null ? null : (message.getClass().getName() + \": \" + message))\n                                + \", channel: consumer: \" + channel.getRemoteAddress() + \" --> provider: \" + channel.getLocalAddress());\n}\n```\n\n最后获取结果执行`channel.send()`方法，向服务消费方返回数据\n\n调用栈：\n\n```\n\"DubboServerHandler-211.69.197.55:20881-thread-2@3215\" daemon prio=5 tid=0x1a nid=NA runnable\n  java.lang.Thread.State: RUNNABLE\n\t  at org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:101)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.send(HeaderExchangeChannel.java:89)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.send(HeaderExchangeChannel.java:78)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler.handleRequest(HeaderExchangeHandler.java:103)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler.received(HeaderExchangeHandler.java:196)\n\t  at org.apache.dubbo.remoting.transport.DecodeHandler.received(DecodeHandler.java:51)\n\t  at org.apache.dubbo.remoting.transport.dispatcher.ChannelEventRunnable.run(ChannelEventRunnable.java:57)\n\t  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\t  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\t  at java.lang.Thread.run(Thread.java:748)\n```\n\n","source":"_posts/dubbo-provider-request-and-response-analysis.md","raw":"---\ntitle: Dubbo服务端接收请求及响应请求原理分析\ndate: 2018-09-24 10:57:36\ntags:\n    - dubbo\n---\n\n之前一篇文章[《Dubbo服务提供者发布及注册过程源码分析》](https://shuaijunlan.github.io/2018/09/09/dubbo-provider-calling-process-source-code-analysis/)已经介绍了Dubbo服务端的服务注册及发布过程，这篇文章将会介绍Dubbo服务端是如何接受请求以及响应请求的。\n\n本文还是以[**Consumer-Provider的Demo**](https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo)为例，分析接收请求及响应请求的具体流程，在Dubbo服务端发布服务之后，它将会监听一个端口等待接收客户端的请求，当接收到请求后，会经过入站处理器进行处理，我们知道在发布服务的时候设置了`NettyServerHandler`入站处理器，接收到请求之后，会经过`NettyServerHandler#channelRead()`方法来获取请求的消息，我们来看一下它的实现：\n\n```java\n@Override\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n    //以ctx.channel()为key，以NettyChannel为value，存储在ConcurrentHashMap中\n    NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n    try {\n        handler.received(channel, msg);\n    } finally {\n        NettyChannel.removeChannelIfDisconnected(ctx.channel());\n    }\n}\n```\n\n<!-- more -->\n\n下面先来看一张整个接收请求和处理请求的流程图，下面将会围绕这张图进行详细的分析：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-10-02 15-49-47.png?raw=true)![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-10-02 15-50-13.png?raw=true)\n\n来看一下`HeaderExchangeHandler#received()`方法：\n\n```java\n@Override\npublic void received(Channel channel, Object message) throws RemotingException {\n    channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());\n    final ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);\n    try {\n        if (message instanceof Request) {//如果是你Request类型的消息\n            // handle request.\n            Request request = (Request) message;\n            if (request.isEvent()) {//事件类型的消息\n                handlerEvent(channel, request);\n            } else {\n                if (request.isTwoWay()) {//请求，需返回：第一种情况，使用handleRequest()处理\n                    handleRequest(exchangeChannel, request);\n                } else {//请求，不需返回：第二种情况，处理请求不需要响应\n                    handler.received(exchangeChannel, request.getData());\n                }\n            }\n        } else if (message instanceof Response) {//如果是Response类型的消息：第三种情况\n            handleResponse(channel, (Response) message);\n        } else if (message instanceof String) {//如果是String类型的消息\n            if (isClientSide(channel)) {\n                Exception e = new Exception(\"Dubbo client can not supported string message: \" + message + \" in channel: \" + channel + \", url: \" + channel.getUrl());\n                logger.error(e.getMessage(), e);\n            } else {//响应回显请求\n                String echo = handler.telnet(channel, (String) message);\n                if (echo != null && echo.length() > 0) {\n                    channel.send(echo);\n                }\n            }\n        } else {//其他情况\n            handler.received(exchangeChannel, message);\n        }\n    } finally {\n        HeaderExchangeChannel.removeChannelIfDisconnected(channel);\n    }\n}\n```\n\n下面我们来分析request-response的模式，也是就分析handleRequest()方法：\n\n```java\nvoid handleRequest(final ExchangeChannel channel, Request req) throws RemotingException {\n    //创建一个Response对象\n    Response res = new Response(req.getId(), req.getVersion());\n    //isBroken？是什么意思？，待进一步探究\n    if (req.isBroken()) {\n        Object data = req.getData();\n\n        String msg;\n        if (data == null) msg = null;\n        else if (data instanceof Throwable) msg = StringUtils.toString((Throwable) data);\n        else msg = data.toString();\n        res.setErrorMessage(\"Fail to decode request due to: \" + msg);\n        res.setStatus(Response.BAD_REQUEST);\n\n        channel.send(res);\n        return;\n    }\n    // find handler by message class.\n    Object msg = req.getData();\n    try {\n        // handle data.\n        //异步处理请求，使用CompletableFuture接收结果\n        //handler实例是在DubboProtocol类中通过匿名内部类实例化传递进来的，可以查看DubboProtocol的77行代码\n        CompletableFuture<Object> future = handler.reply(channel, msg);\n        //执行完成，获取结果\n        if (future.isDone()) {\n            res.setStatus(Response.OK);\n            res.setResult(future.get());\n            //返回结果\n            channel.send(res);\n            return;\n        }\n        //基于通知机制，获取结果\n        future.whenComplete((result, t) -> {\n            try {\n                if (t == null) {\n                    res.setStatus(Response.OK);\n                    res.setResult(result);\n                } else {\n                    res.setStatus(Response.SERVICE_ERROR);\n                    res.setErrorMessage(StringUtils.toString(t));\n                }\n                //返回结果\n                channel.send(res);\n            } catch (RemotingException e) {\n                logger.warn(\"Send result to consumer failed, channel is \" + channel + \", msg is \" + e);\n            } finally {\n                // HeaderExchangeChannel.removeChannelIfDisconnected(channel);\n            }\n        });\n    } catch (Throwable e) {\n        //处理异常，返回结果\n        res.setStatus(Response.SERVICE_ERROR);\n        res.setErrorMessage(StringUtils.toString(e));\n        channel.send(res);\n    }\n}\n```\n\n继续看DubboProtocol类中匿名内部类`ExchangeHandlerAdapter#reply()`方法：\n\n```java\n@Override\npublic CompletableFuture<Object> reply(ExchangeChannel channel, Object message) throws RemotingException {\n    if (message instanceof Invocation) {\n        Invocation inv = (Invocation) message;\n        //获取调用者\n        Invoker<?> invoker = getInvoker(channel, inv);\n        // need to consider backward-compatibility if it's a callback\n        if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {\n            String methodsStr = invoker.getUrl().getParameters().get(\"methods\");\n            boolean hasMethod = false;\n            if (methodsStr == null || !methodsStr.contains(\",\")) {\n                hasMethod = inv.getMethodName().equals(methodsStr);\n            } else {\n                String[] methods = methodsStr.split(\",\");\n                for (String method : methods) {\n                    if (inv.getMethodName().equals(method)) {\n                        hasMethod = true;\n                        break;\n                    }\n                }\n            }\n            if (!hasMethod) {\n                logger.warn(new IllegalStateException(\"The methodName \" + inv.getMethodName()\n                                                      + \" not found in callback service interface ,invoke will be ignored.\"\n                                                      + \" please update the api interface. url is:\"\n                                                      + invoker.getUrl()) + \" ,invocation is :\" + inv);\n                return null;\n            }\n        }\n        //获取调用的上下文，底层使用ThreadLocal实现\n        RpcContext rpcContext = RpcContext.getContext();\n        boolean supportServerAsync = invoker.getUrl().getMethodParameter(inv.getMethodName(), Constants.ASYNC_KEY, false);\n        if (supportServerAsync) {\n            CompletableFuture<Object> future = new CompletableFuture<>();\n            rpcContext.setAsyncContext(new AsyncContextImpl(future));\n        }\n        rpcContext.setRemoteAddress(channel.getRemoteAddress());\n        //发起调用\n        Result result = invoker.invoke(inv);\n\n        if (result instanceof AsyncRpcResult) {\n            return ((AsyncRpcResult) result).getResultFuture().thenApply(r -> (Object) r);\n        } else {\n            return CompletableFuture.completedFuture(result);\n        }\n    }\n    throw new RemotingException(channel, \"Unsupported request: \"\n                                + (message == null ? null : (message.getClass().getName() + \": \" + message))\n                                + \", channel: consumer: \" + channel.getRemoteAddress() + \" --> provider: \" + channel.getLocalAddress());\n}\n```\n\n最后获取结果执行`channel.send()`方法，向服务消费方返回数据\n\n调用栈：\n\n```\n\"DubboServerHandler-211.69.197.55:20881-thread-2@3215\" daemon prio=5 tid=0x1a nid=NA runnable\n  java.lang.Thread.State: RUNNABLE\n\t  at org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:101)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.send(HeaderExchangeChannel.java:89)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.send(HeaderExchangeChannel.java:78)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler.handleRequest(HeaderExchangeHandler.java:103)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler.received(HeaderExchangeHandler.java:196)\n\t  at org.apache.dubbo.remoting.transport.DecodeHandler.received(DecodeHandler.java:51)\n\t  at org.apache.dubbo.remoting.transport.dispatcher.ChannelEventRunnable.run(ChannelEventRunnable.java:57)\n\t  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\t  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\t  at java.lang.Thread.run(Thread.java:748)\n```\n\n","slug":"dubbo-provider-request-and-response-analysis","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4w0016zjiasasfz78n","content":"<p>之前一篇文章<a href=\"https://shuaijunlan.github.io/2018/09/09/dubbo-provider-calling-process-source-code-analysis/\">《Dubbo服务提供者发布及注册过程源码分析》</a>已经介绍了Dubbo服务端的服务注册及发布过程，这篇文章将会介绍Dubbo服务端是如何接受请求以及响应请求的。</p>\n<p>本文还是以<a href=\"https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo\" target=\"_blank\" rel=\"noopener\"><strong>Consumer-Provider的Demo</strong></a>为例，分析接收请求及响应请求的具体流程，在Dubbo服务端发布服务之后，它将会监听一个端口等待接收客户端的请求，当接收到请求后，会经过入站处理器进行处理，我们知道在发布服务的时候设置了<code>NettyServerHandler</code>入站处理器，接收到请求之后，会经过<code>NettyServerHandler#channelRead()</code>方法来获取请求的消息，我们来看一下它的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//以ctx.channel()为key，以NettyChannel为value，存储在ConcurrentHashMap中</span></span><br><span class=\"line\">    NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        handler.received(channel, msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>下面先来看一张整个接收请求和处理请求的流程图，下面将会围绕这张图进行详细的分析：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-10-02 15-49-47.png?raw=true\" alt=\"\"><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-10-02 15-50-13.png?raw=true\" alt=\"\"></p>\n<p>来看一下<code>HeaderExchangeHandler#received()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">received</span><span class=\"params\">(Channel channel, Object message)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (message <span class=\"keyword\">instanceof</span> Request) &#123;<span class=\"comment\">//如果是你Request类型的消息</span></span><br><span class=\"line\">            <span class=\"comment\">// handle request.</span></span><br><span class=\"line\">            Request request = (Request) message;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (request.isEvent()) &#123;<span class=\"comment\">//事件类型的消息</span></span><br><span class=\"line\">                handlerEvent(channel, request);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (request.isTwoWay()) &#123;<span class=\"comment\">//请求，需返回：第一种情况，使用handleRequest()处理</span></span><br><span class=\"line\">                    handleRequest(exchangeChannel, request);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//请求，不需返回：第二种情况，处理请求不需要响应</span></span><br><span class=\"line\">                    handler.received(exchangeChannel, request.getData());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (message <span class=\"keyword\">instanceof</span> Response) &#123;<span class=\"comment\">//如果是Response类型的消息：第三种情况</span></span><br><span class=\"line\">            handleResponse(channel, (Response) message);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (message <span class=\"keyword\">instanceof</span> String) &#123;<span class=\"comment\">//如果是String类型的消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isClientSide(channel)) &#123;</span><br><span class=\"line\">                Exception e = <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Dubbo client can not supported string message: \"</span> + message + <span class=\"string\">\" in channel: \"</span> + channel + <span class=\"string\">\", url: \"</span> + channel.getUrl());</span><br><span class=\"line\">                logger.error(e.getMessage(), e);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//响应回显请求</span></span><br><span class=\"line\">                String echo = handler.telnet(channel, (String) message);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (echo != <span class=\"keyword\">null</span> &amp;&amp; echo.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    channel.send(echo);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//其他情况</span></span><br><span class=\"line\">            handler.received(exchangeChannel, message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面我们来分析request-response的模式，也是就分析handleRequest()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> ExchangeChannel channel, Request req)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个Response对象</span></span><br><span class=\"line\">    Response res = <span class=\"keyword\">new</span> Response(req.getId(), req.getVersion());</span><br><span class=\"line\">    <span class=\"comment\">//isBroken？是什么意思？，待进一步探究</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (req.isBroken()) &#123;</span><br><span class=\"line\">        Object data = req.getData();</span><br><span class=\"line\"></span><br><span class=\"line\">        String msg;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span>) msg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data <span class=\"keyword\">instanceof</span> Throwable) msg = StringUtils.toString((Throwable) data);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> msg = data.toString();</span><br><span class=\"line\">        res.setErrorMessage(<span class=\"string\">\"Fail to decode request due to: \"</span> + msg);</span><br><span class=\"line\">        res.setStatus(Response.BAD_REQUEST);</span><br><span class=\"line\"></span><br><span class=\"line\">        channel.send(res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// find handler by message class.</span></span><br><span class=\"line\">    Object msg = req.getData();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle data.</span></span><br><span class=\"line\">        <span class=\"comment\">//异步处理请求，使用CompletableFuture接收结果</span></span><br><span class=\"line\">        <span class=\"comment\">//handler实例是在DubboProtocol类中通过匿名内部类实例化传递进来的，可以查看DubboProtocol的77行代码</span></span><br><span class=\"line\">        CompletableFuture&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class=\"line\">        <span class=\"comment\">//执行完成，获取结果</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (future.isDone()) &#123;</span><br><span class=\"line\">            res.setStatus(Response.OK);</span><br><span class=\"line\">            res.setResult(future.get());</span><br><span class=\"line\">            <span class=\"comment\">//返回结果</span></span><br><span class=\"line\">            channel.send(res);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//基于通知机制，获取结果</span></span><br><span class=\"line\">        future.whenComplete((result, t) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    res.setStatus(Response.OK);</span><br><span class=\"line\">                    res.setResult(result);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res.setStatus(Response.SERVICE_ERROR);</span><br><span class=\"line\">                    res.setErrorMessage(StringUtils.toString(t));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//返回结果</span></span><br><span class=\"line\">                channel.send(res);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"Send result to consumer failed, channel is \"</span> + channel + <span class=\"string\">\", msg is \"</span> + e);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//处理异常，返回结果</span></span><br><span class=\"line\">        res.setStatus(Response.SERVICE_ERROR);</span><br><span class=\"line\">        res.setErrorMessage(StringUtils.toString(e));</span><br><span class=\"line\">        channel.send(res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续看DubboProtocol类中匿名内部类<code>ExchangeHandlerAdapter#reply()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CompletableFuture&lt;Object&gt; <span class=\"title\">reply</span><span class=\"params\">(ExchangeChannel channel, Object message)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (message <span class=\"keyword\">instanceof</span> Invocation) &#123;</span><br><span class=\"line\">        Invocation inv = (Invocation) message;</span><br><span class=\"line\">        <span class=\"comment\">//获取调用者</span></span><br><span class=\"line\">        Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class=\"line\">        <span class=\"comment\">// need to consider backward-compatibility if it's a callback</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class=\"line\">            String methodsStr = invoker.getUrl().getParameters().get(<span class=\"string\">\"methods\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> hasMethod = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (methodsStr == <span class=\"keyword\">null</span> || !methodsStr.contains(<span class=\"string\">\",\"</span>)) &#123;</span><br><span class=\"line\">                hasMethod = inv.getMethodName().equals(methodsStr);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                String[] methods = methodsStr.split(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (String method : methods) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (inv.getMethodName().equals(method)) &#123;</span><br><span class=\"line\">                        hasMethod = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasMethod) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The methodName \"</span> + inv.getMethodName()</span><br><span class=\"line\">                                                      + <span class=\"string\">\" not found in callback service interface ,invoke will be ignored.\"</span></span><br><span class=\"line\">                                                      + <span class=\"string\">\" please update the api interface. url is:\"</span></span><br><span class=\"line\">                                                      + invoker.getUrl()) + <span class=\"string\">\" ,invocation is :\"</span> + inv);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取调用的上下文，底层使用ThreadLocal实现</span></span><br><span class=\"line\">        RpcContext rpcContext = RpcContext.getContext();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> supportServerAsync = invoker.getUrl().getMethodParameter(inv.getMethodName(), Constants.ASYNC_KEY, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (supportServerAsync) &#123;</span><br><span class=\"line\">            CompletableFuture&lt;Object&gt; future = <span class=\"keyword\">new</span> CompletableFuture&lt;&gt;();</span><br><span class=\"line\">            rpcContext.setAsyncContext(<span class=\"keyword\">new</span> AsyncContextImpl(future));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rpcContext.setRemoteAddress(channel.getRemoteAddress());</span><br><span class=\"line\">        <span class=\"comment\">//发起调用</span></span><br><span class=\"line\">        Result result = invoker.invoke(inv);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result <span class=\"keyword\">instanceof</span> AsyncRpcResult) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ((AsyncRpcResult) result).getResultFuture().thenApply(r -&gt; (Object) r);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> CompletableFuture.completedFuture(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(channel, <span class=\"string\">\"Unsupported request: \"</span></span><br><span class=\"line\">                                + (message == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : (message.getClass().getName() + <span class=\"string\">\": \"</span> + message))</span><br><span class=\"line\">                                + <span class=\"string\">\", channel: consumer: \"</span> + channel.getRemoteAddress() + <span class=\"string\">\" --&gt; provider: \"</span> + channel.getLocalAddress());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后获取结果执行<code>channel.send()</code>方法，向服务消费方返回数据</p>\n<p>调用栈：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;DubboServerHandler-211.69.197.55:20881-thread-2@3215&quot; daemon prio=5 tid=0x1a nid=NA runnable</span><br><span class=\"line\">  java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:101)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.send(HeaderExchangeChannel.java:89)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.send(HeaderExchangeChannel.java:78)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler.handleRequest(HeaderExchangeHandler.java:103)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler.received(HeaderExchangeHandler.java:196)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.DecodeHandler.received(DecodeHandler.java:51)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.dispatcher.ChannelEventRunnable.run(ChannelEventRunnable.java:57)</span><br><span class=\"line\">\t  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class=\"line\">\t  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class=\"line\">\t  at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>之前一篇文章<a href=\"https://shuaijunlan.github.io/2018/09/09/dubbo-provider-calling-process-source-code-analysis/\">《Dubbo服务提供者发布及注册过程源码分析》</a>已经介绍了Dubbo服务端的服务注册及发布过程，这篇文章将会介绍Dubbo服务端是如何接受请求以及响应请求的。</p>\n<p>本文还是以<a href=\"https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo\" target=\"_blank\" rel=\"noopener\"><strong>Consumer-Provider的Demo</strong></a>为例，分析接收请求及响应请求的具体流程，在Dubbo服务端发布服务之后，它将会监听一个端口等待接收客户端的请求，当接收到请求后，会经过入站处理器进行处理，我们知道在发布服务的时候设置了<code>NettyServerHandler</code>入站处理器，接收到请求之后，会经过<code>NettyServerHandler#channelRead()</code>方法来获取请求的消息，我们来看一下它的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//以ctx.channel()为key，以NettyChannel为value，存储在ConcurrentHashMap中</span></span><br><span class=\"line\">    NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        handler.received(channel, msg);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<p>下面先来看一张整个接收请求和处理请求的流程图，下面将会围绕这张图进行详细的分析：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-10-02 15-49-47.png?raw=true\" alt=\"\"><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-10-02 15-50-13.png?raw=true\" alt=\"\"></p>\n<p>来看一下<code>HeaderExchangeHandler#received()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">received</span><span class=\"params\">(Channel channel, Object message)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (message <span class=\"keyword\">instanceof</span> Request) &#123;<span class=\"comment\">//如果是你Request类型的消息</span></span><br><span class=\"line\">            <span class=\"comment\">// handle request.</span></span><br><span class=\"line\">            Request request = (Request) message;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (request.isEvent()) &#123;<span class=\"comment\">//事件类型的消息</span></span><br><span class=\"line\">                handlerEvent(channel, request);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (request.isTwoWay()) &#123;<span class=\"comment\">//请求，需返回：第一种情况，使用handleRequest()处理</span></span><br><span class=\"line\">                    handleRequest(exchangeChannel, request);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//请求，不需返回：第二种情况，处理请求不需要响应</span></span><br><span class=\"line\">                    handler.received(exchangeChannel, request.getData());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (message <span class=\"keyword\">instanceof</span> Response) &#123;<span class=\"comment\">//如果是Response类型的消息：第三种情况</span></span><br><span class=\"line\">            handleResponse(channel, (Response) message);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (message <span class=\"keyword\">instanceof</span> String) &#123;<span class=\"comment\">//如果是String类型的消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isClientSide(channel)) &#123;</span><br><span class=\"line\">                Exception e = <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Dubbo client can not supported string message: \"</span> + message + <span class=\"string\">\" in channel: \"</span> + channel + <span class=\"string\">\", url: \"</span> + channel.getUrl());</span><br><span class=\"line\">                logger.error(e.getMessage(), e);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//响应回显请求</span></span><br><span class=\"line\">                String echo = handler.telnet(channel, (String) message);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (echo != <span class=\"keyword\">null</span> &amp;&amp; echo.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    channel.send(echo);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//其他情况</span></span><br><span class=\"line\">            handler.received(exchangeChannel, message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面我们来分析request-response的模式，也是就分析handleRequest()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">handleRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> ExchangeChannel channel, Request req)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建一个Response对象</span></span><br><span class=\"line\">    Response res = <span class=\"keyword\">new</span> Response(req.getId(), req.getVersion());</span><br><span class=\"line\">    <span class=\"comment\">//isBroken？是什么意思？，待进一步探究</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (req.isBroken()) &#123;</span><br><span class=\"line\">        Object data = req.getData();</span><br><span class=\"line\"></span><br><span class=\"line\">        String msg;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span>) msg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (data <span class=\"keyword\">instanceof</span> Throwable) msg = StringUtils.toString((Throwable) data);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> msg = data.toString();</span><br><span class=\"line\">        res.setErrorMessage(<span class=\"string\">\"Fail to decode request due to: \"</span> + msg);</span><br><span class=\"line\">        res.setStatus(Response.BAD_REQUEST);</span><br><span class=\"line\"></span><br><span class=\"line\">        channel.send(res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// find handler by message class.</span></span><br><span class=\"line\">    Object msg = req.getData();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// handle data.</span></span><br><span class=\"line\">        <span class=\"comment\">//异步处理请求，使用CompletableFuture接收结果</span></span><br><span class=\"line\">        <span class=\"comment\">//handler实例是在DubboProtocol类中通过匿名内部类实例化传递进来的，可以查看DubboProtocol的77行代码</span></span><br><span class=\"line\">        CompletableFuture&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class=\"line\">        <span class=\"comment\">//执行完成，获取结果</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (future.isDone()) &#123;</span><br><span class=\"line\">            res.setStatus(Response.OK);</span><br><span class=\"line\">            res.setResult(future.get());</span><br><span class=\"line\">            <span class=\"comment\">//返回结果</span></span><br><span class=\"line\">            channel.send(res);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//基于通知机制，获取结果</span></span><br><span class=\"line\">        future.whenComplete((result, t) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    res.setStatus(Response.OK);</span><br><span class=\"line\">                    res.setResult(result);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    res.setStatus(Response.SERVICE_ERROR);</span><br><span class=\"line\">                    res.setErrorMessage(StringUtils.toString(t));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//返回结果</span></span><br><span class=\"line\">                channel.send(res);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"Send result to consumer failed, channel is \"</span> + channel + <span class=\"string\">\", msg is \"</span> + e);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//处理异常，返回结果</span></span><br><span class=\"line\">        res.setStatus(Response.SERVICE_ERROR);</span><br><span class=\"line\">        res.setErrorMessage(StringUtils.toString(e));</span><br><span class=\"line\">        channel.send(res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续看DubboProtocol类中匿名内部类<code>ExchangeHandlerAdapter#reply()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CompletableFuture&lt;Object&gt; <span class=\"title\">reply</span><span class=\"params\">(ExchangeChannel channel, Object message)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (message <span class=\"keyword\">instanceof</span> Invocation) &#123;</span><br><span class=\"line\">        Invocation inv = (Invocation) message;</span><br><span class=\"line\">        <span class=\"comment\">//获取调用者</span></span><br><span class=\"line\">        Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class=\"line\">        <span class=\"comment\">// need to consider backward-compatibility if it's a callback</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class=\"line\">            String methodsStr = invoker.getUrl().getParameters().get(<span class=\"string\">\"methods\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> hasMethod = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (methodsStr == <span class=\"keyword\">null</span> || !methodsStr.contains(<span class=\"string\">\",\"</span>)) &#123;</span><br><span class=\"line\">                hasMethod = inv.getMethodName().equals(methodsStr);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                String[] methods = methodsStr.split(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (String method : methods) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (inv.getMethodName().equals(method)) &#123;</span><br><span class=\"line\">                        hasMethod = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasMethod) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"The methodName \"</span> + inv.getMethodName()</span><br><span class=\"line\">                                                      + <span class=\"string\">\" not found in callback service interface ,invoke will be ignored.\"</span></span><br><span class=\"line\">                                                      + <span class=\"string\">\" please update the api interface. url is:\"</span></span><br><span class=\"line\">                                                      + invoker.getUrl()) + <span class=\"string\">\" ,invocation is :\"</span> + inv);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取调用的上下文，底层使用ThreadLocal实现</span></span><br><span class=\"line\">        RpcContext rpcContext = RpcContext.getContext();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> supportServerAsync = invoker.getUrl().getMethodParameter(inv.getMethodName(), Constants.ASYNC_KEY, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (supportServerAsync) &#123;</span><br><span class=\"line\">            CompletableFuture&lt;Object&gt; future = <span class=\"keyword\">new</span> CompletableFuture&lt;&gt;();</span><br><span class=\"line\">            rpcContext.setAsyncContext(<span class=\"keyword\">new</span> AsyncContextImpl(future));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rpcContext.setRemoteAddress(channel.getRemoteAddress());</span><br><span class=\"line\">        <span class=\"comment\">//发起调用</span></span><br><span class=\"line\">        Result result = invoker.invoke(inv);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result <span class=\"keyword\">instanceof</span> AsyncRpcResult) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ((AsyncRpcResult) result).getResultFuture().thenApply(r -&gt; (Object) r);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> CompletableFuture.completedFuture(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(channel, <span class=\"string\">\"Unsupported request: \"</span></span><br><span class=\"line\">                                + (message == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : (message.getClass().getName() + <span class=\"string\">\": \"</span> + message))</span><br><span class=\"line\">                                + <span class=\"string\">\", channel: consumer: \"</span> + channel.getRemoteAddress() + <span class=\"string\">\" --&gt; provider: \"</span> + channel.getLocalAddress());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后获取结果执行<code>channel.send()</code>方法，向服务消费方返回数据</p>\n<p>调用栈：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;DubboServerHandler-211.69.197.55:20881-thread-2@3215&quot; daemon prio=5 tid=0x1a nid=NA runnable</span><br><span class=\"line\">  java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:101)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.send(HeaderExchangeChannel.java:89)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.send(HeaderExchangeChannel.java:78)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler.handleRequest(HeaderExchangeHandler.java:103)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeHandler.received(HeaderExchangeHandler.java:196)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.DecodeHandler.received(DecodeHandler.java:51)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.dispatcher.ChannelEventRunnable.run(ChannelEventRunnable.java:57)</span><br><span class=\"line\">\t  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class=\"line\">\t  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class=\"line\">\t  at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>"},{"title":"Dubbo基于Javassist实现动态代理分析","date":"2018-08-02T08:22:08.000Z","_content":"\n```\norg.apache.dubbo.common.bytecode.Proxy\t//生成代理类\norg.apache.dubbo.common.bytecode.ClassGenerator  //基于javassist封装\n\norg.apache.dubbo.common.utils.ClassHelper;  //工具类\norg.apache.dubbo.common.utils.ReflectUtils;\t//工具类\n```\n\n```java\n// create ProxyInstance class.\n//生成代理类的实例\nString pcn = pkg + \".proxy\" + id;\nccp.setClassName(pcn);\nccp.addField(\"public static java.lang.reflect.Method[] methods;\");\nccp.addField(\"private \" + InvocationHandler.class.getName() + \" handler;\");\nccp.addConstructor(Modifier.PUBLIC, new Class<?>[]{InvocationHandler.class}, new Class<?>[0], \"handler=$1;\");\nccp.addDefaultConstructor();\nClass<?> clazz = ccp.toClass();\nclazz.getField(\"methods\").set(null, methods.toArray(new Method[0]));\n\n// create Proxy class.\n//生成代理类，通过调用newInstance()方法获取实例\nString fcn = Proxy.class.getName() + id;\nccm = ClassGenerator.newInstance(cl);\nccm.setClassName(fcn);\nccm.addDefaultConstructor();\nccm.setSuperClass(Proxy.class);\nccm.addMethod(\"public Object newInstance(\" + InvocationHandler.class.getName() + \" h){ return new \" + pcn + \"($1); }\");\nClass<?> pc = ccm.toClass();\nproxy = (Proxy) pc.newInstance();\n```","source":"_posts/dubbo-proxy-basing-on-javassist.md","raw":"---\ntitle: Dubbo基于Javassist实现动态代理分析\ndate: 2018-08-02 16:22:08\ntags:\n    - dubbo\n    - javassist\n---\n\n```\norg.apache.dubbo.common.bytecode.Proxy\t//生成代理类\norg.apache.dubbo.common.bytecode.ClassGenerator  //基于javassist封装\n\norg.apache.dubbo.common.utils.ClassHelper;  //工具类\norg.apache.dubbo.common.utils.ReflectUtils;\t//工具类\n```\n\n```java\n// create ProxyInstance class.\n//生成代理类的实例\nString pcn = pkg + \".proxy\" + id;\nccp.setClassName(pcn);\nccp.addField(\"public static java.lang.reflect.Method[] methods;\");\nccp.addField(\"private \" + InvocationHandler.class.getName() + \" handler;\");\nccp.addConstructor(Modifier.PUBLIC, new Class<?>[]{InvocationHandler.class}, new Class<?>[0], \"handler=$1;\");\nccp.addDefaultConstructor();\nClass<?> clazz = ccp.toClass();\nclazz.getField(\"methods\").set(null, methods.toArray(new Method[0]));\n\n// create Proxy class.\n//生成代理类，通过调用newInstance()方法获取实例\nString fcn = Proxy.class.getName() + id;\nccm = ClassGenerator.newInstance(cl);\nccm.setClassName(fcn);\nccm.addDefaultConstructor();\nccm.setSuperClass(Proxy.class);\nccm.addMethod(\"public Object newInstance(\" + InvocationHandler.class.getName() + \" h){ return new \" + pcn + \"($1); }\");\nClass<?> pc = ccm.toClass();\nproxy = (Proxy) pc.newInstance();\n```","slug":"dubbo-proxy-basing-on-javassist","published":1,"updated":"2019-01-06T13:01:12.938Z","_id":"cjq6kwn4x0018zjiap1s442vn","comments":1,"layout":"post","photos":[],"link":"","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.apache.dubbo.common.bytecode.Proxy\t//生成代理类</span><br><span class=\"line\">org.apache.dubbo.common.bytecode.ClassGenerator  //基于javassist封装</span><br><span class=\"line\"></span><br><span class=\"line\">org.apache.dubbo.common.utils.ClassHelper;  //工具类</span><br><span class=\"line\">org.apache.dubbo.common.utils.ReflectUtils;\t//工具类</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create ProxyInstance class.</span></span><br><span class=\"line\"><span class=\"comment\">//生成代理类的实例</span></span><br><span class=\"line\">String pcn = pkg + <span class=\"string\">\".proxy\"</span> + id;</span><br><span class=\"line\">ccp.setClassName(pcn);</span><br><span class=\"line\">ccp.addField(<span class=\"string\">\"public static java.lang.reflect.Method[] methods;\"</span>);</span><br><span class=\"line\">ccp.addField(<span class=\"string\">\"private \"</span> + InvocationHandler.class.getName() + <span class=\"string\">\" handler;\"</span>);</span><br><span class=\"line\">ccp.addConstructor(Modifier.PUBLIC, <span class=\"keyword\">new</span> Class&lt;?&gt;[]&#123;InvocationHandler.class&#125;, <span class=\"keyword\">new</span> Class&lt;?&gt;[<span class=\"number\">0</span>], <span class=\"string\">\"handler=$1;\"</span>);</span><br><span class=\"line\">ccp.addDefaultConstructor();</span><br><span class=\"line\">Class&lt;?&gt; clazz = ccp.toClass();</span><br><span class=\"line\">clazz.getField(<span class=\"string\">\"methods\"</span>).set(<span class=\"keyword\">null</span>, methods.toArray(<span class=\"keyword\">new</span> Method[<span class=\"number\">0</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create Proxy class.</span></span><br><span class=\"line\"><span class=\"comment\">//生成代理类，通过调用newInstance()方法获取实例</span></span><br><span class=\"line\">String fcn = Proxy.class.getName() + id;</span><br><span class=\"line\">ccm = ClassGenerator.newInstance(cl);</span><br><span class=\"line\">ccm.setClassName(fcn);</span><br><span class=\"line\">ccm.addDefaultConstructor();</span><br><span class=\"line\">ccm.setSuperClass(Proxy.class);</span><br><span class=\"line\">ccm.addMethod(<span class=\"string\">\"public Object newInstance(\"</span> + InvocationHandler.class.getName() + <span class=\"string\">\" h)&#123; return new \"</span> + pcn + <span class=\"string\">\"($1); &#125;\"</span>);</span><br><span class=\"line\">Class&lt;?&gt; pc = ccm.toClass();</span><br><span class=\"line\">proxy = (Proxy) pc.newInstance();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.apache.dubbo.common.bytecode.Proxy\t//生成代理类</span><br><span class=\"line\">org.apache.dubbo.common.bytecode.ClassGenerator  //基于javassist封装</span><br><span class=\"line\"></span><br><span class=\"line\">org.apache.dubbo.common.utils.ClassHelper;  //工具类</span><br><span class=\"line\">org.apache.dubbo.common.utils.ReflectUtils;\t//工具类</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// create ProxyInstance class.</span></span><br><span class=\"line\"><span class=\"comment\">//生成代理类的实例</span></span><br><span class=\"line\">String pcn = pkg + <span class=\"string\">\".proxy\"</span> + id;</span><br><span class=\"line\">ccp.setClassName(pcn);</span><br><span class=\"line\">ccp.addField(<span class=\"string\">\"public static java.lang.reflect.Method[] methods;\"</span>);</span><br><span class=\"line\">ccp.addField(<span class=\"string\">\"private \"</span> + InvocationHandler.class.getName() + <span class=\"string\">\" handler;\"</span>);</span><br><span class=\"line\">ccp.addConstructor(Modifier.PUBLIC, <span class=\"keyword\">new</span> Class&lt;?&gt;[]&#123;InvocationHandler.class&#125;, <span class=\"keyword\">new</span> Class&lt;?&gt;[<span class=\"number\">0</span>], <span class=\"string\">\"handler=$1;\"</span>);</span><br><span class=\"line\">ccp.addDefaultConstructor();</span><br><span class=\"line\">Class&lt;?&gt; clazz = ccp.toClass();</span><br><span class=\"line\">clazz.getField(<span class=\"string\">\"methods\"</span>).set(<span class=\"keyword\">null</span>, methods.toArray(<span class=\"keyword\">new</span> Method[<span class=\"number\">0</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// create Proxy class.</span></span><br><span class=\"line\"><span class=\"comment\">//生成代理类，通过调用newInstance()方法获取实例</span></span><br><span class=\"line\">String fcn = Proxy.class.getName() + id;</span><br><span class=\"line\">ccm = ClassGenerator.newInstance(cl);</span><br><span class=\"line\">ccm.setClassName(fcn);</span><br><span class=\"line\">ccm.addDefaultConstructor();</span><br><span class=\"line\">ccm.setSuperClass(Proxy.class);</span><br><span class=\"line\">ccm.addMethod(<span class=\"string\">\"public Object newInstance(\"</span> + InvocationHandler.class.getName() + <span class=\"string\">\" h)&#123; return new \"</span> + pcn + <span class=\"string\">\"($1); &#125;\"</span>);</span><br><span class=\"line\">Class&lt;?&gt; pc = ccm.toClass();</span><br><span class=\"line\">proxy = (Proxy) pc.newInstance();</span><br></pre></td></tr></table></figure>"},{"title":"Dubbo路由机制分析","date":"2018-10-17T02:03:57.000Z","_content":"\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-10-17 16-41-11.png?raw=true)\n\n<!-- more -->\n\n这篇文章主要讲Dubbo的路由特性，当Consumer发起一个请求，Dubbo依据配置的路由规则，计算出那些提供者可以提供这次的请求服务，所以路由机制会在`集群容错策略`和`负载均衡策略`之前被执行，下面我们来开始分析源码。\n\n执行路由机制的入口是在AbstractClusterInvoker类的invoke方法，其中调用了list()方法，然后会执行AbstractDirectory的list()方法：\n\n* AbstractDirectory#list()\n\n```java\n@Override\npublic List<Invoker<T>> list(Invocation invocation) throws RpcException {\n    if (destroyed) {\n        throw new RpcException(\"Directory already destroyed .url: \" + getUrl());\n    }\n    //获取所有的提供者\n    List<Invoker<T>> invokers = doList(invocation);\n    //在哪里设置的routers？稍后揭晓\n    List<Router> localRouters = this.routers; // local reference\n    if (localRouters != null && !localRouters.isEmpty()) {\n        for (Router router : localRouters) {\n            try {\n                if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {\n                    //依次通过路由规则进行过滤\n                    invokers = router.route(invokers, getConsumerUrl(), invocation);\n                }\n            } catch (Throwable t) {\n                logger.error(\"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(), t);\n            }\n        }\n    }\n    return invokers;\n}\n```\n\n那么路由器是在哪设置的？通过搜索代码发现是则AbstractDirectory类的setRouters()方法里设置的：\n\n* AbstractDirectory#setRouters()\n\n```java\nprotected void setRouters(List<Router> routers) {\n    // copy list\n    routers = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);\n    // append url router\n    String routerKey = url.getParameter(Constants.ROUTER_KEY);\n    if (routerKey != null && routerKey.length() > 0) {\n        //根据Dubbo SPI机制获取RouterFactory\n        RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerKey);\n        routers.add(routerFactory.getRouter(url));\n    }\n    // append mock invoker selector 为什么添加这个？\n\t//MockInvokersSelector路由器，是dubbo对mock调用支持的一部分,稍后看下源码\n    routers.add(new MockInvokersSelector());\n    //进行排序？？\n    //排序后MockInvokersSelector会放在最后\n    Collections.sort(routers);\n    this.routers = routers;\n}\n```\n\n再进一步分析，setRouters()在哪里被调用了？通过查看方法调用栈，在AbstractDirectory的子类RegisterDirectory里notify()方法里调用了，notify()方法是注册中心通知consumer回调的方法：\n\n* RegisterDirectory#notify()\n\n```java\n@Override\npublic synchronized void notify(List<URL> urls) {\n    List<URL> invokerUrls = new ArrayList<URL>();\n    List<URL> routerUrls = new ArrayList<URL>();\n    List<URL> configuratorUrls = new ArrayList<URL>();\n    for (URL url : urls) {\n        String protocol = url.getProtocol();\n        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n        if (Constants.ROUTERS_CATEGORY.equals(category)\n            || Constants.ROUTE_PROTOCOL.equals(protocol)) {\n            routerUrls.add(url);\n        } else if (Constants.CONFIGURATORS_CATEGORY.equals(category)\n                   || Constants.OVERRIDE_PROTOCOL.equals(protocol)) {\n            configuratorUrls.add(url);\n        } else if (Constants.PROVIDERS_CATEGORY.equals(category)) {\n            invokerUrls.add(url);\n        } else {\n            logger.warn(\"Unsupported category \" + category + \" in notified url: \" + url + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost());\n        }\n    }\n    // configurators\n    if (configuratorUrls != null && !configuratorUrls.isEmpty()) {\n        this.configurators = toConfigurators(configuratorUrls);\n    }\n    // routers\n    if (routerUrls != null && !routerUrls.isEmpty()) {\n        //把路由配置转换成路由实例\n        List<Router> routers = toRouters(routerUrls);\n        if (routers != null) { // null - do nothing\n            setRouters(routers);\n        }\n    }\n    List<Configurator> localConfigurators = this.configurators; // local reference\n    // merge override parameters\n    this.overrideDirectoryUrl = directoryUrl;\n    if (localConfigurators != null && !localConfigurators.isEmpty()) {\n        for (Configurator configurator : localConfigurators) {\n            this.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);\n        }\n    }\n    // providers\n    refreshInvoker(invokerUrls);\n}\n```\n\n在上面的方法中，有一个比较重要的方法`toRouters()`，它将路由配置转换成路由实例：\n\n* RegisterDirectory#toRouters()\n\n```java\n/**\n     * @param urls\n     * @return null : no routers ,do nothing\n     * else :routers list\n     */\nprivate List<Router> toRouters(List<URL> urls) {\n    List<Router> routers = new ArrayList<Router>();\n    if (urls == null || urls.isEmpty()) {\n        return routers;\n    }\n    if (urls != null && !urls.isEmpty()) {\n        for (URL url : urls) {\n            if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {\n                continue;\n            }\n            String routerType = url.getParameter(Constants.ROUTER_KEY);\n            if (routerType != null && routerType.length() > 0) {\n                url = url.setProtocol(routerType);\n            }\n            try {\n                Router router = routerFactory.getRouter(url);\n                if (!routers.contains(router)) {\n                    routers.add(router);\n                }\n            } catch (Throwable t) {\n                logger.error(\"convert router url to router error, url: \" + url, t);\n            }\n        }\n    }\n    return routers;\n}\n```\n\n下面将分别分析四种路由的具体实现和配置方法：\n\n#### ConditionRouterFactory\n\n创建一个`ConditionRouter`实例，\n\n#### ScriptRouterFactory\n\n创建一个`ScriptRouter`实例，\n\n#### TagRouterFactory\n\n创建一个`TagRouter`实例，\n\n#### FileRouterFactory\n\n\n\n\n\n","source":"_posts/dubbo-router-analysis.md","raw":"---\ntitle: Dubbo路由机制分析\ndate: 2018-10-17 10:03:57\ntags:\n    - dubbo\n---\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-10-17 16-41-11.png?raw=true)\n\n<!-- more -->\n\n这篇文章主要讲Dubbo的路由特性，当Consumer发起一个请求，Dubbo依据配置的路由规则，计算出那些提供者可以提供这次的请求服务，所以路由机制会在`集群容错策略`和`负载均衡策略`之前被执行，下面我们来开始分析源码。\n\n执行路由机制的入口是在AbstractClusterInvoker类的invoke方法，其中调用了list()方法，然后会执行AbstractDirectory的list()方法：\n\n* AbstractDirectory#list()\n\n```java\n@Override\npublic List<Invoker<T>> list(Invocation invocation) throws RpcException {\n    if (destroyed) {\n        throw new RpcException(\"Directory already destroyed .url: \" + getUrl());\n    }\n    //获取所有的提供者\n    List<Invoker<T>> invokers = doList(invocation);\n    //在哪里设置的routers？稍后揭晓\n    List<Router> localRouters = this.routers; // local reference\n    if (localRouters != null && !localRouters.isEmpty()) {\n        for (Router router : localRouters) {\n            try {\n                if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {\n                    //依次通过路由规则进行过滤\n                    invokers = router.route(invokers, getConsumerUrl(), invocation);\n                }\n            } catch (Throwable t) {\n                logger.error(\"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(), t);\n            }\n        }\n    }\n    return invokers;\n}\n```\n\n那么路由器是在哪设置的？通过搜索代码发现是则AbstractDirectory类的setRouters()方法里设置的：\n\n* AbstractDirectory#setRouters()\n\n```java\nprotected void setRouters(List<Router> routers) {\n    // copy list\n    routers = routers == null ? new ArrayList<Router>() : new ArrayList<Router>(routers);\n    // append url router\n    String routerKey = url.getParameter(Constants.ROUTER_KEY);\n    if (routerKey != null && routerKey.length() > 0) {\n        //根据Dubbo SPI机制获取RouterFactory\n        RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerKey);\n        routers.add(routerFactory.getRouter(url));\n    }\n    // append mock invoker selector 为什么添加这个？\n\t//MockInvokersSelector路由器，是dubbo对mock调用支持的一部分,稍后看下源码\n    routers.add(new MockInvokersSelector());\n    //进行排序？？\n    //排序后MockInvokersSelector会放在最后\n    Collections.sort(routers);\n    this.routers = routers;\n}\n```\n\n再进一步分析，setRouters()在哪里被调用了？通过查看方法调用栈，在AbstractDirectory的子类RegisterDirectory里notify()方法里调用了，notify()方法是注册中心通知consumer回调的方法：\n\n* RegisterDirectory#notify()\n\n```java\n@Override\npublic synchronized void notify(List<URL> urls) {\n    List<URL> invokerUrls = new ArrayList<URL>();\n    List<URL> routerUrls = new ArrayList<URL>();\n    List<URL> configuratorUrls = new ArrayList<URL>();\n    for (URL url : urls) {\n        String protocol = url.getProtocol();\n        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n        if (Constants.ROUTERS_CATEGORY.equals(category)\n            || Constants.ROUTE_PROTOCOL.equals(protocol)) {\n            routerUrls.add(url);\n        } else if (Constants.CONFIGURATORS_CATEGORY.equals(category)\n                   || Constants.OVERRIDE_PROTOCOL.equals(protocol)) {\n            configuratorUrls.add(url);\n        } else if (Constants.PROVIDERS_CATEGORY.equals(category)) {\n            invokerUrls.add(url);\n        } else {\n            logger.warn(\"Unsupported category \" + category + \" in notified url: \" + url + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost());\n        }\n    }\n    // configurators\n    if (configuratorUrls != null && !configuratorUrls.isEmpty()) {\n        this.configurators = toConfigurators(configuratorUrls);\n    }\n    // routers\n    if (routerUrls != null && !routerUrls.isEmpty()) {\n        //把路由配置转换成路由实例\n        List<Router> routers = toRouters(routerUrls);\n        if (routers != null) { // null - do nothing\n            setRouters(routers);\n        }\n    }\n    List<Configurator> localConfigurators = this.configurators; // local reference\n    // merge override parameters\n    this.overrideDirectoryUrl = directoryUrl;\n    if (localConfigurators != null && !localConfigurators.isEmpty()) {\n        for (Configurator configurator : localConfigurators) {\n            this.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);\n        }\n    }\n    // providers\n    refreshInvoker(invokerUrls);\n}\n```\n\n在上面的方法中，有一个比较重要的方法`toRouters()`，它将路由配置转换成路由实例：\n\n* RegisterDirectory#toRouters()\n\n```java\n/**\n     * @param urls\n     * @return null : no routers ,do nothing\n     * else :routers list\n     */\nprivate List<Router> toRouters(List<URL> urls) {\n    List<Router> routers = new ArrayList<Router>();\n    if (urls == null || urls.isEmpty()) {\n        return routers;\n    }\n    if (urls != null && !urls.isEmpty()) {\n        for (URL url : urls) {\n            if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) {\n                continue;\n            }\n            String routerType = url.getParameter(Constants.ROUTER_KEY);\n            if (routerType != null && routerType.length() > 0) {\n                url = url.setProtocol(routerType);\n            }\n            try {\n                Router router = routerFactory.getRouter(url);\n                if (!routers.contains(router)) {\n                    routers.add(router);\n                }\n            } catch (Throwable t) {\n                logger.error(\"convert router url to router error, url: \" + url, t);\n            }\n        }\n    }\n    return routers;\n}\n```\n\n下面将分别分析四种路由的具体实现和配置方法：\n\n#### ConditionRouterFactory\n\n创建一个`ConditionRouter`实例，\n\n#### ScriptRouterFactory\n\n创建一个`ScriptRouter`实例，\n\n#### TagRouterFactory\n\n创建一个`TagRouter`实例，\n\n#### FileRouterFactory\n\n\n\n\n\n","slug":"dubbo-router-analysis","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4y001azjia1zagib5f","content":"<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-10-17 16-41-11.png?raw=true\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>这篇文章主要讲Dubbo的路由特性，当Consumer发起一个请求，Dubbo依据配置的路由规则，计算出那些提供者可以提供这次的请求服务，所以路由机制会在<code>集群容错策略</code>和<code>负载均衡策略</code>之前被执行，下面我们来开始分析源码。</p>\n<p>执行路由机制的入口是在AbstractClusterInvoker类的invoke方法，其中调用了list()方法，然后会执行AbstractDirectory的list()方法：</p>\n<ul>\n<li>AbstractDirectory#list()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class=\"keyword\">throws</span> RpcException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (destroyed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Directory already destroyed .url: \"</span> + getUrl());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取所有的提供者</span></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br><span class=\"line\">    <span class=\"comment\">//在哪里设置的routers？稍后揭晓</span></span><br><span class=\"line\">    List&lt;Router&gt; localRouters = <span class=\"keyword\">this</span>.routers; <span class=\"comment\">// local reference</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (localRouters != <span class=\"keyword\">null</span> &amp;&amp; !localRouters.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Router router : localRouters) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (router.getUrl() == <span class=\"keyword\">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//依次通过路由规则进行过滤</span></span><br><span class=\"line\">                    invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">\"Failed to execute router: \"</span> + getUrl() + <span class=\"string\">\", cause: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invokers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么路由器是在哪设置的？通过搜索代码发现是则AbstractDirectory类的setRouters()方法里设置的：</p>\n<ul>\n<li>AbstractDirectory#setRouters()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setRouters</span><span class=\"params\">(List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// copy list</span></span><br><span class=\"line\">    routers = routers == <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> ArrayList&lt;Router&gt;() : <span class=\"keyword\">new</span> ArrayList&lt;Router&gt;(routers);</span><br><span class=\"line\">    <span class=\"comment\">// append url router</span></span><br><span class=\"line\">    String routerKey = url.getParameter(Constants.ROUTER_KEY);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (routerKey != <span class=\"keyword\">null</span> &amp;&amp; routerKey.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//根据Dubbo SPI机制获取RouterFactory</span></span><br><span class=\"line\">        RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerKey);</span><br><span class=\"line\">        routers.add(routerFactory.getRouter(url));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// append mock invoker selector 为什么添加这个？</span></span><br><span class=\"line\">\t<span class=\"comment\">//MockInvokersSelector路由器，是dubbo对mock调用支持的一部分,稍后看下源码</span></span><br><span class=\"line\">    routers.add(<span class=\"keyword\">new</span> MockInvokersSelector());</span><br><span class=\"line\">    <span class=\"comment\">//进行排序？？</span></span><br><span class=\"line\">    <span class=\"comment\">//排序后MockInvokersSelector会放在最后</span></span><br><span class=\"line\">    Collections.sort(routers);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routers = routers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再进一步分析，setRouters()在哪里被调用了？通过查看方法调用栈，在AbstractDirectory的子类RegisterDirectory里notify()方法里调用了，notify()方法是注册中心通知consumer回调的方法：</p>\n<ul>\n<li>RegisterDirectory#notify()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;URL&gt; invokerUrls = <span class=\"keyword\">new</span> ArrayList&lt;URL&gt;();</span><br><span class=\"line\">    List&lt;URL&gt; routerUrls = <span class=\"keyword\">new</span> ArrayList&lt;URL&gt;();</span><br><span class=\"line\">    List&lt;URL&gt; configuratorUrls = <span class=\"keyword\">new</span> ArrayList&lt;URL&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (URL url : urls) &#123;</span><br><span class=\"line\">        String protocol = url.getProtocol();</span><br><span class=\"line\">        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Constants.ROUTERS_CATEGORY.equals(category)</span><br><span class=\"line\">            || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;</span><br><span class=\"line\">            routerUrls.add(url);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Constants.CONFIGURATORS_CATEGORY.equals(category)</span><br><span class=\"line\">                   || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;</span><br><span class=\"line\">            configuratorUrls.add(url);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;</span><br><span class=\"line\">            invokerUrls.add(url);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"Unsupported category \"</span> + category + <span class=\"string\">\" in notified url: \"</span> + url + <span class=\"string\">\" from registry \"</span> + getUrl().getAddress() + <span class=\"string\">\" to consumer \"</span> + NetUtils.getLocalHost());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// configurators</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configuratorUrls != <span class=\"keyword\">null</span> &amp;&amp; !configuratorUrls.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.configurators = toConfigurators(configuratorUrls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// routers</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (routerUrls != <span class=\"keyword\">null</span> &amp;&amp; !routerUrls.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//把路由配置转换成路由实例</span></span><br><span class=\"line\">        List&lt;Router&gt; routers = toRouters(routerUrls);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (routers != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// null - do nothing</span></span><br><span class=\"line\">            setRouters(routers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;Configurator&gt; localConfigurators = <span class=\"keyword\">this</span>.configurators; <span class=\"comment\">// local reference</span></span><br><span class=\"line\">    <span class=\"comment\">// merge override parameters</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.overrideDirectoryUrl = directoryUrl;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (localConfigurators != <span class=\"keyword\">null</span> &amp;&amp; !localConfigurators.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Configurator configurator : localConfigurators) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// providers</span></span><br><span class=\"line\">    refreshInvoker(invokerUrls);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的方法中，有一个比较重要的方法<code>toRouters()</code>，它将路由配置转换成路由实例：</p>\n<ul>\n<li>RegisterDirectory#toRouters()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> urls</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> null : no routers ,do nothing</span></span><br><span class=\"line\"><span class=\"comment\">     * else :routers list</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> List&lt;Router&gt; <span class=\"title\">toRouters</span><span class=\"params\">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Router&gt; routers = <span class=\"keyword\">new</span> ArrayList&lt;Router&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls == <span class=\"keyword\">null</span> || urls.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> routers;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls != <span class=\"keyword\">null</span> &amp;&amp; !urls.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (URL url : urls) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String routerType = url.getParameter(Constants.ROUTER_KEY);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (routerType != <span class=\"keyword\">null</span> &amp;&amp; routerType.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                url = url.setProtocol(routerType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Router router = routerFactory.getRouter(url);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!routers.contains(router)) &#123;</span><br><span class=\"line\">                    routers.add(router);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">\"convert router url to router error, url: \"</span> + url, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> routers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面将分别分析四种路由的具体实现和配置方法：</p>\n<h4 id=\"ConditionRouterFactory\"><a href=\"#ConditionRouterFactory\" class=\"headerlink\" title=\"ConditionRouterFactory\"></a>ConditionRouterFactory</h4><p>创建一个<code>ConditionRouter</code>实例，</p>\n<h4 id=\"ScriptRouterFactory\"><a href=\"#ScriptRouterFactory\" class=\"headerlink\" title=\"ScriptRouterFactory\"></a>ScriptRouterFactory</h4><p>创建一个<code>ScriptRouter</code>实例，</p>\n<h4 id=\"TagRouterFactory\"><a href=\"#TagRouterFactory\" class=\"headerlink\" title=\"TagRouterFactory\"></a>TagRouterFactory</h4><p>创建一个<code>TagRouter</code>实例，</p>\n<h4 id=\"FileRouterFactory\"><a href=\"#FileRouterFactory\" class=\"headerlink\" title=\"FileRouterFactory\"></a>FileRouterFactory</h4>","site":{"data":{}},"excerpt":"<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-10-17 16-41-11.png?raw=true\" alt=\"\"></p>","more":"<p>这篇文章主要讲Dubbo的路由特性，当Consumer发起一个请求，Dubbo依据配置的路由规则，计算出那些提供者可以提供这次的请求服务，所以路由机制会在<code>集群容错策略</code>和<code>负载均衡策略</code>之前被执行，下面我们来开始分析源码。</p>\n<p>执行路由机制的入口是在AbstractClusterInvoker类的invoke方法，其中调用了list()方法，然后会执行AbstractDirectory的list()方法：</p>\n<ul>\n<li>AbstractDirectory#list()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class=\"keyword\">throws</span> RpcException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (destroyed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Directory already destroyed .url: \"</span> + getUrl());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取所有的提供者</span></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br><span class=\"line\">    <span class=\"comment\">//在哪里设置的routers？稍后揭晓</span></span><br><span class=\"line\">    List&lt;Router&gt; localRouters = <span class=\"keyword\">this</span>.routers; <span class=\"comment\">// local reference</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (localRouters != <span class=\"keyword\">null</span> &amp;&amp; !localRouters.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Router router : localRouters) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (router.getUrl() == <span class=\"keyword\">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//依次通过路由规则进行过滤</span></span><br><span class=\"line\">                    invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">\"Failed to execute router: \"</span> + getUrl() + <span class=\"string\">\", cause: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invokers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么路由器是在哪设置的？通过搜索代码发现是则AbstractDirectory类的setRouters()方法里设置的：</p>\n<ul>\n<li>AbstractDirectory#setRouters()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setRouters</span><span class=\"params\">(List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// copy list</span></span><br><span class=\"line\">    routers = routers == <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> ArrayList&lt;Router&gt;() : <span class=\"keyword\">new</span> ArrayList&lt;Router&gt;(routers);</span><br><span class=\"line\">    <span class=\"comment\">// append url router</span></span><br><span class=\"line\">    String routerKey = url.getParameter(Constants.ROUTER_KEY);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (routerKey != <span class=\"keyword\">null</span> &amp;&amp; routerKey.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//根据Dubbo SPI机制获取RouterFactory</span></span><br><span class=\"line\">        RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory.class).getExtension(routerKey);</span><br><span class=\"line\">        routers.add(routerFactory.getRouter(url));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// append mock invoker selector 为什么添加这个？</span></span><br><span class=\"line\">\t<span class=\"comment\">//MockInvokersSelector路由器，是dubbo对mock调用支持的一部分,稍后看下源码</span></span><br><span class=\"line\">    routers.add(<span class=\"keyword\">new</span> MockInvokersSelector());</span><br><span class=\"line\">    <span class=\"comment\">//进行排序？？</span></span><br><span class=\"line\">    <span class=\"comment\">//排序后MockInvokersSelector会放在最后</span></span><br><span class=\"line\">    Collections.sort(routers);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routers = routers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再进一步分析，setRouters()在哪里被调用了？通过查看方法调用栈，在AbstractDirectory的子类RegisterDirectory里notify()方法里调用了，notify()方法是注册中心通知consumer回调的方法：</p>\n<ul>\n<li>RegisterDirectory#notify()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">notify</span><span class=\"params\">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;URL&gt; invokerUrls = <span class=\"keyword\">new</span> ArrayList&lt;URL&gt;();</span><br><span class=\"line\">    List&lt;URL&gt; routerUrls = <span class=\"keyword\">new</span> ArrayList&lt;URL&gt;();</span><br><span class=\"line\">    List&lt;URL&gt; configuratorUrls = <span class=\"keyword\">new</span> ArrayList&lt;URL&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (URL url : urls) &#123;</span><br><span class=\"line\">        String protocol = url.getProtocol();</span><br><span class=\"line\">        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Constants.ROUTERS_CATEGORY.equals(category)</span><br><span class=\"line\">            || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;</span><br><span class=\"line\">            routerUrls.add(url);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Constants.CONFIGURATORS_CATEGORY.equals(category)</span><br><span class=\"line\">                   || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;</span><br><span class=\"line\">            configuratorUrls.add(url);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;</span><br><span class=\"line\">            invokerUrls.add(url);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"Unsupported category \"</span> + category + <span class=\"string\">\" in notified url: \"</span> + url + <span class=\"string\">\" from registry \"</span> + getUrl().getAddress() + <span class=\"string\">\" to consumer \"</span> + NetUtils.getLocalHost());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// configurators</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configuratorUrls != <span class=\"keyword\">null</span> &amp;&amp; !configuratorUrls.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.configurators = toConfigurators(configuratorUrls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// routers</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (routerUrls != <span class=\"keyword\">null</span> &amp;&amp; !routerUrls.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//把路由配置转换成路由实例</span></span><br><span class=\"line\">        List&lt;Router&gt; routers = toRouters(routerUrls);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (routers != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// null - do nothing</span></span><br><span class=\"line\">            setRouters(routers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;Configurator&gt; localConfigurators = <span class=\"keyword\">this</span>.configurators; <span class=\"comment\">// local reference</span></span><br><span class=\"line\">    <span class=\"comment\">// merge override parameters</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.overrideDirectoryUrl = directoryUrl;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (localConfigurators != <span class=\"keyword\">null</span> &amp;&amp; !localConfigurators.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Configurator configurator : localConfigurators) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// providers</span></span><br><span class=\"line\">    refreshInvoker(invokerUrls);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的方法中，有一个比较重要的方法<code>toRouters()</code>，它将路由配置转换成路由实例：</p>\n<ul>\n<li>RegisterDirectory#toRouters()</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> urls</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> null : no routers ,do nothing</span></span><br><span class=\"line\"><span class=\"comment\">     * else :routers list</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> List&lt;Router&gt; <span class=\"title\">toRouters</span><span class=\"params\">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Router&gt; routers = <span class=\"keyword\">new</span> ArrayList&lt;Router&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls == <span class=\"keyword\">null</span> || urls.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> routers;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls != <span class=\"keyword\">null</span> &amp;&amp; !urls.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (URL url : urls) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            String routerType = url.getParameter(Constants.ROUTER_KEY);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (routerType != <span class=\"keyword\">null</span> &amp;&amp; routerType.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                url = url.setProtocol(routerType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Router router = routerFactory.getRouter(url);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!routers.contains(router)) &#123;</span><br><span class=\"line\">                    routers.add(router);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">\"convert router url to router error, url: \"</span> + url, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> routers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面将分别分析四种路由的具体实现和配置方法：</p>\n<h4 id=\"ConditionRouterFactory\"><a href=\"#ConditionRouterFactory\" class=\"headerlink\" title=\"ConditionRouterFactory\"></a>ConditionRouterFactory</h4><p>创建一个<code>ConditionRouter</code>实例，</p>\n<h4 id=\"ScriptRouterFactory\"><a href=\"#ScriptRouterFactory\" class=\"headerlink\" title=\"ScriptRouterFactory\"></a>ScriptRouterFactory</h4><p>创建一个<code>ScriptRouter</code>实例，</p>\n<h4 id=\"TagRouterFactory\"><a href=\"#TagRouterFactory\" class=\"headerlink\" title=\"TagRouterFactory\"></a>TagRouterFactory</h4><p>创建一个<code>TagRouter</code>实例，</p>\n<h4 id=\"FileRouterFactory\"><a href=\"#FileRouterFactory\" class=\"headerlink\" title=\"FileRouterFactory\"></a>FileRouterFactory</h4>"},{"title":"HTTP详解","date":"2018-05-19T05:31:08.000Z","_content":"\nThe Hypertext Transfer Protocol (HTTP) is an application-level protocol that uses TCP as an underlying transport and typically runs on port 80. HTTP is a stateless protocol i.e. server maintains no information about past client requests. \n\n<!-- more -->\n\n### HTTP与TCP/IP的关系\n\nHTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。 \n\n### HTTP是无状态的\n\nHTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 \n\n### 长连接和短连接\n\n**在HTTP/1.0中，默认使用的是短连接**。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。\n\n但从 **HTTP/1.1起，默认使用长连接**，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：`Connection:keep-alive`\n\n相对于持久化连接HTTP1.1还有另外比较重要的改动：\n\n- HTTP 1.1增加host字段\n- HTTP 1.1中引入了Chunked transfer-coding，范围请求，实现断点续传(实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输)\n- HTTP 1.1管线化(pipelining)理论，客户端可以同时发出多个HTTP请求，而不用一个个等待响应之后再请求\n  - ​    注意：这个pipelining仅仅是限于理论场景下，大部分桌面浏览器仍然会选择默认关闭HTTP pipelining！\n  - ​    所以现在使用HTTP1.1协议的应用，都是有可能会开多个TCP连接的！\n\n#### 短连接\n\n我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作\n\n* 优点：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段\n\n#### 长连接\n\n接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。 \n\n* 优点\n  * Lower CPU and memory usage because there are less number of connections. \n  * Allows HTTP pipelining of requests and responses. \n  * Reduced network congestion (fewer TCP connections). \n  * Reduced latency in subsequent requests (no handshaking). \n  * Errors can be reported without the penalty of closing the TCP connection. \n\n* 缺点\n  * Resources may be be kept occupied even when not needed and may not be available to others. \n\n\n\n### REFERENCE\n\nhttp://developer.51cto.com/art/201808/580780.htm\n\n[Persistent Connections](https://www.oreilly.com/library/view/http-the-definitive/1565925092/ch04s05.html)\n\n[HTTP Non-Persistent & Persistent Connection | Set 1](https://www.geeksforgeeks.org/http-non-persistent-persistent-connection/)\n\n[HTTP长连接和短连接](http://www.cnblogs.com/0201zcr/p/4694945.html)\n\n","source":"_posts/http.md","raw":"---\ntitle: HTTP详解\ndate: 2018-05-19 13:31:08\ntags:\n    - http\n---\n\nThe Hypertext Transfer Protocol (HTTP) is an application-level protocol that uses TCP as an underlying transport and typically runs on port 80. HTTP is a stateless protocol i.e. server maintains no information about past client requests. \n\n<!-- more -->\n\n### HTTP与TCP/IP的关系\n\nHTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。 \n\n### HTTP是无状态的\n\nHTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 \n\n### 长连接和短连接\n\n**在HTTP/1.0中，默认使用的是短连接**。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。\n\n但从 **HTTP/1.1起，默认使用长连接**，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：`Connection:keep-alive`\n\n相对于持久化连接HTTP1.1还有另外比较重要的改动：\n\n- HTTP 1.1增加host字段\n- HTTP 1.1中引入了Chunked transfer-coding，范围请求，实现断点续传(实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输)\n- HTTP 1.1管线化(pipelining)理论，客户端可以同时发出多个HTTP请求，而不用一个个等待响应之后再请求\n  - ​    注意：这个pipelining仅仅是限于理论场景下，大部分桌面浏览器仍然会选择默认关闭HTTP pipelining！\n  - ​    所以现在使用HTTP1.1协议的应用，都是有可能会开多个TCP连接的！\n\n#### 短连接\n\n我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作\n\n* 优点：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段\n\n#### 长连接\n\n接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。 \n\n* 优点\n  * Lower CPU and memory usage because there are less number of connections. \n  * Allows HTTP pipelining of requests and responses. \n  * Reduced network congestion (fewer TCP connections). \n  * Reduced latency in subsequent requests (no handshaking). \n  * Errors can be reported without the penalty of closing the TCP connection. \n\n* 缺点\n  * Resources may be be kept occupied even when not needed and may not be available to others. \n\n\n\n### REFERENCE\n\nhttp://developer.51cto.com/art/201808/580780.htm\n\n[Persistent Connections](https://www.oreilly.com/library/view/http-the-definitive/1565925092/ch04s05.html)\n\n[HTTP Non-Persistent & Persistent Connection | Set 1](https://www.geeksforgeeks.org/http-non-persistent-persistent-connection/)\n\n[HTTP长连接和短连接](http://www.cnblogs.com/0201zcr/p/4694945.html)\n\n","slug":"http","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4z001czjian41vlcih","content":"<p>The Hypertext Transfer Protocol (HTTP) is an application-level protocol that uses TCP as an underlying transport and typically runs on port 80. HTTP is a stateless protocol i.e. server maintains no information about past client requests. </p>\n<a id=\"more\"></a>\n<h3 id=\"HTTP与TCP-IP的关系\"><a href=\"#HTTP与TCP-IP的关系\" class=\"headerlink\" title=\"HTTP与TCP/IP的关系\"></a>HTTP与TCP/IP的关系</h3><p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。 </p>\n<h3 id=\"HTTP是无状态的\"><a href=\"#HTTP是无状态的\" class=\"headerlink\" title=\"HTTP是无状态的\"></a>HTTP是无状态的</h3><p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 </p>\n<h3 id=\"长连接和短连接\"><a href=\"#长连接和短连接\" class=\"headerlink\" title=\"长连接和短连接\"></a>长连接和短连接</h3><p><strong>在HTTP/1.0中，默认使用的是短连接</strong>。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p>\n<p>但从 <strong>HTTP/1.1起，默认使用长连接</strong>，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：<code>Connection:keep-alive</code></p>\n<p>相对于持久化连接HTTP1.1还有另外比较重要的改动：</p>\n<ul>\n<li>HTTP 1.1增加host字段</li>\n<li>HTTP 1.1中引入了Chunked transfer-coding，范围请求，实现断点续传(实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输)</li>\n<li>HTTP 1.1管线化(pipelining)理论，客户端可以同时发出多个HTTP请求，而不用一个个等待响应之后再请求<ul>\n<li>​    注意：这个pipelining仅仅是限于理论场景下，大部分桌面浏览器仍然会选择默认关闭HTTP pipelining！</li>\n<li>​    所以现在使用HTTP1.1协议的应用，都是有可能会开多个TCP连接的！</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"短连接\"><a href=\"#短连接\" class=\"headerlink\" title=\"短连接\"></a>短连接</h4><p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作</p>\n<ul>\n<li>优点：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</li>\n</ul>\n<h4 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h4><p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。 </p>\n<ul>\n<li><p>优点</p>\n<ul>\n<li>Lower CPU and memory usage because there are less number of connections. </li>\n<li>Allows HTTP pipelining of requests and responses. </li>\n<li>Reduced network congestion (fewer TCP connections). </li>\n<li>Reduced latency in subsequent requests (no handshaking). </li>\n<li>Errors can be reported without the penalty of closing the TCP connection. </li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>Resources may be be kept occupied even when not needed and may not be available to others. </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"REFERENCE\"><a href=\"#REFERENCE\" class=\"headerlink\" title=\"REFERENCE\"></a>REFERENCE</h3><p><a href=\"http://developer.51cto.com/art/201808/580780.htm\" target=\"_blank\" rel=\"noopener\">http://developer.51cto.com/art/201808/580780.htm</a></p>\n<p><a href=\"https://www.oreilly.com/library/view/http-the-definitive/1565925092/ch04s05.html\" target=\"_blank\" rel=\"noopener\">Persistent Connections</a></p>\n<p><a href=\"https://www.geeksforgeeks.org/http-non-persistent-persistent-connection/\" target=\"_blank\" rel=\"noopener\">HTTP Non-Persistent &amp; Persistent Connection | Set 1</a></p>\n<p><a href=\"http://www.cnblogs.com/0201zcr/p/4694945.html\" target=\"_blank\" rel=\"noopener\">HTTP长连接和短连接</a></p>\n","site":{"data":{}},"excerpt":"<p>The Hypertext Transfer Protocol (HTTP) is an application-level protocol that uses TCP as an underlying transport and typically runs on port 80. HTTP is a stateless protocol i.e. server maintains no information about past client requests. </p>","more":"<h3 id=\"HTTP与TCP-IP的关系\"><a href=\"#HTTP与TCP-IP的关系\" class=\"headerlink\" title=\"HTTP与TCP/IP的关系\"></a>HTTP与TCP/IP的关系</h3><p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。 </p>\n<h3 id=\"HTTP是无状态的\"><a href=\"#HTTP是无状态的\" class=\"headerlink\" title=\"HTTP是无状态的\"></a>HTTP是无状态的</h3><p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 </p>\n<h3 id=\"长连接和短连接\"><a href=\"#长连接和短连接\" class=\"headerlink\" title=\"长连接和短连接\"></a>长连接和短连接</h3><p><strong>在HTTP/1.0中，默认使用的是短连接</strong>。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p>\n<p>但从 <strong>HTTP/1.1起，默认使用长连接</strong>，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：<code>Connection:keep-alive</code></p>\n<p>相对于持久化连接HTTP1.1还有另外比较重要的改动：</p>\n<ul>\n<li>HTTP 1.1增加host字段</li>\n<li>HTTP 1.1中引入了Chunked transfer-coding，范围请求，实现断点续传(实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输)</li>\n<li>HTTP 1.1管线化(pipelining)理论，客户端可以同时发出多个HTTP请求，而不用一个个等待响应之后再请求<ul>\n<li>​    注意：这个pipelining仅仅是限于理论场景下，大部分桌面浏览器仍然会选择默认关闭HTTP pipelining！</li>\n<li>​    所以现在使用HTTP1.1协议的应用，都是有可能会开多个TCP连接的！</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"短连接\"><a href=\"#短连接\" class=\"headerlink\" title=\"短连接\"></a>短连接</h4><p>我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作</p>\n<ul>\n<li>优点：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</li>\n</ul>\n<h4 id=\"长连接\"><a href=\"#长连接\" class=\"headerlink\" title=\"长连接\"></a>长连接</h4><p>接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。 </p>\n<ul>\n<li><p>优点</p>\n<ul>\n<li>Lower CPU and memory usage because there are less number of connections. </li>\n<li>Allows HTTP pipelining of requests and responses. </li>\n<li>Reduced network congestion (fewer TCP connections). </li>\n<li>Reduced latency in subsequent requests (no handshaking). </li>\n<li>Errors can be reported without the penalty of closing the TCP connection. </li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>Resources may be be kept occupied even when not needed and may not be available to others. </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"REFERENCE\"><a href=\"#REFERENCE\" class=\"headerlink\" title=\"REFERENCE\"></a>REFERENCE</h3><p><a href=\"http://developer.51cto.com/art/201808/580780.htm\" target=\"_blank\" rel=\"noopener\">http://developer.51cto.com/art/201808/580780.htm</a></p>\n<p><a href=\"https://www.oreilly.com/library/view/http-the-definitive/1565925092/ch04s05.html\" target=\"_blank\" rel=\"noopener\">Persistent Connections</a></p>\n<p><a href=\"https://www.geeksforgeeks.org/http-non-persistent-persistent-connection/\" target=\"_blank\" rel=\"noopener\">HTTP Non-Persistent &amp; Persistent Connection | Set 1</a></p>\n<p><a href=\"http://www.cnblogs.com/0201zcr/p/4694945.html\" target=\"_blank\" rel=\"noopener\">HTTP长连接和短连接</a></p>"},{"title":"Dubbo SPI机制源码分析","date":"2018-08-09T07:03:57.000Z","_content":"\nDubbo是微内核架构，还是开闭原则的应用，把核心流程架构固定，但是流程的各个节点对重新改进是开放的。具体的实现机制就是SPI(Service Provider Interface)机制，Dubbo基于Java SPI机制（不了解Java SPI机制的可以参考这篇文章[《深入理解Java SPI机制》](https://shuaijunlan.github.io/2018/08/03/java-spi-introduction/)），在其基础上做了改进和扩展。\n\n根据SPI规范，接口由框架定义，具体实现可以由不同的厂商提供，在Dubbo jar包可以发现在`/META-INF/dubbo/internal`目录下有许多接口命名的文件，文件里面的内容就是文件名代表的接口的各种实现类，这就是Dubbo SPI机制的配置基础，以`org.apache.dubbo.rpc.Protocol`文件为例，内容如下（dubbo-2.7.0-SNAPSHOT 版本）：\n\n```\nfilter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper\nlistener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper\nmock=org.apache.dubbo.rpc.support.MockProtocol\ndubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol\ninjvm=org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol\nrmi=org.apache.dubbo.rpc.protocol.rmi.RmiProtocol\nhessian=org.apache.dubbo.rpc.protocol.hessian.HessianProtocol\nhttp=org.apache.dubbo.rpc.protocol.http.HttpProtocol\n\norg.apache.dubbo.rpc.protocol.webservice.WebServiceProtocol\nthrift=org.apache.dubbo.rpc.protocol.thrift.ThriftProtocol\nmemcached=org.apache.dubbo.rpc.protocol.memcached.MemcachedProtocol\nredis=org.apache.dubbo.rpc.protocol.redis.RedisProtocol\nrest=org.apache.dubbo.rpc.protocol.rest.RestProtocol\nregistry=org.apache.dubbo.registry.integration.RegistryProtocol\nqos=org.apache.dubbo.qos.protocol.QosProtocolWrapper\n```\n\n<!-- more -->\n\n在Dubbo SPI机制中，`org.apache.dubbo.rpc.Protocol`接口由以上那么多的具体实现，`=`前面是扩展名，后面是扩展类的实现；\n\nSPI的启动的入口类是ExtensionLoader，这个类没定义public构造函数，只有一个privae的，而且public的静态方法也只有一个`public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type)`，这个方法也是SPI的入口方法，**若想获取某个接口类型的扩展，先必须获取其对应的ExtensionLoader**\n\n```java\n//私有构造器\nprivate ExtensionLoader(Class<?> type) {\n    this.type = type;\n    //objectFactory 对象 ，ExtensionFactory本身也是spi的\n    //如果是ExtensionFactory本身的ExtensionLoader实例，objectFactory字段为null\n    //否则，是ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()；关于getAdaptiveExtension()方法返回的实例，后面会看到\n    objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());\n}\n\nprivate static <T> boolean withExtensionAnnotation(Class<T> type) {\n    return type.isAnnotationPresent(SPI.class);\n}\n//获取某个接口的ExtensionLoader\n@SuppressWarnings(\"unchecked\")\npublic static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {\n    if (type == null)\n        throw new IllegalArgumentException(\"Extension type == null\");\n    if (!type.isInterface()) {\n        throw new IllegalArgumentException(\"Extension type(\" + type + \") is not interface!\");\n    }\n    //判断接口是否有SPI注解，Dubbo里所有需要SPI扩展的接口都需要添加@SPI注解\n    if (!withExtensionAnnotation(type)) {\n        throw new IllegalArgumentException(\"Extension type(\" + type +\n                                           \") is not extension, because WITHOUT @\" + SPI.class.getSimpleName() + \" Annotation!\");\n    }\n\t//判断是否已经存在\n    ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n    if (loader == null) {\n        //利用私有构造器创建ExtensionLoader，并且放入缓存\n        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));\n        loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n    }\n    return loader;\n}\n```\n\n创建了ExtensionLoader实例，我们就可以通过SPI机制获取想要的接口扩展类实例了，下面就以`org.apache.dubbo.rpc.Protocol`接口获取名为Dubbo的扩展实例为例：\n\n```java\nExtensionLoader.getExtensionLoader(Protocol.class).getExtension(DubboProtocol.NAME); \n```\n\n跟进getExtension方法：\n\n```java\n/**\n     * Find the extension with the given name. If the specified name is not found, then {@link IllegalStateException}\n     * will be thrown.\n     */\n@SuppressWarnings(\"unchecked\")\npublic T getExtension(String name) {\n    if (name == null || name.length() == 0)\n        throw new IllegalArgumentException(\"Extension name == null\");\n    //获取默认扩展\n    if (\"true\".equals(name)) {\n        return getDefaultExtension();\n    }\n    //指定扩展实例，判断是否已经缓存\n    Holder<Object> holder = cachedInstances.get(name);\n    if (holder == null) {\n        //创建Holder实例，放入缓存\n        cachedInstances.putIfAbsent(name, new Holder<Object>());\n        holder = cachedInstances.get(name);\n    }\n    Object instance = holder.get();\n    //加锁技巧，保证线程安全\n    if (instance == null) {\n        synchronized (holder) {\n            instance = holder.get();\n            if (instance == null) {\n                //根据扩展名，获取具体扩展实例，放入缓存holder中\n                instance = createExtension(name);\n                holder.set(instance);\n            }\n        }\n    }\n    //返回具体的扩展实例\n    return (T) instance;\n}\n```\n\n这里有两个获取扩展的相关方法，一个是`getDefaultExtension()`获取默认扩展，另一个是`createExtension(name)`根据扩展名获取扩展实例，下面分析这两个方法的具体实现：\n\n```java\n/***\n     * 这个方法，总结起来有3个步骤，\n     * 1，通过扩展名，找到扩展实现类，这过程可能触发spi文件加载解析\n     * 2，利用反射机制，获取扩展类实例，并完成依赖注入\n     * 3，如果接口扩展有包装类，实例化包装类\n     * 最后返回经由以上3步流程后，产生的对象。\n     * 这3步，前一步都是后一步的基础，要顺序完成\n     */\n@SuppressWarnings(\"unchecked\")\nprivate T createExtension(String name) {\n    //根据扩展名，获取扩展实现类的class（完成第1步）\n    Class<?> clazz = getExtensionClasses().get(name);\n    if (clazz == null) {\n        throw findException(name);\n    }\n    try {\n        //从缓存里，获取实现类的实例\n        T instance = (T) EXTENSION_INSTANCES.get(clazz);\n        if (instance == null) {\n            //利用newInstance()反射，构造类实例，病放入缓存\n            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());\n            instance = (T) EXTENSION_INSTANCES.get(clazz);\n        }\n        //完成接口实现类依赖注入，依赖组件先从SPI机制构造查找，再从Spring容器查找（完成第2步）\n        injectExtension(instance);\n        //如果这接口的实现，还有wrapper类，（有接口类型的构造函数）\n        //还有把当前实例instance，注入到包装类，包装类有多个，依次层层，循环构造注入\n        //最后返回的是，最后一个包装类实例，这也是dubbo的aop实现机制（完成第3步）\n        Set<Class<?>> wrapperClasses = cachedWrapperClasses;\n        if (wrapperClasses != null && !wrapperClasses.isEmpty()) {\n            for (Class<?> wrapperClass : wrapperClasses) {\n                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));\n            }\n        }\n        return instance;\n    } catch (Throwable t) {\n        throw new IllegalStateException(\"Extension instance(name: \" + name + \", class: \" +\n                                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n    }\n}\n```\n\n#### 第一步，加载扩展实现类\n\n```java\n//获取某个接口所有实现，按照扩展名：扩展实现，存储在map中\nprivate Map<String, Class<?>> getExtensionClasses() {\n    Map<String, Class<?>> classes = cachedClasses.get();\n    if (classes == null) {\n        synchronized (cachedClasses) {\n            classes = cachedClasses.get();\n            if (classes == null) {\n                classes = loadExtensionClasses();\n                cachedClasses.set(classes);\n            }\n        }\n    }\n    return classes;\n}\n\n// synchronized in getExtensionClasses\n//加载类路径中的spi配置文件，构造cachedClasses\nprivate Map<String, Class<?>> loadExtensionClasses() {\n    final SPI defaultAnnotation = type.getAnnotation(SPI.class);\n    //获取spi 注解  SPI(value=\"xxx\")，默认实现xxx\n    if (defaultAnnotation != null) {\n        String value = defaultAnnotation.value();\n        if ((value = value.trim()).length() > 0) {\n            String[] names = NAME_SEPARATOR.split(value);\n            //默认实现只能有一个\n            if (names.length > 1) {\n                throw new IllegalStateException(\"more than 1 default extension name on extension \" + type.getName()\n                                                + \": \" + Arrays.toString(names));\n            }\n            //获取spi默认实现值\n            if (names.length == 1) cachedDefaultName = names[0];\n        }\n    }\n\n    Map<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>();\n    //读取三个目录下的spi 配置文件;/META-INF/dubbo/internal, /META-INF/dubbo, /META-INF/services\n    //构造 扩展名:实现类 map\n    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());\n    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(\"org.apache\", \"com.alibaba\"));\n    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());\n    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(\"org.apache\", \"com.alibaba\"));\n    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());\n    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(\"org.apache\", \"com.alibaba\"));\n    return extensionClasses;\n}\n\nprivate void loadDirectory(Map<String, Class<?>> extensionClasses, String dir, String type) {\n    //拼接接口名作为文件名，例如：/META-INF/dubbo/internal/org.apache.dubbo.rpc.Protocol\n    String fileName = dir + type;\n    try {\n        Enumeration<java.net.URL> urls;\n        //获取加载ClassLoader类的类加载器\n        ClassLoader classLoader = findClassLoader();\n        if (classLoader != null) {\n            urls = classLoader.getResources(fileName);\n        } else {\n            urls = ClassLoader.getSystemResources(fileName);\n        }\n        if (urls != null) {\n            while (urls.hasMoreElements()) {\n                java.net.URL resourceURL = urls.nextElement();\n                //加载资源\n                loadResource(extensionClasses, classLoader, resourceURL);\n            }\n        }\n    } catch (Throwable t) {\n        logger.error(\"Exception when load extension class(interface: \" +\n                     type + \", description file: \" + fileName + \").\", t);\n    }\n}\n```\n\n我们继续来看loadResource()方法\n\n```java\nprivate void loadResource(Map<String, Class<?>> extensionClasses, ClassLoader classLoader, java.net.URL resourceURL) {\n    try {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(resourceURL.openStream(), \"utf-8\"));\n        try {\n            String line;\n            //读取文件每一行\n            while ((line = reader.readLine()) != null) {\n                final int ci = line.indexOf('#');\n                if (ci >= 0) line = line.substring(0, ci);\n                line = line.trim();\n                if (line.length() > 0) {\n                    try {\n                        String name = null;\n                        int i = line.indexOf('=');\n                        if (i > 0) {\n                            //name 是扩展名\n                            name = line.substring(0, i).trim();\n                            //扩展实现类全名\n                            line = line.substring(i + 1).trim();\n                        }\n                        if (line.length() > 0) {\n                            //根据line加载类\n                            loadClass(extensionClasses, resourceURL, Class.forName(line, true, classLoader), name);\n                        }\n                    } catch (Throwable t) {\n                        IllegalStateException e = new IllegalStateException(\"Failed to load extension class(interface: \" + type + \", class line: \" + line + \") in \" + resourceURL + \", cause: \" + t.getMessage(), t);\n                        exceptions.put(line, e);\n                    }\n                }\n            }\n        } finally {\n            reader.close();\n        }\n    } catch (Throwable t) {\n        logger.error(\"Exception when load extension class(interface: \" +\n                     type + \", class file: \" + resourceURL + \") in \" + resourceURL, t);\n    }\n}\n\nprivate void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL resourceURL, Class<?> clazz, String name) throws NoSuchMethodException {\n    //盘判断实现类是否实现了type接口\n    if (!type.isAssignableFrom(clazz)) {\n        throw new IllegalStateException(\"Error when load extension class(interface: \" +\n                                        type + \", class line: \" + clazz.getName() + \"), class \"\n                                        + clazz.getName() + \"is not subtype of interface.\");\n    }\n    //判断实现类是否有Adaptive注解\n    if (clazz.isAnnotationPresent(Adaptive.class)) {\n        if (cachedAdaptiveClass == null) {\n            //赋值\n            cachedAdaptiveClass = clazz;\n        } else if (!cachedAdaptiveClass.equals(clazz)) {\n            //一个接口的SPI实现，只能有一个实现类是Adaptive的\n            throw new IllegalStateException(\"More than 1 adaptive class found: \"\n                                            + cachedAdaptiveClass.getClass().getName()\n                                            + \", \" + clazz.getClass().getName());\n        }\n    } else if (isWrapperClass(clazz)) { //判断是否为包装类\n        //一个接口的SPI实现可以有多个包装类\n        Set<Class<?>> wrappers = cachedWrapperClasses;\n        if (wrappers == null) {\n            cachedWrapperClasses = new ConcurrentHashSet<Class<?>>();\n            wrappers = cachedWrapperClasses;\n        }\n        wrappers.add(clazz);\n    } else {\n        clazz.getConstructor();\n        if (name == null || name.length() == 0) {\n            name = findAnnotationName(clazz);\n            if (name.length() == 0) {\n                throw new IllegalStateException(\"No such extension name for the class \" + clazz.getName() + \" in the config \" + resourceURL);\n            }\n        }\n        String[] names = NAME_SEPARATOR.split(name);\n        if (names != null && names.length > 0) { //？？？\n            //实现类是否有Active注解\n            Activate activate = clazz.getAnnotation(Activate.class);\n            if (activate != null) {\n                //如果有，加入cachedActivates map（扩展名：实现类class）\n                cachedActivates.put(names[0], activate);\n            } else {\n                // support com.alibaba.dubbo.common.extension.Activate\n                com.alibaba.dubbo.common.extension.Activate oldActivate = clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.class);\n                if (oldActivate != null) {\n                    cachedActivates.put(names[0], oldActivate);\n                }\n            }\n            for (String n : names) {\n                if (!cachedNames.containsKey(clazz)) {\n                    //实现类:扩展名 map 放入缓存\n                    cachedNames.put(clazz, n);\n                }\n                Class<?> c = extensionClasses.get(n);\n                if (c == null) {\n                    //Adaptive 和wapper类都不在extensionClasses里!!!\n                    extensionClasses.put(n, clazz);\n                } else if (c != clazz) {\n                    throw new IllegalStateException(\"Duplicate extension \" + type.getName() + \" name \" + n + \" on \" + c.getName() + \" and \" + clazz.getName());\n                }\n            }\n        }\n    }\n}\nprivate boolean isWrapperClass(Class<?> clazz) {\n    try {\n        //实现类里，是否有，参数是接口类型的（比如 com.alibaba.dubbo.rpc.Protocol类型，并且1个参数）的构造函数\n        //表示它是个接口包装类\n        clazz.getConstructor(type);\n        return true;\n    } catch (NoSuchMethodException e) {\n        return false;\n    }\n}\n```\n\n#### 第二步，依赖注入流程分析\n\n首先来看injectExtension(T instance)的实现：\n\n```java\n//实例对象，字段依赖注入。字段类型可以是spi 接口类型，或者是Spring bean 类型\n// 依赖注入的字段对象，是通过ExtensionLoader的objectFactory属性完成的，\n// objectFacotry 会根据先后通过spi机制和从spring 容器里获取属性对象并注入。\n// objectFactory 是在ExtensionLoader私有构造函数中赋值\nprivate T injectExtension(T instance) {\n    try {\n        if (objectFactory != null) {\n            for (Method method : instance.getClass().getMethods()) {\n                if (method.getName().startsWith(\"set\")\n                    && method.getParameterTypes().length == 1\n                    && Modifier.isPublic(method.getModifiers())) { //获取所有public类型，并且只有一个参数的以set开头的方法\n                    Class<?> pt = method.getParameterTypes()[0];\n                    try {\n                        //根据驼峰命名法，根据方法名，构造set方法要赋值的属性名\n                        String property = method.getName().length() > 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : \"\";\n                        //通过getExtension的方法获取属性对象，所以还要看getExtension的实现。\n                        Object object = objectFactory.getExtension(pt, property);\n                        if (object != null) {\n                            //利用反射机制，赋值对象属性\n                            method.invoke(instance, object);\n                        }\n                    } catch (Exception e) {\n                        logger.error(\"fail to inject via method \" + method.getName()\n                                     + \" of interface \" + type.getName() + \": \" + e.getMessage(), e);\n                    }\n                }\n            }\n        }\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n    }\n    return instance;\n}\n```\n\n看下ExtensionLoader定义的私有构造函数，可以看到objectFactory是通过`ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()`赋值的，它是ExtensionFactory接口的Adaptive扩展实现，看下getAdaptiveExtension()方法：\n\n```Java\n//获取一个SPI接口的Adaptive(实现类有Adaptive注解的)类型扩展实现\npublic T getAdaptiveExtension() {\n    //先取缓存\n    Object instance = cachedAdaptiveInstance.get();\n    if (instance == null) {\n        if (createAdaptiveInstanceError == null) {\n            synchronized (cachedAdaptiveInstance) {\n                instance = cachedAdaptiveInstance.get();\n                if (instance == null) {\n                    try {\n                        //缓存不在，就创建Adaptive扩展实例\n                        instance = createAdaptiveExtension();\n                        //对象放入缓存中\n                        cachedAdaptiveInstance.set(instance);\n                    } catch (Throwable t) {\n                        createAdaptiveInstanceError = t;\n                        throw new IllegalStateException(\"fail to create adaptive instance: \" + t.toString(), t);\n                    }\n                }\n            }\n        } else {\n            throw new IllegalStateException(\"fail to create adaptive instance: \" + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);\n        }\n    }\n\n    return (T) instance;\n}\n@SuppressWarnings(\"unchecked\")\nprivate T createAdaptiveExtension() {\n    try {\n        //获取AdaptiveExtensionClass的class 通过反射获取实例，同时要走依赖注入流程\n        //AdaptiveExtensionClass 已在spi 文件解析时赋值\n        return injectExtension((T) getAdaptiveExtensionClass().newInstance());\n    } catch (Exception e) {\n        throw new IllegalStateException(\"Can not create adaptive extension \" + type + \", cause: \" + e.getMessage(), e);\n    }\n}\n\nprivate Class<?> getAdaptiveExtensionClass() {\n    //如果有必要，触发spi加载流程，\n\t//找到类上有Adaptive注解的class,赋值给cachedAdaptiveClass\n    getExtensionClasses();\n    if (cachedAdaptiveClass != null) {\n        return cachedAdaptiveClass;\n    }\n    //Adaptive注解不在扩展实现类上，而是在待扩展接口方法上\n\t//这种情况，就是dubbo动态生成生成java类字串，动态编译生成想要的class\n\t//这个下面再分析下\n    return cachedAdaptiveClass = createAdaptiveExtensionClass();\n}\n```\n\n目前ExtensionFactory接口3个实现类，只有AdaptiveExtensionFactory类是Adaptive的：\n\n```java\n/**\n * AdaptiveExtensionFactory\n */\n@Adaptive\npublic class AdaptiveExtensionFactory implements ExtensionFactory {\n\n    private final List<ExtensionFactory> factories;\n\t//无参构造函数中，把其他实现类实例加入到factories list中\n    public AdaptiveExtensionFactory() {\n        ExtensionLoader<ExtensionFactory> loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);\n        List<ExtensionFactory> list = new ArrayList<ExtensionFactory>();\n        //getSupportedExtensions()返回的是 非包装类扩展，非Adaptive扩展，防止无限循环\n        for (String name : loader.getSupportedExtensions()) {\n            list.add(loader.getExtension(name));\n        }\n        factories = Collections.unmodifiableList(list);\n    }\n\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        for (ExtensionFactory factory : factories) {\n            T extension = factory.getExtension(type, name);\n            if (extension != null) {\n                return extension;\n            }\n        }\n        return null;\n    }\n\n}\n```\n\n另外两个实现类是`SpiExtensionFactory`、`SpringExtensionFactory`：\n\n```java\n/**\n * SpiExtensionFactory\n */\npublic class SpiExtensionFactory implements ExtensionFactory {\n\t//SPI机制获取type扩展接口\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        if (type.isInterface() && type.isAnnotationPresent(SPI.class)) {\n            ExtensionLoader<T> loader = ExtensionLoader.getExtensionLoader(type);\n            if (!loader.getSupportedExtensions().isEmpty()) {\n                //获取的是接口的Adaptive实现\n                return loader.getAdaptiveExtension();\n            }\n        }\n        return null;\n    }\n\n}\n\n/**\n * SpringExtensionFactory\n */\npublic class SpringExtensionFactory implements ExtensionFactory {\n    private static final Logger logger = LoggerFactory.getLogger(SpringExtensionFactory.class);\n\n    private static final Set<ApplicationContext> contexts = new ConcurrentHashSet<ApplicationContext>();\n\t//手动将spring容器传入\n    public static void addApplicationContext(ApplicationContext context) {\n        contexts.add(context);\n    }\n\n    public static void removeApplicationContext(ApplicationContext context) {\n        contexts.remove(context);\n    }\n\n    // currently for test purpose\n    public static void clearContexts() {\n        contexts.clear();\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getExtension(Class<T> type, String name) {\n\n        //SPI should be get from SpiExtensionFactory\n        if (type.isInterface() && type.isAnnotationPresent(SPI.class)) {\n            return null;\n        }\n\t\t//遍历spring容器\n        for (ApplicationContext context : contexts) {\n            if (context.containsBean(name)) {\n                Object bean = context.getBean(name);\n                if (type.isInstance(bean)) {\n                    return (T) bean;\n                }\n            }\n        }\n\n        logger.warn(\"No spring extension(bean) named:\" + name + \", try to find an extension(bean) of type \" + type.getName());\n\n        for (ApplicationContext context : contexts) {\n            try {\n                return context.getBean(type);\n            } catch (NoUniqueBeanDefinitionException multiBeanExe) {\n                throw multiBeanExe;\n            } catch (NoSuchBeanDefinitionException noBeanExe) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Error when get spring extension(bean) for type:\" + type.getName(), noBeanExe);\n                }\n            }\n        }\n\n        logger.warn(\"No spring extension(bean) named:\" + name + \", type:\" + type.getName() + \" found, stop get bean.\");\n\n        return null;\n    }\n\n}\n\n```\n\n\n\n#### 第三步，实例化包装类流程分析\n\n代码上面createExtension方法里已贴出，为了更好的理解，我们可以看下Protocol接口的实现中，ProtocolFIlterWrapper和ProtocolListenerWrapper两个包装类，可以看到他们都有参数为Protocol类型的public构造函数，实例化时，把上层的protocol对象作为参数传入构造函数作为内部属性，同时包装类本身会实现Protocol接口，所以这就可以做些类似aop的操作，如ProtocolFilterWrapper：\n\n```java\n/**\n * ListenerProtocol\n */\npublic class ProtocolFilterWrapper implements Protocol {\n\n    private final Protocol protocol;\n\n    public ProtocolFilterWrapper(Protocol protocol) {\n        if (protocol == null) {\n            throw new IllegalArgumentException(\"protocol == null\");\n        }\n        this.protocol = protocol;\n    }\n\t//实例化过滤器链\n    private static <T> Invoker<T> buildInvokerChain(final Invoker<T> invoker, String key, String group) {\n        Invoker<T> last = invoker;\n        List<Filter> filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);\n        if (!filters.isEmpty()) {\n            for (int i = filters.size() - 1; i >= 0; i--) {\n                final Filter filter = filters.get(i);\n                final Invoker<T> next = last;\n                last = new Invoker<T>() {\n\n                    @Override\n                    public Class<T> getInterface() {\n                        return invoker.getInterface();\n                    }\n\n                    @Override\n                    public URL getUrl() {\n                        return invoker.getUrl();\n                    }\n\n                    @Override\n                    public boolean isAvailable() {\n                        return invoker.isAvailable();\n                    }\n\n                    @Override\n                    public Result invoke(Invocation invocation) throws RpcException {\n                        return filter.invoke(next, invocation);\n                    }\n\n                    @Override\n                    public void destroy() {\n                        invoker.destroy();\n                    }\n\n                    @Override\n                    public String toString() {\n                        return invoker.toString();\n                    }\n                };\n            }\n        }\n        return last;\n    }\n\n    @Override\n    public int getDefaultPort() {\n        return protocol.getDefaultPort();\n    }\n\t//暴露过程前执行过滤器链\n    @Override\n    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n        if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {\n            return protocol.export(invoker);\n        }\n        return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));\n    }\n\t//调用前执行过滤器链\n    @Override\n    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n        if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n            return protocol.refer(type, url);\n        }\n        return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);\n    }\n\n    @Override\n    public void destroy() {\n        protocol.destroy();\n    }\n\n}\n```\n\n到此Dubbo SPI机制的三个步骤分析完了。\n\n上面提到的Adaptive类的另一种配置方式，即Adaptive注解配置在方法上，dubbo里，配置Adaptive类有两种方式，一种在就扣实现里，类本身有Adaptive注解，还有一种配置实在接口定义的方法级上有Adaptive注解，这两种方式第一种优先，没有第一种，dubbo自动完成第二种Adaptive类的生成，以Protocol接口为例：\n\n```java\n@SPI(\"dubbo\")\npublic interface Protocol {\n\n    /**\n     * 获取缺省端口，当用户没有配置端口时使用。\n     *\n     * @return 缺省端口\n     */\n    int getDefaultPort();\n\n    /**\n     * 暴露远程服务：<br>\n     * 1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();<br>\n     * 2. export()必须是幂等的，也就是暴露同一个URL的Invoker两次，和暴露一次没有区别。<br>\n     * 3. export()传入的Invoker由框架实现并传入，协议不需要关心。<br>\n     *\n     * @param <T>     服务的类型\n     * @param invoker 服务的执行体\n     * @return exporter 暴露服务的引用，用于取消暴露\n     * @throws RpcException 当暴露服务出错时抛出，比如端口已占用\n     */\n    @Adaptive\n    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;\n\n    /**\n     * 引用远程服务：<br>\n     * 1. 当用户调用refer()所返回的Invoker对象的invoke()方法时，协议需相应执行同URL远端export()传入的Invoker对象的invoke()方法。<br>\n     * 2. refer()返回的Invoker由协议实现，协议通常需要在此Invoker中发送远程请求。<br>\n     * 3. 当url中有设置check=false时，连接失败不能抛出异常，并内部自动恢复。<br>\n     *\n     * @param <T>  服务的类型\n     * @param type 服务的类型\n     * @param url  远程服务的URL地址\n     * @return invoker 服务的本地代理\n     * @throws RpcException 当连接服务提供方失败时抛出\n     */\n    @Adaptive\n    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;\n    \n    /**\n     * 释放协议：<br>\n     * 1. 取消该协议所有已经暴露和引用的服务。<br>\n     * 2. 释放协议所占用的所有资源，比如连接和端口。<br>\n     * 3. 协议在释放后，依然能暴露和引用新的服务。<br>\n     */\n    void destroy();\n\n}\n```\n\n在export和refer方法上所有Adaptive注解，根据上面的分析，我们跟踪一下createAdaptiveExtensionClass方法：\n\n```java\nprivate Class<?> createAdaptiveExtensionClass() {\n    //生成Adaptive；类源码\n    String code = createAdaptiveExtensionClassCode();\n    ClassLoader classLoader = findClassLoader();\n    //通过SPI获取java 编译器\n    org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();\n    //编译源码返回class\n    return compiler.compile(code, classLoader);\n}\n```\n\n`createAdaptiveExtensionClassCode();`方法就是实现字符串拼接, 不同的接口，生成的code会有不同，默认使用javassist对代码进行编译。 这里贴出Protocal生成的Adaptive类的源代码。**体现的思想是，所谓Adaptive方法，其实现，内部的对象类型都是参数（url）和spi机制动态决定的**。\n\n```java\npackage org.apache.dubbo.rpc;\n\nimport org.apache.dubbo.common.extension.ExtensionLoader;\n\npublic class Protocol$Adaptive implements org.apache.dubbo.rpc.Protocol {\n    public org.apache.dubbo.rpc.Invoker refer(java.lang.Class arg0, org.apache.dubbo.common.URL arg1) throws org.apache.dubbo.rpc.RpcException {\n        if (arg1 == null) throw new IllegalArgumentException(\"url == null\");\n        org.apache.dubbo.common.URL url = arg1;\n        String extName = (url.getProtocol() == null ? \"dubbo\" : url.getProtocol());\n        if (extName == null)\n            throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n        return extension.refer(arg0, arg1);\n    }\n\n    public org.apache.dubbo.rpc.Exporter export(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException {\n        if (arg0 == null) throw new IllegalArgumentException(\"org.apache.dubbo.rpc.Invoker argument == null\");\n        if (arg0.getUrl() == null)\n            throw new IllegalArgumentException(\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\");\n        org.apache.dubbo.common.URL url = arg0.getUrl();\n        String extName = (url.getProtocol() == null ? \"dubbo\" : url.getProtocol());\n        if (extName == null)\n            throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n        return extension.export(arg0);\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException(\"method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!\");\n    }\n\n    public int getDefaultPort() {\n        throw new UnsupportedOperationException(\"method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!\");\n    }\n}\n```\n\n","source":"_posts/dubbo-spi-analysis.md","raw":"---\ntitle: Dubbo SPI机制源码分析\ndate: 2018-08-09 15:03:57\ntags:\n    - dubbo\n---\n\nDubbo是微内核架构，还是开闭原则的应用，把核心流程架构固定，但是流程的各个节点对重新改进是开放的。具体的实现机制就是SPI(Service Provider Interface)机制，Dubbo基于Java SPI机制（不了解Java SPI机制的可以参考这篇文章[《深入理解Java SPI机制》](https://shuaijunlan.github.io/2018/08/03/java-spi-introduction/)），在其基础上做了改进和扩展。\n\n根据SPI规范，接口由框架定义，具体实现可以由不同的厂商提供，在Dubbo jar包可以发现在`/META-INF/dubbo/internal`目录下有许多接口命名的文件，文件里面的内容就是文件名代表的接口的各种实现类，这就是Dubbo SPI机制的配置基础，以`org.apache.dubbo.rpc.Protocol`文件为例，内容如下（dubbo-2.7.0-SNAPSHOT 版本）：\n\n```\nfilter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper\nlistener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper\nmock=org.apache.dubbo.rpc.support.MockProtocol\ndubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol\ninjvm=org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol\nrmi=org.apache.dubbo.rpc.protocol.rmi.RmiProtocol\nhessian=org.apache.dubbo.rpc.protocol.hessian.HessianProtocol\nhttp=org.apache.dubbo.rpc.protocol.http.HttpProtocol\n\norg.apache.dubbo.rpc.protocol.webservice.WebServiceProtocol\nthrift=org.apache.dubbo.rpc.protocol.thrift.ThriftProtocol\nmemcached=org.apache.dubbo.rpc.protocol.memcached.MemcachedProtocol\nredis=org.apache.dubbo.rpc.protocol.redis.RedisProtocol\nrest=org.apache.dubbo.rpc.protocol.rest.RestProtocol\nregistry=org.apache.dubbo.registry.integration.RegistryProtocol\nqos=org.apache.dubbo.qos.protocol.QosProtocolWrapper\n```\n\n<!-- more -->\n\n在Dubbo SPI机制中，`org.apache.dubbo.rpc.Protocol`接口由以上那么多的具体实现，`=`前面是扩展名，后面是扩展类的实现；\n\nSPI的启动的入口类是ExtensionLoader，这个类没定义public构造函数，只有一个privae的，而且public的静态方法也只有一个`public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type)`，这个方法也是SPI的入口方法，**若想获取某个接口类型的扩展，先必须获取其对应的ExtensionLoader**\n\n```java\n//私有构造器\nprivate ExtensionLoader(Class<?> type) {\n    this.type = type;\n    //objectFactory 对象 ，ExtensionFactory本身也是spi的\n    //如果是ExtensionFactory本身的ExtensionLoader实例，objectFactory字段为null\n    //否则，是ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()；关于getAdaptiveExtension()方法返回的实例，后面会看到\n    objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());\n}\n\nprivate static <T> boolean withExtensionAnnotation(Class<T> type) {\n    return type.isAnnotationPresent(SPI.class);\n}\n//获取某个接口的ExtensionLoader\n@SuppressWarnings(\"unchecked\")\npublic static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {\n    if (type == null)\n        throw new IllegalArgumentException(\"Extension type == null\");\n    if (!type.isInterface()) {\n        throw new IllegalArgumentException(\"Extension type(\" + type + \") is not interface!\");\n    }\n    //判断接口是否有SPI注解，Dubbo里所有需要SPI扩展的接口都需要添加@SPI注解\n    if (!withExtensionAnnotation(type)) {\n        throw new IllegalArgumentException(\"Extension type(\" + type +\n                                           \") is not extension, because WITHOUT @\" + SPI.class.getSimpleName() + \" Annotation!\");\n    }\n\t//判断是否已经存在\n    ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n    if (loader == null) {\n        //利用私有构造器创建ExtensionLoader，并且放入缓存\n        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));\n        loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n    }\n    return loader;\n}\n```\n\n创建了ExtensionLoader实例，我们就可以通过SPI机制获取想要的接口扩展类实例了，下面就以`org.apache.dubbo.rpc.Protocol`接口获取名为Dubbo的扩展实例为例：\n\n```java\nExtensionLoader.getExtensionLoader(Protocol.class).getExtension(DubboProtocol.NAME); \n```\n\n跟进getExtension方法：\n\n```java\n/**\n     * Find the extension with the given name. If the specified name is not found, then {@link IllegalStateException}\n     * will be thrown.\n     */\n@SuppressWarnings(\"unchecked\")\npublic T getExtension(String name) {\n    if (name == null || name.length() == 0)\n        throw new IllegalArgumentException(\"Extension name == null\");\n    //获取默认扩展\n    if (\"true\".equals(name)) {\n        return getDefaultExtension();\n    }\n    //指定扩展实例，判断是否已经缓存\n    Holder<Object> holder = cachedInstances.get(name);\n    if (holder == null) {\n        //创建Holder实例，放入缓存\n        cachedInstances.putIfAbsent(name, new Holder<Object>());\n        holder = cachedInstances.get(name);\n    }\n    Object instance = holder.get();\n    //加锁技巧，保证线程安全\n    if (instance == null) {\n        synchronized (holder) {\n            instance = holder.get();\n            if (instance == null) {\n                //根据扩展名，获取具体扩展实例，放入缓存holder中\n                instance = createExtension(name);\n                holder.set(instance);\n            }\n        }\n    }\n    //返回具体的扩展实例\n    return (T) instance;\n}\n```\n\n这里有两个获取扩展的相关方法，一个是`getDefaultExtension()`获取默认扩展，另一个是`createExtension(name)`根据扩展名获取扩展实例，下面分析这两个方法的具体实现：\n\n```java\n/***\n     * 这个方法，总结起来有3个步骤，\n     * 1，通过扩展名，找到扩展实现类，这过程可能触发spi文件加载解析\n     * 2，利用反射机制，获取扩展类实例，并完成依赖注入\n     * 3，如果接口扩展有包装类，实例化包装类\n     * 最后返回经由以上3步流程后，产生的对象。\n     * 这3步，前一步都是后一步的基础，要顺序完成\n     */\n@SuppressWarnings(\"unchecked\")\nprivate T createExtension(String name) {\n    //根据扩展名，获取扩展实现类的class（完成第1步）\n    Class<?> clazz = getExtensionClasses().get(name);\n    if (clazz == null) {\n        throw findException(name);\n    }\n    try {\n        //从缓存里，获取实现类的实例\n        T instance = (T) EXTENSION_INSTANCES.get(clazz);\n        if (instance == null) {\n            //利用newInstance()反射，构造类实例，病放入缓存\n            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());\n            instance = (T) EXTENSION_INSTANCES.get(clazz);\n        }\n        //完成接口实现类依赖注入，依赖组件先从SPI机制构造查找，再从Spring容器查找（完成第2步）\n        injectExtension(instance);\n        //如果这接口的实现，还有wrapper类，（有接口类型的构造函数）\n        //还有把当前实例instance，注入到包装类，包装类有多个，依次层层，循环构造注入\n        //最后返回的是，最后一个包装类实例，这也是dubbo的aop实现机制（完成第3步）\n        Set<Class<?>> wrapperClasses = cachedWrapperClasses;\n        if (wrapperClasses != null && !wrapperClasses.isEmpty()) {\n            for (Class<?> wrapperClass : wrapperClasses) {\n                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));\n            }\n        }\n        return instance;\n    } catch (Throwable t) {\n        throw new IllegalStateException(\"Extension instance(name: \" + name + \", class: \" +\n                                        type + \")  could not be instantiated: \" + t.getMessage(), t);\n    }\n}\n```\n\n#### 第一步，加载扩展实现类\n\n```java\n//获取某个接口所有实现，按照扩展名：扩展实现，存储在map中\nprivate Map<String, Class<?>> getExtensionClasses() {\n    Map<String, Class<?>> classes = cachedClasses.get();\n    if (classes == null) {\n        synchronized (cachedClasses) {\n            classes = cachedClasses.get();\n            if (classes == null) {\n                classes = loadExtensionClasses();\n                cachedClasses.set(classes);\n            }\n        }\n    }\n    return classes;\n}\n\n// synchronized in getExtensionClasses\n//加载类路径中的spi配置文件，构造cachedClasses\nprivate Map<String, Class<?>> loadExtensionClasses() {\n    final SPI defaultAnnotation = type.getAnnotation(SPI.class);\n    //获取spi 注解  SPI(value=\"xxx\")，默认实现xxx\n    if (defaultAnnotation != null) {\n        String value = defaultAnnotation.value();\n        if ((value = value.trim()).length() > 0) {\n            String[] names = NAME_SEPARATOR.split(value);\n            //默认实现只能有一个\n            if (names.length > 1) {\n                throw new IllegalStateException(\"more than 1 default extension name on extension \" + type.getName()\n                                                + \": \" + Arrays.toString(names));\n            }\n            //获取spi默认实现值\n            if (names.length == 1) cachedDefaultName = names[0];\n        }\n    }\n\n    Map<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>();\n    //读取三个目录下的spi 配置文件;/META-INF/dubbo/internal, /META-INF/dubbo, /META-INF/services\n    //构造 扩展名:实现类 map\n    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());\n    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(\"org.apache\", \"com.alibaba\"));\n    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());\n    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(\"org.apache\", \"com.alibaba\"));\n    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());\n    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(\"org.apache\", \"com.alibaba\"));\n    return extensionClasses;\n}\n\nprivate void loadDirectory(Map<String, Class<?>> extensionClasses, String dir, String type) {\n    //拼接接口名作为文件名，例如：/META-INF/dubbo/internal/org.apache.dubbo.rpc.Protocol\n    String fileName = dir + type;\n    try {\n        Enumeration<java.net.URL> urls;\n        //获取加载ClassLoader类的类加载器\n        ClassLoader classLoader = findClassLoader();\n        if (classLoader != null) {\n            urls = classLoader.getResources(fileName);\n        } else {\n            urls = ClassLoader.getSystemResources(fileName);\n        }\n        if (urls != null) {\n            while (urls.hasMoreElements()) {\n                java.net.URL resourceURL = urls.nextElement();\n                //加载资源\n                loadResource(extensionClasses, classLoader, resourceURL);\n            }\n        }\n    } catch (Throwable t) {\n        logger.error(\"Exception when load extension class(interface: \" +\n                     type + \", description file: \" + fileName + \").\", t);\n    }\n}\n```\n\n我们继续来看loadResource()方法\n\n```java\nprivate void loadResource(Map<String, Class<?>> extensionClasses, ClassLoader classLoader, java.net.URL resourceURL) {\n    try {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(resourceURL.openStream(), \"utf-8\"));\n        try {\n            String line;\n            //读取文件每一行\n            while ((line = reader.readLine()) != null) {\n                final int ci = line.indexOf('#');\n                if (ci >= 0) line = line.substring(0, ci);\n                line = line.trim();\n                if (line.length() > 0) {\n                    try {\n                        String name = null;\n                        int i = line.indexOf('=');\n                        if (i > 0) {\n                            //name 是扩展名\n                            name = line.substring(0, i).trim();\n                            //扩展实现类全名\n                            line = line.substring(i + 1).trim();\n                        }\n                        if (line.length() > 0) {\n                            //根据line加载类\n                            loadClass(extensionClasses, resourceURL, Class.forName(line, true, classLoader), name);\n                        }\n                    } catch (Throwable t) {\n                        IllegalStateException e = new IllegalStateException(\"Failed to load extension class(interface: \" + type + \", class line: \" + line + \") in \" + resourceURL + \", cause: \" + t.getMessage(), t);\n                        exceptions.put(line, e);\n                    }\n                }\n            }\n        } finally {\n            reader.close();\n        }\n    } catch (Throwable t) {\n        logger.error(\"Exception when load extension class(interface: \" +\n                     type + \", class file: \" + resourceURL + \") in \" + resourceURL, t);\n    }\n}\n\nprivate void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL resourceURL, Class<?> clazz, String name) throws NoSuchMethodException {\n    //盘判断实现类是否实现了type接口\n    if (!type.isAssignableFrom(clazz)) {\n        throw new IllegalStateException(\"Error when load extension class(interface: \" +\n                                        type + \", class line: \" + clazz.getName() + \"), class \"\n                                        + clazz.getName() + \"is not subtype of interface.\");\n    }\n    //判断实现类是否有Adaptive注解\n    if (clazz.isAnnotationPresent(Adaptive.class)) {\n        if (cachedAdaptiveClass == null) {\n            //赋值\n            cachedAdaptiveClass = clazz;\n        } else if (!cachedAdaptiveClass.equals(clazz)) {\n            //一个接口的SPI实现，只能有一个实现类是Adaptive的\n            throw new IllegalStateException(\"More than 1 adaptive class found: \"\n                                            + cachedAdaptiveClass.getClass().getName()\n                                            + \", \" + clazz.getClass().getName());\n        }\n    } else if (isWrapperClass(clazz)) { //判断是否为包装类\n        //一个接口的SPI实现可以有多个包装类\n        Set<Class<?>> wrappers = cachedWrapperClasses;\n        if (wrappers == null) {\n            cachedWrapperClasses = new ConcurrentHashSet<Class<?>>();\n            wrappers = cachedWrapperClasses;\n        }\n        wrappers.add(clazz);\n    } else {\n        clazz.getConstructor();\n        if (name == null || name.length() == 0) {\n            name = findAnnotationName(clazz);\n            if (name.length() == 0) {\n                throw new IllegalStateException(\"No such extension name for the class \" + clazz.getName() + \" in the config \" + resourceURL);\n            }\n        }\n        String[] names = NAME_SEPARATOR.split(name);\n        if (names != null && names.length > 0) { //？？？\n            //实现类是否有Active注解\n            Activate activate = clazz.getAnnotation(Activate.class);\n            if (activate != null) {\n                //如果有，加入cachedActivates map（扩展名：实现类class）\n                cachedActivates.put(names[0], activate);\n            } else {\n                // support com.alibaba.dubbo.common.extension.Activate\n                com.alibaba.dubbo.common.extension.Activate oldActivate = clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.class);\n                if (oldActivate != null) {\n                    cachedActivates.put(names[0], oldActivate);\n                }\n            }\n            for (String n : names) {\n                if (!cachedNames.containsKey(clazz)) {\n                    //实现类:扩展名 map 放入缓存\n                    cachedNames.put(clazz, n);\n                }\n                Class<?> c = extensionClasses.get(n);\n                if (c == null) {\n                    //Adaptive 和wapper类都不在extensionClasses里!!!\n                    extensionClasses.put(n, clazz);\n                } else if (c != clazz) {\n                    throw new IllegalStateException(\"Duplicate extension \" + type.getName() + \" name \" + n + \" on \" + c.getName() + \" and \" + clazz.getName());\n                }\n            }\n        }\n    }\n}\nprivate boolean isWrapperClass(Class<?> clazz) {\n    try {\n        //实现类里，是否有，参数是接口类型的（比如 com.alibaba.dubbo.rpc.Protocol类型，并且1个参数）的构造函数\n        //表示它是个接口包装类\n        clazz.getConstructor(type);\n        return true;\n    } catch (NoSuchMethodException e) {\n        return false;\n    }\n}\n```\n\n#### 第二步，依赖注入流程分析\n\n首先来看injectExtension(T instance)的实现：\n\n```java\n//实例对象，字段依赖注入。字段类型可以是spi 接口类型，或者是Spring bean 类型\n// 依赖注入的字段对象，是通过ExtensionLoader的objectFactory属性完成的，\n// objectFacotry 会根据先后通过spi机制和从spring 容器里获取属性对象并注入。\n// objectFactory 是在ExtensionLoader私有构造函数中赋值\nprivate T injectExtension(T instance) {\n    try {\n        if (objectFactory != null) {\n            for (Method method : instance.getClass().getMethods()) {\n                if (method.getName().startsWith(\"set\")\n                    && method.getParameterTypes().length == 1\n                    && Modifier.isPublic(method.getModifiers())) { //获取所有public类型，并且只有一个参数的以set开头的方法\n                    Class<?> pt = method.getParameterTypes()[0];\n                    try {\n                        //根据驼峰命名法，根据方法名，构造set方法要赋值的属性名\n                        String property = method.getName().length() > 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : \"\";\n                        //通过getExtension的方法获取属性对象，所以还要看getExtension的实现。\n                        Object object = objectFactory.getExtension(pt, property);\n                        if (object != null) {\n                            //利用反射机制，赋值对象属性\n                            method.invoke(instance, object);\n                        }\n                    } catch (Exception e) {\n                        logger.error(\"fail to inject via method \" + method.getName()\n                                     + \" of interface \" + type.getName() + \": \" + e.getMessage(), e);\n                    }\n                }\n            }\n        }\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n    }\n    return instance;\n}\n```\n\n看下ExtensionLoader定义的私有构造函数，可以看到objectFactory是通过`ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()`赋值的，它是ExtensionFactory接口的Adaptive扩展实现，看下getAdaptiveExtension()方法：\n\n```Java\n//获取一个SPI接口的Adaptive(实现类有Adaptive注解的)类型扩展实现\npublic T getAdaptiveExtension() {\n    //先取缓存\n    Object instance = cachedAdaptiveInstance.get();\n    if (instance == null) {\n        if (createAdaptiveInstanceError == null) {\n            synchronized (cachedAdaptiveInstance) {\n                instance = cachedAdaptiveInstance.get();\n                if (instance == null) {\n                    try {\n                        //缓存不在，就创建Adaptive扩展实例\n                        instance = createAdaptiveExtension();\n                        //对象放入缓存中\n                        cachedAdaptiveInstance.set(instance);\n                    } catch (Throwable t) {\n                        createAdaptiveInstanceError = t;\n                        throw new IllegalStateException(\"fail to create adaptive instance: \" + t.toString(), t);\n                    }\n                }\n            }\n        } else {\n            throw new IllegalStateException(\"fail to create adaptive instance: \" + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);\n        }\n    }\n\n    return (T) instance;\n}\n@SuppressWarnings(\"unchecked\")\nprivate T createAdaptiveExtension() {\n    try {\n        //获取AdaptiveExtensionClass的class 通过反射获取实例，同时要走依赖注入流程\n        //AdaptiveExtensionClass 已在spi 文件解析时赋值\n        return injectExtension((T) getAdaptiveExtensionClass().newInstance());\n    } catch (Exception e) {\n        throw new IllegalStateException(\"Can not create adaptive extension \" + type + \", cause: \" + e.getMessage(), e);\n    }\n}\n\nprivate Class<?> getAdaptiveExtensionClass() {\n    //如果有必要，触发spi加载流程，\n\t//找到类上有Adaptive注解的class,赋值给cachedAdaptiveClass\n    getExtensionClasses();\n    if (cachedAdaptiveClass != null) {\n        return cachedAdaptiveClass;\n    }\n    //Adaptive注解不在扩展实现类上，而是在待扩展接口方法上\n\t//这种情况，就是dubbo动态生成生成java类字串，动态编译生成想要的class\n\t//这个下面再分析下\n    return cachedAdaptiveClass = createAdaptiveExtensionClass();\n}\n```\n\n目前ExtensionFactory接口3个实现类，只有AdaptiveExtensionFactory类是Adaptive的：\n\n```java\n/**\n * AdaptiveExtensionFactory\n */\n@Adaptive\npublic class AdaptiveExtensionFactory implements ExtensionFactory {\n\n    private final List<ExtensionFactory> factories;\n\t//无参构造函数中，把其他实现类实例加入到factories list中\n    public AdaptiveExtensionFactory() {\n        ExtensionLoader<ExtensionFactory> loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);\n        List<ExtensionFactory> list = new ArrayList<ExtensionFactory>();\n        //getSupportedExtensions()返回的是 非包装类扩展，非Adaptive扩展，防止无限循环\n        for (String name : loader.getSupportedExtensions()) {\n            list.add(loader.getExtension(name));\n        }\n        factories = Collections.unmodifiableList(list);\n    }\n\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        for (ExtensionFactory factory : factories) {\n            T extension = factory.getExtension(type, name);\n            if (extension != null) {\n                return extension;\n            }\n        }\n        return null;\n    }\n\n}\n```\n\n另外两个实现类是`SpiExtensionFactory`、`SpringExtensionFactory`：\n\n```java\n/**\n * SpiExtensionFactory\n */\npublic class SpiExtensionFactory implements ExtensionFactory {\n\t//SPI机制获取type扩展接口\n    @Override\n    public <T> T getExtension(Class<T> type, String name) {\n        if (type.isInterface() && type.isAnnotationPresent(SPI.class)) {\n            ExtensionLoader<T> loader = ExtensionLoader.getExtensionLoader(type);\n            if (!loader.getSupportedExtensions().isEmpty()) {\n                //获取的是接口的Adaptive实现\n                return loader.getAdaptiveExtension();\n            }\n        }\n        return null;\n    }\n\n}\n\n/**\n * SpringExtensionFactory\n */\npublic class SpringExtensionFactory implements ExtensionFactory {\n    private static final Logger logger = LoggerFactory.getLogger(SpringExtensionFactory.class);\n\n    private static final Set<ApplicationContext> contexts = new ConcurrentHashSet<ApplicationContext>();\n\t//手动将spring容器传入\n    public static void addApplicationContext(ApplicationContext context) {\n        contexts.add(context);\n    }\n\n    public static void removeApplicationContext(ApplicationContext context) {\n        contexts.remove(context);\n    }\n\n    // currently for test purpose\n    public static void clearContexts() {\n        contexts.clear();\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getExtension(Class<T> type, String name) {\n\n        //SPI should be get from SpiExtensionFactory\n        if (type.isInterface() && type.isAnnotationPresent(SPI.class)) {\n            return null;\n        }\n\t\t//遍历spring容器\n        for (ApplicationContext context : contexts) {\n            if (context.containsBean(name)) {\n                Object bean = context.getBean(name);\n                if (type.isInstance(bean)) {\n                    return (T) bean;\n                }\n            }\n        }\n\n        logger.warn(\"No spring extension(bean) named:\" + name + \", try to find an extension(bean) of type \" + type.getName());\n\n        for (ApplicationContext context : contexts) {\n            try {\n                return context.getBean(type);\n            } catch (NoUniqueBeanDefinitionException multiBeanExe) {\n                throw multiBeanExe;\n            } catch (NoSuchBeanDefinitionException noBeanExe) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Error when get spring extension(bean) for type:\" + type.getName(), noBeanExe);\n                }\n            }\n        }\n\n        logger.warn(\"No spring extension(bean) named:\" + name + \", type:\" + type.getName() + \" found, stop get bean.\");\n\n        return null;\n    }\n\n}\n\n```\n\n\n\n#### 第三步，实例化包装类流程分析\n\n代码上面createExtension方法里已贴出，为了更好的理解，我们可以看下Protocol接口的实现中，ProtocolFIlterWrapper和ProtocolListenerWrapper两个包装类，可以看到他们都有参数为Protocol类型的public构造函数，实例化时，把上层的protocol对象作为参数传入构造函数作为内部属性，同时包装类本身会实现Protocol接口，所以这就可以做些类似aop的操作，如ProtocolFilterWrapper：\n\n```java\n/**\n * ListenerProtocol\n */\npublic class ProtocolFilterWrapper implements Protocol {\n\n    private final Protocol protocol;\n\n    public ProtocolFilterWrapper(Protocol protocol) {\n        if (protocol == null) {\n            throw new IllegalArgumentException(\"protocol == null\");\n        }\n        this.protocol = protocol;\n    }\n\t//实例化过滤器链\n    private static <T> Invoker<T> buildInvokerChain(final Invoker<T> invoker, String key, String group) {\n        Invoker<T> last = invoker;\n        List<Filter> filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);\n        if (!filters.isEmpty()) {\n            for (int i = filters.size() - 1; i >= 0; i--) {\n                final Filter filter = filters.get(i);\n                final Invoker<T> next = last;\n                last = new Invoker<T>() {\n\n                    @Override\n                    public Class<T> getInterface() {\n                        return invoker.getInterface();\n                    }\n\n                    @Override\n                    public URL getUrl() {\n                        return invoker.getUrl();\n                    }\n\n                    @Override\n                    public boolean isAvailable() {\n                        return invoker.isAvailable();\n                    }\n\n                    @Override\n                    public Result invoke(Invocation invocation) throws RpcException {\n                        return filter.invoke(next, invocation);\n                    }\n\n                    @Override\n                    public void destroy() {\n                        invoker.destroy();\n                    }\n\n                    @Override\n                    public String toString() {\n                        return invoker.toString();\n                    }\n                };\n            }\n        }\n        return last;\n    }\n\n    @Override\n    public int getDefaultPort() {\n        return protocol.getDefaultPort();\n    }\n\t//暴露过程前执行过滤器链\n    @Override\n    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {\n        if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {\n            return protocol.export(invoker);\n        }\n        return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));\n    }\n\t//调用前执行过滤器链\n    @Override\n    public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n        if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n            return protocol.refer(type, url);\n        }\n        return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);\n    }\n\n    @Override\n    public void destroy() {\n        protocol.destroy();\n    }\n\n}\n```\n\n到此Dubbo SPI机制的三个步骤分析完了。\n\n上面提到的Adaptive类的另一种配置方式，即Adaptive注解配置在方法上，dubbo里，配置Adaptive类有两种方式，一种在就扣实现里，类本身有Adaptive注解，还有一种配置实在接口定义的方法级上有Adaptive注解，这两种方式第一种优先，没有第一种，dubbo自动完成第二种Adaptive类的生成，以Protocol接口为例：\n\n```java\n@SPI(\"dubbo\")\npublic interface Protocol {\n\n    /**\n     * 获取缺省端口，当用户没有配置端口时使用。\n     *\n     * @return 缺省端口\n     */\n    int getDefaultPort();\n\n    /**\n     * 暴露远程服务：<br>\n     * 1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();<br>\n     * 2. export()必须是幂等的，也就是暴露同一个URL的Invoker两次，和暴露一次没有区别。<br>\n     * 3. export()传入的Invoker由框架实现并传入，协议不需要关心。<br>\n     *\n     * @param <T>     服务的类型\n     * @param invoker 服务的执行体\n     * @return exporter 暴露服务的引用，用于取消暴露\n     * @throws RpcException 当暴露服务出错时抛出，比如端口已占用\n     */\n    @Adaptive\n    <T> Exporter<T> export(Invoker<T> invoker) throws RpcException;\n\n    /**\n     * 引用远程服务：<br>\n     * 1. 当用户调用refer()所返回的Invoker对象的invoke()方法时，协议需相应执行同URL远端export()传入的Invoker对象的invoke()方法。<br>\n     * 2. refer()返回的Invoker由协议实现，协议通常需要在此Invoker中发送远程请求。<br>\n     * 3. 当url中有设置check=false时，连接失败不能抛出异常，并内部自动恢复。<br>\n     *\n     * @param <T>  服务的类型\n     * @param type 服务的类型\n     * @param url  远程服务的URL地址\n     * @return invoker 服务的本地代理\n     * @throws RpcException 当连接服务提供方失败时抛出\n     */\n    @Adaptive\n    <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException;\n    \n    /**\n     * 释放协议：<br>\n     * 1. 取消该协议所有已经暴露和引用的服务。<br>\n     * 2. 释放协议所占用的所有资源，比如连接和端口。<br>\n     * 3. 协议在释放后，依然能暴露和引用新的服务。<br>\n     */\n    void destroy();\n\n}\n```\n\n在export和refer方法上所有Adaptive注解，根据上面的分析，我们跟踪一下createAdaptiveExtensionClass方法：\n\n```java\nprivate Class<?> createAdaptiveExtensionClass() {\n    //生成Adaptive；类源码\n    String code = createAdaptiveExtensionClassCode();\n    ClassLoader classLoader = findClassLoader();\n    //通过SPI获取java 编译器\n    org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();\n    //编译源码返回class\n    return compiler.compile(code, classLoader);\n}\n```\n\n`createAdaptiveExtensionClassCode();`方法就是实现字符串拼接, 不同的接口，生成的code会有不同，默认使用javassist对代码进行编译。 这里贴出Protocal生成的Adaptive类的源代码。**体现的思想是，所谓Adaptive方法，其实现，内部的对象类型都是参数（url）和spi机制动态决定的**。\n\n```java\npackage org.apache.dubbo.rpc;\n\nimport org.apache.dubbo.common.extension.ExtensionLoader;\n\npublic class Protocol$Adaptive implements org.apache.dubbo.rpc.Protocol {\n    public org.apache.dubbo.rpc.Invoker refer(java.lang.Class arg0, org.apache.dubbo.common.URL arg1) throws org.apache.dubbo.rpc.RpcException {\n        if (arg1 == null) throw new IllegalArgumentException(\"url == null\");\n        org.apache.dubbo.common.URL url = arg1;\n        String extName = (url.getProtocol() == null ? \"dubbo\" : url.getProtocol());\n        if (extName == null)\n            throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n        return extension.refer(arg0, arg1);\n    }\n\n    public org.apache.dubbo.rpc.Exporter export(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException {\n        if (arg0 == null) throw new IllegalArgumentException(\"org.apache.dubbo.rpc.Invoker argument == null\");\n        if (arg0.getUrl() == null)\n            throw new IllegalArgumentException(\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\");\n        org.apache.dubbo.common.URL url = arg0.getUrl();\n        String extName = (url.getProtocol() == null ? \"dubbo\" : url.getProtocol());\n        if (extName == null)\n            throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n        return extension.export(arg0);\n    }\n\n    public void destroy() {\n        throw new UnsupportedOperationException(\"method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!\");\n    }\n\n    public int getDefaultPort() {\n        throw new UnsupportedOperationException(\"method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!\");\n    }\n}\n```\n\n","slug":"dubbo-spi-analysis","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn4z001ezjiae75kqjnp","content":"<p>Dubbo是微内核架构，还是开闭原则的应用，把核心流程架构固定，但是流程的各个节点对重新改进是开放的。具体的实现机制就是SPI(Service Provider Interface)机制，Dubbo基于Java SPI机制（不了解Java SPI机制的可以参考这篇文章<a href=\"https://shuaijunlan.github.io/2018/08/03/java-spi-introduction/\">《深入理解Java SPI机制》</a>），在其基础上做了改进和扩展。</p>\n<p>根据SPI规范，接口由框架定义，具体实现可以由不同的厂商提供，在Dubbo jar包可以发现在<code>/META-INF/dubbo/internal</code>目录下有许多接口命名的文件，文件里面的内容就是文件名代表的接口的各种实现类，这就是Dubbo SPI机制的配置基础，以<code>org.apache.dubbo.rpc.Protocol</code>文件为例，内容如下（dubbo-2.7.0-SNAPSHOT 版本）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class=\"line\">listener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br><span class=\"line\">mock=org.apache.dubbo.rpc.support.MockProtocol</span><br><span class=\"line\">dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class=\"line\">injvm=org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol</span><br><span class=\"line\">rmi=org.apache.dubbo.rpc.protocol.rmi.RmiProtocol</span><br><span class=\"line\">hessian=org.apache.dubbo.rpc.protocol.hessian.HessianProtocol</span><br><span class=\"line\">http=org.apache.dubbo.rpc.protocol.http.HttpProtocol</span><br><span class=\"line\"></span><br><span class=\"line\">org.apache.dubbo.rpc.protocol.webservice.WebServiceProtocol</span><br><span class=\"line\">thrift=org.apache.dubbo.rpc.protocol.thrift.ThriftProtocol</span><br><span class=\"line\">memcached=org.apache.dubbo.rpc.protocol.memcached.MemcachedProtocol</span><br><span class=\"line\">redis=org.apache.dubbo.rpc.protocol.redis.RedisProtocol</span><br><span class=\"line\">rest=org.apache.dubbo.rpc.protocol.rest.RestProtocol</span><br><span class=\"line\">registry=org.apache.dubbo.registry.integration.RegistryProtocol</span><br><span class=\"line\">qos=org.apache.dubbo.qos.protocol.QosProtocolWrapper</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>在Dubbo SPI机制中，<code>org.apache.dubbo.rpc.Protocol</code>接口由以上那么多的具体实现，<code>=</code>前面是扩展名，后面是扩展类的实现；</p>\n<p>SPI的启动的入口类是ExtensionLoader，这个类没定义public构造函数，只有一个privae的，而且public的静态方法也只有一个<code>public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type)</code>，这个方法也是SPI的入口方法，<strong>若想获取某个接口类型的扩展，先必须获取其对应的ExtensionLoader</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//私有构造器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ExtensionLoader</span><span class=\"params\">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">    <span class=\"comment\">//objectFactory 对象 ，ExtensionFactory本身也是spi的</span></span><br><span class=\"line\">    <span class=\"comment\">//如果是ExtensionFactory本身的ExtensionLoader实例，objectFactory字段为null</span></span><br><span class=\"line\">    <span class=\"comment\">//否则，是ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()；关于getAdaptiveExtension()方法返回的实例，后面会看到</span></span><br><span class=\"line\">    objectFactory = (type == ExtensionFactory.class ? <span class=\"keyword\">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">withExtensionAnnotation</span><span class=\"params\">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> type.isAnnotationPresent(SPI.class);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取某个接口的ExtensionLoader</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">ExtensionLoader&lt;T&gt; <span class=\"title\">getExtensionLoader</span><span class=\"params\">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Extension type == null\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!type.isInterface()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Extension type(\"</span> + type + <span class=\"string\">\") is not interface!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断接口是否有SPI注解，Dubbo里所有需要SPI扩展的接口都需要添加@SPI注解</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Extension type(\"</span> + type +</span><br><span class=\"line\">                                           <span class=\"string\">\") is not extension, because WITHOUT @\"</span> + SPI.class.getSimpleName() + <span class=\"string\">\" Annotation!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//判断是否已经存在</span></span><br><span class=\"line\">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loader == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//利用私有构造器创建ExtensionLoader，并且放入缓存</span></span><br><span class=\"line\">        EXTENSION_LOADERS.putIfAbsent(type, <span class=\"keyword\">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class=\"line\">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loader;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建了ExtensionLoader实例，我们就可以通过SPI机制获取想要的接口扩展类实例了，下面就以<code>org.apache.dubbo.rpc.Protocol</code>接口获取名为Dubbo的扩展实例为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(DubboProtocol.NAME);</span><br></pre></td></tr></table></figure>\n<p>跟进getExtension方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Find the extension with the given name. If the specified name is not found, then &#123;<span class=\"doctag\">@link</span> IllegalStateException&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * will be thrown.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getExtension</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span> || name.length() == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Extension name == null\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//获取默认扩展</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"true\"</span>.equals(name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getDefaultExtension();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//指定扩展实例，判断是否已经缓存</span></span><br><span class=\"line\">    Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (holder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建Holder实例，放入缓存</span></span><br><span class=\"line\">        cachedInstances.putIfAbsent(name, <span class=\"keyword\">new</span> Holder&lt;Object&gt;());</span><br><span class=\"line\">        holder = cachedInstances.get(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object instance = holder.get();</span><br><span class=\"line\">    <span class=\"comment\">//加锁技巧，保证线程安全</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (holder) &#123;</span><br><span class=\"line\">            instance = holder.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//根据扩展名，获取具体扩展实例，放入缓存holder中</span></span><br><span class=\"line\">                instance = createExtension(name);</span><br><span class=\"line\">                holder.set(instance);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//返回具体的扩展实例</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有两个获取扩展的相关方法，一个是<code>getDefaultExtension()</code>获取默认扩展，另一个是<code>createExtension(name)</code>根据扩展名获取扩展实例，下面分析这两个方法的具体实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个方法，总结起来有3个步骤，</span></span><br><span class=\"line\"><span class=\"comment\">     * 1，通过扩展名，找到扩展实现类，这过程可能触发spi文件加载解析</span></span><br><span class=\"line\"><span class=\"comment\">     * 2，利用反射机制，获取扩展类实例，并完成依赖注入</span></span><br><span class=\"line\"><span class=\"comment\">     * 3，如果接口扩展有包装类，实例化包装类</span></span><br><span class=\"line\"><span class=\"comment\">     * 最后返回经由以上3步流程后，产生的对象。</span></span><br><span class=\"line\"><span class=\"comment\">     * 这3步，前一步都是后一步的基础，要顺序完成</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">createExtension</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//根据扩展名，获取扩展实现类的class（完成第1步）</span></span><br><span class=\"line\">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> findException(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//从缓存里，获取实现类的实例</span></span><br><span class=\"line\">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//利用newInstance()反射，构造类实例，病放入缓存</span></span><br><span class=\"line\">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class=\"line\">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//完成接口实现类依赖注入，依赖组件先从SPI机制构造查找，再从Spring容器查找（完成第2步）</span></span><br><span class=\"line\">        injectExtension(instance);</span><br><span class=\"line\">        <span class=\"comment\">//如果这接口的实现，还有wrapper类，（有接口类型的构造函数）</span></span><br><span class=\"line\">        <span class=\"comment\">//还有把当前实例instance，注入到包装类，包装类有多个，依次层层，循环构造注入</span></span><br><span class=\"line\">        <span class=\"comment\">//最后返回的是，最后一个包装类实例，这也是dubbo的aop实现机制（完成第3步）</span></span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wrapperClasses != <span class=\"keyword\">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class=\"line\">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Extension instance(name: \"</span> + name + <span class=\"string\">\", class: \"</span> +</span><br><span class=\"line\">                                        type + <span class=\"string\">\")  could not be instantiated: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第一步，加载扩展实现类\"><a href=\"#第一步，加载扩展实现类\" class=\"headerlink\" title=\"第一步，加载扩展实现类\"></a>第一步，加载扩展实现类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取某个接口所有实现，按照扩展名：扩展实现，存储在map中</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class=\"line\">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (classes == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (cachedClasses) &#123;</span><br><span class=\"line\">            classes = cachedClasses.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (classes == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                classes = loadExtensionClasses();</span><br><span class=\"line\">                cachedClasses.set(classes);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> classes;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// synchronized in getExtensionClasses</span></span><br><span class=\"line\"><span class=\"comment\">//加载类路径中的spi配置文件，构造cachedClasses</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);</span><br><span class=\"line\">    <span class=\"comment\">//获取spi 注解  SPI(value=\"xxx\")，默认实现xxx</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (defaultAnnotation != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        String value = defaultAnnotation.value();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((value = value.trim()).length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            String[] names = NAME_SEPARATOR.split(value);</span><br><span class=\"line\">            <span class=\"comment\">//默认实现只能有一个</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (names.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"more than 1 default extension name on extension \"</span> + type.getName()</span><br><span class=\"line\">                                                + <span class=\"string\">\": \"</span> + Arrays.toString(names));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//获取spi默认实现值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (names.length == <span class=\"number\">1</span>) cachedDefaultName = names[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class=\"keyword\">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//读取三个目录下的spi 配置文件;/META-INF/dubbo/internal, /META-INF/dubbo, /META-INF/services</span></span><br><span class=\"line\">    <span class=\"comment\">//构造 扩展名:实现类 map</span></span><br><span class=\"line\">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());</span><br><span class=\"line\">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(<span class=\"string\">\"org.apache\"</span>, <span class=\"string\">\"com.alibaba\"</span>));</span><br><span class=\"line\">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());</span><br><span class=\"line\">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(<span class=\"string\">\"org.apache\"</span>, <span class=\"string\">\"com.alibaba\"</span>));</span><br><span class=\"line\">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());</span><br><span class=\"line\">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(<span class=\"string\">\"org.apache\"</span>, <span class=\"string\">\"com.alibaba\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extensionClasses;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadDirectory</span><span class=\"params\">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir, String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//拼接接口名作为文件名，例如：/META-INF/dubbo/internal/org.apache.dubbo.rpc.Protocol</span></span><br><span class=\"line\">    String fileName = dir + type;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Enumeration&lt;java.net.URL&gt; urls;</span><br><span class=\"line\">        <span class=\"comment\">//获取加载ClassLoader类的类加载器</span></span><br><span class=\"line\">        ClassLoader classLoader = findClassLoader();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (classLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            urls = classLoader.getResources(fileName);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            urls = ClassLoader.getSystemResources(fileName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (urls != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (urls.hasMoreElements()) &#123;</span><br><span class=\"line\">                java.net.URL resourceURL = urls.nextElement();</span><br><span class=\"line\">                <span class=\"comment\">//加载资源</span></span><br><span class=\"line\">                loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        logger.error(<span class=\"string\">\"Exception when load extension class(interface: \"</span> +</span><br><span class=\"line\">                     type + <span class=\"string\">\", description file: \"</span> + fileName + <span class=\"string\">\").\"</span>, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们继续来看loadResource()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadResource</span><span class=\"params\">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        BufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(resourceURL.openStream(), <span class=\"string\">\"utf-8\"</span>));</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String line;</span><br><span class=\"line\">            <span class=\"comment\">//读取文件每一行</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((line = reader.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ci = line.indexOf(<span class=\"string\">'#'</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ci &gt;= <span class=\"number\">0</span>) line = line.substring(<span class=\"number\">0</span>, ci);</span><br><span class=\"line\">                line = line.trim();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (line.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        String name = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> i = line.indexOf(<span class=\"string\">'='</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//name 是扩展名</span></span><br><span class=\"line\">                            name = line.substring(<span class=\"number\">0</span>, i).trim();</span><br><span class=\"line\">                            <span class=\"comment\">//扩展实现类全名</span></span><br><span class=\"line\">                            line = line.substring(i + <span class=\"number\">1</span>).trim();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (line.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//根据line加载类</span></span><br><span class=\"line\">                            loadClass(extensionClasses, resourceURL, Class.forName(line, <span class=\"keyword\">true</span>, classLoader), name);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                        IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Failed to load extension class(interface: \"</span> + type + <span class=\"string\">\", class line: \"</span> + line + <span class=\"string\">\") in \"</span> + resourceURL + <span class=\"string\">\", cause: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">                        exceptions.put(line, e);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            reader.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        logger.error(<span class=\"string\">\"Exception when load extension class(interface: \"</span> +</span><br><span class=\"line\">                     type + <span class=\"string\">\", class file: \"</span> + resourceURL + <span class=\"string\">\") in \"</span> + resourceURL, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadClass</span><span class=\"params\">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class=\"keyword\">throws</span> NoSuchMethodException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//盘判断实现类是否实现了type接口</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Error when load extension class(interface: \"</span> +</span><br><span class=\"line\">                                        type + <span class=\"string\">\", class line: \"</span> + clazz.getName() + <span class=\"string\">\"), class \"</span></span><br><span class=\"line\">                                        + clazz.getName() + <span class=\"string\">\"is not subtype of interface.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断实现类是否有Adaptive注解</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cachedAdaptiveClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//赋值</span></span><br><span class=\"line\">            cachedAdaptiveClass = clazz;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//一个接口的SPI实现，只能有一个实现类是Adaptive的</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"More than 1 adaptive class found: \"</span></span><br><span class=\"line\">                                            + cachedAdaptiveClass.getClass().getName()</span><br><span class=\"line\">                                            + <span class=\"string\">\", \"</span> + clazz.getClass().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isWrapperClass(clazz)) &#123; <span class=\"comment\">//判断是否为包装类</span></span><br><span class=\"line\">        <span class=\"comment\">//一个接口的SPI实现可以有多个包装类</span></span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wrappers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            cachedWrapperClasses = <span class=\"keyword\">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class=\"line\">            wrappers = cachedWrapperClasses;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        wrappers.add(clazz);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        clazz.getConstructor();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span> || name.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            name = findAnnotationName(clazz);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (name.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"No such extension name for the class \"</span> + clazz.getName() + <span class=\"string\">\" in the config \"</span> + resourceURL);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (names != <span class=\"keyword\">null</span> &amp;&amp; names.length &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">//？？？</span></span><br><span class=\"line\">            <span class=\"comment\">//实现类是否有Active注解</span></span><br><span class=\"line\">            Activate activate = clazz.getAnnotation(Activate.class);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (activate != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果有，加入cachedActivates map（扩展名：实现类class）</span></span><br><span class=\"line\">                cachedActivates.put(names[<span class=\"number\">0</span>], activate);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// support com.alibaba.dubbo.common.extension.Activate</span></span><br><span class=\"line\">                com.alibaba.dubbo.common.extension.Activate oldActivate = clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.class);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldActivate != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    cachedActivates.put(names[<span class=\"number\">0</span>], oldActivate);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String n : names) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//实现类:扩展名 map 放入缓存</span></span><br><span class=\"line\">                    cachedNames.put(clazz, n);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//Adaptive 和wapper类都不在extensionClasses里!!!</span></span><br><span class=\"line\">                    extensionClasses.put(n, clazz);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c != clazz) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate extension \"</span> + type.getName() + <span class=\"string\">\" name \"</span> + n + <span class=\"string\">\" on \"</span> + c.getName() + <span class=\"string\">\" and \"</span> + clazz.getName());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isWrapperClass</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//实现类里，是否有，参数是接口类型的（比如 com.alibaba.dubbo.rpc.Protocol类型，并且1个参数）的构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">//表示它是个接口包装类</span></span><br><span class=\"line\">        clazz.getConstructor(type);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步，依赖注入流程分析\"><a href=\"#第二步，依赖注入流程分析\" class=\"headerlink\" title=\"第二步，依赖注入流程分析\"></a>第二步，依赖注入流程分析</h4><p>首先来看injectExtension(T instance)的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实例对象，字段依赖注入。字段类型可以是spi 接口类型，或者是Spring bean 类型</span></span><br><span class=\"line\"><span class=\"comment\">// 依赖注入的字段对象，是通过ExtensionLoader的objectFactory属性完成的，</span></span><br><span class=\"line\"><span class=\"comment\">// objectFacotry 会根据先后通过spi机制和从spring 容器里获取属性对象并注入。</span></span><br><span class=\"line\"><span class=\"comment\">// objectFactory 是在ExtensionLoader私有构造函数中赋值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">injectExtension</span><span class=\"params\">(T instance)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (objectFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (method.getName().startsWith(<span class=\"string\">\"set\"</span>)</span><br><span class=\"line\">                    &amp;&amp; method.getParameterTypes().length == <span class=\"number\">1</span></span><br><span class=\"line\">                    &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123; <span class=\"comment\">//获取所有public类型，并且只有一个参数的以set开头的方法</span></span><br><span class=\"line\">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class=\"number\">0</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//根据驼峰命名法，根据方法名，构造set方法要赋值的属性名</span></span><br><span class=\"line\">                        String property = method.getName().length() &gt; <span class=\"number\">3</span> ? method.getName().substring(<span class=\"number\">3</span>, <span class=\"number\">4</span>).toLowerCase() + method.getName().substring(<span class=\"number\">4</span>) : <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">                        <span class=\"comment\">//通过getExtension的方法获取属性对象，所以还要看getExtension的实现。</span></span><br><span class=\"line\">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (object != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//利用反射机制，赋值对象属性</span></span><br><span class=\"line\">                            method.invoke(instance, object);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        logger.error(<span class=\"string\">\"fail to inject via method \"</span> + method.getName()</span><br><span class=\"line\">                                     + <span class=\"string\">\" of interface \"</span> + type.getName() + <span class=\"string\">\": \"</span> + e.getMessage(), e);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        logger.error(e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看下ExtensionLoader定义的私有构造函数，可以看到objectFactory是通过<code>ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()</code>赋值的，它是ExtensionFactory接口的Adaptive扩展实现，看下getAdaptiveExtension()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取一个SPI接口的Adaptive(实现类有Adaptive注解的)类型扩展实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getAdaptiveExtension</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//先取缓存</span></span><br><span class=\"line\">    Object instance = cachedAdaptiveInstance.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (createAdaptiveInstanceError == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class=\"line\">                instance = cachedAdaptiveInstance.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//缓存不在，就创建Adaptive扩展实例</span></span><br><span class=\"line\">                        instance = createAdaptiveExtension();</span><br><span class=\"line\">                        <span class=\"comment\">//对象放入缓存中</span></span><br><span class=\"line\">                        cachedAdaptiveInstance.set(instance);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                        createAdaptiveInstanceError = t;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"fail to create adaptive instance: \"</span> + t.toString(), t);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"fail to create adaptive instance: \"</span> + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">createAdaptiveExtension</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取AdaptiveExtensionClass的class 通过反射获取实例，同时要走依赖注入流程</span></span><br><span class=\"line\">        <span class=\"comment\">//AdaptiveExtensionClass 已在spi 文件解析时赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Can not create adaptive extension \"</span> + type + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果有必要，触发spi加载流程，</span></span><br><span class=\"line\">\t<span class=\"comment\">//找到类上有Adaptive注解的class,赋值给cachedAdaptiveClass</span></span><br><span class=\"line\">    getExtensionClasses();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cachedAdaptiveClass != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cachedAdaptiveClass;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//Adaptive注解不在扩展实现类上，而是在待扩展接口方法上</span></span><br><span class=\"line\">\t<span class=\"comment\">//这种情况，就是dubbo动态生成生成java类字串，动态编译生成想要的class</span></span><br><span class=\"line\">\t<span class=\"comment\">//这个下面再分析下</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>目前ExtensionFactory接口3个实现类，只有AdaptiveExtensionFactory类是Adaptive的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * AdaptiveExtensionFactory</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Adaptive</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdaptiveExtensionFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ExtensionFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class=\"line\">\t<span class=\"comment\">//无参构造函数中，把其他实现类实例加入到factories list中</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AdaptiveExtensionFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);</span><br><span class=\"line\">        List&lt;ExtensionFactory&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;ExtensionFactory&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//getSupportedExtensions()返回的是 非包装类扩展，非Adaptive扩展，防止无限循环</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : loader.getSupportedExtensions()) &#123;</span><br><span class=\"line\">            list.add(loader.getExtension(name));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        factories = Collections.unmodifiableList(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getExtension</span><span class=\"params\">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class=\"line\">            T extension = factory.getExtension(type, name);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (extension != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> extension;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外两个实现类是<code>SpiExtensionFactory</code>、<code>SpringExtensionFactory</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SpiExtensionFactory</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpiExtensionFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ExtensionFactory</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//SPI机制获取type扩展接口</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getExtension</span><span class=\"params\">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class=\"line\">            ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!loader.getSupportedExtensions().isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//获取的是接口的Adaptive实现</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> loader.getAdaptiveExtension();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SpringExtensionFactory</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringExtensionFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ExtensionFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(SpringExtensionFactory.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Set&lt;ApplicationContext&gt; contexts = <span class=\"keyword\">new</span> ConcurrentHashSet&lt;ApplicationContext&gt;();</span><br><span class=\"line\">\t<span class=\"comment\">//手动将spring容器传入</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">addApplicationContext</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">        contexts.add(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">removeApplicationContext</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">        contexts.remove(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// currently for test purpose</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clearContexts</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        contexts.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getExtension</span><span class=\"params\">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//SPI should be get from SpiExtensionFactory</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历spring容器</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ApplicationContext context : contexts) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (context.containsBean(name)) &#123;</span><br><span class=\"line\">                Object bean = context.getBean(name);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (type.isInstance(bean)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> (T) bean;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        logger.warn(<span class=\"string\">\"No spring extension(bean) named:\"</span> + name + <span class=\"string\">\", try to find an extension(bean) of type \"</span> + type.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ApplicationContext context : contexts) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> context.getBean(type);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoUniqueBeanDefinitionException multiBeanExe) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> multiBeanExe;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoSuchBeanDefinitionException noBeanExe) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">                    logger.debug(<span class=\"string\">\"Error when get spring extension(bean) for type:\"</span> + type.getName(), noBeanExe);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        logger.warn(<span class=\"string\">\"No spring extension(bean) named:\"</span> + name + <span class=\"string\">\", type:\"</span> + type.getName() + <span class=\"string\">\" found, stop get bean.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三步，实例化包装类流程分析\"><a href=\"#第三步，实例化包装类流程分析\" class=\"headerlink\" title=\"第三步，实例化包装类流程分析\"></a>第三步，实例化包装类流程分析</h4><p>代码上面createExtension方法里已贴出，为了更好的理解，我们可以看下Protocol接口的实现中，ProtocolFIlterWrapper和ProtocolListenerWrapper两个包装类，可以看到他们都有参数为Protocol类型的public构造函数，实例化时，把上层的protocol对象作为参数传入构造函数作为内部属性，同时包装类本身会实现Protocol接口，所以这就可以做些类似aop的操作，如ProtocolFilterWrapper：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ListenerProtocol</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProtocolFilterWrapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">Protocol</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Protocol protocol;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProtocolFilterWrapper</span><span class=\"params\">(Protocol protocol)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (protocol == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"protocol == null\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.protocol = protocol;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//实例化过滤器链</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">buildInvokerChain</span><span class=\"params\">(<span class=\"keyword\">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class=\"line\">        Invoker&lt;T&gt; last = invoker;</span><br><span class=\"line\">        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!filters.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = filters.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Filter filter = filters.get(i);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Invoker&lt;T&gt; next = last;</span><br><span class=\"line\">                last = <span class=\"keyword\">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Class&lt;T&gt; <span class=\"title\">getInterface</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> invoker.getInterface();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> URL <span class=\"title\">getUrl</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> invoker.getUrl();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> invoker.isAvailable();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> filter.invoke(next, invocation);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        invoker.destroy();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> invoker.toString();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getDefaultPort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> protocol.getDefaultPort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//暴露过程前执行过滤器链</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> protocol.export(invoker);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//调用前执行过滤器链</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> protocol.refer(type, url);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        protocol.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此Dubbo SPI机制的三个步骤分析完了。</p>\n<p>上面提到的Adaptive类的另一种配置方式，即Adaptive注解配置在方法上，dubbo里，配置Adaptive类有两种方式，一种在就扣实现里，类本身有Adaptive注解，还有一种配置实在接口定义的方法级上有Adaptive注解，这两种方式第一种优先，没有第一种，dubbo自动完成第二种Adaptive类的生成，以Protocol接口为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SPI</span>(<span class=\"string\">\"dubbo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Protocol</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取缺省端口，当用户没有配置端口时使用。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 缺省端口</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getDefaultPort</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 暴露远程服务：&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. export()必须是幂等的，也就是暴露同一个URL的Invoker两次，和暴露一次没有区别。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 3. export()传入的Invoker由框架实现并传入，协议不需要关心。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt;     服务的类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> invoker 服务的执行体</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> exporter 暴露服务的引用，用于取消暴露</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> RpcException 当暴露服务出错时抛出，比如端口已占用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Adaptive</span></span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"keyword\">throws</span> RpcException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 引用远程服务：&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. 当用户调用refer()所返回的Invoker对象的invoke()方法时，协议需相应执行同URL远端export()传入的Invoker对象的invoke()方法。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. refer()返回的Invoker由协议实现，协议通常需要在此Invoker中发送远程请求。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 3. 当url中有设置check=false时，连接失败不能抛出异常，并内部自动恢复。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt;  服务的类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> type 服务的类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> url  远程服务的URL地址</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> invoker 服务的本地代理</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> RpcException 当连接服务提供方失败时抛出</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Adaptive</span></span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 释放协议：&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. 取消该协议所有已经暴露和引用的服务。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. 释放协议所占用的所有资源，比如连接和端口。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 3. 协议在释放后，依然能暴露和引用新的服务。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在export和refer方法上所有Adaptive注解，根据上面的分析，我们跟踪一下createAdaptiveExtensionClass方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//生成Adaptive；类源码</span></span><br><span class=\"line\">    String code = createAdaptiveExtensionClassCode();</span><br><span class=\"line\">    ClassLoader classLoader = findClassLoader();</span><br><span class=\"line\">    <span class=\"comment\">//通过SPI获取java 编译器</span></span><br><span class=\"line\">    org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class=\"line\">    <span class=\"comment\">//编译源码返回class</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> compiler.compile(code, classLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>createAdaptiveExtensionClassCode();</code>方法就是实现字符串拼接, 不同的接口，生成的code会有不同，默认使用javassist对代码进行编译。 这里贴出Protocal生成的Adaptive类的源代码。<strong>体现的思想是，所谓Adaptive方法，其实现，内部的对象类型都是参数（url）和spi机制动态决定的</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.apache.dubbo.rpc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Protocol</span>$<span class=\"title\">Adaptive</span> <span class=\"keyword\">implements</span> <span class=\"title\">org</span>.<span class=\"title\">apache</span>.<span class=\"title\">dubbo</span>.<span class=\"title\">rpc</span>.<span class=\"title\">Protocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Invoker <span class=\"title\">refer</span><span class=\"params\">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.common.URL url = arg1;</span><br><span class=\"line\">        String extName = (url.getProtocol() == <span class=\"keyword\">null</span> ? <span class=\"string\">\"dubbo\"</span> : url.getProtocol());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([protocol])\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension.refer(arg0, arg1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Exporter <span class=\"title\">export</span><span class=\"params\">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.Invoker argument == null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0.getUrl() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class=\"line\">        String extName = (url.getProtocol() == <span class=\"keyword\">null</span> ? <span class=\"string\">\"dubbo\"</span> : url.getProtocol());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([protocol])\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension.export(arg0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getDefaultPort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Dubbo是微内核架构，还是开闭原则的应用，把核心流程架构固定，但是流程的各个节点对重新改进是开放的。具体的实现机制就是SPI(Service Provider Interface)机制，Dubbo基于Java SPI机制（不了解Java SPI机制的可以参考这篇文章<a href=\"https://shuaijunlan.github.io/2018/08/03/java-spi-introduction/\">《深入理解Java SPI机制》</a>），在其基础上做了改进和扩展。</p>\n<p>根据SPI规范，接口由框架定义，具体实现可以由不同的厂商提供，在Dubbo jar包可以发现在<code>/META-INF/dubbo/internal</code>目录下有许多接口命名的文件，文件里面的内容就是文件名代表的接口的各种实现类，这就是Dubbo SPI机制的配置基础，以<code>org.apache.dubbo.rpc.Protocol</code>文件为例，内容如下（dubbo-2.7.0-SNAPSHOT 版本）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class=\"line\">listener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br><span class=\"line\">mock=org.apache.dubbo.rpc.support.MockProtocol</span><br><span class=\"line\">dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class=\"line\">injvm=org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol</span><br><span class=\"line\">rmi=org.apache.dubbo.rpc.protocol.rmi.RmiProtocol</span><br><span class=\"line\">hessian=org.apache.dubbo.rpc.protocol.hessian.HessianProtocol</span><br><span class=\"line\">http=org.apache.dubbo.rpc.protocol.http.HttpProtocol</span><br><span class=\"line\"></span><br><span class=\"line\">org.apache.dubbo.rpc.protocol.webservice.WebServiceProtocol</span><br><span class=\"line\">thrift=org.apache.dubbo.rpc.protocol.thrift.ThriftProtocol</span><br><span class=\"line\">memcached=org.apache.dubbo.rpc.protocol.memcached.MemcachedProtocol</span><br><span class=\"line\">redis=org.apache.dubbo.rpc.protocol.redis.RedisProtocol</span><br><span class=\"line\">rest=org.apache.dubbo.rpc.protocol.rest.RestProtocol</span><br><span class=\"line\">registry=org.apache.dubbo.registry.integration.RegistryProtocol</span><br><span class=\"line\">qos=org.apache.dubbo.qos.protocol.QosProtocolWrapper</span><br></pre></td></tr></table></figure>","more":"<p>在Dubbo SPI机制中，<code>org.apache.dubbo.rpc.Protocol</code>接口由以上那么多的具体实现，<code>=</code>前面是扩展名，后面是扩展类的实现；</p>\n<p>SPI的启动的入口类是ExtensionLoader，这个类没定义public构造函数，只有一个privae的，而且public的静态方法也只有一个<code>public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type)</code>，这个方法也是SPI的入口方法，<strong>若想获取某个接口类型的扩展，先必须获取其对应的ExtensionLoader</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//私有构造器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ExtensionLoader</span><span class=\"params\">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.type = type;</span><br><span class=\"line\">    <span class=\"comment\">//objectFactory 对象 ，ExtensionFactory本身也是spi的</span></span><br><span class=\"line\">    <span class=\"comment\">//如果是ExtensionFactory本身的ExtensionLoader实例，objectFactory字段为null</span></span><br><span class=\"line\">    <span class=\"comment\">//否则，是ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()；关于getAdaptiveExtension()方法返回的实例，后面会看到</span></span><br><span class=\"line\">    objectFactory = (type == ExtensionFactory.class ? <span class=\"keyword\">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">withExtensionAnnotation</span><span class=\"params\">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> type.isAnnotationPresent(SPI.class);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取某个接口的ExtensionLoader</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">ExtensionLoader&lt;T&gt; <span class=\"title\">getExtensionLoader</span><span class=\"params\">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Extension type == null\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!type.isInterface()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Extension type(\"</span> + type + <span class=\"string\">\") is not interface!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断接口是否有SPI注解，Dubbo里所有需要SPI扩展的接口都需要添加@SPI注解</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Extension type(\"</span> + type +</span><br><span class=\"line\">                                           <span class=\"string\">\") is not extension, because WITHOUT @\"</span> + SPI.class.getSimpleName() + <span class=\"string\">\" Annotation!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//判断是否已经存在</span></span><br><span class=\"line\">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loader == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//利用私有构造器创建ExtensionLoader，并且放入缓存</span></span><br><span class=\"line\">        EXTENSION_LOADERS.putIfAbsent(type, <span class=\"keyword\">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class=\"line\">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loader;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建了ExtensionLoader实例，我们就可以通过SPI机制获取想要的接口扩展类实例了，下面就以<code>org.apache.dubbo.rpc.Protocol</code>接口获取名为Dubbo的扩展实例为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(DubboProtocol.NAME);</span><br></pre></td></tr></table></figure>\n<p>跟进getExtension方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Find the extension with the given name. If the specified name is not found, then &#123;<span class=\"doctag\">@link</span> IllegalStateException&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * will be thrown.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getExtension</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span> || name.length() == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Extension name == null\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//获取默认扩展</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"true\"</span>.equals(name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getDefaultExtension();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//指定扩展实例，判断是否已经缓存</span></span><br><span class=\"line\">    Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (holder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建Holder实例，放入缓存</span></span><br><span class=\"line\">        cachedInstances.putIfAbsent(name, <span class=\"keyword\">new</span> Holder&lt;Object&gt;());</span><br><span class=\"line\">        holder = cachedInstances.get(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object instance = holder.get();</span><br><span class=\"line\">    <span class=\"comment\">//加锁技巧，保证线程安全</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (holder) &#123;</span><br><span class=\"line\">            instance = holder.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//根据扩展名，获取具体扩展实例，放入缓存holder中</span></span><br><span class=\"line\">                instance = createExtension(name);</span><br><span class=\"line\">                holder.set(instance);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//返回具体的扩展实例</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有两个获取扩展的相关方法，一个是<code>getDefaultExtension()</code>获取默认扩展，另一个是<code>createExtension(name)</code>根据扩展名获取扩展实例，下面分析这两个方法的具体实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***</span></span><br><span class=\"line\"><span class=\"comment\">     * 这个方法，总结起来有3个步骤，</span></span><br><span class=\"line\"><span class=\"comment\">     * 1，通过扩展名，找到扩展实现类，这过程可能触发spi文件加载解析</span></span><br><span class=\"line\"><span class=\"comment\">     * 2，利用反射机制，获取扩展类实例，并完成依赖注入</span></span><br><span class=\"line\"><span class=\"comment\">     * 3，如果接口扩展有包装类，实例化包装类</span></span><br><span class=\"line\"><span class=\"comment\">     * 最后返回经由以上3步流程后，产生的对象。</span></span><br><span class=\"line\"><span class=\"comment\">     * 这3步，前一步都是后一步的基础，要顺序完成</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">createExtension</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//根据扩展名，获取扩展实现类的class（完成第1步）</span></span><br><span class=\"line\">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> findException(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//从缓存里，获取实现类的实例</span></span><br><span class=\"line\">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//利用newInstance()反射，构造类实例，病放入缓存</span></span><br><span class=\"line\">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class=\"line\">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//完成接口实现类依赖注入，依赖组件先从SPI机制构造查找，再从Spring容器查找（完成第2步）</span></span><br><span class=\"line\">        injectExtension(instance);</span><br><span class=\"line\">        <span class=\"comment\">//如果这接口的实现，还有wrapper类，（有接口类型的构造函数）</span></span><br><span class=\"line\">        <span class=\"comment\">//还有把当前实例instance，注入到包装类，包装类有多个，依次层层，循环构造注入</span></span><br><span class=\"line\">        <span class=\"comment\">//最后返回的是，最后一个包装类实例，这也是dubbo的aop实现机制（完成第3步）</span></span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wrapperClasses != <span class=\"keyword\">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class=\"line\">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Extension instance(name: \"</span> + name + <span class=\"string\">\", class: \"</span> +</span><br><span class=\"line\">                                        type + <span class=\"string\">\")  could not be instantiated: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第一步，加载扩展实现类\"><a href=\"#第一步，加载扩展实现类\" class=\"headerlink\" title=\"第一步，加载扩展实现类\"></a>第一步，加载扩展实现类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取某个接口所有实现，按照扩展名：扩展实现，存储在map中</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class=\"line\">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (classes == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (cachedClasses) &#123;</span><br><span class=\"line\">            classes = cachedClasses.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (classes == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                classes = loadExtensionClasses();</span><br><span class=\"line\">                cachedClasses.set(classes);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> classes;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// synchronized in getExtensionClasses</span></span><br><span class=\"line\"><span class=\"comment\">//加载类路径中的spi配置文件，构造cachedClasses</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);</span><br><span class=\"line\">    <span class=\"comment\">//获取spi 注解  SPI(value=\"xxx\")，默认实现xxx</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (defaultAnnotation != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        String value = defaultAnnotation.value();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((value = value.trim()).length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            String[] names = NAME_SEPARATOR.split(value);</span><br><span class=\"line\">            <span class=\"comment\">//默认实现只能有一个</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (names.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"more than 1 default extension name on extension \"</span> + type.getName()</span><br><span class=\"line\">                                                + <span class=\"string\">\": \"</span> + Arrays.toString(names));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//获取spi默认实现值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (names.length == <span class=\"number\">1</span>) cachedDefaultName = names[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class=\"keyword\">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//读取三个目录下的spi 配置文件;/META-INF/dubbo/internal, /META-INF/dubbo, /META-INF/services</span></span><br><span class=\"line\">    <span class=\"comment\">//构造 扩展名:实现类 map</span></span><br><span class=\"line\">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());</span><br><span class=\"line\">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(<span class=\"string\">\"org.apache\"</span>, <span class=\"string\">\"com.alibaba\"</span>));</span><br><span class=\"line\">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());</span><br><span class=\"line\">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(<span class=\"string\">\"org.apache\"</span>, <span class=\"string\">\"com.alibaba\"</span>));</span><br><span class=\"line\">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());</span><br><span class=\"line\">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(<span class=\"string\">\"org.apache\"</span>, <span class=\"string\">\"com.alibaba\"</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extensionClasses;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadDirectory</span><span class=\"params\">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir, String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//拼接接口名作为文件名，例如：/META-INF/dubbo/internal/org.apache.dubbo.rpc.Protocol</span></span><br><span class=\"line\">    String fileName = dir + type;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Enumeration&lt;java.net.URL&gt; urls;</span><br><span class=\"line\">        <span class=\"comment\">//获取加载ClassLoader类的类加载器</span></span><br><span class=\"line\">        ClassLoader classLoader = findClassLoader();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (classLoader != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            urls = classLoader.getResources(fileName);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            urls = ClassLoader.getSystemResources(fileName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (urls != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (urls.hasMoreElements()) &#123;</span><br><span class=\"line\">                java.net.URL resourceURL = urls.nextElement();</span><br><span class=\"line\">                <span class=\"comment\">//加载资源</span></span><br><span class=\"line\">                loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        logger.error(<span class=\"string\">\"Exception when load extension class(interface: \"</span> +</span><br><span class=\"line\">                     type + <span class=\"string\">\", description file: \"</span> + fileName + <span class=\"string\">\").\"</span>, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们继续来看loadResource()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadResource</span><span class=\"params\">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        BufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(resourceURL.openStream(), <span class=\"string\">\"utf-8\"</span>));</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String line;</span><br><span class=\"line\">            <span class=\"comment\">//读取文件每一行</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((line = reader.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ci = line.indexOf(<span class=\"string\">'#'</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ci &gt;= <span class=\"number\">0</span>) line = line.substring(<span class=\"number\">0</span>, ci);</span><br><span class=\"line\">                line = line.trim();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (line.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        String name = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">int</span> i = line.indexOf(<span class=\"string\">'='</span>);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//name 是扩展名</span></span><br><span class=\"line\">                            name = line.substring(<span class=\"number\">0</span>, i).trim();</span><br><span class=\"line\">                            <span class=\"comment\">//扩展实现类全名</span></span><br><span class=\"line\">                            line = line.substring(i + <span class=\"number\">1</span>).trim();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (line.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//根据line加载类</span></span><br><span class=\"line\">                            loadClass(extensionClasses, resourceURL, Class.forName(line, <span class=\"keyword\">true</span>, classLoader), name);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                        IllegalStateException e = <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Failed to load extension class(interface: \"</span> + type + <span class=\"string\">\", class line: \"</span> + line + <span class=\"string\">\") in \"</span> + resourceURL + <span class=\"string\">\", cause: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">                        exceptions.put(line, e);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            reader.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        logger.error(<span class=\"string\">\"Exception when load extension class(interface: \"</span> +</span><br><span class=\"line\">                     type + <span class=\"string\">\", class file: \"</span> + resourceURL + <span class=\"string\">\") in \"</span> + resourceURL, t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadClass</span><span class=\"params\">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class=\"keyword\">throws</span> NoSuchMethodException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//盘判断实现类是否实现了type接口</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Error when load extension class(interface: \"</span> +</span><br><span class=\"line\">                                        type + <span class=\"string\">\", class line: \"</span> + clazz.getName() + <span class=\"string\">\"), class \"</span></span><br><span class=\"line\">                                        + clazz.getName() + <span class=\"string\">\"is not subtype of interface.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//判断实现类是否有Adaptive注解</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cachedAdaptiveClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//赋值</span></span><br><span class=\"line\">            cachedAdaptiveClass = clazz;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//一个接口的SPI实现，只能有一个实现类是Adaptive的</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"More than 1 adaptive class found: \"</span></span><br><span class=\"line\">                                            + cachedAdaptiveClass.getClass().getName()</span><br><span class=\"line\">                                            + <span class=\"string\">\", \"</span> + clazz.getClass().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isWrapperClass(clazz)) &#123; <span class=\"comment\">//判断是否为包装类</span></span><br><span class=\"line\">        <span class=\"comment\">//一个接口的SPI实现可以有多个包装类</span></span><br><span class=\"line\">        Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (wrappers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            cachedWrapperClasses = <span class=\"keyword\">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class=\"line\">            wrappers = cachedWrapperClasses;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        wrappers.add(clazz);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        clazz.getConstructor();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span> || name.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            name = findAnnotationName(clazz);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (name.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"No such extension name for the class \"</span> + clazz.getName() + <span class=\"string\">\" in the config \"</span> + resourceURL);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (names != <span class=\"keyword\">null</span> &amp;&amp; names.length &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">//？？？</span></span><br><span class=\"line\">            <span class=\"comment\">//实现类是否有Active注解</span></span><br><span class=\"line\">            Activate activate = clazz.getAnnotation(Activate.class);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (activate != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果有，加入cachedActivates map（扩展名：实现类class）</span></span><br><span class=\"line\">                cachedActivates.put(names[<span class=\"number\">0</span>], activate);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// support com.alibaba.dubbo.common.extension.Activate</span></span><br><span class=\"line\">                com.alibaba.dubbo.common.extension.Activate oldActivate = clazz.getAnnotation(com.alibaba.dubbo.common.extension.Activate.class);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldActivate != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    cachedActivates.put(names[<span class=\"number\">0</span>], oldActivate);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String n : names) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//实现类:扩展名 map 放入缓存</span></span><br><span class=\"line\">                    cachedNames.put(clazz, n);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//Adaptive 和wapper类都不在extensionClasses里!!!</span></span><br><span class=\"line\">                    extensionClasses.put(n, clazz);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c != clazz) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Duplicate extension \"</span> + type.getName() + <span class=\"string\">\" name \"</span> + n + <span class=\"string\">\" on \"</span> + c.getName() + <span class=\"string\">\" and \"</span> + clazz.getName());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isWrapperClass</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//实现类里，是否有，参数是接口类型的（比如 com.alibaba.dubbo.rpc.Protocol类型，并且1个参数）的构造函数</span></span><br><span class=\"line\">        <span class=\"comment\">//表示它是个接口包装类</span></span><br><span class=\"line\">        clazz.getConstructor(type);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步，依赖注入流程分析\"><a href=\"#第二步，依赖注入流程分析\" class=\"headerlink\" title=\"第二步，依赖注入流程分析\"></a>第二步，依赖注入流程分析</h4><p>首先来看injectExtension(T instance)的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实例对象，字段依赖注入。字段类型可以是spi 接口类型，或者是Spring bean 类型</span></span><br><span class=\"line\"><span class=\"comment\">// 依赖注入的字段对象，是通过ExtensionLoader的objectFactory属性完成的，</span></span><br><span class=\"line\"><span class=\"comment\">// objectFacotry 会根据先后通过spi机制和从spring 容器里获取属性对象并注入。</span></span><br><span class=\"line\"><span class=\"comment\">// objectFactory 是在ExtensionLoader私有构造函数中赋值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">injectExtension</span><span class=\"params\">(T instance)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (objectFactory != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (method.getName().startsWith(<span class=\"string\">\"set\"</span>)</span><br><span class=\"line\">                    &amp;&amp; method.getParameterTypes().length == <span class=\"number\">1</span></span><br><span class=\"line\">                    &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123; <span class=\"comment\">//获取所有public类型，并且只有一个参数的以set开头的方法</span></span><br><span class=\"line\">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class=\"number\">0</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//根据驼峰命名法，根据方法名，构造set方法要赋值的属性名</span></span><br><span class=\"line\">                        String property = method.getName().length() &gt; <span class=\"number\">3</span> ? method.getName().substring(<span class=\"number\">3</span>, <span class=\"number\">4</span>).toLowerCase() + method.getName().substring(<span class=\"number\">4</span>) : <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">                        <span class=\"comment\">//通过getExtension的方法获取属性对象，所以还要看getExtension的实现。</span></span><br><span class=\"line\">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (object != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            <span class=\"comment\">//利用反射机制，赋值对象属性</span></span><br><span class=\"line\">                            method.invoke(instance, object);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                        logger.error(<span class=\"string\">\"fail to inject via method \"</span> + method.getName()</span><br><span class=\"line\">                                     + <span class=\"string\">\" of interface \"</span> + type.getName() + <span class=\"string\">\": \"</span> + e.getMessage(), e);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        logger.error(e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看下ExtensionLoader定义的私有构造函数，可以看到objectFactory是通过<code>ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()</code>赋值的，它是ExtensionFactory接口的Adaptive扩展实现，看下getAdaptiveExtension()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取一个SPI接口的Adaptive(实现类有Adaptive注解的)类型扩展实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getAdaptiveExtension</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//先取缓存</span></span><br><span class=\"line\">    Object instance = cachedAdaptiveInstance.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (createAdaptiveInstanceError == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class=\"line\">                instance = cachedAdaptiveInstance.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//缓存不在，就创建Adaptive扩展实例</span></span><br><span class=\"line\">                        instance = createAdaptiveExtension();</span><br><span class=\"line\">                        <span class=\"comment\">//对象放入缓存中</span></span><br><span class=\"line\">                        cachedAdaptiveInstance.set(instance);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                        createAdaptiveInstanceError = t;</span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"fail to create adaptive instance: \"</span> + t.toString(), t);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"fail to create adaptive instance: \"</span> + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">createAdaptiveExtension</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取AdaptiveExtensionClass的class 通过反射获取实例，同时要走依赖注入流程</span></span><br><span class=\"line\">        <span class=\"comment\">//AdaptiveExtensionClass 已在spi 文件解析时赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Can not create adaptive extension \"</span> + type + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果有必要，触发spi加载流程，</span></span><br><span class=\"line\">\t<span class=\"comment\">//找到类上有Adaptive注解的class,赋值给cachedAdaptiveClass</span></span><br><span class=\"line\">    getExtensionClasses();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cachedAdaptiveClass != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cachedAdaptiveClass;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//Adaptive注解不在扩展实现类上，而是在待扩展接口方法上</span></span><br><span class=\"line\">\t<span class=\"comment\">//这种情况，就是dubbo动态生成生成java类字串，动态编译生成想要的class</span></span><br><span class=\"line\">\t<span class=\"comment\">//这个下面再分析下</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>目前ExtensionFactory接口3个实现类，只有AdaptiveExtensionFactory类是Adaptive的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * AdaptiveExtensionFactory</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Adaptive</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdaptiveExtensionFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ExtensionFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class=\"line\">\t<span class=\"comment\">//无参构造函数中，把其他实现类实例加入到factories list中</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AdaptiveExtensionFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);</span><br><span class=\"line\">        List&lt;ExtensionFactory&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;ExtensionFactory&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//getSupportedExtensions()返回的是 非包装类扩展，非Adaptive扩展，防止无限循环</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : loader.getSupportedExtensions()) &#123;</span><br><span class=\"line\">            list.add(loader.getExtension(name));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        factories = Collections.unmodifiableList(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getExtension</span><span class=\"params\">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class=\"line\">            T extension = factory.getExtension(type, name);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (extension != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> extension;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外两个实现类是<code>SpiExtensionFactory</code>、<code>SpringExtensionFactory</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SpiExtensionFactory</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpiExtensionFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ExtensionFactory</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//SPI机制获取type扩展接口</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getExtension</span><span class=\"params\">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class=\"line\">            ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!loader.getSupportedExtensions().isEmpty()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//获取的是接口的Adaptive实现</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> loader.getAdaptiveExtension();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SpringExtensionFactory</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringExtensionFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ExtensionFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(SpringExtensionFactory.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Set&lt;ApplicationContext&gt; contexts = <span class=\"keyword\">new</span> ConcurrentHashSet&lt;ApplicationContext&gt;();</span><br><span class=\"line\">\t<span class=\"comment\">//手动将spring容器传入</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">addApplicationContext</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">        contexts.add(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">removeApplicationContext</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">        contexts.remove(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// currently for test purpose</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clearContexts</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        contexts.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getExtension</span><span class=\"params\">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//SPI should be get from SpiExtensionFactory</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//遍历spring容器</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ApplicationContext context : contexts) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (context.containsBean(name)) &#123;</span><br><span class=\"line\">                Object bean = context.getBean(name);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (type.isInstance(bean)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> (T) bean;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        logger.warn(<span class=\"string\">\"No spring extension(bean) named:\"</span> + name + <span class=\"string\">\", try to find an extension(bean) of type \"</span> + type.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ApplicationContext context : contexts) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> context.getBean(type);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoUniqueBeanDefinitionException multiBeanExe) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> multiBeanExe;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (NoSuchBeanDefinitionException noBeanExe) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">                    logger.debug(<span class=\"string\">\"Error when get spring extension(bean) for type:\"</span> + type.getName(), noBeanExe);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        logger.warn(<span class=\"string\">\"No spring extension(bean) named:\"</span> + name + <span class=\"string\">\", type:\"</span> + type.getName() + <span class=\"string\">\" found, stop get bean.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三步，实例化包装类流程分析\"><a href=\"#第三步，实例化包装类流程分析\" class=\"headerlink\" title=\"第三步，实例化包装类流程分析\"></a>第三步，实例化包装类流程分析</h4><p>代码上面createExtension方法里已贴出，为了更好的理解，我们可以看下Protocol接口的实现中，ProtocolFIlterWrapper和ProtocolListenerWrapper两个包装类，可以看到他们都有参数为Protocol类型的public构造函数，实例化时，把上层的protocol对象作为参数传入构造函数作为内部属性，同时包装类本身会实现Protocol接口，所以这就可以做些类似aop的操作，如ProtocolFilterWrapper：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * ListenerProtocol</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProtocolFilterWrapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">Protocol</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Protocol protocol;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ProtocolFilterWrapper</span><span class=\"params\">(Protocol protocol)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (protocol == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"protocol == null\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.protocol = protocol;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//实例化过滤器链</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">buildInvokerChain</span><span class=\"params\">(<span class=\"keyword\">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class=\"line\">        Invoker&lt;T&gt; last = invoker;</span><br><span class=\"line\">        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!filters.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = filters.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Filter filter = filters.get(i);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Invoker&lt;T&gt; next = last;</span><br><span class=\"line\">                last = <span class=\"keyword\">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Class&lt;T&gt; <span class=\"title\">getInterface</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> invoker.getInterface();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> URL <span class=\"title\">getUrl</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> invoker.getUrl();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> invoker.isAvailable();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> filter.invoke(next, invocation);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        invoker.destroy();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> invoker.toString();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getDefaultPort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> protocol.getDefaultPort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//暴露过程前执行过滤器链</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> protocol.export(invoker);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//调用前执行过滤器链</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> protocol.refer(type, url);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        protocol.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此Dubbo SPI机制的三个步骤分析完了。</p>\n<p>上面提到的Adaptive类的另一种配置方式，即Adaptive注解配置在方法上，dubbo里，配置Adaptive类有两种方式，一种在就扣实现里，类本身有Adaptive注解，还有一种配置实在接口定义的方法级上有Adaptive注解，这两种方式第一种优先，没有第一种，dubbo自动完成第二种Adaptive类的生成，以Protocol接口为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SPI</span>(<span class=\"string\">\"dubbo\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Protocol</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取缺省端口，当用户没有配置端口时使用。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 缺省端口</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getDefaultPort</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 暴露远程服务：&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. export()必须是幂等的，也就是暴露同一个URL的Invoker两次，和暴露一次没有区别。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 3. export()传入的Invoker由框架实现并传入，协议不需要关心。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt;     服务的类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> invoker 服务的执行体</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> exporter 暴露服务的引用，用于取消暴露</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> RpcException 当暴露服务出错时抛出，比如端口已占用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Adaptive</span></span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">Exporter&lt;T&gt; <span class=\"title\">export</span><span class=\"params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"keyword\">throws</span> RpcException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 引用远程服务：&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. 当用户调用refer()所返回的Invoker对象的invoke()方法时，协议需相应执行同URL远端export()传入的Invoker对象的invoke()方法。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. refer()返回的Invoker由协议实现，协议通常需要在此Invoker中发送远程请求。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 3. 当url中有设置check=false时，连接失败不能抛出异常，并内部自动恢复。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt;  服务的类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> type 服务的类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> url  远程服务的URL地址</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> invoker 服务的本地代理</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> RpcException 当连接服务提供方失败时抛出</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Adaptive</span></span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 释放协议：&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. 取消该协议所有已经暴露和引用的服务。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. 释放协议所占用的所有资源，比如连接和端口。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * 3. 协议在释放后，依然能暴露和引用新的服务。&lt;br&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在export和refer方法上所有Adaptive注解，根据上面的分析，我们跟踪一下createAdaptiveExtensionClass方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class=\"line\">    <span class=\"comment\">//生成Adaptive；类源码</span></span><br><span class=\"line\">    String code = createAdaptiveExtensionClassCode();</span><br><span class=\"line\">    ClassLoader classLoader = findClassLoader();</span><br><span class=\"line\">    <span class=\"comment\">//通过SPI获取java 编译器</span></span><br><span class=\"line\">    org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class=\"line\">    <span class=\"comment\">//编译源码返回class</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> compiler.compile(code, classLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>createAdaptiveExtensionClassCode();</code>方法就是实现字符串拼接, 不同的接口，生成的code会有不同，默认使用javassist对代码进行编译。 这里贴出Protocal生成的Adaptive类的源代码。<strong>体现的思想是，所谓Adaptive方法，其实现，内部的对象类型都是参数（url）和spi机制动态决定的</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.apache.dubbo.rpc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Protocol</span>$<span class=\"title\">Adaptive</span> <span class=\"keyword\">implements</span> <span class=\"title\">org</span>.<span class=\"title\">apache</span>.<span class=\"title\">dubbo</span>.<span class=\"title\">rpc</span>.<span class=\"title\">Protocol</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Invoker <span class=\"title\">refer</span><span class=\"params\">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.common.URL url = arg1;</span><br><span class=\"line\">        String extName = (url.getProtocol() == <span class=\"keyword\">null</span> ? <span class=\"string\">\"dubbo\"</span> : url.getProtocol());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([protocol])\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension.refer(arg0, arg1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Exporter <span class=\"title\">export</span><span class=\"params\">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.Invoker argument == null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0.getUrl() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class=\"line\">        String extName = (url.getProtocol() == <span class=\"keyword\">null</span> ? <span class=\"string\">\"dubbo\"</span> : url.getProtocol());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([protocol])\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension.export(arg0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getDefaultPort</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Collections.sort()源码分析（基于jdk1.8）","date":"2017-02-26T02:07:15.000Z","_content":"\n> Collections类中定义了一系列的静态方法，其中就包括sort方法(下面为该方法的源码),从这个方法的源码中可以看出，它调用的是list.sort()方法，在该方法中先将list转换成数组，然后调用Arrays.sort()方法。在Arrays.sort()方法中，有一个条件判断（LegacyMergeSort.userRequested），当此条件为true时，调用legacyMergeSort(a, c);若为false则调用TimSort.sort(a, 0, a.length, c, null, 0, 0);通过legacyMergeSort(a, c);源码就可以看出此方法实现的是归并排序，\n\n<!-- more -->\n\n* Collections.sort()方法源码\n```java\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic static <T> void sort(List<T> list, Comparator<? super T> c) {\n    list.sort(c);\n}\n```\n* list.sort()方法源码\n```java\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\ndefault void sort(Comparator<? super E> c) {\n    Object[] a = this.toArray();\n    Arrays.sort(a, (Comparator) c);\n    ListIterator<E> i = this.listIterator();\n    for (Object e : a) {\n        i.next();\n        i.set((E) e);\n    }\n}\n```\n* Arrays.sort()方法源码\n```java\npublic static <T> void sort(T[] a, Comparator<? super T> c) {\n    if (c == null) {\n        sort(a);\n    } else {\n        if (LegacyMergeSort.userRequested)\n            legacyMergeSort(a, c);\n        else\n            TimSort.sort(a, 0, a.length, c, null, 0, 0);\n    }\n}\n```\n> mergeSort()方法源码，legacyMergeSort()方法将会在未来的版本中被移除。mergeSort()方法中，当待排序数组长度小于7时，使用的是插入排序。\n\n```java\n/** To be removed in a future release. */\nprivate static <T> void legacyMergeSort(T[] a, Comparator<? super T> c) {\n    T[] aux = a.clone();\n    if (c==null)\n        mergeSort(aux, a, 0, a.length, 0);\n    else\n        mergeSort(aux, a, 0, a.length, 0, c);\n}\n/**\n * Tuning parameter: list size at or below which insertion sort will be\n * used in preference to mergesort.\n * To be removed in a future release.\n */\nprivate static final int INSERTIONSORT_THRESHOLD = 7;\n\n/**\n * Src is the source array that starts at index 0\n * Dest is the (possibly larger) array destination with a possible offset\n * low is the index in dest to start sorting\n * high is the end index in dest to end sorting\n * off is the offset to generate corresponding low, high in src\n * To be removed in a future release.\n */\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nprivate static void mergeSort(Object[] src,\n                              Object[] dest,\n                              int low,\n                              int high,\n                              int off) {\n    int length = high - low;\n\n    // Insertion sort on smallest arrays\n    if (length < INSERTIONSORT_THRESHOLD) {\n        for (int i=low; i<high; i++)\n            for (int j=i; j>low &&\n                     ((Comparable) dest[j-1]).compareTo(dest[j])>0; j--)\n                swap(dest, j, j-1);\n        return;\n    }\n\n    // Recursively sort halves of dest into src\n    int destLow  = low;\n    int destHigh = high;\n    low  += off;\n    high += off;\n    int mid = (low + high) >>> 1;\n    mergeSort(dest, src, low, mid, -off);\n    mergeSort(dest, src, mid, high, -off);\n\n    // If list is already sorted, just copy from src to dest.  This is an\n    // optimization that results in faster sorts for nearly ordered lists.\n    if (((Comparable)src[mid-1]).compareTo(src[mid]) <= 0) {\n        System.arraycopy(src, low, dest, destLow, length);\n        return;\n    }\n\n    // Merge sorted halves (now in src) into dest\n    for(int i = destLow, p = low, q = mid; i < destHigh; i++) {\n        if (q >= high || p < mid && ((Comparable)src[p]).compareTo(src[q])<=0)\n            dest[i] = src[p++];\n        else\n            dest[i] = src[q++];\n    }\n}\n\n/**\n * Swaps x[a] with x[b].\n */\nprivate static void swap(Object[] x, int a, int b) {\n    Object t = x[a];\n    x[a] = x[b];\n    x[b] = t;\n}\n```\n","source":"_posts/java-Collections-sort-method.md","raw":"---\ntitle: Collections.sort()源码分析（基于jdk1.8）\ndate: 2017-02-26 10:07:15\ntags:\n    - java\n---\n\n> Collections类中定义了一系列的静态方法，其中就包括sort方法(下面为该方法的源码),从这个方法的源码中可以看出，它调用的是list.sort()方法，在该方法中先将list转换成数组，然后调用Arrays.sort()方法。在Arrays.sort()方法中，有一个条件判断（LegacyMergeSort.userRequested），当此条件为true时，调用legacyMergeSort(a, c);若为false则调用TimSort.sort(a, 0, a.length, c, null, 0, 0);通过legacyMergeSort(a, c);源码就可以看出此方法实现的是归并排序，\n\n<!-- more -->\n\n* Collections.sort()方法源码\n```java\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic static <T> void sort(List<T> list, Comparator<? super T> c) {\n    list.sort(c);\n}\n```\n* list.sort()方法源码\n```java\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\ndefault void sort(Comparator<? super E> c) {\n    Object[] a = this.toArray();\n    Arrays.sort(a, (Comparator) c);\n    ListIterator<E> i = this.listIterator();\n    for (Object e : a) {\n        i.next();\n        i.set((E) e);\n    }\n}\n```\n* Arrays.sort()方法源码\n```java\npublic static <T> void sort(T[] a, Comparator<? super T> c) {\n    if (c == null) {\n        sort(a);\n    } else {\n        if (LegacyMergeSort.userRequested)\n            legacyMergeSort(a, c);\n        else\n            TimSort.sort(a, 0, a.length, c, null, 0, 0);\n    }\n}\n```\n> mergeSort()方法源码，legacyMergeSort()方法将会在未来的版本中被移除。mergeSort()方法中，当待排序数组长度小于7时，使用的是插入排序。\n\n```java\n/** To be removed in a future release. */\nprivate static <T> void legacyMergeSort(T[] a, Comparator<? super T> c) {\n    T[] aux = a.clone();\n    if (c==null)\n        mergeSort(aux, a, 0, a.length, 0);\n    else\n        mergeSort(aux, a, 0, a.length, 0, c);\n}\n/**\n * Tuning parameter: list size at or below which insertion sort will be\n * used in preference to mergesort.\n * To be removed in a future release.\n */\nprivate static final int INSERTIONSORT_THRESHOLD = 7;\n\n/**\n * Src is the source array that starts at index 0\n * Dest is the (possibly larger) array destination with a possible offset\n * low is the index in dest to start sorting\n * high is the end index in dest to end sorting\n * off is the offset to generate corresponding low, high in src\n * To be removed in a future release.\n */\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\nprivate static void mergeSort(Object[] src,\n                              Object[] dest,\n                              int low,\n                              int high,\n                              int off) {\n    int length = high - low;\n\n    // Insertion sort on smallest arrays\n    if (length < INSERTIONSORT_THRESHOLD) {\n        for (int i=low; i<high; i++)\n            for (int j=i; j>low &&\n                     ((Comparable) dest[j-1]).compareTo(dest[j])>0; j--)\n                swap(dest, j, j-1);\n        return;\n    }\n\n    // Recursively sort halves of dest into src\n    int destLow  = low;\n    int destHigh = high;\n    low  += off;\n    high += off;\n    int mid = (low + high) >>> 1;\n    mergeSort(dest, src, low, mid, -off);\n    mergeSort(dest, src, mid, high, -off);\n\n    // If list is already sorted, just copy from src to dest.  This is an\n    // optimization that results in faster sorts for nearly ordered lists.\n    if (((Comparable)src[mid-1]).compareTo(src[mid]) <= 0) {\n        System.arraycopy(src, low, dest, destLow, length);\n        return;\n    }\n\n    // Merge sorted halves (now in src) into dest\n    for(int i = destLow, p = low, q = mid; i < destHigh; i++) {\n        if (q >= high || p < mid && ((Comparable)src[p]).compareTo(src[q])<=0)\n            dest[i] = src[p++];\n        else\n            dest[i] = src[q++];\n    }\n}\n\n/**\n * Swaps x[a] with x[b].\n */\nprivate static void swap(Object[] x, int a, int b) {\n    Object t = x[a];\n    x[a] = x[b];\n    x[b] = t;\n}\n```\n","slug":"java-Collections-sort-method","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn50001gzjiaywx25rth","content":"<blockquote>\n<p>Collections类中定义了一系列的静态方法，其中就包括sort方法(下面为该方法的源码),从这个方法的源码中可以看出，它调用的是list.sort()方法，在该方法中先将list转换成数组，然后调用Arrays.sort()方法。在Arrays.sort()方法中，有一个条件判断（LegacyMergeSort.userRequested），当此条件为true时，调用legacyMergeSort(a, c);若为false则调用TimSort.sort(a, 0, a.length, c, null, 0, 0);通过legacyMergeSort(a, c);源码就可以看出此方法实现的是归并排序，</p>\n</blockquote>\n<a id=\"more\"></a>\n<ul>\n<li><p>Collections.sort()方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List&lt;T&gt; list, Comparator&lt;? <span class=\"keyword\">super</span> T&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    list.sort(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>list.sort()方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(Comparator&lt;? <span class=\"keyword\">super</span> E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    Object[] a = <span class=\"keyword\">this</span>.toArray();</span><br><span class=\"line\">    Arrays.sort(a, (Comparator) c);</span><br><span class=\"line\">    ListIterator&lt;E&gt; i = <span class=\"keyword\">this</span>.listIterator();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object e : a) &#123;</span><br><span class=\"line\">        i.next();</span><br><span class=\"line\">        i.set((E) e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Arrays.sort()方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] a, Comparator&lt;? <span class=\"keyword\">super</span> T&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        sort(a);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LegacyMergeSort.userRequested)</span><br><span class=\"line\">            legacyMergeSort(a, c);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            TimSort.sort(a, <span class=\"number\">0</span>, a.length, c, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>mergeSort()方法源码，legacyMergeSort()方法将会在未来的版本中被移除。mergeSort()方法中，当待排序数组长度小于7时，使用的是插入排序。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** To be removed in a future release. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">legacyMergeSort</span><span class=\"params\">(T[] a, Comparator&lt;? <span class=\"keyword\">super</span> T&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    T[] aux = a.clone();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        mergeSort(aux, a, <span class=\"number\">0</span>, a.length, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        mergeSort(aux, a, <span class=\"number\">0</span>, a.length, <span class=\"number\">0</span>, c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Tuning parameter: list size at or below which insertion sort will be</span></span><br><span class=\"line\"><span class=\"comment\"> * used in preference to mergesort.</span></span><br><span class=\"line\"><span class=\"comment\"> * To be removed in a future release.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INSERTIONSORT_THRESHOLD = <span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Src is the source array that starts at index 0</span></span><br><span class=\"line\"><span class=\"comment\"> * Dest is the (possibly larger) array destination with a possible offset</span></span><br><span class=\"line\"><span class=\"comment\"> * low is the index in dest to start sorting</span></span><br><span class=\"line\"><span class=\"comment\"> * high is the end index in dest to end sorting</span></span><br><span class=\"line\"><span class=\"comment\"> * off is the offset to generate corresponding low, high in src</span></span><br><span class=\"line\"><span class=\"comment\"> * To be removed in a future release.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(Object[] src,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              Object[] dest,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> low,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> high,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> off)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = high - low;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Insertion sort on smallest arrays</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=low; i&lt;high; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=i; j&gt;low &amp;&amp;</span><br><span class=\"line\">                     ((Comparable) dest[j-<span class=\"number\">1</span>]).compareTo(dest[j])&gt;<span class=\"number\">0</span>; j--)</span><br><span class=\"line\">                swap(dest, j, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Recursively sort halves of dest into src</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> destLow  = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> destHigh = high;</span><br><span class=\"line\">    low  += off;</span><br><span class=\"line\">    high += off;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (low + high) &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    mergeSort(dest, src, low, mid, -off);</span><br><span class=\"line\">    mergeSort(dest, src, mid, high, -off);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If list is already sorted, just copy from src to dest.  This is an</span></span><br><span class=\"line\">    <span class=\"comment\">// optimization that results in faster sorts for nearly ordered lists.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((Comparable)src[mid-<span class=\"number\">1</span>]).compareTo(src[mid]) &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        System.arraycopy(src, low, dest, destLow, length);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Merge sorted halves (now in src) into dest</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">            dest[i] = src[p++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            dest[i] = src[q++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Swaps x[a] with x[b].</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Object[] x, <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    Object t = x[a];</span><br><span class=\"line\">    x[a] = x[b];</span><br><span class=\"line\">    x[b] = t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Collections类中定义了一系列的静态方法，其中就包括sort方法(下面为该方法的源码),从这个方法的源码中可以看出，它调用的是list.sort()方法，在该方法中先将list转换成数组，然后调用Arrays.sort()方法。在Arrays.sort()方法中，有一个条件判断（LegacyMergeSort.userRequested），当此条件为true时，调用legacyMergeSort(a, c);若为false则调用TimSort.sort(a, 0, a.length, c, null, 0, 0);通过legacyMergeSort(a, c);源码就可以看出此方法实现的是归并排序，</p>\n</blockquote>","more":"<ul>\n<li><p>Collections.sort()方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List&lt;T&gt; list, Comparator&lt;? <span class=\"keyword\">super</span> T&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    list.sort(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>list.sort()方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(Comparator&lt;? <span class=\"keyword\">super</span> E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    Object[] a = <span class=\"keyword\">this</span>.toArray();</span><br><span class=\"line\">    Arrays.sort(a, (Comparator) c);</span><br><span class=\"line\">    ListIterator&lt;E&gt; i = <span class=\"keyword\">this</span>.listIterator();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object e : a) &#123;</span><br><span class=\"line\">        i.next();</span><br><span class=\"line\">        i.set((E) e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Arrays.sort()方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(T[] a, Comparator&lt;? <span class=\"keyword\">super</span> T&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        sort(a);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LegacyMergeSort.userRequested)</span><br><span class=\"line\">            legacyMergeSort(a, c);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            TimSort.sort(a, <span class=\"number\">0</span>, a.length, c, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>mergeSort()方法源码，legacyMergeSort()方法将会在未来的版本中被移除。mergeSort()方法中，当待排序数组长度小于7时，使用的是插入排序。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** To be removed in a future release. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">legacyMergeSort</span><span class=\"params\">(T[] a, Comparator&lt;? <span class=\"keyword\">super</span> T&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    T[] aux = a.clone();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">        mergeSort(aux, a, <span class=\"number\">0</span>, a.length, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        mergeSort(aux, a, <span class=\"number\">0</span>, a.length, <span class=\"number\">0</span>, c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Tuning parameter: list size at or below which insertion sort will be</span></span><br><span class=\"line\"><span class=\"comment\"> * used in preference to mergesort.</span></span><br><span class=\"line\"><span class=\"comment\"> * To be removed in a future release.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INSERTIONSORT_THRESHOLD = <span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Src is the source array that starts at index 0</span></span><br><span class=\"line\"><span class=\"comment\"> * Dest is the (possibly larger) array destination with a possible offset</span></span><br><span class=\"line\"><span class=\"comment\"> * low is the index in dest to start sorting</span></span><br><span class=\"line\"><span class=\"comment\"> * high is the end index in dest to end sorting</span></span><br><span class=\"line\"><span class=\"comment\"> * off is the offset to generate corresponding low, high in src</span></span><br><span class=\"line\"><span class=\"comment\"> * To be removed in a future release.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(Object[] src,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              Object[] dest,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> low,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> high,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> off)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> length = high - low;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Insertion sort on smallest arrays</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=low; i&lt;high; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=i; j&gt;low &amp;&amp;</span><br><span class=\"line\">                     ((Comparable) dest[j-<span class=\"number\">1</span>]).compareTo(dest[j])&gt;<span class=\"number\">0</span>; j--)</span><br><span class=\"line\">                swap(dest, j, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Recursively sort halves of dest into src</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> destLow  = low;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> destHigh = high;</span><br><span class=\"line\">    low  += off;</span><br><span class=\"line\">    high += off;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (low + high) &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    mergeSort(dest, src, low, mid, -off);</span><br><span class=\"line\">    mergeSort(dest, src, mid, high, -off);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If list is already sorted, just copy from src to dest.  This is an</span></span><br><span class=\"line\">    <span class=\"comment\">// optimization that results in faster sorts for nearly ordered lists.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (((Comparable)src[mid-<span class=\"number\">1</span>]).compareTo(src[mid]) &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        System.arraycopy(src, low, dest, destLow, length);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Merge sorted halves (now in src) into dest</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">            dest[i] = src[p++];</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            dest[i] = src[q++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Swaps x[a] with x[b].</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Object[] x, <span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    Object t = x[a];</span><br><span class=\"line\">    x[a] = x[b];</span><br><span class=\"line\">    x[b] = t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java基础知识点总结","date":"2018-12-26T07:41:34.000Z","_content":"\n总结了一些Java基础知识点，主要包括Container、Concurrent、IO、JVM等方面，通过思维导图的方式展现，随着我进一步的学习，也会不断更新下面的知识点，具体请看下图：\n\n<!-- more -->\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Java.png?raw=true)","source":"_posts/java-basic-knowledge-summary.md","raw":"---\ntitle: Java基础知识点总结\ndate: 2018-12-26 15:41:34\ntags:\n    - java\n---\n\n总结了一些Java基础知识点，主要包括Container、Concurrent、IO、JVM等方面，通过思维导图的方式展现，随着我进一步的学习，也会不断更新下面的知识点，具体请看下图：\n\n<!-- more -->\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Java.png?raw=true)","slug":"java-basic-knowledge-summary","published":1,"updated":"2018-12-26T07:48:35.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn51001hzjiaig78enrw","content":"<p>总结了一些Java基础知识点，主要包括Container、Concurrent、IO、JVM等方面，通过思维导图的方式展现，随着我进一步的学习，也会不断更新下面的知识点，具体请看下图：</p>\n<a id=\"more\"></a>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Java.png?raw=true\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>总结了一些Java基础知识点，主要包括Container、Concurrent、IO、JVM等方面，通过思维导图的方式展现，随着我进一步的学习，也会不断更新下面的知识点，具体请看下图：</p>","more":"<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Java.png?raw=true\" alt=\"\"></p>"},{"title":"CAS and Lock-Free in Java","date":"2018-12-27T12:06:41.000Z","_content":"\n在Java中的原子类中频繁的使用CAS策略来保证数据更新的安全性，它是一种Lock-Free机制，这篇文章将会讲解CAS原理，以及它在Java中的应用。\n\n<!-- more -->\n\n### Lock-Free\n\n> *如果一个方法是 Lock-Free 的, 它保证线程无限次调用这个方法都能够在有限步内完成.*\n\n相比于传统的基于 Mutex 锁机制, Lock-Free 有下面的优势:\n\n- Lock-Free 的速度更快\n- 线程之间不会相互影响, 没有死锁\n- 不受异步信号影响, 可重入\n- 不会发生线程优先级反转\n\n在通常使用 Mutex 互斥锁的场景, 有的线程抢占了锁, 其他线程则会被阻塞, 当获得锁的进程挂掉之后, 整个程序就 block 住了. 但在 Lock-Free 的程序中, 单个线程挂掉, 也不会影响其他线程, 因为线程之间不会相互影响.\n\n但是, Lock-Free 也有不少缺陷:\n\n- 只能利用有限的原子操作, 例如 CAS (操作的位数有限), 编码实现复杂\n- 竞争会加剧, 优先级不好控制\n- 测试时需要考虑各种软硬件环境, 很难做到尽善尽美\n\n再引入一个 Wait-Free 概念:\n\n> *假如一个方法是 Wait-Free 的, 那么它保证了每一次调用都可以在有限的步骤内结束.*\n\n一般来说: **阻塞 > Lock-Free > Wait-Free**\n\n### CAS原语\n\nCAS (compare and swap) 是 CPU 硬件同步原语(primitive), CAS(V, A, B) 操作可以用下面的代码来示意:\n\n```cpp\ntemplate <class T>\nbool CAS(T* addr, T expect_val, T val) {\n    if (*addr == expect_val) {\n        *addr = val;\n        return true;\n    }\n    return false;\n}\n```\n\n从 80486 开始, 所有的 Intel 处理器上, 通过一条汇编指令 CMPXCHG 即可实现 CAS 操作. CAS 的价值在于它是一个**原子操作**, 不会被 CPU中断或者其他方式打断, 因为在硬件层实现, 所以**开销极小**.\n\nCAS 并不是一项新技术, 它的使用可以追溯到 70 年代, 早在 80 年代就有很多经典书籍中提到使用 CAS 来实现并行编程, 如 USC 大牛 [Kai HWang](http://gridsec.usc.edu/Hwang.html) 的 \"Computer Architecture and Parallel Processing\".\n\nGCC 4.1+ 开始支持 CAS 的[原子操作](https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html):\n\n```C\nbool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval)\ntype __sync_val_compare_and_swap (type *ptr, type oldval, type newval)\n```\n\n通常将 CAS 用于同步的方式是从地址 V 读取值 A, 执行多步计算来获得新值 B, 然后使用 CAS 将 V 的值从 A 改为 B, 如果 V 处的值尚未同时更改, 则 CAS 操作成功.\n\n### CAS中的ABA问题\n\nABA 问题描述:\n\n- 切换到线程 T1, 获取内存 V 的值 A\n- 切换到线程 T2, 获取内存 V 的值 A, 修改成 B, 然后再修改成 A\n- 切换到线程 T1, 获取内存 V 的值还是 A, 继续执行\n\n[coolshell 上有篇文章](http://coolshell.cn/articles/8239.html)给出了一个生动的例子(From 维基百科):\n\n> *你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了.*\n\n更具有参考意义的是[Hazard Pointer Wiki](http://en.wikipedia.org/wiki/Hazard_pointer)上提到的一个 Lock-Free 堆栈的例子:\n\n- 当前栈元素 [A, B, C], 栈顶 head 指向 A\n- 线程 T1 执行 pop() 准备 CAS(&head, B, A)\n- 线程 T2 抢占, pop A, pop B, 然后 push A\n- 线程 T1 恢复, CAS(&head, B, A) 成功, 则此时 head 指向一个被 pop 的元素 B\n\nCAS机制还存在其他问题：\n\n* **循环时间长开销大:**\n\n  > 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。\n\n* **只能保证一个共享变量的原子操作**:\n\n  > 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了**AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。**\n\n### CAS在Java中的应用\n\n* 在Java中所有原子类都采用了CAS机制，并且在jdk1.5之后提供了AtomicStampedReference来解决上述提到的ABA问题；\n* AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用CAS机制来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-12-27 20-39-35.png?raw=true)","source":"_posts/java-cas-and-lock-free.md","raw":"---\ntitle: CAS and Lock-Free in Java\ndate: 2018-12-27 20:06:41\ntags:\n    - java\n---\n\n在Java中的原子类中频繁的使用CAS策略来保证数据更新的安全性，它是一种Lock-Free机制，这篇文章将会讲解CAS原理，以及它在Java中的应用。\n\n<!-- more -->\n\n### Lock-Free\n\n> *如果一个方法是 Lock-Free 的, 它保证线程无限次调用这个方法都能够在有限步内完成.*\n\n相比于传统的基于 Mutex 锁机制, Lock-Free 有下面的优势:\n\n- Lock-Free 的速度更快\n- 线程之间不会相互影响, 没有死锁\n- 不受异步信号影响, 可重入\n- 不会发生线程优先级反转\n\n在通常使用 Mutex 互斥锁的场景, 有的线程抢占了锁, 其他线程则会被阻塞, 当获得锁的进程挂掉之后, 整个程序就 block 住了. 但在 Lock-Free 的程序中, 单个线程挂掉, 也不会影响其他线程, 因为线程之间不会相互影响.\n\n但是, Lock-Free 也有不少缺陷:\n\n- 只能利用有限的原子操作, 例如 CAS (操作的位数有限), 编码实现复杂\n- 竞争会加剧, 优先级不好控制\n- 测试时需要考虑各种软硬件环境, 很难做到尽善尽美\n\n再引入一个 Wait-Free 概念:\n\n> *假如一个方法是 Wait-Free 的, 那么它保证了每一次调用都可以在有限的步骤内结束.*\n\n一般来说: **阻塞 > Lock-Free > Wait-Free**\n\n### CAS原语\n\nCAS (compare and swap) 是 CPU 硬件同步原语(primitive), CAS(V, A, B) 操作可以用下面的代码来示意:\n\n```cpp\ntemplate <class T>\nbool CAS(T* addr, T expect_val, T val) {\n    if (*addr == expect_val) {\n        *addr = val;\n        return true;\n    }\n    return false;\n}\n```\n\n从 80486 开始, 所有的 Intel 处理器上, 通过一条汇编指令 CMPXCHG 即可实现 CAS 操作. CAS 的价值在于它是一个**原子操作**, 不会被 CPU中断或者其他方式打断, 因为在硬件层实现, 所以**开销极小**.\n\nCAS 并不是一项新技术, 它的使用可以追溯到 70 年代, 早在 80 年代就有很多经典书籍中提到使用 CAS 来实现并行编程, 如 USC 大牛 [Kai HWang](http://gridsec.usc.edu/Hwang.html) 的 \"Computer Architecture and Parallel Processing\".\n\nGCC 4.1+ 开始支持 CAS 的[原子操作](https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html):\n\n```C\nbool __sync_bool_compare_and_swap (type *ptr, type oldval, type newval)\ntype __sync_val_compare_and_swap (type *ptr, type oldval, type newval)\n```\n\n通常将 CAS 用于同步的方式是从地址 V 读取值 A, 执行多步计算来获得新值 B, 然后使用 CAS 将 V 的值从 A 改为 B, 如果 V 处的值尚未同时更改, 则 CAS 操作成功.\n\n### CAS中的ABA问题\n\nABA 问题描述:\n\n- 切换到线程 T1, 获取内存 V 的值 A\n- 切换到线程 T2, 获取内存 V 的值 A, 修改成 B, 然后再修改成 A\n- 切换到线程 T1, 获取内存 V 的值还是 A, 继续执行\n\n[coolshell 上有篇文章](http://coolshell.cn/articles/8239.html)给出了一个生动的例子(From 维基百科):\n\n> *你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了.*\n\n更具有参考意义的是[Hazard Pointer Wiki](http://en.wikipedia.org/wiki/Hazard_pointer)上提到的一个 Lock-Free 堆栈的例子:\n\n- 当前栈元素 [A, B, C], 栈顶 head 指向 A\n- 线程 T1 执行 pop() 准备 CAS(&head, B, A)\n- 线程 T2 抢占, pop A, pop B, 然后 push A\n- 线程 T1 恢复, CAS(&head, B, A) 成功, 则此时 head 指向一个被 pop 的元素 B\n\nCAS机制还存在其他问题：\n\n* **循环时间长开销大:**\n\n  > 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。\n\n* **只能保证一个共享变量的原子操作**:\n\n  > 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了**AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。**\n\n### CAS在Java中的应用\n\n* 在Java中所有原子类都采用了CAS机制，并且在jdk1.5之后提供了AtomicStampedReference来解决上述提到的ABA问题；\n* AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用CAS机制来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-12-27 20-39-35.png?raw=true)","slug":"java-cas-and-lock-free","published":1,"updated":"2018-12-27T12:45:15.825Z","_id":"cjq6kwn52001kzjiavdz5yh12","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在Java中的原子类中频繁的使用CAS策略来保证数据更新的安全性，它是一种Lock-Free机制，这篇文章将会讲解CAS原理，以及它在Java中的应用。</p>\n<a id=\"more\"></a>\n<h3 id=\"Lock-Free\"><a href=\"#Lock-Free\" class=\"headerlink\" title=\"Lock-Free\"></a>Lock-Free</h3><blockquote>\n<p><em>如果一个方法是 Lock-Free 的, 它保证线程无限次调用这个方法都能够在有限步内完成.</em></p>\n</blockquote>\n<p>相比于传统的基于 Mutex 锁机制, Lock-Free 有下面的优势:</p>\n<ul>\n<li>Lock-Free 的速度更快</li>\n<li>线程之间不会相互影响, 没有死锁</li>\n<li>不受异步信号影响, 可重入</li>\n<li>不会发生线程优先级反转</li>\n</ul>\n<p>在通常使用 Mutex 互斥锁的场景, 有的线程抢占了锁, 其他线程则会被阻塞, 当获得锁的进程挂掉之后, 整个程序就 block 住了. 但在 Lock-Free 的程序中, 单个线程挂掉, 也不会影响其他线程, 因为线程之间不会相互影响.</p>\n<p>但是, Lock-Free 也有不少缺陷:</p>\n<ul>\n<li>只能利用有限的原子操作, 例如 CAS (操作的位数有限), 编码实现复杂</li>\n<li>竞争会加剧, 优先级不好控制</li>\n<li>测试时需要考虑各种软硬件环境, 很难做到尽善尽美</li>\n</ul>\n<p>再引入一个 Wait-Free 概念:</p>\n<blockquote>\n<p><em>假如一个方法是 Wait-Free 的, 那么它保证了每一次调用都可以在有限的步骤内结束.</em></p>\n</blockquote>\n<p>一般来说: <strong>阻塞 &gt; Lock-Free &gt; Wait-Free</strong></p>\n<h3 id=\"CAS原语\"><a href=\"#CAS原语\" class=\"headerlink\" title=\"CAS原语\"></a>CAS原语</h3><p>CAS (compare and swap) 是 CPU 硬件同步原语(primitive), CAS(V, A, B) 操作可以用下面的代码来示意:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">bool</span> <span class=\"title\">CAS</span>(<span class=\"title\">T</span>* <span class=\"title\">addr</span>, <span class=\"title\">T</span> <span class=\"title\">expect_val</span>, <span class=\"title\">T</span> <span class=\"title\">val</span>) &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*addr == expect_val) &#123;</span><br><span class=\"line\">        *addr = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从 80486 开始, 所有的 Intel 处理器上, 通过一条汇编指令 CMPXCHG 即可实现 CAS 操作. CAS 的价值在于它是一个<strong>原子操作</strong>, 不会被 CPU中断或者其他方式打断, 因为在硬件层实现, 所以<strong>开销极小</strong>.</p>\n<p>CAS 并不是一项新技术, 它的使用可以追溯到 70 年代, 早在 80 年代就有很多经典书籍中提到使用 CAS 来实现并行编程, 如 USC 大牛 <a href=\"http://gridsec.usc.edu/Hwang.html\" target=\"_blank\" rel=\"noopener\">Kai HWang</a> 的 “Computer Architecture and Parallel Processing”.</p>\n<p>GCC 4.1+ 开始支持 CAS 的<a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html\" target=\"_blank\" rel=\"noopener\">原子操作</a>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> __sync_bool_compare_and_swap (type *ptr, type oldval, type newval)</span><br><span class=\"line\">type __sync_val_compare_and_swap (type *ptr, type oldval, type newval)</span><br></pre></td></tr></table></figure>\n<p>通常将 CAS 用于同步的方式是从地址 V 读取值 A, 执行多步计算来获得新值 B, 然后使用 CAS 将 V 的值从 A 改为 B, 如果 V 处的值尚未同时更改, 则 CAS 操作成功.</p>\n<h3 id=\"CAS中的ABA问题\"><a href=\"#CAS中的ABA问题\" class=\"headerlink\" title=\"CAS中的ABA问题\"></a>CAS中的ABA问题</h3><p>ABA 问题描述:</p>\n<ul>\n<li>切换到线程 T1, 获取内存 V 的值 A</li>\n<li>切换到线程 T2, 获取内存 V 的值 A, 修改成 B, 然后再修改成 A</li>\n<li>切换到线程 T1, 获取内存 V 的值还是 A, 继续执行</li>\n</ul>\n<p><a href=\"http://coolshell.cn/articles/8239.html\" target=\"_blank\" rel=\"noopener\">coolshell 上有篇文章</a>给出了一个生动的例子(From 维基百科):</p>\n<blockquote>\n<p><em>你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了.</em></p>\n</blockquote>\n<p>更具有参考意义的是<a href=\"http://en.wikipedia.org/wiki/Hazard_pointer\" target=\"_blank\" rel=\"noopener\">Hazard Pointer Wiki</a>上提到的一个 Lock-Free 堆栈的例子:</p>\n<ul>\n<li>当前栈元素 [A, B, C], 栈顶 head 指向 A</li>\n<li>线程 T1 执行 pop() 准备 CAS(&amp;head, B, A)</li>\n<li>线程 T2 抢占, pop A, pop B, 然后 push A</li>\n<li>线程 T1 恢复, CAS(&amp;head, B, A) 成功, 则此时 head 指向一个被 pop 的元素 B</li>\n</ul>\n<p>CAS机制还存在其他问题：</p>\n<ul>\n<li><p><strong>循环时间长开销大:</strong></p>\n<blockquote>\n<p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>\n</blockquote>\n</li>\n<li><p><strong>只能保证一个共享变量的原子操作</strong>:</p>\n<blockquote>\n<p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了<strong>AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</strong></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"CAS在Java中的应用\"><a href=\"#CAS在Java中的应用\" class=\"headerlink\" title=\"CAS在Java中的应用\"></a>CAS在Java中的应用</h3><ul>\n<li>在Java中所有原子类都采用了CAS机制，并且在jdk1.5之后提供了AtomicStampedReference来解决上述提到的ABA问题；</li>\n<li>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用CAS机制来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：</li>\n</ul>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-12-27 20-39-35.png?raw=true\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>在Java中的原子类中频繁的使用CAS策略来保证数据更新的安全性，它是一种Lock-Free机制，这篇文章将会讲解CAS原理，以及它在Java中的应用。</p>","more":"<h3 id=\"Lock-Free\"><a href=\"#Lock-Free\" class=\"headerlink\" title=\"Lock-Free\"></a>Lock-Free</h3><blockquote>\n<p><em>如果一个方法是 Lock-Free 的, 它保证线程无限次调用这个方法都能够在有限步内完成.</em></p>\n</blockquote>\n<p>相比于传统的基于 Mutex 锁机制, Lock-Free 有下面的优势:</p>\n<ul>\n<li>Lock-Free 的速度更快</li>\n<li>线程之间不会相互影响, 没有死锁</li>\n<li>不受异步信号影响, 可重入</li>\n<li>不会发生线程优先级反转</li>\n</ul>\n<p>在通常使用 Mutex 互斥锁的场景, 有的线程抢占了锁, 其他线程则会被阻塞, 当获得锁的进程挂掉之后, 整个程序就 block 住了. 但在 Lock-Free 的程序中, 单个线程挂掉, 也不会影响其他线程, 因为线程之间不会相互影响.</p>\n<p>但是, Lock-Free 也有不少缺陷:</p>\n<ul>\n<li>只能利用有限的原子操作, 例如 CAS (操作的位数有限), 编码实现复杂</li>\n<li>竞争会加剧, 优先级不好控制</li>\n<li>测试时需要考虑各种软硬件环境, 很难做到尽善尽美</li>\n</ul>\n<p>再引入一个 Wait-Free 概念:</p>\n<blockquote>\n<p><em>假如一个方法是 Wait-Free 的, 那么它保证了每一次调用都可以在有限的步骤内结束.</em></p>\n</blockquote>\n<p>一般来说: <strong>阻塞 &gt; Lock-Free &gt; Wait-Free</strong></p>\n<h3 id=\"CAS原语\"><a href=\"#CAS原语\" class=\"headerlink\" title=\"CAS原语\"></a>CAS原语</h3><p>CAS (compare and swap) 是 CPU 硬件同步原语(primitive), CAS(V, A, B) 操作可以用下面的代码来示意:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">bool</span> <span class=\"title\">CAS</span>(<span class=\"title\">T</span>* <span class=\"title\">addr</span>, <span class=\"title\">T</span> <span class=\"title\">expect_val</span>, <span class=\"title\">T</span> <span class=\"title\">val</span>) &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*addr == expect_val) &#123;</span><br><span class=\"line\">        *addr = val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从 80486 开始, 所有的 Intel 处理器上, 通过一条汇编指令 CMPXCHG 即可实现 CAS 操作. CAS 的价值在于它是一个<strong>原子操作</strong>, 不会被 CPU中断或者其他方式打断, 因为在硬件层实现, 所以<strong>开销极小</strong>.</p>\n<p>CAS 并不是一项新技术, 它的使用可以追溯到 70 年代, 早在 80 年代就有很多经典书籍中提到使用 CAS 来实现并行编程, 如 USC 大牛 <a href=\"http://gridsec.usc.edu/Hwang.html\" target=\"_blank\" rel=\"noopener\">Kai HWang</a> 的 “Computer Architecture and Parallel Processing”.</p>\n<p>GCC 4.1+ 开始支持 CAS 的<a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html\" target=\"_blank\" rel=\"noopener\">原子操作</a>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">bool</span> __sync_bool_compare_and_swap (type *ptr, type oldval, type newval)</span><br><span class=\"line\">type __sync_val_compare_and_swap (type *ptr, type oldval, type newval)</span><br></pre></td></tr></table></figure>\n<p>通常将 CAS 用于同步的方式是从地址 V 读取值 A, 执行多步计算来获得新值 B, 然后使用 CAS 将 V 的值从 A 改为 B, 如果 V 处的值尚未同时更改, 则 CAS 操作成功.</p>\n<h3 id=\"CAS中的ABA问题\"><a href=\"#CAS中的ABA问题\" class=\"headerlink\" title=\"CAS中的ABA问题\"></a>CAS中的ABA问题</h3><p>ABA 问题描述:</p>\n<ul>\n<li>切换到线程 T1, 获取内存 V 的值 A</li>\n<li>切换到线程 T2, 获取内存 V 的值 A, 修改成 B, 然后再修改成 A</li>\n<li>切换到线程 T1, 获取内存 V 的值还是 A, 继续执行</li>\n</ul>\n<p><a href=\"http://coolshell.cn/articles/8239.html\" target=\"_blank\" rel=\"noopener\">coolshell 上有篇文章</a>给出了一个生动的例子(From 维基百科):</p>\n<blockquote>\n<p><em>你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了.</em></p>\n</blockquote>\n<p>更具有参考意义的是<a href=\"http://en.wikipedia.org/wiki/Hazard_pointer\" target=\"_blank\" rel=\"noopener\">Hazard Pointer Wiki</a>上提到的一个 Lock-Free 堆栈的例子:</p>\n<ul>\n<li>当前栈元素 [A, B, C], 栈顶 head 指向 A</li>\n<li>线程 T1 执行 pop() 准备 CAS(&amp;head, B, A)</li>\n<li>线程 T2 抢占, pop A, pop B, 然后 push A</li>\n<li>线程 T1 恢复, CAS(&amp;head, B, A) 成功, 则此时 head 指向一个被 pop 的元素 B</li>\n</ul>\n<p>CAS机制还存在其他问题：</p>\n<ul>\n<li><p><strong>循环时间长开销大:</strong></p>\n<blockquote>\n<p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>\n</blockquote>\n</li>\n<li><p><strong>只能保证一个共享变量的原子操作</strong>:</p>\n<blockquote>\n<p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了<strong>AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</strong></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"CAS在Java中的应用\"><a href=\"#CAS在Java中的应用\" class=\"headerlink\" title=\"CAS在Java中的应用\"></a>CAS在Java中的应用</h3><ul>\n<li>在Java中所有原子类都采用了CAS机制，并且在jdk1.5之后提供了AtomicStampedReference来解决上述提到的ABA问题；</li>\n<li>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用CAS机制来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：</li>\n</ul>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-12-27 20-39-35.png?raw=true\" alt=\"\"></p>"},{"title":"深入研究Java阻塞队列实现","date":"2018-10-15T07:24:55.000Z","_content":"\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/BlockingQueue.png?raw=true)\n\n<!-- more -->\n\n阻塞队列是一个非常常见的数据结构，比如在线程池中用阻塞队列存放任务，下面我们将围绕阻塞队列的实现对其源码进行深度剖析，主要讲解`ArrayBlockingQueue、PriorityBlockingQueue、SynchronousQueue和LinkedBlockingQueue`四大阻塞队列的实现。\n\n\n\n#### LinkedBlockingQueue\n\n* 双锁队列算法的变体\n* \n\n#### 优化\n\n* [Why copy final member field into local final variable?](https://stackoverflow.com/questions/2785964/in-arrayblockingqueue-why-copy-final-member-field-into-local-final-variable)\n* 双锁队列比单锁队列的好处？\n* LinkedBlockingQueue#dequeue()的优化\n\n```java\nprivate E dequeue() {\n    // assert takeLock.isHeldByCurrentThread();\n    // assert head.item == null;\n    Node<E> h = head;\n    Node<E> first = h.next;\n    h.next = h; // help GC\n    head = first;\n    E x = first.item;\n    first.item = null;\n    return x;\n}\n```\n\n#### 基本接口\n\n* offer()方法和put()方法的区别？","source":"_posts/java-blocking-queue.md","raw":"---\ntitle: 深入研究Java阻塞队列实现\ndate: 2018-10-15 15:24:55\ntags:\n    - java\n---\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/BlockingQueue.png?raw=true)\n\n<!-- more -->\n\n阻塞队列是一个非常常见的数据结构，比如在线程池中用阻塞队列存放任务，下面我们将围绕阻塞队列的实现对其源码进行深度剖析，主要讲解`ArrayBlockingQueue、PriorityBlockingQueue、SynchronousQueue和LinkedBlockingQueue`四大阻塞队列的实现。\n\n\n\n#### LinkedBlockingQueue\n\n* 双锁队列算法的变体\n* \n\n#### 优化\n\n* [Why copy final member field into local final variable?](https://stackoverflow.com/questions/2785964/in-arrayblockingqueue-why-copy-final-member-field-into-local-final-variable)\n* 双锁队列比单锁队列的好处？\n* LinkedBlockingQueue#dequeue()的优化\n\n```java\nprivate E dequeue() {\n    // assert takeLock.isHeldByCurrentThread();\n    // assert head.item == null;\n    Node<E> h = head;\n    Node<E> first = h.next;\n    h.next = h; // help GC\n    head = first;\n    E x = first.item;\n    first.item = null;\n    return x;\n}\n```\n\n#### 基本接口\n\n* offer()方法和put()方法的区别？","slug":"java-blocking-queue","published":1,"updated":"2019-01-11T04:07:42.674Z","_id":"cjq6kwn52001mzjiaijq128ll","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/BlockingQueue.png?raw=true\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>阻塞队列是一个非常常见的数据结构，比如在线程池中用阻塞队列存放任务，下面我们将围绕阻塞队列的实现对其源码进行深度剖析，主要讲解<code>ArrayBlockingQueue、PriorityBlockingQueue、SynchronousQueue和LinkedBlockingQueue</code>四大阻塞队列的实现。</p>\n<h4 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h4><ul>\n<li>双锁队列算法的变体</li>\n<li></li>\n</ul>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><ul>\n<li><a href=\"https://stackoverflow.com/questions/2785964/in-arrayblockingqueue-why-copy-final-member-field-into-local-final-variable\" target=\"_blank\" rel=\"noopener\">Why copy final member field into local final variable?</a></li>\n<li>双锁队列比单锁队列的好处？</li>\n<li>LinkedBlockingQueue#dequeue()的优化</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class=\"line\">    <span class=\"comment\">// assert head.item == null;</span></span><br><span class=\"line\">    Node&lt;E&gt; h = head;</span><br><span class=\"line\">    Node&lt;E&gt; first = h.next;</span><br><span class=\"line\">    h.next = h; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">    head = first;</span><br><span class=\"line\">    E x = first.item;</span><br><span class=\"line\">    first.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"基本接口\"><a href=\"#基本接口\" class=\"headerlink\" title=\"基本接口\"></a>基本接口</h4><ul>\n<li>offer()方法和put()方法的区别？</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/BlockingQueue.png?raw=true\" alt=\"\"></p>","more":"<p>阻塞队列是一个非常常见的数据结构，比如在线程池中用阻塞队列存放任务，下面我们将围绕阻塞队列的实现对其源码进行深度剖析，主要讲解<code>ArrayBlockingQueue、PriorityBlockingQueue、SynchronousQueue和LinkedBlockingQueue</code>四大阻塞队列的实现。</p>\n<h4 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h4><ul>\n<li>双锁队列算法的变体</li>\n<li></li>\n</ul>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><ul>\n<li><a href=\"https://stackoverflow.com/questions/2785964/in-arrayblockingqueue-why-copy-final-member-field-into-local-final-variable\" target=\"_blank\" rel=\"noopener\">Why copy final member field into local final variable?</a></li>\n<li>双锁队列比单锁队列的好处？</li>\n<li>LinkedBlockingQueue#dequeue()的优化</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">dequeue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class=\"line\">    <span class=\"comment\">// assert head.item == null;</span></span><br><span class=\"line\">    Node&lt;E&gt; h = head;</span><br><span class=\"line\">    Node&lt;E&gt; first = h.next;</span><br><span class=\"line\">    h.next = h; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">    head = first;</span><br><span class=\"line\">    E x = first.item;</span><br><span class=\"line\">    first.item = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"基本接口\"><a href=\"#基本接口\" class=\"headerlink\" title=\"基本接口\"></a>基本接口</h4><ul>\n<li>offer()方法和put()方法的区别？</li>\n</ul>"},{"title":"Java中常量池详解","date":"2016-07-26T02:07:15.000Z","_content":"\n>阅读这篇文章之前先来理解几个基本的概念\n\n\n* 什么是常量\n* equals()方法和==的区别\n* 引用和对象的区别\n\n### 1. String常量池\n\n#### 1.1 创建String对象的两种方式\n\n* 通过new来创建String创对象，例如：String a = new String(\"a\");\n* 直接将字符串常量赋值给一个对象引用，例如：String b = \"b\";\n\n    > 这两种不同的创建方法是有差别的，第一种方式是直接在Java heap内存空间创建一个新的对象，并且引用变量a指向这个对象，第二种方式是引用变量b指向常量池中的字符串。\n\n<!-- more -->\n\n#### 1.2 先来看一个Demo\n\n```java\npackage com.sh.oc.test;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.BlockJUnit4ClassRunner;\n\n/**\n * Created by Mr SJL on 2016/12/16.\n *\n * @Author Junlan Shuai\n */\n@RunWith(BlockJUnit4ClassRunner.class)\npublic class Test1\n{\n    @Test\n    public void test1()\n    {\n        String a = \"helloWorld\";\n        String b = \"helloWorld\";\n        String c = new String(\"helloWorld\");\n        String d = \"hello\";\n        String e = new String(\"hello\");\n        String temp = \"World\";\n        String f = \"hello\" + temp;\n        String g = \"hello\" + \"World\";\n\n\n        System.out.println(\"(1) a=b:\" + (a == b));\n        System.out.println(\"(2) b=c:\" + (b == c));\n        System.out.println(\"(3) a=d:\" + (a == (d + \"World\")));\n        System.out.println(\"(4) a=e:\" + (a == (e + \"World\")));\n        System.out.println(\"(5) c=d:\" + (c == (d + \"World\")));\n        System.out.println(\"(6) c=e:\" + (c == (e + \"World\")));\n        System.out.println(\"(7) a=g:\" + (a == g));\n        System.out.println(\"(8) a=f:\" + (a == f));\n    }\n}\n```\n\n> 结果输出：\n\n```java\n(1) a=b:true\n(2) b=c:false\n(3) a=d:false\n(4) a=e:false\n(5) c=d:false\n(6) c=e:false\n(7) a=g:true\n(8) a=f:false\n\nProcess finished with exit code 0\n```\n\n#### 1.3 总结：\n* 对于第(1)个结果，直接将相同的字符串常量赋值给字符串引用变量（后称‘变量’）a，b，在编译的时候该字符串直接保存在常量池中，同时变量a，b同时指向这个字符串常量，所以a==b返回true；\n* 第(2)个结果，对于变量c，是通过new一个对象（该对象保存在java heap中），然后变量c指向这个对象。故变量b和c指向的是不同的内存空间，b==c返回false；\n\n* 第(3)个结果，对于加法运算d + \"World\"在执行的时候，首先是通过创建一个StringBuilder对象，然后调用该对象的append()方法，最后调用该对象的toString()方法。也就是相当于执行了new StringBuilder().append(d).append(\"Word\").toString()。由StringBuilder源码可知，最后结果返回一个String对象(存放在java heap中)。故变量a和d指向不同的内存地址空间，虽然value是一样的，最终返回false。对于第(4)个结果，原理和(3)一样。\n\n    ```java\n    @Override\n    public String toString() {\n        // Create a copy, don't share the array\n        return new String(value, 0, count);\n    }\n    ```\n* 对于第(5)和(6)个结果，因为变量c指向的是在java heap中的一个String对象，并且加法运算(d + \"World\")，返回的也是一个String对象，但是它们指向的地址空间不同，故返回false。\n* 对于第(7)和(8)的结果，原理和前面相同。\n\n----\n持续更新中。。。。。。\n","source":"_posts/java-constant-pool.md","raw":"---\ntitle: Java中常量池详解\ndate: 2016-07-26 10:07:15\ntags:\n    - java\n---\n\n>阅读这篇文章之前先来理解几个基本的概念\n\n\n* 什么是常量\n* equals()方法和==的区别\n* 引用和对象的区别\n\n### 1. String常量池\n\n#### 1.1 创建String对象的两种方式\n\n* 通过new来创建String创对象，例如：String a = new String(\"a\");\n* 直接将字符串常量赋值给一个对象引用，例如：String b = \"b\";\n\n    > 这两种不同的创建方法是有差别的，第一种方式是直接在Java heap内存空间创建一个新的对象，并且引用变量a指向这个对象，第二种方式是引用变量b指向常量池中的字符串。\n\n<!-- more -->\n\n#### 1.2 先来看一个Demo\n\n```java\npackage com.sh.oc.test;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.BlockJUnit4ClassRunner;\n\n/**\n * Created by Mr SJL on 2016/12/16.\n *\n * @Author Junlan Shuai\n */\n@RunWith(BlockJUnit4ClassRunner.class)\npublic class Test1\n{\n    @Test\n    public void test1()\n    {\n        String a = \"helloWorld\";\n        String b = \"helloWorld\";\n        String c = new String(\"helloWorld\");\n        String d = \"hello\";\n        String e = new String(\"hello\");\n        String temp = \"World\";\n        String f = \"hello\" + temp;\n        String g = \"hello\" + \"World\";\n\n\n        System.out.println(\"(1) a=b:\" + (a == b));\n        System.out.println(\"(2) b=c:\" + (b == c));\n        System.out.println(\"(3) a=d:\" + (a == (d + \"World\")));\n        System.out.println(\"(4) a=e:\" + (a == (e + \"World\")));\n        System.out.println(\"(5) c=d:\" + (c == (d + \"World\")));\n        System.out.println(\"(6) c=e:\" + (c == (e + \"World\")));\n        System.out.println(\"(7) a=g:\" + (a == g));\n        System.out.println(\"(8) a=f:\" + (a == f));\n    }\n}\n```\n\n> 结果输出：\n\n```java\n(1) a=b:true\n(2) b=c:false\n(3) a=d:false\n(4) a=e:false\n(5) c=d:false\n(6) c=e:false\n(7) a=g:true\n(8) a=f:false\n\nProcess finished with exit code 0\n```\n\n#### 1.3 总结：\n* 对于第(1)个结果，直接将相同的字符串常量赋值给字符串引用变量（后称‘变量’）a，b，在编译的时候该字符串直接保存在常量池中，同时变量a，b同时指向这个字符串常量，所以a==b返回true；\n* 第(2)个结果，对于变量c，是通过new一个对象（该对象保存在java heap中），然后变量c指向这个对象。故变量b和c指向的是不同的内存空间，b==c返回false；\n\n* 第(3)个结果，对于加法运算d + \"World\"在执行的时候，首先是通过创建一个StringBuilder对象，然后调用该对象的append()方法，最后调用该对象的toString()方法。也就是相当于执行了new StringBuilder().append(d).append(\"Word\").toString()。由StringBuilder源码可知，最后结果返回一个String对象(存放在java heap中)。故变量a和d指向不同的内存地址空间，虽然value是一样的，最终返回false。对于第(4)个结果，原理和(3)一样。\n\n    ```java\n    @Override\n    public String toString() {\n        // Create a copy, don't share the array\n        return new String(value, 0, count);\n    }\n    ```\n* 对于第(5)和(6)个结果，因为变量c指向的是在java heap中的一个String对象，并且加法运算(d + \"World\")，返回的也是一个String对象，但是它们指向的地址空间不同，故返回false。\n* 对于第(7)和(8)的结果，原理和前面相同。\n\n----\n持续更新中。。。。。。\n","slug":"java-constant-pool","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn55001pzjiafiz5i81m","content":"<blockquote>\n<p>阅读这篇文章之前先来理解几个基本的概念</p>\n</blockquote>\n<ul>\n<li>什么是常量</li>\n<li>equals()方法和==的区别</li>\n<li>引用和对象的区别</li>\n</ul>\n<h3 id=\"1-String常量池\"><a href=\"#1-String常量池\" class=\"headerlink\" title=\"1. String常量池\"></a>1. String常量池</h3><h4 id=\"1-1-创建String对象的两种方式\"><a href=\"#1-1-创建String对象的两种方式\" class=\"headerlink\" title=\"1.1 创建String对象的两种方式\"></a>1.1 创建String对象的两种方式</h4><ul>\n<li>通过new来创建String创对象，例如：String a = new String(“a”);</li>\n<li><p>直接将字符串常量赋值给一个对象引用，例如：String b = “b”;</p>\n<blockquote>\n<p>这两种不同的创建方法是有差别的，第一种方式是直接在Java heap内存空间创建一个新的对象，并且引用变量a指向这个对象，第二种方式是引用变量b指向常量池中的字符串。</p>\n</blockquote>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"1-2-先来看一个Demo\"><a href=\"#1-2-先来看一个Demo\" class=\"headerlink\" title=\"1.2 先来看一个Demo\"></a>1.2 先来看一个Demo</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.oc.test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runners.BlockJUnit4ClassRunner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/12/16.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(BlockJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        String a = <span class=\"string\">\"helloWorld\"</span>;</span><br><span class=\"line\">        String b = <span class=\"string\">\"helloWorld\"</span>;</span><br><span class=\"line\">        String c = <span class=\"keyword\">new</span> String(<span class=\"string\">\"helloWorld\"</span>);</span><br><span class=\"line\">        String d = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">        String e = <span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">        String temp = <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\">        String f = <span class=\"string\">\"hello\"</span> + temp;</span><br><span class=\"line\">        String g = <span class=\"string\">\"hello\"</span> + <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(1) a=b:\"</span> + (a == b));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(2) b=c:\"</span> + (b == c));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(3) a=d:\"</span> + (a == (d + <span class=\"string\">\"World\"</span>)));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(4) a=e:\"</span> + (a == (e + <span class=\"string\">\"World\"</span>)));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(5) c=d:\"</span> + (c == (d + <span class=\"string\">\"World\"</span>)));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(6) c=e:\"</span> + (c == (e + <span class=\"string\">\"World\"</span>)));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(7) a=g:\"</span> + (a == g));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(8) a=f:\"</span> + (a == f));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>结果输出：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>) a=b:<span class=\"keyword\">true</span></span><br><span class=\"line\">(<span class=\"number\">2</span>) b=c:<span class=\"keyword\">false</span></span><br><span class=\"line\">(<span class=\"number\">3</span>) a=d:<span class=\"keyword\">false</span></span><br><span class=\"line\">(<span class=\"number\">4</span>) a=e:<span class=\"keyword\">false</span></span><br><span class=\"line\">(<span class=\"number\">5</span>) c=d:<span class=\"keyword\">false</span></span><br><span class=\"line\">(<span class=\"number\">6</span>) c=e:<span class=\"keyword\">false</span></span><br><span class=\"line\">(<span class=\"number\">7</span>) a=g:<span class=\"keyword\">true</span></span><br><span class=\"line\">(<span class=\"number\">8</span>) a=f:<span class=\"keyword\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-总结：\"><a href=\"#1-3-总结：\" class=\"headerlink\" title=\"1.3 总结：\"></a>1.3 总结：</h4><ul>\n<li>对于第(1)个结果，直接将相同的字符串常量赋值给字符串引用变量（后称‘变量’）a，b，在编译的时候该字符串直接保存在常量池中，同时变量a，b同时指向这个字符串常量，所以a==b返回true；</li>\n<li><p>第(2)个结果，对于变量c，是通过new一个对象（该对象保存在java heap中），然后变量c指向这个对象。故变量b和c指向的是不同的内存空间，b==c返回false；</p>\n</li>\n<li><p>第(3)个结果，对于加法运算d + “World”在执行的时候，首先是通过创建一个StringBuilder对象，然后调用该对象的append()方法，最后调用该对象的toString()方法。也就是相当于执行了new StringBuilder().append(d).append(“Word”).toString()。由StringBuilder源码可知，最后结果返回一个String对象(存放在java heap中)。故变量a和d指向不同的内存地址空间，虽然value是一样的，最终返回false。对于第(4)个结果，原理和(3)一样。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a copy, don't share the array</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(value, <span class=\"number\">0</span>, count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于第(5)和(6)个结果，因为变量c指向的是在java heap中的一个String对象，并且加法运算(d + “World”)，返回的也是一个String对象，但是它们指向的地址空间不同，故返回false。</p>\n</li>\n<li>对于第(7)和(8)的结果，原理和前面相同。</li>\n</ul>\n<hr>\n<p>持续更新中。。。。。。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>阅读这篇文章之前先来理解几个基本的概念</p>\n</blockquote>\n<ul>\n<li>什么是常量</li>\n<li>equals()方法和==的区别</li>\n<li>引用和对象的区别</li>\n</ul>\n<h3 id=\"1-String常量池\"><a href=\"#1-String常量池\" class=\"headerlink\" title=\"1. String常量池\"></a>1. String常量池</h3><h4 id=\"1-1-创建String对象的两种方式\"><a href=\"#1-1-创建String对象的两种方式\" class=\"headerlink\" title=\"1.1 创建String对象的两种方式\"></a>1.1 创建String对象的两种方式</h4><ul>\n<li>通过new来创建String创对象，例如：String a = new String(“a”);</li>\n<li><p>直接将字符串常量赋值给一个对象引用，例如：String b = “b”;</p>\n<blockquote>\n<p>这两种不同的创建方法是有差别的，第一种方式是直接在Java heap内存空间创建一个新的对象，并且引用变量a指向这个对象，第二种方式是引用变量b指向常量池中的字符串。</p>\n</blockquote>\n</li>\n</ul>","more":"<h4 id=\"1-2-先来看一个Demo\"><a href=\"#1-2-先来看一个Demo\" class=\"headerlink\" title=\"1.2 先来看一个Demo\"></a>1.2 先来看一个Demo</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.oc.test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runners.BlockJUnit4ClassRunner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/12/16.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(BlockJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        String a = <span class=\"string\">\"helloWorld\"</span>;</span><br><span class=\"line\">        String b = <span class=\"string\">\"helloWorld\"</span>;</span><br><span class=\"line\">        String c = <span class=\"keyword\">new</span> String(<span class=\"string\">\"helloWorld\"</span>);</span><br><span class=\"line\">        String d = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">        String e = <span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">        String temp = <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\">        String f = <span class=\"string\">\"hello\"</span> + temp;</span><br><span class=\"line\">        String g = <span class=\"string\">\"hello\"</span> + <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(1) a=b:\"</span> + (a == b));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(2) b=c:\"</span> + (b == c));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(3) a=d:\"</span> + (a == (d + <span class=\"string\">\"World\"</span>)));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(4) a=e:\"</span> + (a == (e + <span class=\"string\">\"World\"</span>)));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(5) c=d:\"</span> + (c == (d + <span class=\"string\">\"World\"</span>)));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(6) c=e:\"</span> + (c == (e + <span class=\"string\">\"World\"</span>)));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(7) a=g:\"</span> + (a == g));</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"(8) a=f:\"</span> + (a == f));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>结果输出：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">1</span>) a=b:<span class=\"keyword\">true</span></span><br><span class=\"line\">(<span class=\"number\">2</span>) b=c:<span class=\"keyword\">false</span></span><br><span class=\"line\">(<span class=\"number\">3</span>) a=d:<span class=\"keyword\">false</span></span><br><span class=\"line\">(<span class=\"number\">4</span>) a=e:<span class=\"keyword\">false</span></span><br><span class=\"line\">(<span class=\"number\">5</span>) c=d:<span class=\"keyword\">false</span></span><br><span class=\"line\">(<span class=\"number\">6</span>) c=e:<span class=\"keyword\">false</span></span><br><span class=\"line\">(<span class=\"number\">7</span>) a=g:<span class=\"keyword\">true</span></span><br><span class=\"line\">(<span class=\"number\">8</span>) a=f:<span class=\"keyword\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-总结：\"><a href=\"#1-3-总结：\" class=\"headerlink\" title=\"1.3 总结：\"></a>1.3 总结：</h4><ul>\n<li>对于第(1)个结果，直接将相同的字符串常量赋值给字符串引用变量（后称‘变量’）a，b，在编译的时候该字符串直接保存在常量池中，同时变量a，b同时指向这个字符串常量，所以a==b返回true；</li>\n<li><p>第(2)个结果，对于变量c，是通过new一个对象（该对象保存在java heap中），然后变量c指向这个对象。故变量b和c指向的是不同的内存空间，b==c返回false；</p>\n</li>\n<li><p>第(3)个结果，对于加法运算d + “World”在执行的时候，首先是通过创建一个StringBuilder对象，然后调用该对象的append()方法，最后调用该对象的toString()方法。也就是相当于执行了new StringBuilder().append(d).append(“Word”).toString()。由StringBuilder源码可知，最后结果返回一个String对象(存放在java heap中)。故变量a和d指向不同的内存地址空间，虽然value是一样的，最终返回false。对于第(4)个结果，原理和(3)一样。</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a copy, don't share the array</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(value, <span class=\"number\">0</span>, count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于第(5)和(6)个结果，因为变量c指向的是在java heap中的一个String对象，并且加法运算(d + “World”)，返回的也是一个String对象，但是它们指向的地址空间不同，故返回false。</p>\n</li>\n<li>对于第(7)和(8)的结果，原理和前面相同。</li>\n</ul>\n<hr>\n<p>持续更新中。。。。。。</p>"},{"title":"队列同步器(AbstractQueuedSynchronizer)源码分析","date":"2018-11-22T11:11:40.000Z","_content":"\n> `AbstractQueuedSynchronizer(队列同步器)`在Java并发工具中经常被用到，比如说我们常用的`CountDownLatch`、`ReentrantLock`、`ReentrantReadWriteLock`和`Semaphore`等等并发工具类底层都是基于`队列同步器`的，只有掌握了`队列同步器`底层的工作原理才能更好的理解其他的并发工具的工作机制，这篇文章将会从源码的角度分析`队列同步器`的工作原理。\n\n<!-- more -->\n\n队列同步器设计是基于模板方法的，使用者只需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。\n\n通过对队列同步器的API进行分析，主要通过三个方法来修改队列同步器的状态：\n\n* getState()  //获取当前的状态\n* setState()  //设置当前的同步状态\n* compareAndSetState()   //使用CAS机制设置当前的状态\n\n需要重写的方法：\n\n**独占操作**\n\n| 方法名称                              | 描述                                                         |\n| ------------------------------------- | ------------------------------------------------------------ |\n| protected boolean tryAcquire(int arg) | 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态 |\n| protected boolean tryRelease(int arg) | 独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态 |\n\n**共享操作**\n\n| 方法名称                                    | 描述                                                         |\n| ------------------------------------------- | ------------------------------------------------------------ |\n| protected int tryAcquireShared(int arg)     | 共享式获取同步状态，返回大于等于0，表示获取成功，反之获取失败 |\n| protected boolean tryReleaseShared(int arg) | 共享式释放同步状态                                           |\n| protected boolean isHeldExclusively()       | 当前同步器是否独占模式下被线程占用，一般该方法表示是否被当前线程所占用 |\n\n#### 同步队列\n\n队列同步器一来内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前显示获取同步状态失败时，队列同步器将会以当前线程以及等待状态等信息来构建一个Node节点，并将其加入同步队列的尾部，同时会阻塞当前线程，当同步状态释放时，会把同步队列的首节点中的线程唤醒，使其再次尝试获取同步状态。\n\n我们来看一下Node节点有哪些属性：\n\n| 属性类型和名称  | 描述                                                         |\n| --------------- | ------------------------------------------------------------ |\n| int waitStatus  | 等待状态，包含如下状态： <br> 1.CANCELLED，值为1，由于在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待。节点进入该状态将不会发生变化<br>2.SIGNAL，值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行<br>3.CONDITION，值为-2，表示当前节点正在条件队列（AQS下的ConditionObject里也维护了个队列）中，<br>在从conditionObject队列转移到同步队列前，它不会在同步队列（AQS下的队列）中被使用，当成功转移后，该节点的状态值将由CONDITION设置为0<br>4.PROPAGATE，值为-3，共享模式下的释放操作应该被传播到其他节点。该状态值在doReleaseShared方法中被设置的<br>5.INITIAL，值为0，初始状态 |\n| Node prev       | 前驱节点，当节点加入同步队列时被设置                         |\n| Node next       | 后继节点                                                     |\n| Node nextWaiter | ConditionObject链表的后继节点或者代表共享模式的节点SHARED。<br>Condition条件队列：因为Condition队列只能在独占模式下被能被访问， 我们只需要简单的使用链表队列来链接正在等待条件的节点。<br>再然后它们会被转移到同步队列（AQS队列）再次重新获取。由于条件队列只能在独占模式下使用，所以我们要表示共享模式的节点的话只要使用特殊值SHARED来标明即可。 |\n| Thread thread   | 节点所指向的线程                                             |\n\n\n\n#### 独占式同步状态获取与释放\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-11-23 20-17-54.png?raw=true)\n\n#### 共享式同步状态获取与释放\n\n#### 独占式超时获取同步状态\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-11-23 20-22-05.png?raw=true)\n\n#### 自定义同步组件\n\n\n\n#### Reference\n\n* 《Java并发编程的艺术》","source":"_posts/java-abstract-queued-synchronizer.md","raw":"---\ntitle: 队列同步器(AbstractQueuedSynchronizer)源码分析\ndate: 2018-11-22 19:11:40\ntags:\n    - java\n    - AQS\n---\n\n> `AbstractQueuedSynchronizer(队列同步器)`在Java并发工具中经常被用到，比如说我们常用的`CountDownLatch`、`ReentrantLock`、`ReentrantReadWriteLock`和`Semaphore`等等并发工具类底层都是基于`队列同步器`的，只有掌握了`队列同步器`底层的工作原理才能更好的理解其他的并发工具的工作机制，这篇文章将会从源码的角度分析`队列同步器`的工作原理。\n\n<!-- more -->\n\n队列同步器设计是基于模板方法的，使用者只需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。\n\n通过对队列同步器的API进行分析，主要通过三个方法来修改队列同步器的状态：\n\n* getState()  //获取当前的状态\n* setState()  //设置当前的同步状态\n* compareAndSetState()   //使用CAS机制设置当前的状态\n\n需要重写的方法：\n\n**独占操作**\n\n| 方法名称                              | 描述                                                         |\n| ------------------------------------- | ------------------------------------------------------------ |\n| protected boolean tryAcquire(int arg) | 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态 |\n| protected boolean tryRelease(int arg) | 独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态 |\n\n**共享操作**\n\n| 方法名称                                    | 描述                                                         |\n| ------------------------------------------- | ------------------------------------------------------------ |\n| protected int tryAcquireShared(int arg)     | 共享式获取同步状态，返回大于等于0，表示获取成功，反之获取失败 |\n| protected boolean tryReleaseShared(int arg) | 共享式释放同步状态                                           |\n| protected boolean isHeldExclusively()       | 当前同步器是否独占模式下被线程占用，一般该方法表示是否被当前线程所占用 |\n\n#### 同步队列\n\n队列同步器一来内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前显示获取同步状态失败时，队列同步器将会以当前线程以及等待状态等信息来构建一个Node节点，并将其加入同步队列的尾部，同时会阻塞当前线程，当同步状态释放时，会把同步队列的首节点中的线程唤醒，使其再次尝试获取同步状态。\n\n我们来看一下Node节点有哪些属性：\n\n| 属性类型和名称  | 描述                                                         |\n| --------------- | ------------------------------------------------------------ |\n| int waitStatus  | 等待状态，包含如下状态： <br> 1.CANCELLED，值为1，由于在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待。节点进入该状态将不会发生变化<br>2.SIGNAL，值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行<br>3.CONDITION，值为-2，表示当前节点正在条件队列（AQS下的ConditionObject里也维护了个队列）中，<br>在从conditionObject队列转移到同步队列前，它不会在同步队列（AQS下的队列）中被使用，当成功转移后，该节点的状态值将由CONDITION设置为0<br>4.PROPAGATE，值为-3，共享模式下的释放操作应该被传播到其他节点。该状态值在doReleaseShared方法中被设置的<br>5.INITIAL，值为0，初始状态 |\n| Node prev       | 前驱节点，当节点加入同步队列时被设置                         |\n| Node next       | 后继节点                                                     |\n| Node nextWaiter | ConditionObject链表的后继节点或者代表共享模式的节点SHARED。<br>Condition条件队列：因为Condition队列只能在独占模式下被能被访问， 我们只需要简单的使用链表队列来链接正在等待条件的节点。<br>再然后它们会被转移到同步队列（AQS队列）再次重新获取。由于条件队列只能在独占模式下使用，所以我们要表示共享模式的节点的话只要使用特殊值SHARED来标明即可。 |\n| Thread thread   | 节点所指向的线程                                             |\n\n\n\n#### 独占式同步状态获取与释放\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-11-23 20-17-54.png?raw=true)\n\n#### 共享式同步状态获取与释放\n\n#### 独占式超时获取同步状态\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-11-23 20-22-05.png?raw=true)\n\n#### 自定义同步组件\n\n\n\n#### Reference\n\n* 《Java并发编程的艺术》","slug":"java-abstract-queued-synchronizer","published":1,"updated":"2018-11-24T03:11:47.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn56001rzjian0f3utzc","content":"<blockquote>\n<p><code>AbstractQueuedSynchronizer(队列同步器)</code>在Java并发工具中经常被用到，比如说我们常用的<code>CountDownLatch</code>、<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>和<code>Semaphore</code>等等并发工具类底层都是基于<code>队列同步器</code>的，只有掌握了<code>队列同步器</code>底层的工作原理才能更好的理解其他的并发工具的工作机制，这篇文章将会从源码的角度分析<code>队列同步器</code>的工作原理。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>队列同步器设计是基于模板方法的，使用者只需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p>\n<p>通过对队列同步器的API进行分析，主要通过三个方法来修改队列同步器的状态：</p>\n<ul>\n<li>getState()  //获取当前的状态</li>\n<li>setState()  //设置当前的同步状态</li>\n<li>compareAndSetState()   //使用CAS机制设置当前的状态</li>\n</ul>\n<p>需要重写的方法：</p>\n<p><strong>独占操作</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>protected boolean tryAcquire(int arg)</td>\n<td>独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</td>\n</tr>\n<tr>\n<td>protected boolean tryRelease(int arg)</td>\n<td>独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</td>\n</tr>\n</tbody>\n</table>\n<p><strong>共享操作</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>protected int tryAcquireShared(int arg)</td>\n<td>共享式获取同步状态，返回大于等于0，表示获取成功，反之获取失败</td>\n</tr>\n<tr>\n<td>protected boolean tryReleaseShared(int arg)</td>\n<td>共享式释放同步状态</td>\n</tr>\n<tr>\n<td>protected boolean isHeldExclusively()</td>\n<td>当前同步器是否独占模式下被线程占用，一般该方法表示是否被当前线程所占用</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"同步队列\"><a href=\"#同步队列\" class=\"headerlink\" title=\"同步队列\"></a>同步队列</h4><p>队列同步器一来内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前显示获取同步状态失败时，队列同步器将会以当前线程以及等待状态等信息来构建一个Node节点，并将其加入同步队列的尾部，同时会阻塞当前线程，当同步状态释放时，会把同步队列的首节点中的线程唤醒，使其再次尝试获取同步状态。</p>\n<p>我们来看一下Node节点有哪些属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性类型和名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int waitStatus</td>\n<td>等待状态，包含如下状态： <br> 1.CANCELLED，值为1，由于在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待。节点进入该状态将不会发生变化<br>2.SIGNAL，值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行<br>3.CONDITION，值为-2，表示当前节点正在条件队列（AQS下的ConditionObject里也维护了个队列）中，<br>在从conditionObject队列转移到同步队列前，它不会在同步队列（AQS下的队列）中被使用，当成功转移后，该节点的状态值将由CONDITION设置为0<br>4.PROPAGATE，值为-3，共享模式下的释放操作应该被传播到其他节点。该状态值在doReleaseShared方法中被设置的<br>5.INITIAL，值为0，初始状态</td>\n</tr>\n<tr>\n<td>Node prev</td>\n<td>前驱节点，当节点加入同步队列时被设置</td>\n</tr>\n<tr>\n<td>Node next</td>\n<td>后继节点</td>\n</tr>\n<tr>\n<td>Node nextWaiter</td>\n<td>ConditionObject链表的后继节点或者代表共享模式的节点SHARED。<br>Condition条件队列：因为Condition队列只能在独占模式下被能被访问， 我们只需要简单的使用链表队列来链接正在等待条件的节点。<br>再然后它们会被转移到同步队列（AQS队列）再次重新获取。由于条件队列只能在独占模式下使用，所以我们要表示共享模式的节点的话只要使用特殊值SHARED来标明即可。</td>\n</tr>\n<tr>\n<td>Thread thread</td>\n<td>节点所指向的线程</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"独占式同步状态获取与释放\"><a href=\"#独占式同步状态获取与释放\" class=\"headerlink\" title=\"独占式同步状态获取与释放\"></a>独占式同步状态获取与释放</h4><p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-11-23 20-17-54.png?raw=true\" alt=\"\"></p>\n<h4 id=\"共享式同步状态获取与释放\"><a href=\"#共享式同步状态获取与释放\" class=\"headerlink\" title=\"共享式同步状态获取与释放\"></a>共享式同步状态获取与释放</h4><h4 id=\"独占式超时获取同步状态\"><a href=\"#独占式超时获取同步状态\" class=\"headerlink\" title=\"独占式超时获取同步状态\"></a>独占式超时获取同步状态</h4><p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-11-23 20-22-05.png?raw=true\" alt=\"\"></p>\n<h4 id=\"自定义同步组件\"><a href=\"#自定义同步组件\" class=\"headerlink\" title=\"自定义同步组件\"></a>自定义同步组件</h4><h4 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h4><ul>\n<li>《Java并发编程的艺术》</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><code>AbstractQueuedSynchronizer(队列同步器)</code>在Java并发工具中经常被用到，比如说我们常用的<code>CountDownLatch</code>、<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>和<code>Semaphore</code>等等并发工具类底层都是基于<code>队列同步器</code>的，只有掌握了<code>队列同步器</code>底层的工作原理才能更好的理解其他的并发工具的工作机制，这篇文章将会从源码的角度分析<code>队列同步器</code>的工作原理。</p>\n</blockquote>","more":"<p>队列同步器设计是基于模板方法的，使用者只需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p>\n<p>通过对队列同步器的API进行分析，主要通过三个方法来修改队列同步器的状态：</p>\n<ul>\n<li>getState()  //获取当前的状态</li>\n<li>setState()  //设置当前的同步状态</li>\n<li>compareAndSetState()   //使用CAS机制设置当前的状态</li>\n</ul>\n<p>需要重写的方法：</p>\n<p><strong>独占操作</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>protected boolean tryAcquire(int arg)</td>\n<td>独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</td>\n</tr>\n<tr>\n<td>protected boolean tryRelease(int arg)</td>\n<td>独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</td>\n</tr>\n</tbody>\n</table>\n<p><strong>共享操作</strong></p>\n<table>\n<thead>\n<tr>\n<th>方法名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>protected int tryAcquireShared(int arg)</td>\n<td>共享式获取同步状态，返回大于等于0，表示获取成功，反之获取失败</td>\n</tr>\n<tr>\n<td>protected boolean tryReleaseShared(int arg)</td>\n<td>共享式释放同步状态</td>\n</tr>\n<tr>\n<td>protected boolean isHeldExclusively()</td>\n<td>当前同步器是否独占模式下被线程占用，一般该方法表示是否被当前线程所占用</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"同步队列\"><a href=\"#同步队列\" class=\"headerlink\" title=\"同步队列\"></a>同步队列</h4><p>队列同步器一来内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前显示获取同步状态失败时，队列同步器将会以当前线程以及等待状态等信息来构建一个Node节点，并将其加入同步队列的尾部，同时会阻塞当前线程，当同步状态释放时，会把同步队列的首节点中的线程唤醒，使其再次尝试获取同步状态。</p>\n<p>我们来看一下Node节点有哪些属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性类型和名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int waitStatus</td>\n<td>等待状态，包含如下状态： <br> 1.CANCELLED，值为1，由于在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待。节点进入该状态将不会发生变化<br>2.SIGNAL，值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行<br>3.CONDITION，值为-2，表示当前节点正在条件队列（AQS下的ConditionObject里也维护了个队列）中，<br>在从conditionObject队列转移到同步队列前，它不会在同步队列（AQS下的队列）中被使用，当成功转移后，该节点的状态值将由CONDITION设置为0<br>4.PROPAGATE，值为-3，共享模式下的释放操作应该被传播到其他节点。该状态值在doReleaseShared方法中被设置的<br>5.INITIAL，值为0，初始状态</td>\n</tr>\n<tr>\n<td>Node prev</td>\n<td>前驱节点，当节点加入同步队列时被设置</td>\n</tr>\n<tr>\n<td>Node next</td>\n<td>后继节点</td>\n</tr>\n<tr>\n<td>Node nextWaiter</td>\n<td>ConditionObject链表的后继节点或者代表共享模式的节点SHARED。<br>Condition条件队列：因为Condition队列只能在独占模式下被能被访问， 我们只需要简单的使用链表队列来链接正在等待条件的节点。<br>再然后它们会被转移到同步队列（AQS队列）再次重新获取。由于条件队列只能在独占模式下使用，所以我们要表示共享模式的节点的话只要使用特殊值SHARED来标明即可。</td>\n</tr>\n<tr>\n<td>Thread thread</td>\n<td>节点所指向的线程</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"独占式同步状态获取与释放\"><a href=\"#独占式同步状态获取与释放\" class=\"headerlink\" title=\"独占式同步状态获取与释放\"></a>独占式同步状态获取与释放</h4><p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-11-23 20-17-54.png?raw=true\" alt=\"\"></p>\n<h4 id=\"共享式同步状态获取与释放\"><a href=\"#共享式同步状态获取与释放\" class=\"headerlink\" title=\"共享式同步状态获取与释放\"></a>共享式同步状态获取与释放</h4><h4 id=\"独占式超时获取同步状态\"><a href=\"#独占式超时获取同步状态\" class=\"headerlink\" title=\"独占式超时获取同步状态\"></a>独占式超时获取同步状态</h4><p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/Screenshot from 2018-11-23 20-22-05.png?raw=true\" alt=\"\"></p>\n<h4 id=\"自定义同步组件\"><a href=\"#自定义同步组件\" class=\"headerlink\" title=\"自定义同步组件\"></a>自定义同步组件</h4><h4 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h4><ul>\n<li>《Java并发编程的艺术》</li>\n</ul>"},{"title":"Java创建线程的三种方式(Thread/Runnable/Callable)","date":"2017-05-26T02:07:15.000Z","_content":"\n### 1.继承Thread类\n> 此方式只需要重写Thread类中的run()方法即可，示例如下：\n\n```java\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 19:41 2017/4/10.\n */\npublic class ExtendThread extends Thread\n{\n    String name;\n    public ExtendThread(String name)\n    {\n        this.name = name;\n    }\n    @Override\n    public void run()\n    {\n        System.out.println(name);\n    }\n}\n```\n\n<!-- more -->\n### 2.实现Runnable接口\n> 此方式只需要实现Runnable接口中的run()方法，示例如下：\n\n```java\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 19:40 2017/4/10.\n */\npublic class ImplRunnable implements Runnable\n{\n    public String name;\n    public ImplRunnable(String name)\n    {\n        this.name = name;\n    }\n    public void run()\n    {\n        System.out.println(name);\n    }\n}\n```\n### 3.实现Callable接口\n> 实现Callable接口中的calla()方法，示例如下：\n\n```java\nimport java.util.concurrent.Callable;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 19:43 2017/4/10.\n */\npublic class ImplCallable implements Callable<String>\n{\n    public String name;\n    public ImplCallable(String name)\n    {\n        this.name = name;\n    }\n    public String call() throws Exception\n    {\n        return name;\n    }\n}\n```\n### 4.Runnable和Callable的区别\n```java\npublic interface Callable<V> {\n    /**\n     * Computes a result, or throws an exception if unable to do so.\n     *\n     * @return computed result\n     * @throws Exception if unable to compute a result\n     */\n    V call() throws Exception;\n}\npublic interface Runnable {\n    /**\n     * When an object implementing interface <code>Runnable</code> is used\n     * to create a thread, starting the thread causes the object's\n     * <code>run</code> method to be called in that separately executing\n     * thread.\n     * <p>\n     * The general contract of the method <code>run</code> is that it may\n     * take any action whatsoever.\n     *\n     * @see     java.lang.Thread#run()\n     */\n    public abstract void run();\n}\n\n```\n* Callable中申明的方法是call(),Runnable中申明的方法是run();\n* Callable中的call()方法有返回值，而run()方法没有返回值;\n* call()方法可抛出异常，而run()方法则没有;\n### 5.Future详解\n\n```java\npublic interface Future<V> {\n    boolean cancel(boolean mayInterruptIfRunning);\n    boolean isCancelled();\n    boolean isDone();\n    V get() throws InterruptedException, ExecutionException;\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n```\n* cancel()方法：当参数为true时，直接终止当前执行的任务，当参数为false是允许当前的任务执行完成；\n* get()方法：等待任务执行完成，并可以获取任务执行完成的返回结果；\n\n> ExecutorService中所有的submit()方法都将返回一个Future，从而将Callable或Runnable提交给Executor，并得到一个Future来获得任务的执行结果或取消任务；\n\n### 附录：测试代码\n```java\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.BlockJUnit4ClassRunner;\nimport java.util.concurrent.*;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 19:45 2017/4/10.\n */\n@RunWith(BlockJUnit4ClassRunner.class)\npublic class Test1\n{\n    @Test\n    public void test1()\n    {\n        Thread thread = new ExtendThread(\"Junlan Shuai\");\n        thread.start();\n        try\n        {\n            Thread.sleep(1000);\n        } catch (InterruptedException e)\n        {\n            e.printStackTrace();\n        }\n    }\n    @Test\n    public void test2()\n    {\n        Thread thread = new Thread(new ImplRunnable(\"Junlan Shuai\"));\n        thread.start();\n        try\n        {\n            Thread.sleep(1000);\n        } catch (InterruptedException e)\n        {\n            e.printStackTrace();\n        }\n    }\n    @Test\n    public void test3()\n    {\n        ImplCallable implCallable = new ImplCallable(\"Junlan Shuai\");\n        ExecutorService es = Executors.newFixedThreadPool(3);\n        Future future = es.submit(implCallable);\n        try\n        {\n            System.out.println(future.get());\n            Thread.sleep(1000);\n        } catch (InterruptedException e)\n        {\n            e.printStackTrace();\n        } catch (ExecutionException e)\n        {\n            e.printStackTrace();\n        }\n    }\n}\n```\n","source":"_posts/java-creating-thread.md","raw":"---\ntitle: Java创建线程的三种方式(Thread/Runnable/Callable)\ndate: 2017-05-26 10:07:15\ntags:\n    - java\n    - MutliThread\n---\n\n### 1.继承Thread类\n> 此方式只需要重写Thread类中的run()方法即可，示例如下：\n\n```java\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 19:41 2017/4/10.\n */\npublic class ExtendThread extends Thread\n{\n    String name;\n    public ExtendThread(String name)\n    {\n        this.name = name;\n    }\n    @Override\n    public void run()\n    {\n        System.out.println(name);\n    }\n}\n```\n\n<!-- more -->\n### 2.实现Runnable接口\n> 此方式只需要实现Runnable接口中的run()方法，示例如下：\n\n```java\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 19:40 2017/4/10.\n */\npublic class ImplRunnable implements Runnable\n{\n    public String name;\n    public ImplRunnable(String name)\n    {\n        this.name = name;\n    }\n    public void run()\n    {\n        System.out.println(name);\n    }\n}\n```\n### 3.实现Callable接口\n> 实现Callable接口中的calla()方法，示例如下：\n\n```java\nimport java.util.concurrent.Callable;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 19:43 2017/4/10.\n */\npublic class ImplCallable implements Callable<String>\n{\n    public String name;\n    public ImplCallable(String name)\n    {\n        this.name = name;\n    }\n    public String call() throws Exception\n    {\n        return name;\n    }\n}\n```\n### 4.Runnable和Callable的区别\n```java\npublic interface Callable<V> {\n    /**\n     * Computes a result, or throws an exception if unable to do so.\n     *\n     * @return computed result\n     * @throws Exception if unable to compute a result\n     */\n    V call() throws Exception;\n}\npublic interface Runnable {\n    /**\n     * When an object implementing interface <code>Runnable</code> is used\n     * to create a thread, starting the thread causes the object's\n     * <code>run</code> method to be called in that separately executing\n     * thread.\n     * <p>\n     * The general contract of the method <code>run</code> is that it may\n     * take any action whatsoever.\n     *\n     * @see     java.lang.Thread#run()\n     */\n    public abstract void run();\n}\n\n```\n* Callable中申明的方法是call(),Runnable中申明的方法是run();\n* Callable中的call()方法有返回值，而run()方法没有返回值;\n* call()方法可抛出异常，而run()方法则没有;\n### 5.Future详解\n\n```java\npublic interface Future<V> {\n    boolean cancel(boolean mayInterruptIfRunning);\n    boolean isCancelled();\n    boolean isDone();\n    V get() throws InterruptedException, ExecutionException;\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n```\n* cancel()方法：当参数为true时，直接终止当前执行的任务，当参数为false是允许当前的任务执行完成；\n* get()方法：等待任务执行完成，并可以获取任务执行完成的返回结果；\n\n> ExecutorService中所有的submit()方法都将返回一个Future，从而将Callable或Runnable提交给Executor，并得到一个Future来获得任务的执行结果或取消任务；\n\n### 附录：测试代码\n```java\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.BlockJUnit4ClassRunner;\nimport java.util.concurrent.*;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 19:45 2017/4/10.\n */\n@RunWith(BlockJUnit4ClassRunner.class)\npublic class Test1\n{\n    @Test\n    public void test1()\n    {\n        Thread thread = new ExtendThread(\"Junlan Shuai\");\n        thread.start();\n        try\n        {\n            Thread.sleep(1000);\n        } catch (InterruptedException e)\n        {\n            e.printStackTrace();\n        }\n    }\n    @Test\n    public void test2()\n    {\n        Thread thread = new Thread(new ImplRunnable(\"Junlan Shuai\"));\n        thread.start();\n        try\n        {\n            Thread.sleep(1000);\n        } catch (InterruptedException e)\n        {\n            e.printStackTrace();\n        }\n    }\n    @Test\n    public void test3()\n    {\n        ImplCallable implCallable = new ImplCallable(\"Junlan Shuai\");\n        ExecutorService es = Executors.newFixedThreadPool(3);\n        Future future = es.submit(implCallable);\n        try\n        {\n            System.out.println(future.get());\n            Thread.sleep(1000);\n        } catch (InterruptedException e)\n        {\n            e.printStackTrace();\n        } catch (ExecutionException e)\n        {\n            e.printStackTrace();\n        }\n    }\n}\n```\n","slug":"java-creating-thread","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn58001uzjia1q8hdpgf","content":"<h3 id=\"1-继承Thread类\"><a href=\"#1-继承Thread类\" class=\"headerlink\" title=\"1.继承Thread类\"></a>1.继承Thread类</h3><blockquote>\n<p>此方式只需要重写Thread类中的run()方法即可，示例如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 19:41 2017/4/10.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExtendThread</span><span class=\"params\">(String name)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"2-实现Runnable接口\"><a href=\"#2-实现Runnable接口\" class=\"headerlink\" title=\"2.实现Runnable接口\"></a>2.实现Runnable接口</h3><blockquote>\n<p>此方式只需要实现Runnable接口中的run()方法，示例如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 19:40 2017/4/10.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImplRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ImplRunnable</span><span class=\"params\">(String name)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-实现Callable接口\"><a href=\"#3-实现Callable接口\" class=\"headerlink\" title=\"3.实现Callable接口\"></a>3.实现Callable接口</h3><blockquote>\n<p>实现Callable接口中的calla()方法，示例如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Callable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 19:43 2017/4/10.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImplCallable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ImplCallable</span><span class=\"params\">(String name)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-Runnable和Callable的区别\"><a href=\"#4-Runnable和Callable的区别\" class=\"headerlink\" title=\"4.Runnable和Callable的区别\"></a>4.Runnable和Callable的区别</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> computed result</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception if unable to compute a result</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class=\"line\"><span class=\"comment\">     * to create a thread, starting the thread causes the object's</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class=\"line\"><span class=\"comment\">     * thread.</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class=\"line\"><span class=\"comment\">     * take any action whatsoever.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@see</span>     java.lang.Thread#run()</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Callable中申明的方法是call(),Runnable中申明的方法是run();</li>\n<li>Callable中的call()方法有返回值，而run()方法没有返回值;</li>\n<li>call()方法可抛出异常，而run()方法则没有;<h3 id=\"5-Future详解\"><a href=\"#5-Future详解\" class=\"headerlink\" title=\"5.Future详解\"></a>5.Future详解</h3></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isCancelled</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isDone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>cancel()方法：当参数为true时，直接终止当前执行的任务，当参数为false是允许当前的任务执行完成；</li>\n<li>get()方法：等待任务执行完成，并可以获取任务执行完成的返回结果；</li>\n</ul>\n<blockquote>\n<p>ExecutorService中所有的submit()方法都将返回一个Future，从而将Callable或Runnable提交给Executor，并得到一个Future来获得任务的执行结果或取消任务；</p>\n</blockquote>\n<h3 id=\"附录：测试代码\"><a href=\"#附录：测试代码\" class=\"headerlink\" title=\"附录：测试代码\"></a>附录：测试代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runners.BlockJUnit4ClassRunner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 19:45 2017/4/10.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(BlockJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> ExtendThread(<span class=\"string\">\"Junlan Shuai\"</span>);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> ImplRunnable(<span class=\"string\">\"Junlan Shuai\"</span>));</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        ImplCallable implCallable = <span class=\"keyword\">new</span> ImplCallable(<span class=\"string\">\"Junlan Shuai\"</span>);</span><br><span class=\"line\">        ExecutorService es = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">        Future future = es.submit(implCallable);</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            System.out.println(future.get());</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-继承Thread类\"><a href=\"#1-继承Thread类\" class=\"headerlink\" title=\"1.继承Thread类\"></a>1.继承Thread类</h3><blockquote>\n<p>此方式只需要重写Thread类中的run()方法即可，示例如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 19:41 2017/4/10.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExtendThread</span><span class=\"params\">(String name)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"2-实现Runnable接口\"><a href=\"#2-实现Runnable接口\" class=\"headerlink\" title=\"2.实现Runnable接口\"></a>2.实现Runnable接口</h3><blockquote>\n<p>此方式只需要实现Runnable接口中的run()方法，示例如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 19:40 2017/4/10.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImplRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ImplRunnable</span><span class=\"params\">(String name)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        System.out.println(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-实现Callable接口\"><a href=\"#3-实现Callable接口\" class=\"headerlink\" title=\"3.实现Callable接口\"></a>3.实现Callable接口</h3><blockquote>\n<p>实现Callable接口中的calla()方法，示例如下：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Callable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 19:43 2017/4/10.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImplCallable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ImplCallable</span><span class=\"params\">(String name)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-Runnable和Callable的区别\"><a href=\"#4-Runnable和Callable的区别\" class=\"headerlink\" title=\"4.Runnable和Callable的区别\"></a>4.Runnable和Callable的区别</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> computed result</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception if unable to compute a result</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class=\"line\"><span class=\"comment\">     * to create a thread, starting the thread causes the object's</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class=\"line\"><span class=\"comment\">     * thread.</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class=\"line\"><span class=\"comment\">     * take any action whatsoever.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@see</span>     java.lang.Thread#run()</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Callable中申明的方法是call(),Runnable中申明的方法是run();</li>\n<li>Callable中的call()方法有返回值，而run()方法没有返回值;</li>\n<li>call()方法可抛出异常，而run()方法则没有;<h3 id=\"5-Future详解\"><a href=\"#5-Future详解\" class=\"headerlink\" title=\"5.Future详解\"></a>5.Future详解</h3></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isCancelled</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isDone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>cancel()方法：当参数为true时，直接终止当前执行的任务，当参数为false是允许当前的任务执行完成；</li>\n<li>get()方法：等待任务执行完成，并可以获取任务执行完成的返回结果；</li>\n</ul>\n<blockquote>\n<p>ExecutorService中所有的submit()方法都将返回一个Future，从而将Callable或Runnable提交给Executor，并得到一个Future来获得任务的执行结果或取消任务；</p>\n</blockquote>\n<h3 id=\"附录：测试代码\"><a href=\"#附录：测试代码\" class=\"headerlink\" title=\"附录：测试代码\"></a>附录：测试代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runner.RunWith;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.runners.BlockJUnit4ClassRunner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 19:45 2017/4/10.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(BlockJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> ExtendThread(<span class=\"string\">\"Junlan Shuai\"</span>);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> ImplRunnable(<span class=\"string\">\"Junlan Shuai\"</span>));</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test3</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        ImplCallable implCallable = <span class=\"keyword\">new</span> ImplCallable(<span class=\"string\">\"Junlan Shuai\"</span>);</span><br><span class=\"line\">        ExecutorService es = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">        Future future = es.submit(implCallable);</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            System.out.println(future.get());</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ExecutionException e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Java中Copy-On-Write容器","date":"2018-12-05T11:29:22.000Z","_content":"\nCopy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是`CopyOnWriteArrayList`和`CopyOnWriteArraySet`。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。\n\n<!-- more -->\n\n#### CopyOnWrite的缺点\n\nCopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。\n\n* **内存占用问题**。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象**（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）**。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。\n\n  针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。\n\n* **数据一致性问题**。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。\n\n#### Reference\n\n* http://ifeve.com/java-copy-on-write/\n\n* https://blog.csdn.net/qq_31780525/article/details/54375792","source":"_posts/java-copy-on-write.md","raw":"---\ntitle: Java中Copy-On-Write容器\ndate: 2018-12-05 19:29:22\ntags:\n    - java\n---\n\nCopy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是`CopyOnWriteArrayList`和`CopyOnWriteArraySet`。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。\n\n<!-- more -->\n\n#### CopyOnWrite的缺点\n\nCopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。\n\n* **内存占用问题**。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象**（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）**。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。\n\n  针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。\n\n* **数据一致性问题**。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。\n\n#### Reference\n\n* http://ifeve.com/java-copy-on-write/\n\n* https://blog.csdn.net/qq_31780525/article/details/54375792","slug":"java-copy-on-write","published":1,"updated":"2018-12-05T12:52:27.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5b001wzjiadqg270c7","content":"<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>\n<a id=\"more\"></a>\n<h4 id=\"CopyOnWrite的缺点\"><a href=\"#CopyOnWrite的缺点\" class=\"headerlink\" title=\"CopyOnWrite的缺点\"></a>CopyOnWrite的缺点</h4><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>\n<ul>\n<li><p><strong>内存占用问题</strong>。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象<strong>（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）</strong>。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>\n<p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>\n</li>\n<li><p><strong>数据一致性问题</strong>。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>\n</li>\n</ul>\n<h4 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h4><ul>\n<li><p><a href=\"http://ifeve.com/java-copy-on-write/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/java-copy-on-write/</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_31780525/article/details/54375792\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_31780525/article/details/54375792</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>","more":"<h4 id=\"CopyOnWrite的缺点\"><a href=\"#CopyOnWrite的缺点\" class=\"headerlink\" title=\"CopyOnWrite的缺点\"></a>CopyOnWrite的缺点</h4><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>\n<ul>\n<li><p><strong>内存占用问题</strong>。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象<strong>（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）</strong>。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p>\n<p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>\n</li>\n<li><p><strong>数据一致性问题</strong>。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>\n</li>\n</ul>\n<h4 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h4><ul>\n<li><p><a href=\"http://ifeve.com/java-copy-on-write/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/java-copy-on-write/</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_31780525/article/details/54375792\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_31780525/article/details/54375792</a></p>\n</li>\n</ul>"},{"title":"深入理解Java SPI机制","date":"2018-08-03T10:38:48.000Z","_content":"\n SPI的全名为Service Provider Interface，在java.util.ServiceLoader的[文档:https://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html](https://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html)中有比较详细的介绍。究其思想，其实和`Callback`差不多。`Callback`的思想是我们在调用API的时候，我们可以写入一段逻辑代码传到API里面，API内部在合适的时候会调用它，从而实现某种程度上的“定制”。\n\n典型的是`Collections.sort(List<T> list,Comparator<? super T> c)`这个方法，它的第二个参数是一个实现Comparator接口的实例。我们可以根据自己的排序规则写一个类，实现此接口，传入此方法，那么这个方法就会根据我们的规则对list进行排序。\n\n#### Java SPI的具体约定如下\n\n当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 \n\n基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。\n\nJDK提供服务实现查找的一个工具类：**java.util.ServiceLoader**\n\n<!-- more -->\n\n#### 实现一个Java SPI示例\n\n假设我们有一个日志服务`ILogService`，其只定义了一个`warn`方法用于输出日志信息，我们希望把它作为SPI，然后具体的实现由对应的服务提供者去实现。ILogService的定义如下:\n\n```java\npackage cn.shuaijunlan.spi;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 7:13 PM 2018/08/04.\n */\npublic interface ILogService {\n    void warn(String msg);\n}\n```\n\n然后基于这个服务接口实现了两个类，分别是`ConsoleLogServiceImpl`、`FileLogServiceImpl`，代码如下：\n\n```java\npackage cn.shuaijunlan.spi.impl;\n\nimport cn.shuaijunlan.spi.ILogService;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 7:14 PM 2018/08/04.\n */\npublic class ConsoleLogServiceImpl implements ILogService {\n    @Override\n    public void warn(String msg) {\n        System.out.println(\"Console log:\"+ msg + \"!\");\n    }\n}\n=======================================================================================\n\npackage cn.shuaijunlan.spi.impl;\n\nimport cn.shuaijunlan.spi.ILogService;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 7:15 PM 2018/08/04.\n */\npublic class FileLogServiceImpl implements ILogService {\n    @Override\n    public void warn(String msg) {\n        System.out.println(\"File log:\" + msg +\"!\");\n    }\n}\n```\n\n根据SPI的规范我们的服务实现类必须有一个无参构造方法。我们的SPI服务提供者需要将其在`classpath`下的`META-INF/services`目录下以服务接口全路径名命名的文件中写对应的实现类的全路径名称，每一行代表一个实现，如果需要注释信息可以使用**#**进行注释，根据官方的要求，这个文件的编码格式必须是UTF-8。我们示例中的ILogService的全路径名是`cn.shuaijunlan.spi.ILogService`，所以我们需要在类路径下的`META-INF/services`目录下创建一个名称为`cn.shuaijunlan.spi.ILogService`文件。在本示例中我们一个提供了两个实现，所以该文件的内容如下：\n\n```\n# Console log & File log\n\ncn.shuaijunlan.spi.impl.ConsoleLogServiceImpl\ncn.shuaijunlan.spi.impl.FileLogServiceImpl\n```\n\nServiceLoader是实现了java.util.Iterator接口的，而且是基于我们所使用的服务的实现，所以可以通过ServiceLoader的实例来遍历其中的服务实现者，从而调用对应的服务提供者。测试函数如下：\n\n```java\npackage cn.shuaijunlan.spi;\n\nimport java.util.Iterator;\nimport java.util.ServiceLoader;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 7:28 PM 2018/08/04.\n */\npublic class Main {\n    private static ServiceLoader<ILogService> services = ServiceLoader.load(ILogService.class);\n\n    public static void main(String[] args) {\n        Iterator<ILogService> iterator = services.iterator();\n        while (iterator.hasNext()){\n            iterator.next().warn(\"Hello SPI\");\n        }\n    }\n}\n\n```\n\n控制台输出结果如下：\n\n```\nConsole log:Hello SPI!\nFile log:Hello SPI!\n```\n\n基于SPI规范，我们最终实现了想要的结果。\n\n#### ServiceLoader源码分析\n\n在调用`ServiceLoader.load(ILogService.class);`时，代码进入：\n\n```java\npublic static <S> ServiceLoader<S> load(Class<S> service) {\n    //获取当前线程上下文类加载器\n    ClassLoader cl = Thread.currentThread().getContextClassLoader();\n    return ServiceLoader.load(service, cl);\n}\n```\n\n执行之后，程序进入`ServiceLoader.load(service, cl);`方法\n\n```java\npublic static <S> ServiceLoader<S> load(Class<S> service,\n                                        ClassLoader loader)\n{\n    return new ServiceLoader<>(service, loader);\n}\n```\n\n返回一个ServiceLoader的实例\n\n在调用`services.iterator();`方法时，返回一个Iterator容器\n\n```java\npublic Iterator<S> iterator() {\n    return new Iterator<S>() {\n\n        Iterator<Map.Entry<String,S>> knownProviders\n            = providers.entrySet().iterator();\n        //第一次执行hasNext方法时，knownProviders的size为0，会继续执行lookupIterator.hasNext()，最后进入到hasNextService方法中\n        public boolean hasNext() {\n            if (knownProviders.hasNext())\n                return true;\n            return lookupIterator.hasNext();\n        }\n\n        public S next() {\n            if (knownProviders.hasNext())\n                return knownProviders.next().getValue();\n            return lookupIterator.next();\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    };\n}\n```\n\n我们来看hasNextService方法：\n\n```java\nprivate boolean hasNextService() {\n    if (nextName != null) {\n        return true;\n    }\n    if (configs == null) {\n        try {\n            //获取接口的全名\n            String fullName = PREFIX + service.getName();\n            if (loader == null)\n                configs = ClassLoader.getSystemResources(fullName);\n            else\n                configs = loader.getResources(fullName);\n        } catch (IOException x) {\n            fail(service, \"Error locating configuration files\", x);\n        }\n    }\n    while ((pending == null) || !pending.hasNext()) {\n        if (!configs.hasMoreElements()) {\n            return false;\n        }\n        //获取所有实现类的全名，具体的解析函数查看parse函数\n        pending = parse(service, configs.nextElement());\n    }\n    nextName = pending.next();\n    return true;\n}\n```\n\n当调用`iterator.next()`方法时，会进入到：\n\n```java\nprivate S nextService() {\n    if (!hasNextService())\n        throw new NoSuchElementException();\n    String cn = nextName;\n    nextName = null;\n    Class<?> c = null;\n    try {\n        //生成名称为cn的Class对象，不进行初始化\n        c = Class.forName(cn, false, loader);\n    } catch (ClassNotFoundException x) {\n        //没找到类则会抛出异常\n        fail(service,\n             \"Provider \" + cn + \" not found\");\n    }\n    if (!service.isAssignableFrom(c)) {\n        fail(service,\n             \"Provider \" + cn  + \" not a subtype\");\n    }\n    try {\n        //进行实例化\n        S p = service.cast(c.newInstance());\n        providers.put(cn, p);\n        //返回实例\n        return p;\n    } catch (Throwable x) {\n        fail(service,\n             \"Provider \" + cn + \" could not be instantiated\",\n             x);\n    }\n    throw new Error();          // This cannot happen\n}\n```\n\n 在上述分析中我们可以看到ServiceLoader不是一实例化以后立马就去读配置文件中的服务实现者，并且进行对应的实例化工作的，而是会等到需要通过其Iterator实现获取对应的服务提供者时才会加载对应的配置文件进行解析，具体来说是在调用Iterator的hasNext方法时会去加载配置文件进行解析，在调用next方法时会将对应的服务提供者进行实例化并进行缓存。所有的配置文件只加载一次，服务提供者也只实例化一次，如需要重新加载配置文件可调用ServiceLoader的reload方法。\n\n#### 框架案例\n\n**1.common-logging**\n\napache最早提供的日志的门面接口。只有接口，没有实现。具体方案由各提供商实现，发现日志提供商是通过扫描 META-INF/services/org.apache.commons.logging.LogFactory配置文件，通过读取该文件的内容找到日志提供商实现类。只要我们的日志实现里包含了这个文件，并在文件里指定 LogFactory工厂接口的实现类即可。\n\n**2.jdbc**\n\njdbc4.0以前，开发人员还需要基于Class.forName(\"xxx\")的方式来装载驱动，jdbc4也基于spi的机制来发现驱动提供商了，可以通过META-INF/services/java.sql.Driver文件里指定实现类的方式来暴露驱动提供者。\n\n#### SPI不足之处\n\n* 通过上面的解析，可以发现，我们使用SPI查找具体的实现的时候，需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要实现。这应该也是最大的缺点，需要把所有的实现都实例化了，即便我们不需要，也都给实例化了。\n* 获取某个实现类的方式不够灵活，只能通过Iterator的形式获取，不能根据某个参数来获取对应的实现类。\n\n#### REFERENCES\n\n1.[https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html](https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html)\n\n2.[https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90](https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#comments)\n\n","source":"_posts/java-spi-introduction.md","raw":"---\ntitle: 深入理解Java SPI机制\ndate: 2018-08-03 18:38:48\ntags:\n    - java\n    - SPI\n---\n\n SPI的全名为Service Provider Interface，在java.util.ServiceLoader的[文档:https://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html](https://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html)中有比较详细的介绍。究其思想，其实和`Callback`差不多。`Callback`的思想是我们在调用API的时候，我们可以写入一段逻辑代码传到API里面，API内部在合适的时候会调用它，从而实现某种程度上的“定制”。\n\n典型的是`Collections.sort(List<T> list,Comparator<? super T> c)`这个方法，它的第二个参数是一个实现Comparator接口的实例。我们可以根据自己的排序规则写一个类，实现此接口，传入此方法，那么这个方法就会根据我们的规则对list进行排序。\n\n#### Java SPI的具体约定如下\n\n当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 \n\n基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。\n\nJDK提供服务实现查找的一个工具类：**java.util.ServiceLoader**\n\n<!-- more -->\n\n#### 实现一个Java SPI示例\n\n假设我们有一个日志服务`ILogService`，其只定义了一个`warn`方法用于输出日志信息，我们希望把它作为SPI，然后具体的实现由对应的服务提供者去实现。ILogService的定义如下:\n\n```java\npackage cn.shuaijunlan.spi;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 7:13 PM 2018/08/04.\n */\npublic interface ILogService {\n    void warn(String msg);\n}\n```\n\n然后基于这个服务接口实现了两个类，分别是`ConsoleLogServiceImpl`、`FileLogServiceImpl`，代码如下：\n\n```java\npackage cn.shuaijunlan.spi.impl;\n\nimport cn.shuaijunlan.spi.ILogService;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 7:14 PM 2018/08/04.\n */\npublic class ConsoleLogServiceImpl implements ILogService {\n    @Override\n    public void warn(String msg) {\n        System.out.println(\"Console log:\"+ msg + \"!\");\n    }\n}\n=======================================================================================\n\npackage cn.shuaijunlan.spi.impl;\n\nimport cn.shuaijunlan.spi.ILogService;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 7:15 PM 2018/08/04.\n */\npublic class FileLogServiceImpl implements ILogService {\n    @Override\n    public void warn(String msg) {\n        System.out.println(\"File log:\" + msg +\"!\");\n    }\n}\n```\n\n根据SPI的规范我们的服务实现类必须有一个无参构造方法。我们的SPI服务提供者需要将其在`classpath`下的`META-INF/services`目录下以服务接口全路径名命名的文件中写对应的实现类的全路径名称，每一行代表一个实现，如果需要注释信息可以使用**#**进行注释，根据官方的要求，这个文件的编码格式必须是UTF-8。我们示例中的ILogService的全路径名是`cn.shuaijunlan.spi.ILogService`，所以我们需要在类路径下的`META-INF/services`目录下创建一个名称为`cn.shuaijunlan.spi.ILogService`文件。在本示例中我们一个提供了两个实现，所以该文件的内容如下：\n\n```\n# Console log & File log\n\ncn.shuaijunlan.spi.impl.ConsoleLogServiceImpl\ncn.shuaijunlan.spi.impl.FileLogServiceImpl\n```\n\nServiceLoader是实现了java.util.Iterator接口的，而且是基于我们所使用的服务的实现，所以可以通过ServiceLoader的实例来遍历其中的服务实现者，从而调用对应的服务提供者。测试函数如下：\n\n```java\npackage cn.shuaijunlan.spi;\n\nimport java.util.Iterator;\nimport java.util.ServiceLoader;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 7:28 PM 2018/08/04.\n */\npublic class Main {\n    private static ServiceLoader<ILogService> services = ServiceLoader.load(ILogService.class);\n\n    public static void main(String[] args) {\n        Iterator<ILogService> iterator = services.iterator();\n        while (iterator.hasNext()){\n            iterator.next().warn(\"Hello SPI\");\n        }\n    }\n}\n\n```\n\n控制台输出结果如下：\n\n```\nConsole log:Hello SPI!\nFile log:Hello SPI!\n```\n\n基于SPI规范，我们最终实现了想要的结果。\n\n#### ServiceLoader源码分析\n\n在调用`ServiceLoader.load(ILogService.class);`时，代码进入：\n\n```java\npublic static <S> ServiceLoader<S> load(Class<S> service) {\n    //获取当前线程上下文类加载器\n    ClassLoader cl = Thread.currentThread().getContextClassLoader();\n    return ServiceLoader.load(service, cl);\n}\n```\n\n执行之后，程序进入`ServiceLoader.load(service, cl);`方法\n\n```java\npublic static <S> ServiceLoader<S> load(Class<S> service,\n                                        ClassLoader loader)\n{\n    return new ServiceLoader<>(service, loader);\n}\n```\n\n返回一个ServiceLoader的实例\n\n在调用`services.iterator();`方法时，返回一个Iterator容器\n\n```java\npublic Iterator<S> iterator() {\n    return new Iterator<S>() {\n\n        Iterator<Map.Entry<String,S>> knownProviders\n            = providers.entrySet().iterator();\n        //第一次执行hasNext方法时，knownProviders的size为0，会继续执行lookupIterator.hasNext()，最后进入到hasNextService方法中\n        public boolean hasNext() {\n            if (knownProviders.hasNext())\n                return true;\n            return lookupIterator.hasNext();\n        }\n\n        public S next() {\n            if (knownProviders.hasNext())\n                return knownProviders.next().getValue();\n            return lookupIterator.next();\n        }\n\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    };\n}\n```\n\n我们来看hasNextService方法：\n\n```java\nprivate boolean hasNextService() {\n    if (nextName != null) {\n        return true;\n    }\n    if (configs == null) {\n        try {\n            //获取接口的全名\n            String fullName = PREFIX + service.getName();\n            if (loader == null)\n                configs = ClassLoader.getSystemResources(fullName);\n            else\n                configs = loader.getResources(fullName);\n        } catch (IOException x) {\n            fail(service, \"Error locating configuration files\", x);\n        }\n    }\n    while ((pending == null) || !pending.hasNext()) {\n        if (!configs.hasMoreElements()) {\n            return false;\n        }\n        //获取所有实现类的全名，具体的解析函数查看parse函数\n        pending = parse(service, configs.nextElement());\n    }\n    nextName = pending.next();\n    return true;\n}\n```\n\n当调用`iterator.next()`方法时，会进入到：\n\n```java\nprivate S nextService() {\n    if (!hasNextService())\n        throw new NoSuchElementException();\n    String cn = nextName;\n    nextName = null;\n    Class<?> c = null;\n    try {\n        //生成名称为cn的Class对象，不进行初始化\n        c = Class.forName(cn, false, loader);\n    } catch (ClassNotFoundException x) {\n        //没找到类则会抛出异常\n        fail(service,\n             \"Provider \" + cn + \" not found\");\n    }\n    if (!service.isAssignableFrom(c)) {\n        fail(service,\n             \"Provider \" + cn  + \" not a subtype\");\n    }\n    try {\n        //进行实例化\n        S p = service.cast(c.newInstance());\n        providers.put(cn, p);\n        //返回实例\n        return p;\n    } catch (Throwable x) {\n        fail(service,\n             \"Provider \" + cn + \" could not be instantiated\",\n             x);\n    }\n    throw new Error();          // This cannot happen\n}\n```\n\n 在上述分析中我们可以看到ServiceLoader不是一实例化以后立马就去读配置文件中的服务实现者，并且进行对应的实例化工作的，而是会等到需要通过其Iterator实现获取对应的服务提供者时才会加载对应的配置文件进行解析，具体来说是在调用Iterator的hasNext方法时会去加载配置文件进行解析，在调用next方法时会将对应的服务提供者进行实例化并进行缓存。所有的配置文件只加载一次，服务提供者也只实例化一次，如需要重新加载配置文件可调用ServiceLoader的reload方法。\n\n#### 框架案例\n\n**1.common-logging**\n\napache最早提供的日志的门面接口。只有接口，没有实现。具体方案由各提供商实现，发现日志提供商是通过扫描 META-INF/services/org.apache.commons.logging.LogFactory配置文件，通过读取该文件的内容找到日志提供商实现类。只要我们的日志实现里包含了这个文件，并在文件里指定 LogFactory工厂接口的实现类即可。\n\n**2.jdbc**\n\njdbc4.0以前，开发人员还需要基于Class.forName(\"xxx\")的方式来装载驱动，jdbc4也基于spi的机制来发现驱动提供商了，可以通过META-INF/services/java.sql.Driver文件里指定实现类的方式来暴露驱动提供者。\n\n#### SPI不足之处\n\n* 通过上面的解析，可以发现，我们使用SPI查找具体的实现的时候，需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要实现。这应该也是最大的缺点，需要把所有的实现都实例化了，即便我们不需要，也都给实例化了。\n* 获取某个实现类的方式不够灵活，只能通过Iterator的形式获取，不能根据某个参数来获取对应的实现类。\n\n#### REFERENCES\n\n1.[https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html](https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html)\n\n2.[https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90](https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#comments)\n\n","slug":"java-spi-introduction","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5c001zzjiat7xsawre","content":"<p> SPI的全名为Service Provider Interface，在java.util.ServiceLoader的<a href=\"https://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html\" target=\"_blank\" rel=\"noopener\">文档:https://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html</a>中有比较详细的介绍。究其思想，其实和<code>Callback</code>差不多。<code>Callback</code>的思想是我们在调用API的时候，我们可以写入一段逻辑代码传到API里面，API内部在合适的时候会调用它，从而实现某种程度上的“定制”。</p>\n<p>典型的是<code>Collections.sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)</code>这个方法，它的第二个参数是一个实现Comparator接口的实例。我们可以根据自己的排序规则写一个类，实现此接口，传入此方法，那么这个方法就会根据我们的规则对list进行排序。</p>\n<h4 id=\"Java-SPI的具体约定如下\"><a href=\"#Java-SPI的具体约定如下\" class=\"headerlink\" title=\"Java SPI的具体约定如下\"></a>Java SPI的具体约定如下</h4><p>当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 </p>\n<p>基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。</p>\n<p>JDK提供服务实现查找的一个工具类：<strong>java.util.ServiceLoader</strong></p>\n<a id=\"more\"></a>\n<h4 id=\"实现一个Java-SPI示例\"><a href=\"#实现一个Java-SPI示例\" class=\"headerlink\" title=\"实现一个Java SPI示例\"></a>实现一个Java SPI示例</h4><p>假设我们有一个日志服务<code>ILogService</code>，其只定义了一个<code>warn</code>方法用于输出日志信息，我们希望把它作为SPI，然后具体的实现由对应的服务提供者去实现。ILogService的定义如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.shuaijunlan.spi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 7:13 PM 2018/08/04.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ILogService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">warn</span><span class=\"params\">(String msg)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后基于这个服务接口实现了两个类，分别是<code>ConsoleLogServiceImpl</code>、<code>FileLogServiceImpl</code>，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.shuaijunlan.spi.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> cn.shuaijunlan.spi.ILogService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 7:14 PM 2018/08/04.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsoleLogServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ILogService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">warn</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Console log:\"</span>+ msg + <span class=\"string\">\"!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">=======================================================================================</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> cn.shuaijunlan.spi.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> cn.shuaijunlan.spi.ILogService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 7:15 PM 2018/08/04.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileLogServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ILogService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">warn</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"File log:\"</span> + msg +<span class=\"string\">\"!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据SPI的规范我们的服务实现类必须有一个无参构造方法。我们的SPI服务提供者需要将其在<code>classpath</code>下的<code>META-INF/services</code>目录下以服务接口全路径名命名的文件中写对应的实现类的全路径名称，每一行代表一个实现，如果需要注释信息可以使用<strong>#</strong>进行注释，根据官方的要求，这个文件的编码格式必须是UTF-8。我们示例中的ILogService的全路径名是<code>cn.shuaijunlan.spi.ILogService</code>，所以我们需要在类路径下的<code>META-INF/services</code>目录下创建一个名称为<code>cn.shuaijunlan.spi.ILogService</code>文件。在本示例中我们一个提供了两个实现，所以该文件的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Console log &amp; File log</span><br><span class=\"line\"></span><br><span class=\"line\">cn.shuaijunlan.spi.impl.ConsoleLogServiceImpl</span><br><span class=\"line\">cn.shuaijunlan.spi.impl.FileLogServiceImpl</span><br></pre></td></tr></table></figure>\n<p>ServiceLoader是实现了java.util.Iterator接口的，而且是基于我们所使用的服务的实现，所以可以通过ServiceLoader的实例来遍历其中的服务实现者，从而调用对应的服务提供者。测试函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.shuaijunlan.spi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ServiceLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 7:28 PM 2018/08/04.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ServiceLoader&lt;ILogService&gt; services = ServiceLoader.load(ILogService.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Iterator&lt;ILogService&gt; iterator = services.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator.hasNext())&#123;</span><br><span class=\"line\">            iterator.next().warn(<span class=\"string\">\"Hello SPI\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Console log:Hello SPI!</span><br><span class=\"line\">File log:Hello SPI!</span><br></pre></td></tr></table></figure>\n<p>基于SPI规范，我们最终实现了想要的结果。</p>\n<h4 id=\"ServiceLoader源码分析\"><a href=\"#ServiceLoader源码分析\" class=\"headerlink\" title=\"ServiceLoader源码分析\"></a>ServiceLoader源码分析</h4><p>在调用<code>ServiceLoader.load(ILogService.class);</code>时，代码进入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;S&gt; <span class=\"function\">ServiceLoader&lt;S&gt; <span class=\"title\">load</span><span class=\"params\">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取当前线程上下文类加载器</span></span><br><span class=\"line\">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ServiceLoader.load(service, cl);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行之后，程序进入<code>ServiceLoader.load(service, cl);</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;S&gt; <span class=\"function\">ServiceLoader&lt;S&gt; <span class=\"title\">load</span><span class=\"params\">(Class&lt;S&gt; service,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                        ClassLoader loader)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回一个ServiceLoader的实例</p>\n<p>在调用<code>services.iterator();</code>方法时，返回一个Iterator容器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;S&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class=\"line\">            = providers.entrySet().iterator();</span><br><span class=\"line\">        <span class=\"comment\">//第一次执行hasNext方法时，knownProviders的size为0，会继续执行lookupIterator.hasNext()，最后进入到hasNextService方法中</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (knownProviders.hasNext())</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lookupIterator.hasNext();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> S <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (knownProviders.hasNext())</span><br><span class=\"line\">                <span class=\"keyword\">return</span> knownProviders.next().getValue();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lookupIterator.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来看hasNextService方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNextService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextName != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configs == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取接口的全名</span></span><br><span class=\"line\">            String fullName = PREFIX + service.getName();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (loader == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                configs = loader.getResources(fullName);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException x) &#123;</span><br><span class=\"line\">            fail(service, <span class=\"string\">\"Error locating configuration files\"</span>, x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((pending == <span class=\"keyword\">null</span>) || !pending.hasNext()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取所有实现类的全名，具体的解析函数查看parse函数</span></span><br><span class=\"line\">        pending = parse(service, configs.nextElement());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextName = pending.next();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当调用<code>iterator.next()</code>方法时，会进入到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> S <span class=\"title\">nextService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasNextService())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    String cn = nextName;</span><br><span class=\"line\">    nextName = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Class&lt;?&gt; c = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//生成名称为cn的Class对象，不进行初始化</span></span><br><span class=\"line\">        c = Class.forName(cn, <span class=\"keyword\">false</span>, loader);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException x) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//没找到类则会抛出异常</span></span><br><span class=\"line\">        fail(service,</span><br><span class=\"line\">             <span class=\"string\">\"Provider \"</span> + cn + <span class=\"string\">\" not found\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class=\"line\">        fail(service,</span><br><span class=\"line\">             <span class=\"string\">\"Provider \"</span> + cn  + <span class=\"string\">\" not a subtype\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//进行实例化</span></span><br><span class=\"line\">        S p = service.cast(c.newInstance());</span><br><span class=\"line\">        providers.put(cn, p);</span><br><span class=\"line\">        <span class=\"comment\">//返回实例</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">        fail(service,</span><br><span class=\"line\">             <span class=\"string\">\"Provider \"</span> + cn + <span class=\"string\">\" could not be instantiated\"</span>,</span><br><span class=\"line\">             x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error();          <span class=\"comment\">// This cannot happen</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 在上述分析中我们可以看到ServiceLoader不是一实例化以后立马就去读配置文件中的服务实现者，并且进行对应的实例化工作的，而是会等到需要通过其Iterator实现获取对应的服务提供者时才会加载对应的配置文件进行解析，具体来说是在调用Iterator的hasNext方法时会去加载配置文件进行解析，在调用next方法时会将对应的服务提供者进行实例化并进行缓存。所有的配置文件只加载一次，服务提供者也只实例化一次，如需要重新加载配置文件可调用ServiceLoader的reload方法。</p>\n<h4 id=\"框架案例\"><a href=\"#框架案例\" class=\"headerlink\" title=\"框架案例\"></a>框架案例</h4><p><strong>1.common-logging</strong></p>\n<p>apache最早提供的日志的门面接口。只有接口，没有实现。具体方案由各提供商实现，发现日志提供商是通过扫描 META-INF/services/org.apache.commons.logging.LogFactory配置文件，通过读取该文件的内容找到日志提供商实现类。只要我们的日志实现里包含了这个文件，并在文件里指定 LogFactory工厂接口的实现类即可。</p>\n<p><strong>2.jdbc</strong></p>\n<p>jdbc4.0以前，开发人员还需要基于Class.forName(“xxx”)的方式来装载驱动，jdbc4也基于spi的机制来发现驱动提供商了，可以通过META-INF/services/java.sql.Driver文件里指定实现类的方式来暴露驱动提供者。</p>\n<h4 id=\"SPI不足之处\"><a href=\"#SPI不足之处\" class=\"headerlink\" title=\"SPI不足之处\"></a>SPI不足之处</h4><ul>\n<li>通过上面的解析，可以发现，我们使用SPI查找具体的实现的时候，需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要实现。这应该也是最大的缺点，需要把所有的实现都实例化了，即便我们不需要，也都给实例化了。</li>\n<li>获取某个实现类的方式不够灵活，只能通过Iterator的形式获取，不能根据某个参数来获取对应的实现类。</li>\n</ul>\n<h4 id=\"REFERENCES\"><a href=\"#REFERENCES\" class=\"headerlink\" title=\"REFERENCES\"></a>REFERENCES</h4><p>1.<a href=\"https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html</a></p>\n<p>2.<a href=\"https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#comments\" target=\"_blank\" rel=\"noopener\">https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</a></p>\n","site":{"data":{}},"excerpt":"<p> SPI的全名为Service Provider Interface，在java.util.ServiceLoader的<a href=\"https://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html\" target=\"_blank\" rel=\"noopener\">文档:https://docs.oracle.com/javase/6/docs/api/java/util/ServiceLoader.html</a>中有比较详细的介绍。究其思想，其实和<code>Callback</code>差不多。<code>Callback</code>的思想是我们在调用API的时候，我们可以写入一段逻辑代码传到API里面，API内部在合适的时候会调用它，从而实现某种程度上的“定制”。</p>\n<p>典型的是<code>Collections.sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)</code>这个方法，它的第二个参数是一个实现Comparator接口的实例。我们可以根据自己的排序规则写一个类，实现此接口，传入此方法，那么这个方法就会根据我们的规则对list进行排序。</p>\n<h4 id=\"Java-SPI的具体约定如下\"><a href=\"#Java-SPI的具体约定如下\" class=\"headerlink\" title=\"Java SPI的具体约定如下\"></a>Java SPI的具体约定如下</h4><p>当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 </p>\n<p>基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。</p>\n<p>JDK提供服务实现查找的一个工具类：<strong>java.util.ServiceLoader</strong></p>","more":"<h4 id=\"实现一个Java-SPI示例\"><a href=\"#实现一个Java-SPI示例\" class=\"headerlink\" title=\"实现一个Java SPI示例\"></a>实现一个Java SPI示例</h4><p>假设我们有一个日志服务<code>ILogService</code>，其只定义了一个<code>warn</code>方法用于输出日志信息，我们希望把它作为SPI，然后具体的实现由对应的服务提供者去实现。ILogService的定义如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.shuaijunlan.spi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 7:13 PM 2018/08/04.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ILogService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">warn</span><span class=\"params\">(String msg)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后基于这个服务接口实现了两个类，分别是<code>ConsoleLogServiceImpl</code>、<code>FileLogServiceImpl</code>，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.shuaijunlan.spi.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> cn.shuaijunlan.spi.ILogService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 7:14 PM 2018/08/04.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConsoleLogServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ILogService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">warn</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Console log:\"</span>+ msg + <span class=\"string\">\"!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">=======================================================================================</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> cn.shuaijunlan.spi.impl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> cn.shuaijunlan.spi.ILogService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 7:15 PM 2018/08/04.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileLogServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">ILogService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">warn</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"File log:\"</span> + msg +<span class=\"string\">\"!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据SPI的规范我们的服务实现类必须有一个无参构造方法。我们的SPI服务提供者需要将其在<code>classpath</code>下的<code>META-INF/services</code>目录下以服务接口全路径名命名的文件中写对应的实现类的全路径名称，每一行代表一个实现，如果需要注释信息可以使用<strong>#</strong>进行注释，根据官方的要求，这个文件的编码格式必须是UTF-8。我们示例中的ILogService的全路径名是<code>cn.shuaijunlan.spi.ILogService</code>，所以我们需要在类路径下的<code>META-INF/services</code>目录下创建一个名称为<code>cn.shuaijunlan.spi.ILogService</code>文件。在本示例中我们一个提供了两个实现，所以该文件的内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Console log &amp; File log</span><br><span class=\"line\"></span><br><span class=\"line\">cn.shuaijunlan.spi.impl.ConsoleLogServiceImpl</span><br><span class=\"line\">cn.shuaijunlan.spi.impl.FileLogServiceImpl</span><br></pre></td></tr></table></figure>\n<p>ServiceLoader是实现了java.util.Iterator接口的，而且是基于我们所使用的服务的实现，所以可以通过ServiceLoader的实例来遍历其中的服务实现者，从而调用对应的服务提供者。测试函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.shuaijunlan.spi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ServiceLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 7:28 PM 2018/08/04.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ServiceLoader&lt;ILogService&gt; services = ServiceLoader.load(ILogService.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Iterator&lt;ILogService&gt; iterator = services.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iterator.hasNext())&#123;</span><br><span class=\"line\">            iterator.next().warn(<span class=\"string\">\"Hello SPI\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Console log:Hello SPI!</span><br><span class=\"line\">File log:Hello SPI!</span><br></pre></td></tr></table></figure>\n<p>基于SPI规范，我们最终实现了想要的结果。</p>\n<h4 id=\"ServiceLoader源码分析\"><a href=\"#ServiceLoader源码分析\" class=\"headerlink\" title=\"ServiceLoader源码分析\"></a>ServiceLoader源码分析</h4><p>在调用<code>ServiceLoader.load(ILogService.class);</code>时，代码进入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;S&gt; <span class=\"function\">ServiceLoader&lt;S&gt; <span class=\"title\">load</span><span class=\"params\">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取当前线程上下文类加载器</span></span><br><span class=\"line\">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ServiceLoader.load(service, cl);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行之后，程序进入<code>ServiceLoader.load(service, cl);</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;S&gt; <span class=\"function\">ServiceLoader&lt;S&gt; <span class=\"title\">load</span><span class=\"params\">(Class&lt;S&gt; service,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                        ClassLoader loader)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>返回一个ServiceLoader的实例</p>\n<p>在调用<code>services.iterator();</code>方法时，返回一个Iterator容器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;S&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class=\"line\">            = providers.entrySet().iterator();</span><br><span class=\"line\">        <span class=\"comment\">//第一次执行hasNext方法时，knownProviders的size为0，会继续执行lookupIterator.hasNext()，最后进入到hasNextService方法中</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (knownProviders.hasNext())</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lookupIterator.hasNext();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> S <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (knownProviders.hasNext())</span><br><span class=\"line\">                <span class=\"keyword\">return</span> knownProviders.next().getValue();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lookupIterator.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来看hasNextService方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNextService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextName != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (configs == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取接口的全名</span></span><br><span class=\"line\">            String fullName = PREFIX + service.getName();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (loader == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                configs = loader.getResources(fullName);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException x) &#123;</span><br><span class=\"line\">            fail(service, <span class=\"string\">\"Error locating configuration files\"</span>, x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((pending == <span class=\"keyword\">null</span>) || !pending.hasNext()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取所有实现类的全名，具体的解析函数查看parse函数</span></span><br><span class=\"line\">        pending = parse(service, configs.nextElement());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    nextName = pending.next();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当调用<code>iterator.next()</code>方法时，会进入到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> S <span class=\"title\">nextService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasNextService())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">    String cn = nextName;</span><br><span class=\"line\">    nextName = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Class&lt;?&gt; c = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//生成名称为cn的Class对象，不进行初始化</span></span><br><span class=\"line\">        c = Class.forName(cn, <span class=\"keyword\">false</span>, loader);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException x) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//没找到类则会抛出异常</span></span><br><span class=\"line\">        fail(service,</span><br><span class=\"line\">             <span class=\"string\">\"Provider \"</span> + cn + <span class=\"string\">\" not found\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class=\"line\">        fail(service,</span><br><span class=\"line\">             <span class=\"string\">\"Provider \"</span> + cn  + <span class=\"string\">\" not a subtype\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//进行实例化</span></span><br><span class=\"line\">        S p = service.cast(c.newInstance());</span><br><span class=\"line\">        providers.put(cn, p);</span><br><span class=\"line\">        <span class=\"comment\">//返回实例</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">        fail(service,</span><br><span class=\"line\">             <span class=\"string\">\"Provider \"</span> + cn + <span class=\"string\">\" could not be instantiated\"</span>,</span><br><span class=\"line\">             x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error();          <span class=\"comment\">// This cannot happen</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 在上述分析中我们可以看到ServiceLoader不是一实例化以后立马就去读配置文件中的服务实现者，并且进行对应的实例化工作的，而是会等到需要通过其Iterator实现获取对应的服务提供者时才会加载对应的配置文件进行解析，具体来说是在调用Iterator的hasNext方法时会去加载配置文件进行解析，在调用next方法时会将对应的服务提供者进行实例化并进行缓存。所有的配置文件只加载一次，服务提供者也只实例化一次，如需要重新加载配置文件可调用ServiceLoader的reload方法。</p>\n<h4 id=\"框架案例\"><a href=\"#框架案例\" class=\"headerlink\" title=\"框架案例\"></a>框架案例</h4><p><strong>1.common-logging</strong></p>\n<p>apache最早提供的日志的门面接口。只有接口，没有实现。具体方案由各提供商实现，发现日志提供商是通过扫描 META-INF/services/org.apache.commons.logging.LogFactory配置文件，通过读取该文件的内容找到日志提供商实现类。只要我们的日志实现里包含了这个文件，并在文件里指定 LogFactory工厂接口的实现类即可。</p>\n<p><strong>2.jdbc</strong></p>\n<p>jdbc4.0以前，开发人员还需要基于Class.forName(“xxx”)的方式来装载驱动，jdbc4也基于spi的机制来发现驱动提供商了，可以通过META-INF/services/java.sql.Driver文件里指定实现类的方式来暴露驱动提供者。</p>\n<h4 id=\"SPI不足之处\"><a href=\"#SPI不足之处\" class=\"headerlink\" title=\"SPI不足之处\"></a>SPI不足之处</h4><ul>\n<li>通过上面的解析，可以发现，我们使用SPI查找具体的实现的时候，需要遍历所有的实现，并实例化，然后我们在循环中才能找到我们需要实现。这应该也是最大的缺点，需要把所有的实现都实例化了，即便我们不需要，也都给实例化了。</li>\n<li>获取某个实现类的方式不够灵活，只能通过Iterator的形式获取，不能根据某个参数来获取对应的实现类。</li>\n</ul>\n<h4 id=\"REFERENCES\"><a href=\"#REFERENCES\" class=\"headerlink\" title=\"REFERENCES\"></a>REFERENCES</h4><p>1.<a href=\"https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html</a></p>\n<p>2.<a href=\"https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#comments\" target=\"_blank\" rel=\"noopener\">https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</a></p>"},{"title":"Java线程池分析","date":"2018-10-11T01:03:18.000Z","_content":"\n### 基于ThreadPoolExecutor构造线程池\n\n我们来看一下ThreadPoolExecutor类的构造函数，一共需要传入7个参数，下面的注释中有详细的解释：\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n    //先判断参数是否合法\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n        null :\n    \tAccessController.getContext();\n    //核心线程数量\n    this.corePoolSize = corePoolSize;\n    //最大线程数量\n    this.maximumPoolSize = maximumPoolSize;\n    //工作队列\n    this.workQueue = workQueue;\n    //保活时间，unit为时间单位，转换为秒\n    this.keepAliveTime = unit.toNanos(keepAliveTime);、\n    //线程工厂\n    this.threadFactory = threadFactory;\n    //拒绝策略\n    this.handler = handler;\n}\n```\n\n工作队列使用的是一种阻塞队列，**关于阻塞队列的实现我将会在另一片文章中详细讲解**。\n\n<!-- more -->\n\n#### 提交任务\n\n提交任务的过程主要分为三步：\n\n```java\n/*\n* Proceed in 3 steps:\n*\n* 1. If fewer than corePoolSize threads are running, try to\n* start a new thread with the given command as its first\n* task.  The call to addWorker atomically checks runState and\n* workerCount, and so prevents false alarms that would add\n* threads when it shouldn't, by returning false.\n*\n* 2. If a task can be successfully queued, then we still need\n* to double-check whether we should have added a thread\n* (because existing ones died since last checking) or that\n* the pool shut down since entry into this method. So we\n* recheck state and if necessary roll back the enqueuing if\n* stopped, or start a new thread if there are none.\n*\n* 3. If we cannot queue task, then we try to add a new\n* thread.  If it fails, we know we are shut down or saturated\n* and so reject the task.\n*/\nint c = ctl.get();\nif (workerCountOf(c) < corePoolSize) {\n    if (addWorker(command, true))\n        return;\n    c = ctl.get();\n}\nif (isRunning(c) && workQueue.offer(command)) {\n    int recheck = ctl.get();\n    if (! isRunning(recheck) && remove(command))\n        reject(command);\n    else if (workerCountOf(recheck) == 0)\n        addWorker(null, false);\n}\nelse if (!addWorker(command, false))\n    reject(command);\n```\n\n* 1.如果运行的线程数小于`corePoolSize`，则会调用`addWorker()`，检查`runState`和`workerCount`，并且**创建一个新的线程**，把任务给它当做第一个任务来执行，然后就返回。\n* 2.如果任务成功的**加入队列**，然后我们仍然需要去再次检查是否我们应该添加一个thread（因为在之前一次检查之后可能会有thread终止），或者线程池停止了自从进入这个函数。因此我们需要重复检查状态，并且在线程池停止的情况下回滚入队操作，或者开启一个新的线程如果这没有线程。\n* 3.如果任务不能加入队列（队列已满），则尝试**创建一个新的线程**（此时线程数量应该小于maximumPoolSize）。如果创建失败，我们知道可能是线程池停止或者线程数量达到了`maximumPoolSize`，因此会拒绝这个任务。\n\n#### 五种运行状态\n\n```java\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS; //接收新的任务并且处理队列中的任务\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS; //不接受新的任务，但是会继续处理队列中的任务\nprivate static final int STOP       =  1 << COUNT_BITS; //不接受新的任务，也不处理队列中的任务，并且打断中正在处理的任务\nprivate static final int TIDYING    =  2 << COUNT_BITS; //所有任务都终止，workerCount为零，线程状态过渡到TIDYING，将会执行terminated()方法\nprivate static final int TERMINATED =  3 << COUNT_BITS; //terminated()函数执行完成\n```\n状态转换：\n\n|      原始状态       |  目标状态  |                           转变原因                           |\n| :-----------------: | :--------: | :----------------------------------------------------------: |\n|       RUNNING       |  SHUTDOWN  | On invocation of shutdown(), perhaps implicitly in finalize() |\n| RUNNING or SHUTDOWN |    STOP    |                On invocation of shutdownNow()                |\n|      SHUTDOWN       |  TIDYING   |              When both queue and pool are empty              |\n|        STOP         |  TIDYING   |                      When pool is empty                      |\n|       TIDYING       | TERMINATED |       When the terminated() hook method has completed        |\n\n### 饱和策略分析\n\n当有界队列填满后，饱和策略开始发挥作用，所有饱和策略实现类都实现了`RejectExecutionHandler`接口，我们来看一下JDK提供了哪些饱和策略实现类：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/RejectedExecutionHandler.png?raw=true)\n\n从类的关系图中可以看出，JDK实现了`DiscardPolicy、CallerRunsPolicy、DiscardOldestPolicy和AbortPolicy`四种饱和策略，下面我们将会一一进行分析。\n\n#### AbortPolicy\n\n```java\n    /**\n     * A handler for rejected tasks that throws a\n     * {@code RejectedExecutionException}.\n     */\n    public static class AbortPolicy implements RejectedExecutionHandler {\n        /**\n         * Creates an {@code AbortPolicy}.\n         */\n        public AbortPolicy() { }\n\n        /**\n         * Always throws RejectedExecutionException.\n         *\n         * @param r the runnable task requested to be executed\n         * @param e the executor attempting to execute this task\n         * @throws RejectedExecutionException always\n         */\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }\n    }\n```\n\n\n\n中止策略是默认的饱和策略，该则略将会抛出未检查的RejectedExecutionException，调用者可以捕获这个异常，然后根据需求编写自己的处理代码。\n\n#### CallerRunsPolicy\n\n```java\n    /**\n     * A handler for rejected tasks that runs the rejected task\n     * directly in the calling thread of the {@code execute} method,\n     * unless the executor has been shut down, in which case the task\n     * is discarded.\n     */\n    public static class CallerRunsPolicy implements RejectedExecutionHandler {\n        /**\n         * Creates a {@code CallerRunsPolicy}.\n         */\n        public CallerRunsPolicy() { }\n\n        /**\n         * Executes task r in the caller's thread, unless the executor\n         * has been shut down, in which case the task is discarded.\n         *\n         * @param r the runnable task requested to be executed\n         * @param e the executor attempting to execute this task\n         */\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            if (!e.isShutdown()) {\n                r.run();\n            }\n        }\n    }\n```\n\n\n\n调用者运行策略实现了一种调节机制，该策略不抛弃任何任务，也不会抛出异常，而是将某些任务会退到调用者执行，从而降低新任务的流量。他不会在线程池中的某个线程中执行任务，而是在调用execute()方法的线程中执行该任务。\n\n#### DiscardPolicy\n\n```java\n    /**\n     * A handler for rejected tasks that silently discards the\n     * rejected task.\n     */\n    public static class DiscardPolicy implements RejectedExecutionHandler {\n        /**\n         * Creates a {@code DiscardPolicy}.\n         */\n        public DiscardPolicy() { }\n\n        /**\n         * Does nothing, which has the effect of discarding task r.\n         *\n         * @param r the runnable task requested to be executed\n         * @param e the executor attempting to execute this task\n         */\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n        }\n    }\n```\n\n\n\n抛弃策略，直接抛弃该提交的任务。\n\n#### DiscardOldestPolicy\n\n```java\n    /**\n     * A handler for rejected tasks that discards the oldest unhandled\n     * request and then retries {@code execute}, unless the executor\n     * is shut down, in which case the task is discarded.\n     */\n    public static class DiscardOldestPolicy implements RejectedExecutionHandler {\n        /**\n         * Creates a {@code DiscardOldestPolicy} for the given executor.\n         */\n        public DiscardOldestPolicy() { }\n\n        /**\n         * Obtains and ignores the next task that the executor\n         * would otherwise execute, if one is immediately available,\n         * and then retries execution of task r, unless the executor\n         * is shut down, in which case task r is instead discarded.\n         *\n         * @param r the runnable task requested to be executed\n         * @param e the executor attempting to execute this task\n         */\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            if (!e.isShutdown()) {\n                e.getQueue().poll();\n                e.execute(r);\n            }\n        }\n    }\n```\n\n\n\n抛弃最旧的策略，则会抛弃下一个将会执行的任务，然后尝试重新提交该任务。如果工作队列是一个优先级队列，那么该策略会导致抛弃优先级最高的任务，因此最好不要将优先级队列和DiscardOldestPolicy一起使用。\n\n### 自定义线程工厂\n\n在ThreadPoolExecutor构造函数中可以看到，在构造线程池时，可以传入自定义的线程工厂，也可以使用默认的线程工厂。我们先来看一下默认的线程工厂的实现，它是Executors的静态内部类：\n\n```java\n/**\n     * The default thread factory\n     */\nstatic class DefaultThreadFactory implements ThreadFactory {\n    //记录创建默认线程池的数量，类变量\n    private static final AtomicInteger poolNumber = new AtomicInteger(1);\n    //线程组\n    private final ThreadGroup group;\n    //记录创建线程的数量，实例变量\n    private final AtomicInteger threadNumber = new AtomicInteger(1);\n    //线程名称前缀\n    private final String namePrefix;\n\n    DefaultThreadFactory() {、\n        //这句话啥意思？\n        SecurityManager s = System.getSecurityManager();\n        //赋值线程组\n        group = (s != null) ? s.getThreadGroup() :\n        Thread.currentThread().getThreadGroup();\n        namePrefix = \"pool-\" +\n            poolNumber.getAndIncrement() +\n            \"-thread-\";\n    }\n\n    public Thread newThread(Runnable r) {\n        Thread t = new Thread(group, r,\n                              namePrefix + threadNumber.getAndIncrement(),\n                              0);\n        if (t.isDaemon()) //??为什么这里判断是守护进程，还设置为false？？\n            t.setDaemon(false);\n        if (t.getPriority() != Thread.NORM_PRIORITY)//设置优先级\n            t.setPriority(Thread.NORM_PRIORITY);\n        return t;\n    }\n}\n```\n\n我们可以参考上面的默认线程工厂的实现方式，可以自定义任意的线程工厂。\n\n### Executors类分析\n\n在Executors类中主要提供了三种创建线程池的方法，分别是newCachedThreadPool()、newFixedThreadPool()和newSIngleThreadPool()，下面对这三种方式进行对比分析：\n\n|         方法          | corePoolSize |  maximumPoolSize  | keepAliveTime&TimeUnit |    BlockingQueue    |\n| :-------------------: | :----------: | :---------------: | :--------------------: | :-----------------: |\n| newCachedThreadPool() |      0       | Integer.MAX_VALUE |          60s           |  SynchronousQueue   |\n| newFixedThreadPool()  |   nThreads   |     nThreads      |          0ms           | LinkedBlockingQueue |\n| newSIngleThreadPool() |      1       |         1         |          0ms           | LinkedBlockingQueue |\n|  ScheduledThreadPool  |              |                   |                        |                     |\n在这里提两个问题：\n\n* 1.为什么FixedThreadExecutor的corePoolSize和maximumPoolSize要设计成一样的？\n* 2.为什么CachedThreadExecutor的maximumPoolSize要设计成Integer.MAX_VALUE？\n\n> 对于问题一，因为线程池是先判断corePoolSize,再判断workQueue,最后判断maximumPoolSize，然而LinkedBlockingQueue是无界队列（Integer.MAX_VALUE），所以他是达不到判断maximumPoolSize这一步的，所以maximumPoolSize设置成多少，并没有多大关系。\n\n------\n\n> 对于问题二，因为SynchronousQueue设计的原因，如果maximumPoolSize不设计的很大，那么就很容易导致线程占满，然后抛出异常。\n\n### 关闭线程池\n\n通过源码可以看到，停止线程池执行主要是两个方法，第一个是`shutdown()`，第二个是`shutdownNow()`方法，他们的主要区别是：\n\n* 调用shutdown()方法，将会把线程池的状态标记为`SHUTDOWN`，通过前面的状态分析，我们知道这个状态下线程池将不会接收任何新的任务，并且会继续执行队列里的任务，直到所有任务执行完成，终                                                                                                                                                                                                         止线程池；\n* 调用shutdownNow()方法，将会把线程池的状态标记为`STOP`，此时线程池也不会接收任何新的任务，并且立即停止正在执行任务的线程，将队列里的任务返回给调用者；\n\n我们可以看到，使用shutdownNow()强行关闭的速度更快，但风险也更大，因为任务很可能执行一半就被停止了；而使用shutdown()正常关闭虽然速度慢，但却更安全，因为会一直等到队列中的任务全部执行完成后才关闭。\n\n### 使用建议\n\n在阿里巴巴Java开发手册中，【强制】建议使用者不要通过Executors去创建线程池，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，从而规避资源耗尽的风险。","source":"_posts/java-thread-pool.md","raw":"---\ntitle: Java线程池分析\ndate: 2018-10-11 09:03:18\ntags:\n    - java\n---\n\n### 基于ThreadPoolExecutor构造线程池\n\n我们来看一下ThreadPoolExecutor类的构造函数，一共需要传入7个参数，下面的注释中有详细的解释：\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n    //先判断参数是否合法\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n        null :\n    \tAccessController.getContext();\n    //核心线程数量\n    this.corePoolSize = corePoolSize;\n    //最大线程数量\n    this.maximumPoolSize = maximumPoolSize;\n    //工作队列\n    this.workQueue = workQueue;\n    //保活时间，unit为时间单位，转换为秒\n    this.keepAliveTime = unit.toNanos(keepAliveTime);、\n    //线程工厂\n    this.threadFactory = threadFactory;\n    //拒绝策略\n    this.handler = handler;\n}\n```\n\n工作队列使用的是一种阻塞队列，**关于阻塞队列的实现我将会在另一片文章中详细讲解**。\n\n<!-- more -->\n\n#### 提交任务\n\n提交任务的过程主要分为三步：\n\n```java\n/*\n* Proceed in 3 steps:\n*\n* 1. If fewer than corePoolSize threads are running, try to\n* start a new thread with the given command as its first\n* task.  The call to addWorker atomically checks runState and\n* workerCount, and so prevents false alarms that would add\n* threads when it shouldn't, by returning false.\n*\n* 2. If a task can be successfully queued, then we still need\n* to double-check whether we should have added a thread\n* (because existing ones died since last checking) or that\n* the pool shut down since entry into this method. So we\n* recheck state and if necessary roll back the enqueuing if\n* stopped, or start a new thread if there are none.\n*\n* 3. If we cannot queue task, then we try to add a new\n* thread.  If it fails, we know we are shut down or saturated\n* and so reject the task.\n*/\nint c = ctl.get();\nif (workerCountOf(c) < corePoolSize) {\n    if (addWorker(command, true))\n        return;\n    c = ctl.get();\n}\nif (isRunning(c) && workQueue.offer(command)) {\n    int recheck = ctl.get();\n    if (! isRunning(recheck) && remove(command))\n        reject(command);\n    else if (workerCountOf(recheck) == 0)\n        addWorker(null, false);\n}\nelse if (!addWorker(command, false))\n    reject(command);\n```\n\n* 1.如果运行的线程数小于`corePoolSize`，则会调用`addWorker()`，检查`runState`和`workerCount`，并且**创建一个新的线程**，把任务给它当做第一个任务来执行，然后就返回。\n* 2.如果任务成功的**加入队列**，然后我们仍然需要去再次检查是否我们应该添加一个thread（因为在之前一次检查之后可能会有thread终止），或者线程池停止了自从进入这个函数。因此我们需要重复检查状态，并且在线程池停止的情况下回滚入队操作，或者开启一个新的线程如果这没有线程。\n* 3.如果任务不能加入队列（队列已满），则尝试**创建一个新的线程**（此时线程数量应该小于maximumPoolSize）。如果创建失败，我们知道可能是线程池停止或者线程数量达到了`maximumPoolSize`，因此会拒绝这个任务。\n\n#### 五种运行状态\n\n```java\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS; //接收新的任务并且处理队列中的任务\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS; //不接受新的任务，但是会继续处理队列中的任务\nprivate static final int STOP       =  1 << COUNT_BITS; //不接受新的任务，也不处理队列中的任务，并且打断中正在处理的任务\nprivate static final int TIDYING    =  2 << COUNT_BITS; //所有任务都终止，workerCount为零，线程状态过渡到TIDYING，将会执行terminated()方法\nprivate static final int TERMINATED =  3 << COUNT_BITS; //terminated()函数执行完成\n```\n状态转换：\n\n|      原始状态       |  目标状态  |                           转变原因                           |\n| :-----------------: | :--------: | :----------------------------------------------------------: |\n|       RUNNING       |  SHUTDOWN  | On invocation of shutdown(), perhaps implicitly in finalize() |\n| RUNNING or SHUTDOWN |    STOP    |                On invocation of shutdownNow()                |\n|      SHUTDOWN       |  TIDYING   |              When both queue and pool are empty              |\n|        STOP         |  TIDYING   |                      When pool is empty                      |\n|       TIDYING       | TERMINATED |       When the terminated() hook method has completed        |\n\n### 饱和策略分析\n\n当有界队列填满后，饱和策略开始发挥作用，所有饱和策略实现类都实现了`RejectExecutionHandler`接口，我们来看一下JDK提供了哪些饱和策略实现类：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/RejectedExecutionHandler.png?raw=true)\n\n从类的关系图中可以看出，JDK实现了`DiscardPolicy、CallerRunsPolicy、DiscardOldestPolicy和AbortPolicy`四种饱和策略，下面我们将会一一进行分析。\n\n#### AbortPolicy\n\n```java\n    /**\n     * A handler for rejected tasks that throws a\n     * {@code RejectedExecutionException}.\n     */\n    public static class AbortPolicy implements RejectedExecutionHandler {\n        /**\n         * Creates an {@code AbortPolicy}.\n         */\n        public AbortPolicy() { }\n\n        /**\n         * Always throws RejectedExecutionException.\n         *\n         * @param r the runnable task requested to be executed\n         * @param e the executor attempting to execute this task\n         * @throws RejectedExecutionException always\n         */\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            throw new RejectedExecutionException(\"Task \" + r.toString() +\n                                                 \" rejected from \" +\n                                                 e.toString());\n        }\n    }\n```\n\n\n\n中止策略是默认的饱和策略，该则略将会抛出未检查的RejectedExecutionException，调用者可以捕获这个异常，然后根据需求编写自己的处理代码。\n\n#### CallerRunsPolicy\n\n```java\n    /**\n     * A handler for rejected tasks that runs the rejected task\n     * directly in the calling thread of the {@code execute} method,\n     * unless the executor has been shut down, in which case the task\n     * is discarded.\n     */\n    public static class CallerRunsPolicy implements RejectedExecutionHandler {\n        /**\n         * Creates a {@code CallerRunsPolicy}.\n         */\n        public CallerRunsPolicy() { }\n\n        /**\n         * Executes task r in the caller's thread, unless the executor\n         * has been shut down, in which case the task is discarded.\n         *\n         * @param r the runnable task requested to be executed\n         * @param e the executor attempting to execute this task\n         */\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            if (!e.isShutdown()) {\n                r.run();\n            }\n        }\n    }\n```\n\n\n\n调用者运行策略实现了一种调节机制，该策略不抛弃任何任务，也不会抛出异常，而是将某些任务会退到调用者执行，从而降低新任务的流量。他不会在线程池中的某个线程中执行任务，而是在调用execute()方法的线程中执行该任务。\n\n#### DiscardPolicy\n\n```java\n    /**\n     * A handler for rejected tasks that silently discards the\n     * rejected task.\n     */\n    public static class DiscardPolicy implements RejectedExecutionHandler {\n        /**\n         * Creates a {@code DiscardPolicy}.\n         */\n        public DiscardPolicy() { }\n\n        /**\n         * Does nothing, which has the effect of discarding task r.\n         *\n         * @param r the runnable task requested to be executed\n         * @param e the executor attempting to execute this task\n         */\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n        }\n    }\n```\n\n\n\n抛弃策略，直接抛弃该提交的任务。\n\n#### DiscardOldestPolicy\n\n```java\n    /**\n     * A handler for rejected tasks that discards the oldest unhandled\n     * request and then retries {@code execute}, unless the executor\n     * is shut down, in which case the task is discarded.\n     */\n    public static class DiscardOldestPolicy implements RejectedExecutionHandler {\n        /**\n         * Creates a {@code DiscardOldestPolicy} for the given executor.\n         */\n        public DiscardOldestPolicy() { }\n\n        /**\n         * Obtains and ignores the next task that the executor\n         * would otherwise execute, if one is immediately available,\n         * and then retries execution of task r, unless the executor\n         * is shut down, in which case task r is instead discarded.\n         *\n         * @param r the runnable task requested to be executed\n         * @param e the executor attempting to execute this task\n         */\n        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n            if (!e.isShutdown()) {\n                e.getQueue().poll();\n                e.execute(r);\n            }\n        }\n    }\n```\n\n\n\n抛弃最旧的策略，则会抛弃下一个将会执行的任务，然后尝试重新提交该任务。如果工作队列是一个优先级队列，那么该策略会导致抛弃优先级最高的任务，因此最好不要将优先级队列和DiscardOldestPolicy一起使用。\n\n### 自定义线程工厂\n\n在ThreadPoolExecutor构造函数中可以看到，在构造线程池时，可以传入自定义的线程工厂，也可以使用默认的线程工厂。我们先来看一下默认的线程工厂的实现，它是Executors的静态内部类：\n\n```java\n/**\n     * The default thread factory\n     */\nstatic class DefaultThreadFactory implements ThreadFactory {\n    //记录创建默认线程池的数量，类变量\n    private static final AtomicInteger poolNumber = new AtomicInteger(1);\n    //线程组\n    private final ThreadGroup group;\n    //记录创建线程的数量，实例变量\n    private final AtomicInteger threadNumber = new AtomicInteger(1);\n    //线程名称前缀\n    private final String namePrefix;\n\n    DefaultThreadFactory() {、\n        //这句话啥意思？\n        SecurityManager s = System.getSecurityManager();\n        //赋值线程组\n        group = (s != null) ? s.getThreadGroup() :\n        Thread.currentThread().getThreadGroup();\n        namePrefix = \"pool-\" +\n            poolNumber.getAndIncrement() +\n            \"-thread-\";\n    }\n\n    public Thread newThread(Runnable r) {\n        Thread t = new Thread(group, r,\n                              namePrefix + threadNumber.getAndIncrement(),\n                              0);\n        if (t.isDaemon()) //??为什么这里判断是守护进程，还设置为false？？\n            t.setDaemon(false);\n        if (t.getPriority() != Thread.NORM_PRIORITY)//设置优先级\n            t.setPriority(Thread.NORM_PRIORITY);\n        return t;\n    }\n}\n```\n\n我们可以参考上面的默认线程工厂的实现方式，可以自定义任意的线程工厂。\n\n### Executors类分析\n\n在Executors类中主要提供了三种创建线程池的方法，分别是newCachedThreadPool()、newFixedThreadPool()和newSIngleThreadPool()，下面对这三种方式进行对比分析：\n\n|         方法          | corePoolSize |  maximumPoolSize  | keepAliveTime&TimeUnit |    BlockingQueue    |\n| :-------------------: | :----------: | :---------------: | :--------------------: | :-----------------: |\n| newCachedThreadPool() |      0       | Integer.MAX_VALUE |          60s           |  SynchronousQueue   |\n| newFixedThreadPool()  |   nThreads   |     nThreads      |          0ms           | LinkedBlockingQueue |\n| newSIngleThreadPool() |      1       |         1         |          0ms           | LinkedBlockingQueue |\n|  ScheduledThreadPool  |              |                   |                        |                     |\n在这里提两个问题：\n\n* 1.为什么FixedThreadExecutor的corePoolSize和maximumPoolSize要设计成一样的？\n* 2.为什么CachedThreadExecutor的maximumPoolSize要设计成Integer.MAX_VALUE？\n\n> 对于问题一，因为线程池是先判断corePoolSize,再判断workQueue,最后判断maximumPoolSize，然而LinkedBlockingQueue是无界队列（Integer.MAX_VALUE），所以他是达不到判断maximumPoolSize这一步的，所以maximumPoolSize设置成多少，并没有多大关系。\n\n------\n\n> 对于问题二，因为SynchronousQueue设计的原因，如果maximumPoolSize不设计的很大，那么就很容易导致线程占满，然后抛出异常。\n\n### 关闭线程池\n\n通过源码可以看到，停止线程池执行主要是两个方法，第一个是`shutdown()`，第二个是`shutdownNow()`方法，他们的主要区别是：\n\n* 调用shutdown()方法，将会把线程池的状态标记为`SHUTDOWN`，通过前面的状态分析，我们知道这个状态下线程池将不会接收任何新的任务，并且会继续执行队列里的任务，直到所有任务执行完成，终                                                                                                                                                                                                         止线程池；\n* 调用shutdownNow()方法，将会把线程池的状态标记为`STOP`，此时线程池也不会接收任何新的任务，并且立即停止正在执行任务的线程，将队列里的任务返回给调用者；\n\n我们可以看到，使用shutdownNow()强行关闭的速度更快，但风险也更大，因为任务很可能执行一半就被停止了；而使用shutdown()正常关闭虽然速度慢，但却更安全，因为会一直等到队列中的任务全部执行完成后才关闭。\n\n### 使用建议\n\n在阿里巴巴Java开发手册中，【强制】建议使用者不要通过Executors去创建线程池，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，从而规避资源耗尽的风险。","slug":"java-thread-pool","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5d0021zjiadhlz1cq8","content":"<h3 id=\"基于ThreadPoolExecutor构造线程池\"><a href=\"#基于ThreadPoolExecutor构造线程池\" class=\"headerlink\" title=\"基于ThreadPoolExecutor构造线程池\"></a>基于ThreadPoolExecutor构造线程池</h3><p>我们来看一下ThreadPoolExecutor类的构造函数，一共需要传入7个参数，下面的注释中有详细的解释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//先判断参数是否合法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.acc = System.getSecurityManager() == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">        <span class=\"keyword\">null</span> :</span><br><span class=\"line\">    \tAccessController.getContext();</span><br><span class=\"line\">    <span class=\"comment\">//核心线程数量</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">    <span class=\"comment\">//最大线程数量</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">    <span class=\"comment\">//工作队列</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">    <span class=\"comment\">//保活时间，unit为时间单位，转换为秒</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);、</span><br><span class=\"line\">    <span class=\"comment\">//线程工厂</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">    <span class=\"comment\">//拒绝策略</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>工作队列使用的是一种阻塞队列，<strong>关于阻塞队列的实现我将会在另一片文章中详细讲解</strong>。</p>\n<a id=\"more\"></a>\n<h4 id=\"提交任务\"><a href=\"#提交任务\" class=\"headerlink\" title=\"提交任务\"></a>提交任务</h4><p>提交任务的过程主要分为三步：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* Proceed in 3 steps:</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class=\"line\"><span class=\"comment\">* start a new thread with the given command as its first</span></span><br><span class=\"line\"><span class=\"comment\">* task.  The call to addWorker atomically checks runState and</span></span><br><span class=\"line\"><span class=\"comment\">* workerCount, and so prevents false alarms that would add</span></span><br><span class=\"line\"><span class=\"comment\">* threads when it shouldn't, by returning false.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* 2. If a task can be successfully queued, then we still need</span></span><br><span class=\"line\"><span class=\"comment\">* to double-check whether we should have added a thread</span></span><br><span class=\"line\"><span class=\"comment\">* (because existing ones died since last checking) or that</span></span><br><span class=\"line\"><span class=\"comment\">* the pool shut down since entry into this method. So we</span></span><br><span class=\"line\"><span class=\"comment\">* recheck state and if necessary roll back the enqueuing if</span></span><br><span class=\"line\"><span class=\"comment\">* stopped, or start a new thread if there are none.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* 3. If we cannot queue task, then we try to add a new</span></span><br><span class=\"line\"><span class=\"comment\">* thread.  If it fails, we know we are shut down or saturated</span></span><br><span class=\"line\"><span class=\"comment\">* and so reject the task.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    c = ctl.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">    reject(command);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>1.如果运行的线程数小于<code>corePoolSize</code>，则会调用<code>addWorker()</code>，检查<code>runState</code>和<code>workerCount</code>，并且<strong>创建一个新的线程</strong>，把任务给它当做第一个任务来执行，然后就返回。</li>\n<li>2.如果任务成功的<strong>加入队列</strong>，然后我们仍然需要去再次检查是否我们应该添加一个thread（因为在之前一次检查之后可能会有thread终止），或者线程池停止了自从进入这个函数。因此我们需要重复检查状态，并且在线程池停止的情况下回滚入队操作，或者开启一个新的线程如果这没有线程。</li>\n<li>3.如果任务不能加入队列（队列已满），则尝试<strong>创建一个新的线程</strong>（此时线程数量应该小于maximumPoolSize）。如果创建失败，我们知道可能是线程池停止或者线程数量达到了<code>maximumPoolSize</code>，因此会拒绝这个任务。</li>\n</ul>\n<h4 id=\"五种运行状态\"><a href=\"#五种运行状态\" class=\"headerlink\" title=\"五种运行状态\"></a>五种运行状态</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// runState is stored in the high-order bits</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS; <span class=\"comment\">//接收新的任务并且处理队列中的任务</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS; <span class=\"comment\">//不接受新的任务，但是会继续处理队列中的任务</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS; <span class=\"comment\">//不接受新的任务，也不处理队列中的任务，并且打断中正在处理的任务</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS; <span class=\"comment\">//所有任务都终止，workerCount为零，线程状态过渡到TIDYING，将会执行terminated()方法</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS; <span class=\"comment\">//terminated()函数执行完成</span></span><br></pre></td></tr></table></figure>\n<p>状态转换：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">原始状态</th>\n<th style=\"text-align:center\">目标状态</th>\n<th style=\"text-align:center\">转变原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">RUNNING</td>\n<td style=\"text-align:center\">SHUTDOWN</td>\n<td style=\"text-align:center\">On invocation of shutdown(), perhaps implicitly in finalize()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RUNNING or SHUTDOWN</td>\n<td style=\"text-align:center\">STOP</td>\n<td style=\"text-align:center\">On invocation of shutdownNow()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SHUTDOWN</td>\n<td style=\"text-align:center\">TIDYING</td>\n<td style=\"text-align:center\">When both queue and pool are empty</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">STOP</td>\n<td style=\"text-align:center\">TIDYING</td>\n<td style=\"text-align:center\">When pool is empty</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TIDYING</td>\n<td style=\"text-align:center\">TERMINATED</td>\n<td style=\"text-align:center\">When the terminated() hook method has completed</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"饱和策略分析\"><a href=\"#饱和策略分析\" class=\"headerlink\" title=\"饱和策略分析\"></a>饱和策略分析</h3><p>当有界队列填满后，饱和策略开始发挥作用，所有饱和策略实现类都实现了<code>RejectExecutionHandler</code>接口，我们来看一下JDK提供了哪些饱和策略实现类：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/RejectedExecutionHandler.png?raw=true\" alt=\"\"></p>\n<p>从类的关系图中可以看出，JDK实现了<code>DiscardPolicy、CallerRunsPolicy、DiscardOldestPolicy和AbortPolicy</code>四种饱和策略，下面我们将会一一进行分析。</p>\n<h4 id=\"AbortPolicy\"><a href=\"#AbortPolicy\" class=\"headerlink\" title=\"AbortPolicy\"></a>AbortPolicy</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A handler for rejected tasks that throws a</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> RejectedExecutionException&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbortPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates an &#123;<span class=\"doctag\">@code</span> AbortPolicy&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AbortPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Always throws RejectedExecutionException.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> r the runnable task requested to be executed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> e the executor attempting to execute this task</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> RejectedExecutionException always</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RejectedExecutionException(<span class=\"string\">\"Task \"</span> + r.toString() +</span><br><span class=\"line\">                                             <span class=\"string\">\" rejected from \"</span> +</span><br><span class=\"line\">                                             e.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>中止策略是默认的饱和策略，该则略将会抛出未检查的RejectedExecutionException，调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</p>\n<h4 id=\"CallerRunsPolicy\"><a href=\"#CallerRunsPolicy\" class=\"headerlink\" title=\"CallerRunsPolicy\"></a>CallerRunsPolicy</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A handler for rejected tasks that runs the rejected task</span></span><br><span class=\"line\"><span class=\"comment\"> * directly in the calling thread of the &#123;<span class=\"doctag\">@code</span> execute&#125; method,</span></span><br><span class=\"line\"><span class=\"comment\"> * unless the executor has been shut down, in which case the task</span></span><br><span class=\"line\"><span class=\"comment\"> * is discarded.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallerRunsPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates a &#123;<span class=\"doctag\">@code</span> CallerRunsPolicy&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CallerRunsPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Executes task r in the caller's thread, unless the executor</span></span><br><span class=\"line\"><span class=\"comment\">     * has been shut down, in which case the task is discarded.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> r the runnable task requested to be executed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> e the executor attempting to execute this task</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!e.isShutdown()) &#123;</span><br><span class=\"line\">            r.run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用者运行策略实现了一种调节机制，该策略不抛弃任何任务，也不会抛出异常，而是将某些任务会退到调用者执行，从而降低新任务的流量。他不会在线程池中的某个线程中执行任务，而是在调用execute()方法的线程中执行该任务。</p>\n<h4 id=\"DiscardPolicy\"><a href=\"#DiscardPolicy\" class=\"headerlink\" title=\"DiscardPolicy\"></a>DiscardPolicy</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A handler for rejected tasks that silently discards the</span></span><br><span class=\"line\"><span class=\"comment\"> * rejected task.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscardPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates a &#123;<span class=\"doctag\">@code</span> DiscardPolicy&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiscardPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Does nothing, which has the effect of discarding task r.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> r the runnable task requested to be executed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> e the executor attempting to execute this task</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抛弃策略，直接抛弃该提交的任务。</p>\n<h4 id=\"DiscardOldestPolicy\"><a href=\"#DiscardOldestPolicy\" class=\"headerlink\" title=\"DiscardOldestPolicy\"></a>DiscardOldestPolicy</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A handler for rejected tasks that discards the oldest unhandled</span></span><br><span class=\"line\"><span class=\"comment\"> * request and then retries &#123;<span class=\"doctag\">@code</span> execute&#125;, unless the executor</span></span><br><span class=\"line\"><span class=\"comment\"> * is shut down, in which case the task is discarded.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscardOldestPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates a &#123;<span class=\"doctag\">@code</span> DiscardOldestPolicy&#125; for the given executor.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiscardOldestPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Obtains and ignores the next task that the executor</span></span><br><span class=\"line\"><span class=\"comment\">     * would otherwise execute, if one is immediately available,</span></span><br><span class=\"line\"><span class=\"comment\">     * and then retries execution of task r, unless the executor</span></span><br><span class=\"line\"><span class=\"comment\">     * is shut down, in which case task r is instead discarded.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> r the runnable task requested to be executed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> e the executor attempting to execute this task</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!e.isShutdown()) &#123;</span><br><span class=\"line\">            e.getQueue().poll();</span><br><span class=\"line\">            e.execute(r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抛弃最旧的策略，则会抛弃下一个将会执行的任务，然后尝试重新提交该任务。如果工作队列是一个优先级队列，那么该策略会导致抛弃优先级最高的任务，因此最好不要将优先级队列和DiscardOldestPolicy一起使用。</p>\n<h3 id=\"自定义线程工厂\"><a href=\"#自定义线程工厂\" class=\"headerlink\" title=\"自定义线程工厂\"></a>自定义线程工厂</h3><p>在ThreadPoolExecutor构造函数中可以看到，在构造线程池时，可以传入自定义的线程工厂，也可以使用默认的线程工厂。我们先来看一下默认的线程工厂的实现，它是Executors的静态内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The default thread factory</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultThreadFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ThreadFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//记录创建默认线程池的数量，类变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicInteger poolNumber = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//线程组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadGroup group;</span><br><span class=\"line\">    <span class=\"comment\">//记录创建线程的数量，实例变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger threadNumber = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//线程名称前缀</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String namePrefix;</span><br><span class=\"line\"></span><br><span class=\"line\">    DefaultThreadFactory() &#123;、</span><br><span class=\"line\">        <span class=\"comment\">//这句话啥意思？</span></span><br><span class=\"line\">        SecurityManager s = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"comment\">//赋值线程组</span></span><br><span class=\"line\">        group = (s != <span class=\"keyword\">null</span>) ? s.getThreadGroup() :</span><br><span class=\"line\">        Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">        namePrefix = <span class=\"string\">\"pool-\"</span> +</span><br><span class=\"line\">            poolNumber.getAndIncrement() +</span><br><span class=\"line\">            <span class=\"string\">\"-thread-\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(group, r,</span><br><span class=\"line\">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class=\"line\">                              <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.isDaemon()) <span class=\"comment\">//??为什么这里判断是守护进程，还设置为false？？</span></span><br><span class=\"line\">            t.setDaemon(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<span class=\"comment\">//设置优先级</span></span><br><span class=\"line\">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以参考上面的默认线程工厂的实现方式，可以自定义任意的线程工厂。</p>\n<h3 id=\"Executors类分析\"><a href=\"#Executors类分析\" class=\"headerlink\" title=\"Executors类分析\"></a>Executors类分析</h3><p>在Executors类中主要提供了三种创建线程池的方法，分别是newCachedThreadPool()、newFixedThreadPool()和newSIngleThreadPool()，下面对这三种方式进行对比分析：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法</th>\n<th style=\"text-align:center\">corePoolSize</th>\n<th style=\"text-align:center\">maximumPoolSize</th>\n<th style=\"text-align:center\">keepAliveTime&amp;TimeUnit</th>\n<th style=\"text-align:center\">BlockingQueue</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">newCachedThreadPool()</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">Integer.MAX_VALUE</td>\n<td style=\"text-align:center\">60s</td>\n<td style=\"text-align:center\">SynchronousQueue</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">newFixedThreadPool()</td>\n<td style=\"text-align:center\">nThreads</td>\n<td style=\"text-align:center\">nThreads</td>\n<td style=\"text-align:center\">0ms</td>\n<td style=\"text-align:center\">LinkedBlockingQueue</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">newSIngleThreadPool()</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0ms</td>\n<td style=\"text-align:center\">LinkedBlockingQueue</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ScheduledThreadPool</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<p>在这里提两个问题：</p>\n<ul>\n<li>1.为什么FixedThreadExecutor的corePoolSize和maximumPoolSize要设计成一样的？</li>\n<li>2.为什么CachedThreadExecutor的maximumPoolSize要设计成Integer.MAX_VALUE？</li>\n</ul>\n<blockquote>\n<p>对于问题一，因为线程池是先判断corePoolSize,再判断workQueue,最后判断maximumPoolSize，然而LinkedBlockingQueue是无界队列（Integer.MAX_VALUE），所以他是达不到判断maximumPoolSize这一步的，所以maximumPoolSize设置成多少，并没有多大关系。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>对于问题二，因为SynchronousQueue设计的原因，如果maximumPoolSize不设计的很大，那么就很容易导致线程占满，然后抛出异常。</p>\n</blockquote>\n<h3 id=\"关闭线程池\"><a href=\"#关闭线程池\" class=\"headerlink\" title=\"关闭线程池\"></a>关闭线程池</h3><p>通过源码可以看到，停止线程池执行主要是两个方法，第一个是<code>shutdown()</code>，第二个是<code>shutdownNow()</code>方法，他们的主要区别是：</p>\n<ul>\n<li>调用shutdown()方法，将会把线程池的状态标记为<code>SHUTDOWN</code>，通过前面的状态分析，我们知道这个状态下线程池将不会接收任何新的任务，并且会继续执行队列里的任务，直到所有任务执行完成，终                                                                                                                                                                                                         止线程池；</li>\n<li>调用shutdownNow()方法，将会把线程池的状态标记为<code>STOP</code>，此时线程池也不会接收任何新的任务，并且立即停止正在执行任务的线程，将队列里的任务返回给调用者；</li>\n</ul>\n<p>我们可以看到，使用shutdownNow()强行关闭的速度更快，但风险也更大，因为任务很可能执行一半就被停止了；而使用shutdown()正常关闭虽然速度慢，但却更安全，因为会一直等到队列中的任务全部执行完成后才关闭。</p>\n<h3 id=\"使用建议\"><a href=\"#使用建议\" class=\"headerlink\" title=\"使用建议\"></a>使用建议</h3><p>在阿里巴巴Java开发手册中，【强制】建议使用者不要通过Executors去创建线程池，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，从而规避资源耗尽的风险。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"基于ThreadPoolExecutor构造线程池\"><a href=\"#基于ThreadPoolExecutor构造线程池\" class=\"headerlink\" title=\"基于ThreadPoolExecutor构造线程池\"></a>基于ThreadPoolExecutor构造线程池</h3><p>我们来看一下ThreadPoolExecutor类的构造函数，一共需要传入7个参数，下面的注释中有详细的解释：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//先判断参数是否合法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.acc = System.getSecurityManager() == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">        <span class=\"keyword\">null</span> :</span><br><span class=\"line\">    \tAccessController.getContext();</span><br><span class=\"line\">    <span class=\"comment\">//核心线程数量</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">    <span class=\"comment\">//最大线程数量</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">    <span class=\"comment\">//工作队列</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">    <span class=\"comment\">//保活时间，unit为时间单位，转换为秒</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);、</span><br><span class=\"line\">    <span class=\"comment\">//线程工厂</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">    <span class=\"comment\">//拒绝策略</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>工作队列使用的是一种阻塞队列，<strong>关于阻塞队列的实现我将会在另一片文章中详细讲解</strong>。</p>","more":"<h4 id=\"提交任务\"><a href=\"#提交任务\" class=\"headerlink\" title=\"提交任务\"></a>提交任务</h4><p>提交任务的过程主要分为三步：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* Proceed in 3 steps:</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class=\"line\"><span class=\"comment\">* start a new thread with the given command as its first</span></span><br><span class=\"line\"><span class=\"comment\">* task.  The call to addWorker atomically checks runState and</span></span><br><span class=\"line\"><span class=\"comment\">* workerCount, and so prevents false alarms that would add</span></span><br><span class=\"line\"><span class=\"comment\">* threads when it shouldn't, by returning false.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* 2. If a task can be successfully queued, then we still need</span></span><br><span class=\"line\"><span class=\"comment\">* to double-check whether we should have added a thread</span></span><br><span class=\"line\"><span class=\"comment\">* (because existing ones died since last checking) or that</span></span><br><span class=\"line\"><span class=\"comment\">* the pool shut down since entry into this method. So we</span></span><br><span class=\"line\"><span class=\"comment\">* recheck state and if necessary roll back the enqueuing if</span></span><br><span class=\"line\"><span class=\"comment\">* stopped, or start a new thread if there are none.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* 3. If we cannot queue task, then we try to add a new</span></span><br><span class=\"line\"><span class=\"comment\">* thread.  If it fails, we know we are shut down or saturated</span></span><br><span class=\"line\"><span class=\"comment\">* and so reject the task.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    c = ctl.get();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">    reject(command);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>1.如果运行的线程数小于<code>corePoolSize</code>，则会调用<code>addWorker()</code>，检查<code>runState</code>和<code>workerCount</code>，并且<strong>创建一个新的线程</strong>，把任务给它当做第一个任务来执行，然后就返回。</li>\n<li>2.如果任务成功的<strong>加入队列</strong>，然后我们仍然需要去再次检查是否我们应该添加一个thread（因为在之前一次检查之后可能会有thread终止），或者线程池停止了自从进入这个函数。因此我们需要重复检查状态，并且在线程池停止的情况下回滚入队操作，或者开启一个新的线程如果这没有线程。</li>\n<li>3.如果任务不能加入队列（队列已满），则尝试<strong>创建一个新的线程</strong>（此时线程数量应该小于maximumPoolSize）。如果创建失败，我们知道可能是线程池停止或者线程数量达到了<code>maximumPoolSize</code>，因此会拒绝这个任务。</li>\n</ul>\n<h4 id=\"五种运行状态\"><a href=\"#五种运行状态\" class=\"headerlink\" title=\"五种运行状态\"></a>五种运行状态</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// runState is stored in the high-order bits</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS; <span class=\"comment\">//接收新的任务并且处理队列中的任务</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS; <span class=\"comment\">//不接受新的任务，但是会继续处理队列中的任务</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS; <span class=\"comment\">//不接受新的任务，也不处理队列中的任务，并且打断中正在处理的任务</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS; <span class=\"comment\">//所有任务都终止，workerCount为零，线程状态过渡到TIDYING，将会执行terminated()方法</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS; <span class=\"comment\">//terminated()函数执行完成</span></span><br></pre></td></tr></table></figure>\n<p>状态转换：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">原始状态</th>\n<th style=\"text-align:center\">目标状态</th>\n<th style=\"text-align:center\">转变原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">RUNNING</td>\n<td style=\"text-align:center\">SHUTDOWN</td>\n<td style=\"text-align:center\">On invocation of shutdown(), perhaps implicitly in finalize()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RUNNING or SHUTDOWN</td>\n<td style=\"text-align:center\">STOP</td>\n<td style=\"text-align:center\">On invocation of shutdownNow()</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SHUTDOWN</td>\n<td style=\"text-align:center\">TIDYING</td>\n<td style=\"text-align:center\">When both queue and pool are empty</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">STOP</td>\n<td style=\"text-align:center\">TIDYING</td>\n<td style=\"text-align:center\">When pool is empty</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TIDYING</td>\n<td style=\"text-align:center\">TERMINATED</td>\n<td style=\"text-align:center\">When the terminated() hook method has completed</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"饱和策略分析\"><a href=\"#饱和策略分析\" class=\"headerlink\" title=\"饱和策略分析\"></a>饱和策略分析</h3><p>当有界队列填满后，饱和策略开始发挥作用，所有饱和策略实现类都实现了<code>RejectExecutionHandler</code>接口，我们来看一下JDK提供了哪些饱和策略实现类：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/RejectedExecutionHandler.png?raw=true\" alt=\"\"></p>\n<p>从类的关系图中可以看出，JDK实现了<code>DiscardPolicy、CallerRunsPolicy、DiscardOldestPolicy和AbortPolicy</code>四种饱和策略，下面我们将会一一进行分析。</p>\n<h4 id=\"AbortPolicy\"><a href=\"#AbortPolicy\" class=\"headerlink\" title=\"AbortPolicy\"></a>AbortPolicy</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A handler for rejected tasks that throws a</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> RejectedExecutionException&#125;.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbortPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates an &#123;<span class=\"doctag\">@code</span> AbortPolicy&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AbortPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Always throws RejectedExecutionException.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> r the runnable task requested to be executed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> e the executor attempting to execute this task</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> RejectedExecutionException always</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RejectedExecutionException(<span class=\"string\">\"Task \"</span> + r.toString() +</span><br><span class=\"line\">                                             <span class=\"string\">\" rejected from \"</span> +</span><br><span class=\"line\">                                             e.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>中止策略是默认的饱和策略，该则略将会抛出未检查的RejectedExecutionException，调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</p>\n<h4 id=\"CallerRunsPolicy\"><a href=\"#CallerRunsPolicy\" class=\"headerlink\" title=\"CallerRunsPolicy\"></a>CallerRunsPolicy</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A handler for rejected tasks that runs the rejected task</span></span><br><span class=\"line\"><span class=\"comment\"> * directly in the calling thread of the &#123;<span class=\"doctag\">@code</span> execute&#125; method,</span></span><br><span class=\"line\"><span class=\"comment\"> * unless the executor has been shut down, in which case the task</span></span><br><span class=\"line\"><span class=\"comment\"> * is discarded.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallerRunsPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates a &#123;<span class=\"doctag\">@code</span> CallerRunsPolicy&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CallerRunsPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Executes task r in the caller's thread, unless the executor</span></span><br><span class=\"line\"><span class=\"comment\">     * has been shut down, in which case the task is discarded.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> r the runnable task requested to be executed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> e the executor attempting to execute this task</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!e.isShutdown()) &#123;</span><br><span class=\"line\">            r.run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用者运行策略实现了一种调节机制，该策略不抛弃任何任务，也不会抛出异常，而是将某些任务会退到调用者执行，从而降低新任务的流量。他不会在线程池中的某个线程中执行任务，而是在调用execute()方法的线程中执行该任务。</p>\n<h4 id=\"DiscardPolicy\"><a href=\"#DiscardPolicy\" class=\"headerlink\" title=\"DiscardPolicy\"></a>DiscardPolicy</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A handler for rejected tasks that silently discards the</span></span><br><span class=\"line\"><span class=\"comment\"> * rejected task.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscardPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates a &#123;<span class=\"doctag\">@code</span> DiscardPolicy&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiscardPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Does nothing, which has the effect of discarding task r.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> r the runnable task requested to be executed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> e the executor attempting to execute this task</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抛弃策略，直接抛弃该提交的任务。</p>\n<h4 id=\"DiscardOldestPolicy\"><a href=\"#DiscardOldestPolicy\" class=\"headerlink\" title=\"DiscardOldestPolicy\"></a>DiscardOldestPolicy</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A handler for rejected tasks that discards the oldest unhandled</span></span><br><span class=\"line\"><span class=\"comment\"> * request and then retries &#123;<span class=\"doctag\">@code</span> execute&#125;, unless the executor</span></span><br><span class=\"line\"><span class=\"comment\"> * is shut down, in which case the task is discarded.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscardOldestPolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">RejectedExecutionHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates a &#123;<span class=\"doctag\">@code</span> DiscardOldestPolicy&#125; for the given executor.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiscardOldestPolicy</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Obtains and ignores the next task that the executor</span></span><br><span class=\"line\"><span class=\"comment\">     * would otherwise execute, if one is immediately available,</span></span><br><span class=\"line\"><span class=\"comment\">     * and then retries execution of task r, unless the executor</span></span><br><span class=\"line\"><span class=\"comment\">     * is shut down, in which case task r is instead discarded.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> r the runnable task requested to be executed</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> e the executor attempting to execute this task</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectedExecution</span><span class=\"params\">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!e.isShutdown()) &#123;</span><br><span class=\"line\">            e.getQueue().poll();</span><br><span class=\"line\">            e.execute(r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>抛弃最旧的策略，则会抛弃下一个将会执行的任务，然后尝试重新提交该任务。如果工作队列是一个优先级队列，那么该策略会导致抛弃优先级最高的任务，因此最好不要将优先级队列和DiscardOldestPolicy一起使用。</p>\n<h3 id=\"自定义线程工厂\"><a href=\"#自定义线程工厂\" class=\"headerlink\" title=\"自定义线程工厂\"></a>自定义线程工厂</h3><p>在ThreadPoolExecutor构造函数中可以看到，在构造线程池时，可以传入自定义的线程工厂，也可以使用默认的线程工厂。我们先来看一下默认的线程工厂的实现，它是Executors的静态内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The default thread factory</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultThreadFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ThreadFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//记录创建默认线程池的数量，类变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> AtomicInteger poolNumber = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//线程组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadGroup group;</span><br><span class=\"line\">    <span class=\"comment\">//记录创建线程的数量，实例变量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger threadNumber = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//线程名称前缀</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String namePrefix;</span><br><span class=\"line\"></span><br><span class=\"line\">    DefaultThreadFactory() &#123;、</span><br><span class=\"line\">        <span class=\"comment\">//这句话啥意思？</span></span><br><span class=\"line\">        SecurityManager s = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"comment\">//赋值线程组</span></span><br><span class=\"line\">        group = (s != <span class=\"keyword\">null</span>) ? s.getThreadGroup() :</span><br><span class=\"line\">        Thread.currentThread().getThreadGroup();</span><br><span class=\"line\">        namePrefix = <span class=\"string\">\"pool-\"</span> +</span><br><span class=\"line\">            poolNumber.getAndIncrement() +</span><br><span class=\"line\">            <span class=\"string\">\"-thread-\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread(group, r,</span><br><span class=\"line\">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class=\"line\">                              <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.isDaemon()) <span class=\"comment\">//??为什么这里判断是守护进程，还设置为false？？</span></span><br><span class=\"line\">            t.setDaemon(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.getPriority() != Thread.NORM_PRIORITY)<span class=\"comment\">//设置优先级</span></span><br><span class=\"line\">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以参考上面的默认线程工厂的实现方式，可以自定义任意的线程工厂。</p>\n<h3 id=\"Executors类分析\"><a href=\"#Executors类分析\" class=\"headerlink\" title=\"Executors类分析\"></a>Executors类分析</h3><p>在Executors类中主要提供了三种创建线程池的方法，分别是newCachedThreadPool()、newFixedThreadPool()和newSIngleThreadPool()，下面对这三种方式进行对比分析：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法</th>\n<th style=\"text-align:center\">corePoolSize</th>\n<th style=\"text-align:center\">maximumPoolSize</th>\n<th style=\"text-align:center\">keepAliveTime&amp;TimeUnit</th>\n<th style=\"text-align:center\">BlockingQueue</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">newCachedThreadPool()</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">Integer.MAX_VALUE</td>\n<td style=\"text-align:center\">60s</td>\n<td style=\"text-align:center\">SynchronousQueue</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">newFixedThreadPool()</td>\n<td style=\"text-align:center\">nThreads</td>\n<td style=\"text-align:center\">nThreads</td>\n<td style=\"text-align:center\">0ms</td>\n<td style=\"text-align:center\">LinkedBlockingQueue</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">newSIngleThreadPool()</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">0ms</td>\n<td style=\"text-align:center\">LinkedBlockingQueue</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ScheduledThreadPool</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<p>在这里提两个问题：</p>\n<ul>\n<li>1.为什么FixedThreadExecutor的corePoolSize和maximumPoolSize要设计成一样的？</li>\n<li>2.为什么CachedThreadExecutor的maximumPoolSize要设计成Integer.MAX_VALUE？</li>\n</ul>\n<blockquote>\n<p>对于问题一，因为线程池是先判断corePoolSize,再判断workQueue,最后判断maximumPoolSize，然而LinkedBlockingQueue是无界队列（Integer.MAX_VALUE），所以他是达不到判断maximumPoolSize这一步的，所以maximumPoolSize设置成多少，并没有多大关系。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>对于问题二，因为SynchronousQueue设计的原因，如果maximumPoolSize不设计的很大，那么就很容易导致线程占满，然后抛出异常。</p>\n</blockquote>\n<h3 id=\"关闭线程池\"><a href=\"#关闭线程池\" class=\"headerlink\" title=\"关闭线程池\"></a>关闭线程池</h3><p>通过源码可以看到，停止线程池执行主要是两个方法，第一个是<code>shutdown()</code>，第二个是<code>shutdownNow()</code>方法，他们的主要区别是：</p>\n<ul>\n<li>调用shutdown()方法，将会把线程池的状态标记为<code>SHUTDOWN</code>，通过前面的状态分析，我们知道这个状态下线程池将不会接收任何新的任务，并且会继续执行队列里的任务，直到所有任务执行完成，终                                                                                                                                                                                                         止线程池；</li>\n<li>调用shutdownNow()方法，将会把线程池的状态标记为<code>STOP</code>，此时线程池也不会接收任何新的任务，并且立即停止正在执行任务的线程，将队列里的任务返回给调用者；</li>\n</ul>\n<p>我们可以看到，使用shutdownNow()强行关闭的速度更快，但风险也更大，因为任务很可能执行一半就被停止了；而使用shutdown()正常关闭虽然速度慢，但却更安全，因为会一直等到队列中的任务全部执行完成后才关闭。</p>\n<h3 id=\"使用建议\"><a href=\"#使用建议\" class=\"headerlink\" title=\"使用建议\"></a>使用建议</h3><p>在阿里巴巴Java开发手册中，【强制】建议使用者不要通过Executors去创建线程池，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，从而规避资源耗尽的风险。</p>"},{"layout":"post","title":"java中“...”的含义","date":"2016-06-26T02:07:15.000Z","_content":"\n1. 问题来源\n\n    > 在阅读spring源码时发现问题：\n\n    ```java\n    /**\n     * Create a new ClassPathXmlApplicationContext, loading the definitions\n     * from the given XML files and automatically refreshing the context.\n     * @param configLocations array of resource locations\n     * @throws BeansException if context creation failed\n     */\n    public ClassPathXmlApplicationContext(String... configLocations) throws BeansException {\n    \tthis(configLocations, true, null);\n    }\n    ```\n<!-- more -->\n\n2. 简介\n\n    > 是jdk1.5新增加特性，Java语言对方法参数支持一种新写法，叫可变长度参数列表，其语法就是类型后跟...，表示此处接受的参数为0到多个Object类型的对象，或者是一个Object[]。\n\n3. 测试\n    > com.sh.test\n\n    ```java\n    package com.sh.test;\n    /**\n     * Created by Mr SJL on 2016/11/19.\n     *\n     * @author Junlan Shuai\n     */\n    public class Test1\n    {\n        public static void main(String[] args)\n        {\n            //  创建string对象数组，调用测试函数\n            String[] colors = new String[]{\"green\", \"blue\", \"red\"};\n            t1(colors);\n            t2(colors);\n\n            //  创建string实例，并调用测试函数\n            String color = \"black\";\n            t1(color);\n    //        t2(color);    // 此处报错 java.lang.String[] can not be applied java.lang.String\n        }\n\n        /**\n         * 测试函数1\n         * @param colors    String...类型\n         */\n        public static void t1(String... colors)\n        {\n            for (String c : colors)\n            {\n                System.out.println(c);\n            }\n        }\n\n        /**\n         * 测试函数2\n         * @param colors    String[]类型\n         */\n        public static void t2(String[] colors)\n        {\n            for (String c : colors)\n            {\n                System.out.println(c);\n            }\n        }\n    }\n\n    ```\n\n4. 注意事项\n    > Error:(38, 24) java: 无法在com.sh.test.Test1中同时声明t1(java.lang.String[])和t1(java.lang.String...)\n\n    ```java\n    /**\n     * 测试函数1\n     * @param colors    String...类型\n     */\n    public static void t1(String... colors)\n    {\n        for (String c : colors)\n        {\n            System.out.println(c);\n        }\n    }\n    /**\n     * 测试函数2\n     * @param colors    String[]类型\n     */\n    public static void t1(String[] colors)\n    {\n        for (String c : colors)\n        {\n            System.out.println(c);\n        }\n    }\n    ```\n","source":"_posts/java-three-point.md","raw":"---\nlayout: post\ntitle: java中“...”的含义\ndate: 2016-06-26 10:07:15\ntags:\n    - java\n---\n\n1. 问题来源\n\n    > 在阅读spring源码时发现问题：\n\n    ```java\n    /**\n     * Create a new ClassPathXmlApplicationContext, loading the definitions\n     * from the given XML files and automatically refreshing the context.\n     * @param configLocations array of resource locations\n     * @throws BeansException if context creation failed\n     */\n    public ClassPathXmlApplicationContext(String... configLocations) throws BeansException {\n    \tthis(configLocations, true, null);\n    }\n    ```\n<!-- more -->\n\n2. 简介\n\n    > 是jdk1.5新增加特性，Java语言对方法参数支持一种新写法，叫可变长度参数列表，其语法就是类型后跟...，表示此处接受的参数为0到多个Object类型的对象，或者是一个Object[]。\n\n3. 测试\n    > com.sh.test\n\n    ```java\n    package com.sh.test;\n    /**\n     * Created by Mr SJL on 2016/11/19.\n     *\n     * @author Junlan Shuai\n     */\n    public class Test1\n    {\n        public static void main(String[] args)\n        {\n            //  创建string对象数组，调用测试函数\n            String[] colors = new String[]{\"green\", \"blue\", \"red\"};\n            t1(colors);\n            t2(colors);\n\n            //  创建string实例，并调用测试函数\n            String color = \"black\";\n            t1(color);\n    //        t2(color);    // 此处报错 java.lang.String[] can not be applied java.lang.String\n        }\n\n        /**\n         * 测试函数1\n         * @param colors    String...类型\n         */\n        public static void t1(String... colors)\n        {\n            for (String c : colors)\n            {\n                System.out.println(c);\n            }\n        }\n\n        /**\n         * 测试函数2\n         * @param colors    String[]类型\n         */\n        public static void t2(String[] colors)\n        {\n            for (String c : colors)\n            {\n                System.out.println(c);\n            }\n        }\n    }\n\n    ```\n\n4. 注意事项\n    > Error:(38, 24) java: 无法在com.sh.test.Test1中同时声明t1(java.lang.String[])和t1(java.lang.String...)\n\n    ```java\n    /**\n     * 测试函数1\n     * @param colors    String...类型\n     */\n    public static void t1(String... colors)\n    {\n        for (String c : colors)\n        {\n            System.out.println(c);\n        }\n    }\n    /**\n     * 测试函数2\n     * @param colors    String[]类型\n     */\n    public static void t1(String[] colors)\n    {\n        for (String c : colors)\n        {\n            System.out.println(c);\n        }\n    }\n    ```\n","slug":"java-three-point","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"photos":[],"link":"","_id":"cjq6kwn5e0024zjia48uu3pu6","content":"<ol>\n<li><p>问题来源</p>\n<blockquote>\n<p>在阅读spring源码时发现问题：</p>\n</blockquote>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Create a new ClassPathXmlApplicationContext, loading the definitions</span></span><br><span class=\"line\"><span class=\"comment\"> * from the given XML files and automatically refreshing the context.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> configLocations array of resource locations</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> BeansException if context creation failed</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ClassPathXmlApplicationContext</span><span class=\"params\">(String... configLocations)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>(configLocations, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<a id=\"more\"></a>\n<ol>\n<li><p>简介</p>\n<blockquote>\n<p>是jdk1.5新增加特性，Java语言对方法参数支持一种新写法，叫可变长度参数列表，其语法就是类型后跟…，表示此处接受的参数为0到多个Object类型的对象，或者是一个Object[]。</p>\n</blockquote>\n</li>\n<li><p>测试</p>\n<blockquote>\n<p>com.sh.test</p>\n</blockquote>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.test;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/19.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//  创建string对象数组，调用测试函数</span></span><br><span class=\"line\">        String[] colors = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"green\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"red\"</span>&#125;;</span><br><span class=\"line\">        t1(colors);</span><br><span class=\"line\">        t2(colors);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//  创建string实例，并调用测试函数</span></span><br><span class=\"line\">        String color = <span class=\"string\">\"black\"</span>;</span><br><span class=\"line\">        t1(color);</span><br><span class=\"line\"><span class=\"comment\">//        t2(color);    // 此处报错 java.lang.String[] can not be applied java.lang.String</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试函数1</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> colors    String...类型</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">t1</span><span class=\"params\">(String... colors)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String c : colors)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            System.out.println(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试函数2</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> colors    String[]类型</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">t2</span><span class=\"params\">(String[] colors)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String c : colors)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            System.out.println(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意事项</p>\n<blockquote>\n<p>Error:(38, 24) java: 无法在com.sh.test.Test1中同时声明t1(java.lang.String[])和t1(java.lang.String…)</p>\n</blockquote>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试函数1</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> colors    String...类型</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">t1</span><span class=\"params\">(String... colors)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String c : colors)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试函数2</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> colors    String[]类型</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">t1</span><span class=\"params\">(String[] colors)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String c : colors)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li><p>问题来源</p>\n<blockquote>\n<p>在阅读spring源码时发现问题：</p>\n</blockquote>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Create a new ClassPathXmlApplicationContext, loading the definitions</span></span><br><span class=\"line\"><span class=\"comment\"> * from the given XML files and automatically refreshing the context.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> configLocations array of resource locations</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@throws</span> BeansException if context creation failed</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ClassPathXmlApplicationContext</span><span class=\"params\">(String... configLocations)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>(configLocations, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>","more":"<ol>\n<li><p>简介</p>\n<blockquote>\n<p>是jdk1.5新增加特性，Java语言对方法参数支持一种新写法，叫可变长度参数列表，其语法就是类型后跟…，表示此处接受的参数为0到多个Object类型的对象，或者是一个Object[]。</p>\n</blockquote>\n</li>\n<li><p>测试</p>\n<blockquote>\n<p>com.sh.test</p>\n</blockquote>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.test;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/19.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test1</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//  创建string对象数组，调用测试函数</span></span><br><span class=\"line\">        String[] colors = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"green\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"red\"</span>&#125;;</span><br><span class=\"line\">        t1(colors);</span><br><span class=\"line\">        t2(colors);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//  创建string实例，并调用测试函数</span></span><br><span class=\"line\">        String color = <span class=\"string\">\"black\"</span>;</span><br><span class=\"line\">        t1(color);</span><br><span class=\"line\"><span class=\"comment\">//        t2(color);    // 此处报错 java.lang.String[] can not be applied java.lang.String</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试函数1</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> colors    String...类型</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">t1</span><span class=\"params\">(String... colors)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String c : colors)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            System.out.println(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 测试函数2</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> colors    String[]类型</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">t2</span><span class=\"params\">(String[] colors)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String c : colors)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            System.out.println(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注意事项</p>\n<blockquote>\n<p>Error:(38, 24) java: 无法在com.sh.test.Test1中同时声明t1(java.lang.String[])和t1(java.lang.String…)</p>\n</blockquote>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试函数1</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> colors    String...类型</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">t1</span><span class=\"params\">(String... colors)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String c : colors)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试函数2</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> colors    String[]类型</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">t1</span><span class=\"params\">(String[] colors)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String c : colors)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>"},{"title":"Java中Memory Mapped File原理分析","date":"2018-12-08T04:56:55.000Z","_content":"\n> 在传统的文件读写方式中，会有两次数据拷贝，一次是从硬盘拷贝到操作系统内核，另一次是从操作系统内核拷贝到用户态的应用程序。而在内存映射文件中，一般情况下，只有一次拷贝，且内存分配在操作系统内核，应用程序访问的就是操作系统的内核内存空间，这显然要比普通的读写效率更高。\n>\n> 内存映射文件的另一个重要特点是，它可以被多个不同的应用程序共享，多个程序可以映射同一个文件，映射到同一块内存区域，一个程序对内存的修改，可以让其他程序也看到，这使得它特别适合用于不同应用程序之间的通信。**比普通的基于loopback接口的Socket要快10倍。**那么在Java语言中是如何实现Memory Mapped File的呢？\n\n<!-- more -->\n\n在Java nio包中引入了`MappedByteBuffer`来实现Memory Mapped File，从继承结构上来看MappedByteBuffer继承自ByteBuffer，内部维护了一个逻辑地址address。\n\n下面写个简单的示例来演示如何使用FileChannel和MappedByteBuffer：\n\n```java\n/**\n * @author Shuai Junlan[shuaijunlan@gmail.com].\n * @since Created in 3:03 PM 12/8/18.\n */\npublic class MmapTest {\n    public static void main(String[] args) throws IOException {\n        File file = new File(\"test.txt\");\n        assert file.exists() || file.createNewFile();\n        FileChannel channel = new RandomAccessFile(file, \"rw\").getChannel();\n        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 1000);\n        for (int i = 0; i < 1000; i++){\n            mappedByteBuffer.put((byte)i);\n        }\n        mappedByteBuffer.position(0);\n        for (int i = 0; i < 1000; i++){\n            System.out.println(mappedByteBuffer.get());\n        }\n    }\n}\n```\n\n在上面的代码中可以看到，FileChannel通过调用map方法把文件映射到了虚拟内存，在Java中规定的最大映射大小为**Integer.MAX_VALUE**，如果文件太大可以进行分段映射，我们来分析一下map方法中各个参数的含义：\n\n**mode**:内存映射文件访问的方式，包括以下三种：\n\n* 1.`MapMode.READ_ONLY`：只读，试图修改得到的缓冲区将导致抛出异常。\n\n* 2.`MapMode.READ_WRITE`：读/写，对得到的缓冲区的更改最终将写入文件；但该更改对映射到同一文件的其他程序不一定是可见的。\n\n* 3.`MapMode.PRIVATE`：私用，可读可写,但是修改的内容不会写入文件，只是buffer自身的改变，这种能力称之为**copy on write**。\n\n**position**:被映射文件的其实位置；\n\n**size**:映射区域的大小，单位为byte，最大映射大小为**Integer.MAX_VALUE**；\n\n#### 进一步分析map过程的内部实现原理：\n\n##### 第一步，通过RandomAccessFile获取FileChannel：\n\n```java\npublic final FileChannel getChannel() {\n    synchronized (this) {\n        if (channel == null) {\n            channel = FileChannelImpl.open(fd, path, true, rw, this);\n        }\n        return channel;\n    }\n}\n```\n\n该方法中使用了同步关键字，保证了多线程情况下只能初始化一个FileChannel实例。\n\n##### 第二步，使用FileChannel的map方法，把文件映射到用户虚拟内存空间，并返回逻辑地址\n\n```java\n    public MappedByteBuffer map(MapMode mode, long position, long size)\n        throws IOException\n    {\n\t\t//省略参数检查\n\t\t\n        long addr = -1;\n        int ti = -1;\n        try {\n            begin();\n            ti = threads.add();\n            if (!isOpen())\n                return null;\n\n            long mapSize;\n            int pagePosition;\n            //加锁，保证线程安全\n            synchronized (positionLock) {\n                long filesize;\n                do {\n                    filesize = nd.size(fd);\n                } while ((filesize == IOStatus.INTERRUPTED) && isOpen());\n                if (!isOpen())\n                    return null;\n\t\t\t\t//如果映射范围超出文件的大小且不可写，则抛出异常\n                if (filesize < position + size) { // Extend file size\n                    if (!writable) {\n                        throw new IOException(\"Channel not open for writing \" +\n                            \"- cannot extend file to required size\");\n                    }\n                    int rv;\n                    //填充文件\n                    do {\n                        rv = nd.allocate(fd, position + size);\n                    } while ((rv == IOStatus.INTERRUPTED) && isOpen());\n                    if (!isOpen())\n                        return null;\n                }\n\n                pagePosition = (int)(position % allocationGranularity);\n                long mapPosition = position - pagePosition;\n                mapSize = size + pagePosition;\n                try {\n                    // If map0 did not throw an exception, the address is valid\n                    addr = map0(imode, mapPosition, mapSize);\n                } catch (OutOfMemoryError x) {\n                    // An OutOfMemoryError may indicate that we've exhausted\n                    // memory so force gc and re-attempt map\n                    System.gc();\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException y) {\n                        Thread.currentThread().interrupt();\n                    }\n                    try {\n                        addr = map0(imode, mapPosition, mapSize);\n                    } catch (OutOfMemoryError y) {\n                        // After a second OOME, fail\n                        throw new IOException(\"Map failed\", y);\n                    }\n                }\n            } // synchronized\n\n            // On Windows, and potentially other platforms, we need an open\n            // file descriptor for some mapping operations.\n            FileDescriptor mfd;\n            try {\n                mfd = nd.duplicateForMapping(fd);\n            } catch (IOException ioe) {\n                unmap0(addr, mapSize);\n                throw ioe;\n            }\n\n            assert (IOStatus.checkAll(addr));\n            assert (addr % allocationGranularity == 0);\n            int isize = (int)size;\n            Unmapper um = new Unmapper(addr, mapSize, isize, mfd);\n            if ((!writable) || (imode == MAP_RO)) {\n                return Util.newMappedByteBufferR(isize,\n                                                 addr + pagePosition,\n                                                 mfd,\n                                                 um);\n            } else {\n                return Util.newMappedByteBuffer(isize,\n                                                addr + pagePosition,\n                                                mfd,\n                                                um);\n            }\n        } finally {\n            threads.remove(ti);\n            end(IOStatus.checkAll(addr));\n        }\n    }\n```\n\nmap方法最终是通过调用native函数map0()完成文件映射：\n\n1.如果第一次文件映射导致OOM，则手动处罚垃圾回收，休眠100ms后再尝试映射，如果失败则抛出异常；\n\n2.通过`newMappedByteBuffer`（ReadWrite）或者`newMappedByteBufferR`（Read Only）方法初始化MappedByteBuffer实例，最终返回DirectByteBuffer的实例，该类是MappedByteBuffer的子类；\n\n```java\nstatic MappedByteBuffer newMappedByteBuffer(int size, long addr,\n                                            FileDescriptor fd,\n                                            Runnable unmapper)\n{\n    MappedByteBuffer dbb;\n    if (directByteBufferConstructor == null)\n        initDBBConstructor();\n    try {\n        dbb = (MappedByteBuffer)directByteBufferConstructor.newInstance(\n            new Object[] { new Integer(size),\n                          new Long(addr),\n                          fd,\n                          unmapper });\n    } catch (InstantiationException |\n             IllegalAccessException |\n             InvocationTargetException e) {\n        throw new InternalError(e);\n    }\n    return dbb;\n}\n\nprivate static void initDBBRConstructor() {\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n        public Void run() {\n            try {\n                Class<?> cl = Class.forName(\"java.nio.DirectByteBufferR\");\n                Constructor<?> ctor = cl.getDeclaredConstructor(\n                    new Class<?>[] { int.class,\n                                    long.class,\n                                    FileDescriptor.class,\n                                    Runnable.class });\n                ctor.setAccessible(true);\n                directByteBufferRConstructor = ctor;\n            } catch (ClassNotFoundException |\n                     NoSuchMethodException |\n                     IllegalArgumentException |\n                     ClassCastException x) {\n                throw new InternalError(x);\n            }\n            return null;\n        }});\n}\n```\n\n由于FileChannelImpl和DirectByteBuffer不在同一个包中，并切DirectByteBuffer类是默认的访问权限，因此无法直接在FileChannelImpl的map函数中直接实例化DirectByteBuffer，通过Util.java类的newMappedByteBuffer()方法去实例化，在上面的代码中，实例化的核心逻辑就是通过AccessController获取DirectByteBuffer类的构造函数进行实例化。\n\n关于本地方法map0()，在JDK源码中找到了他的具体实现，如下：\n\n```c\nJava_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this,\n                                     jint prot, jlong off, jlong len)\n{\n    void *mapAddress = 0;\n    jobject fdo = (*env)->GetObjectField(env, this, chan_fd);\n    jint fd = fdval(env, fdo);\n    int protections = 0;\n    int flags = 0;\n\n    if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) {\n        protections = PROT_READ;\n        flags = MAP_SHARED;\n    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) {\n        protections = PROT_WRITE | PROT_READ;\n        flags = MAP_SHARED;\n    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) {\n        protections =  PROT_WRITE | PROT_READ;\n        flags = MAP_PRIVATE;\n    }\n\n    mapAddress = mmap64(\n        0,                    /* Let OS decide location */\n        len,                  /* Number of bytes to map */\n        protections,          /* File permissions */\n        flags,                /* Changes are shared */\n        fd,                   /* File descriptor of mapped file */\n        off);                 /* Offset into file */\n\n    if (mapAddress == MAP_FAILED) {\n        if (errno == ENOMEM) {\n            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n            return IOS_THROWN;\n        }\n        return handle(env, -1, \"Map failed\");\n    }\n\n    return ((jlong) (unsigned long) mapAddress);\n}\n```\n\n#### get和put方法\n\n调用get和put方法对数据进行读写，最终其实是调用DirectByteBuffer类的get和put方法，\n\n```java\npublic byte get() {\n    return ((unsafe.getByte(ix(nextGetIndex()))));\n}\npublic ByteBuffer put(byte x) {\n    unsafe.putByte(ix(nextPutIndex()), ((x)));\n    return this;\n}\n```\n\n通过上面的代码可以看出，底层都是通过调用Unsafe类的getByte和putByte方法来操作数据的。\n\n* 第一次访问address所指向的内存区域，导致缺页中断，中断响应函数会在交换区中查找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则从硬盘上将文件指定页读取到物理内存中（非jvm堆内存）。\n\n* 如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘的虚拟内存中。\n\n#### 性能分析\n\n从代码层面上看，从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，并且数据拷贝操作是由文件系统和硬件驱动实现的，理论上来说，拷贝数据的效率是一样的。\n 但是通过内存映射的方法访问硬盘上的文件，效率要比read和write系统调用高，这是为什么？\n\n- read()是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝；\n- map()也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝。\n\n所以，采用内存映射的读写效率要比传统的read/write性能高。\n\n#### 总结\n\n* MappedByteBuffer使用虚拟内存，因此分配(map)的内存大小不受JVM的-Xmx参数限制，但是也是有大小限制的。\n\n* 如果当文件超出Integer.MAX_VALUE字节限制时，可以通过position参数重新map文件后面的内容。\n\n* MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。\n   javadoc中也提到：*A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected.*","source":"_posts/java-memory-mapped-file.md","raw":"---\ntitle: Java中Memory Mapped File原理分析\ndate: 2018-12-08 12:56:55\ntags:\n    - java\n    - mmap\n---\n\n> 在传统的文件读写方式中，会有两次数据拷贝，一次是从硬盘拷贝到操作系统内核，另一次是从操作系统内核拷贝到用户态的应用程序。而在内存映射文件中，一般情况下，只有一次拷贝，且内存分配在操作系统内核，应用程序访问的就是操作系统的内核内存空间，这显然要比普通的读写效率更高。\n>\n> 内存映射文件的另一个重要特点是，它可以被多个不同的应用程序共享，多个程序可以映射同一个文件，映射到同一块内存区域，一个程序对内存的修改，可以让其他程序也看到，这使得它特别适合用于不同应用程序之间的通信。**比普通的基于loopback接口的Socket要快10倍。**那么在Java语言中是如何实现Memory Mapped File的呢？\n\n<!-- more -->\n\n在Java nio包中引入了`MappedByteBuffer`来实现Memory Mapped File，从继承结构上来看MappedByteBuffer继承自ByteBuffer，内部维护了一个逻辑地址address。\n\n下面写个简单的示例来演示如何使用FileChannel和MappedByteBuffer：\n\n```java\n/**\n * @author Shuai Junlan[shuaijunlan@gmail.com].\n * @since Created in 3:03 PM 12/8/18.\n */\npublic class MmapTest {\n    public static void main(String[] args) throws IOException {\n        File file = new File(\"test.txt\");\n        assert file.exists() || file.createNewFile();\n        FileChannel channel = new RandomAccessFile(file, \"rw\").getChannel();\n        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 1000);\n        for (int i = 0; i < 1000; i++){\n            mappedByteBuffer.put((byte)i);\n        }\n        mappedByteBuffer.position(0);\n        for (int i = 0; i < 1000; i++){\n            System.out.println(mappedByteBuffer.get());\n        }\n    }\n}\n```\n\n在上面的代码中可以看到，FileChannel通过调用map方法把文件映射到了虚拟内存，在Java中规定的最大映射大小为**Integer.MAX_VALUE**，如果文件太大可以进行分段映射，我们来分析一下map方法中各个参数的含义：\n\n**mode**:内存映射文件访问的方式，包括以下三种：\n\n* 1.`MapMode.READ_ONLY`：只读，试图修改得到的缓冲区将导致抛出异常。\n\n* 2.`MapMode.READ_WRITE`：读/写，对得到的缓冲区的更改最终将写入文件；但该更改对映射到同一文件的其他程序不一定是可见的。\n\n* 3.`MapMode.PRIVATE`：私用，可读可写,但是修改的内容不会写入文件，只是buffer自身的改变，这种能力称之为**copy on write**。\n\n**position**:被映射文件的其实位置；\n\n**size**:映射区域的大小，单位为byte，最大映射大小为**Integer.MAX_VALUE**；\n\n#### 进一步分析map过程的内部实现原理：\n\n##### 第一步，通过RandomAccessFile获取FileChannel：\n\n```java\npublic final FileChannel getChannel() {\n    synchronized (this) {\n        if (channel == null) {\n            channel = FileChannelImpl.open(fd, path, true, rw, this);\n        }\n        return channel;\n    }\n}\n```\n\n该方法中使用了同步关键字，保证了多线程情况下只能初始化一个FileChannel实例。\n\n##### 第二步，使用FileChannel的map方法，把文件映射到用户虚拟内存空间，并返回逻辑地址\n\n```java\n    public MappedByteBuffer map(MapMode mode, long position, long size)\n        throws IOException\n    {\n\t\t//省略参数检查\n\t\t\n        long addr = -1;\n        int ti = -1;\n        try {\n            begin();\n            ti = threads.add();\n            if (!isOpen())\n                return null;\n\n            long mapSize;\n            int pagePosition;\n            //加锁，保证线程安全\n            synchronized (positionLock) {\n                long filesize;\n                do {\n                    filesize = nd.size(fd);\n                } while ((filesize == IOStatus.INTERRUPTED) && isOpen());\n                if (!isOpen())\n                    return null;\n\t\t\t\t//如果映射范围超出文件的大小且不可写，则抛出异常\n                if (filesize < position + size) { // Extend file size\n                    if (!writable) {\n                        throw new IOException(\"Channel not open for writing \" +\n                            \"- cannot extend file to required size\");\n                    }\n                    int rv;\n                    //填充文件\n                    do {\n                        rv = nd.allocate(fd, position + size);\n                    } while ((rv == IOStatus.INTERRUPTED) && isOpen());\n                    if (!isOpen())\n                        return null;\n                }\n\n                pagePosition = (int)(position % allocationGranularity);\n                long mapPosition = position - pagePosition;\n                mapSize = size + pagePosition;\n                try {\n                    // If map0 did not throw an exception, the address is valid\n                    addr = map0(imode, mapPosition, mapSize);\n                } catch (OutOfMemoryError x) {\n                    // An OutOfMemoryError may indicate that we've exhausted\n                    // memory so force gc and re-attempt map\n                    System.gc();\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException y) {\n                        Thread.currentThread().interrupt();\n                    }\n                    try {\n                        addr = map0(imode, mapPosition, mapSize);\n                    } catch (OutOfMemoryError y) {\n                        // After a second OOME, fail\n                        throw new IOException(\"Map failed\", y);\n                    }\n                }\n            } // synchronized\n\n            // On Windows, and potentially other platforms, we need an open\n            // file descriptor for some mapping operations.\n            FileDescriptor mfd;\n            try {\n                mfd = nd.duplicateForMapping(fd);\n            } catch (IOException ioe) {\n                unmap0(addr, mapSize);\n                throw ioe;\n            }\n\n            assert (IOStatus.checkAll(addr));\n            assert (addr % allocationGranularity == 0);\n            int isize = (int)size;\n            Unmapper um = new Unmapper(addr, mapSize, isize, mfd);\n            if ((!writable) || (imode == MAP_RO)) {\n                return Util.newMappedByteBufferR(isize,\n                                                 addr + pagePosition,\n                                                 mfd,\n                                                 um);\n            } else {\n                return Util.newMappedByteBuffer(isize,\n                                                addr + pagePosition,\n                                                mfd,\n                                                um);\n            }\n        } finally {\n            threads.remove(ti);\n            end(IOStatus.checkAll(addr));\n        }\n    }\n```\n\nmap方法最终是通过调用native函数map0()完成文件映射：\n\n1.如果第一次文件映射导致OOM，则手动处罚垃圾回收，休眠100ms后再尝试映射，如果失败则抛出异常；\n\n2.通过`newMappedByteBuffer`（ReadWrite）或者`newMappedByteBufferR`（Read Only）方法初始化MappedByteBuffer实例，最终返回DirectByteBuffer的实例，该类是MappedByteBuffer的子类；\n\n```java\nstatic MappedByteBuffer newMappedByteBuffer(int size, long addr,\n                                            FileDescriptor fd,\n                                            Runnable unmapper)\n{\n    MappedByteBuffer dbb;\n    if (directByteBufferConstructor == null)\n        initDBBConstructor();\n    try {\n        dbb = (MappedByteBuffer)directByteBufferConstructor.newInstance(\n            new Object[] { new Integer(size),\n                          new Long(addr),\n                          fd,\n                          unmapper });\n    } catch (InstantiationException |\n             IllegalAccessException |\n             InvocationTargetException e) {\n        throw new InternalError(e);\n    }\n    return dbb;\n}\n\nprivate static void initDBBRConstructor() {\n    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n        public Void run() {\n            try {\n                Class<?> cl = Class.forName(\"java.nio.DirectByteBufferR\");\n                Constructor<?> ctor = cl.getDeclaredConstructor(\n                    new Class<?>[] { int.class,\n                                    long.class,\n                                    FileDescriptor.class,\n                                    Runnable.class });\n                ctor.setAccessible(true);\n                directByteBufferRConstructor = ctor;\n            } catch (ClassNotFoundException |\n                     NoSuchMethodException |\n                     IllegalArgumentException |\n                     ClassCastException x) {\n                throw new InternalError(x);\n            }\n            return null;\n        }});\n}\n```\n\n由于FileChannelImpl和DirectByteBuffer不在同一个包中，并切DirectByteBuffer类是默认的访问权限，因此无法直接在FileChannelImpl的map函数中直接实例化DirectByteBuffer，通过Util.java类的newMappedByteBuffer()方法去实例化，在上面的代码中，实例化的核心逻辑就是通过AccessController获取DirectByteBuffer类的构造函数进行实例化。\n\n关于本地方法map0()，在JDK源码中找到了他的具体实现，如下：\n\n```c\nJava_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this,\n                                     jint prot, jlong off, jlong len)\n{\n    void *mapAddress = 0;\n    jobject fdo = (*env)->GetObjectField(env, this, chan_fd);\n    jint fd = fdval(env, fdo);\n    int protections = 0;\n    int flags = 0;\n\n    if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) {\n        protections = PROT_READ;\n        flags = MAP_SHARED;\n    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) {\n        protections = PROT_WRITE | PROT_READ;\n        flags = MAP_SHARED;\n    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) {\n        protections =  PROT_WRITE | PROT_READ;\n        flags = MAP_PRIVATE;\n    }\n\n    mapAddress = mmap64(\n        0,                    /* Let OS decide location */\n        len,                  /* Number of bytes to map */\n        protections,          /* File permissions */\n        flags,                /* Changes are shared */\n        fd,                   /* File descriptor of mapped file */\n        off);                 /* Offset into file */\n\n    if (mapAddress == MAP_FAILED) {\n        if (errno == ENOMEM) {\n            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n            return IOS_THROWN;\n        }\n        return handle(env, -1, \"Map failed\");\n    }\n\n    return ((jlong) (unsigned long) mapAddress);\n}\n```\n\n#### get和put方法\n\n调用get和put方法对数据进行读写，最终其实是调用DirectByteBuffer类的get和put方法，\n\n```java\npublic byte get() {\n    return ((unsafe.getByte(ix(nextGetIndex()))));\n}\npublic ByteBuffer put(byte x) {\n    unsafe.putByte(ix(nextPutIndex()), ((x)));\n    return this;\n}\n```\n\n通过上面的代码可以看出，底层都是通过调用Unsafe类的getByte和putByte方法来操作数据的。\n\n* 第一次访问address所指向的内存区域，导致缺页中断，中断响应函数会在交换区中查找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则从硬盘上将文件指定页读取到物理内存中（非jvm堆内存）。\n\n* 如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘的虚拟内存中。\n\n#### 性能分析\n\n从代码层面上看，从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，并且数据拷贝操作是由文件系统和硬件驱动实现的，理论上来说，拷贝数据的效率是一样的。\n 但是通过内存映射的方法访问硬盘上的文件，效率要比read和write系统调用高，这是为什么？\n\n- read()是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝；\n- map()也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝。\n\n所以，采用内存映射的读写效率要比传统的read/write性能高。\n\n#### 总结\n\n* MappedByteBuffer使用虚拟内存，因此分配(map)的内存大小不受JVM的-Xmx参数限制，但是也是有大小限制的。\n\n* 如果当文件超出Integer.MAX_VALUE字节限制时，可以通过position参数重新map文件后面的内容。\n\n* MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。\n   javadoc中也提到：*A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected.*","slug":"java-memory-mapped-file","published":1,"updated":"2018-12-08T12:20:36.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5f0026zjia8u7f5jdf","content":"<blockquote>\n<p>在传统的文件读写方式中，会有两次数据拷贝，一次是从硬盘拷贝到操作系统内核，另一次是从操作系统内核拷贝到用户态的应用程序。而在内存映射文件中，一般情况下，只有一次拷贝，且内存分配在操作系统内核，应用程序访问的就是操作系统的内核内存空间，这显然要比普通的读写效率更高。</p>\n<p>内存映射文件的另一个重要特点是，它可以被多个不同的应用程序共享，多个程序可以映射同一个文件，映射到同一块内存区域，一个程序对内存的修改，可以让其他程序也看到，这使得它特别适合用于不同应用程序之间的通信。<strong>比普通的基于loopback接口的Socket要快10倍。</strong>那么在Java语言中是如何实现Memory Mapped File的呢？</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>在Java nio包中引入了<code>MappedByteBuffer</code>来实现Memory Mapped File，从继承结构上来看MappedByteBuffer继承自ByteBuffer，内部维护了一个逻辑地址address。</p>\n<p>下面写个简单的示例来演示如何使用FileChannel和MappedByteBuffer：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Shuai Junlan[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> Created in 3:03 PM 12/8/18.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MmapTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"test.txt\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> file.exists() || file.createNewFile();</span><br><span class=\"line\">        FileChannel channel = <span class=\"keyword\">new</span> RandomAccessFile(file, <span class=\"string\">\"rw\"</span>).getChannel();</span><br><span class=\"line\">        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class=\"number\">0</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">            mappedByteBuffer.put((<span class=\"keyword\">byte</span>)i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mappedByteBuffer.position(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">            System.out.println(mappedByteBuffer.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中可以看到，FileChannel通过调用map方法把文件映射到了虚拟内存，在Java中规定的最大映射大小为<strong>Integer.MAX_VALUE</strong>，如果文件太大可以进行分段映射，我们来分析一下map方法中各个参数的含义：</p>\n<p><strong>mode</strong>:内存映射文件访问的方式，包括以下三种：</p>\n<ul>\n<li><p>1.<code>MapMode.READ_ONLY</code>：只读，试图修改得到的缓冲区将导致抛出异常。</p>\n</li>\n<li><p>2.<code>MapMode.READ_WRITE</code>：读/写，对得到的缓冲区的更改最终将写入文件；但该更改对映射到同一文件的其他程序不一定是可见的。</p>\n</li>\n<li><p>3.<code>MapMode.PRIVATE</code>：私用，可读可写,但是修改的内容不会写入文件，只是buffer自身的改变，这种能力称之为<strong>copy on write</strong>。</p>\n</li>\n</ul>\n<p><strong>position</strong>:被映射文件的其实位置；</p>\n<p><strong>size</strong>:映射区域的大小，单位为byte，最大映射大小为<strong>Integer.MAX_VALUE</strong>；</p>\n<h4 id=\"进一步分析map过程的内部实现原理：\"><a href=\"#进一步分析map过程的内部实现原理：\" class=\"headerlink\" title=\"进一步分析map过程的内部实现原理：\"></a>进一步分析map过程的内部实现原理：</h4><h5 id=\"第一步，通过RandomAccessFile获取FileChannel：\"><a href=\"#第一步，通过RandomAccessFile获取FileChannel：\" class=\"headerlink\" title=\"第一步，通过RandomAccessFile获取FileChannel：\"></a>第一步，通过RandomAccessFile获取FileChannel：</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> FileChannel <span class=\"title\">getChannel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            channel = FileChannelImpl.open(fd, path, <span class=\"keyword\">true</span>, rw, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法中使用了同步关键字，保证了多线程情况下只能初始化一个FileChannel实例。</p>\n<h5 id=\"第二步，使用FileChannel的map方法，把文件映射到用户虚拟内存空间，并返回逻辑地址\"><a href=\"#第二步，使用FileChannel的map方法，把文件映射到用户虚拟内存空间，并返回逻辑地址\" class=\"headerlink\" title=\"第二步，使用FileChannel的map方法，把文件映射到用户虚拟内存空间，并返回逻辑地址\"></a>第二步，使用FileChannel的map方法，把文件映射到用户虚拟内存空间，并返回逻辑地址</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> MappedByteBuffer <span class=\"title\">map</span><span class=\"params\">(MapMode mode, <span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\">      <span class=\"keyword\">throws</span> IOException</span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//省略参数检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">long</span> addr = -<span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> ti = -<span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          begin();</span><br><span class=\"line\">          ti = threads.add();</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">long</span> mapSize;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> pagePosition;</span><br><span class=\"line\">          <span class=\"comment\">//加锁，保证线程安全</span></span><br><span class=\"line\">          <span class=\"keyword\">synchronized</span> (positionLock) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">long</span> filesize;</span><br><span class=\"line\">              <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                  filesize = nd.size(fd);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">while</span> ((filesize == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果映射范围超出文件的大小且不可写，则抛出异常</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (filesize &lt; position + size) &#123; <span class=\"comment\">// Extend file size</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (!writable) &#123;</span><br><span class=\"line\">                      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Channel not open for writing \"</span> +</span><br><span class=\"line\">                          <span class=\"string\">\"- cannot extend file to required size\"</span>);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">int</span> rv;</span><br><span class=\"line\">                  <span class=\"comment\">//填充文件</span></span><br><span class=\"line\">                  <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                      rv = nd.allocate(fd, position + size);</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">while</span> ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">                      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              pagePosition = (<span class=\"keyword\">int</span>)(position % allocationGranularity);</span><br><span class=\"line\">              <span class=\"keyword\">long</span> mapPosition = position - pagePosition;</span><br><span class=\"line\">              mapSize = size + pagePosition;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// If map0 did not throw an exception, the address is valid</span></span><br><span class=\"line\">                  addr = map0(imode, mapPosition, mapSize);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError x) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// An OutOfMemoryError may indicate that we've exhausted</span></span><br><span class=\"line\">                  <span class=\"comment\">// memory so force gc and re-attempt map</span></span><br><span class=\"line\">                  System.gc();</span><br><span class=\"line\">                  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                      Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">catch</span> (InterruptedException y) &#123;</span><br><span class=\"line\">                      Thread.currentThread().interrupt();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                      addr = map0(imode, mapPosition, mapSize);</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError y) &#123;</span><br><span class=\"line\">                      <span class=\"comment\">// After a second OOME, fail</span></span><br><span class=\"line\">                      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Map failed\"</span>, y);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125; <span class=\"comment\">// synchronized</span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// On Windows, and potentially other platforms, we need an open</span></span><br><span class=\"line\">          <span class=\"comment\">// file descriptor for some mapping operations.</span></span><br><span class=\"line\">          FileDescriptor mfd;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              mfd = nd.duplicateForMapping(fd);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">              unmap0(addr, mapSize);</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> ioe;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">assert</span> (IOStatus.checkAll(addr));</span><br><span class=\"line\">          <span class=\"keyword\">assert</span> (addr % allocationGranularity == <span class=\"number\">0</span>);</span><br><span class=\"line\">          <span class=\"keyword\">int</span> isize = (<span class=\"keyword\">int</span>)size;</span><br><span class=\"line\">          Unmapper um = <span class=\"keyword\">new</span> Unmapper(addr, mapSize, isize, mfd);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((!writable) || (imode == MAP_RO)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> Util.newMappedByteBufferR(isize,</span><br><span class=\"line\">                                               addr + pagePosition,</span><br><span class=\"line\">                                               mfd,</span><br><span class=\"line\">                                               um);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> Util.newMappedByteBuffer(isize,</span><br><span class=\"line\">                                              addr + pagePosition,</span><br><span class=\"line\">                                              mfd,</span><br><span class=\"line\">                                              um);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          threads.remove(ti);</span><br><span class=\"line\">          end(IOStatus.checkAll(addr));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>map方法最终是通过调用native函数map0()完成文件映射：</p>\n<p>1.如果第一次文件映射导致OOM，则手动处罚垃圾回收，休眠100ms后再尝试映射，如果失败则抛出异常；</p>\n<p>2.通过<code>newMappedByteBuffer</code>（ReadWrite）或者<code>newMappedByteBufferR</code>（Read Only）方法初始化MappedByteBuffer实例，最终返回DirectByteBuffer的实例，该类是MappedByteBuffer的子类；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> MappedByteBuffer <span class=\"title\">newMappedByteBuffer</span><span class=\"params\">(<span class=\"keyword\">int</span> size, <span class=\"keyword\">long</span> addr,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                            FileDescriptor fd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                            Runnable unmapper)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    MappedByteBuffer dbb;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (directByteBufferConstructor == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        initDBBConstructor();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        dbb = (MappedByteBuffer)directByteBufferConstructor.newInstance(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Object[] &#123; <span class=\"keyword\">new</span> Integer(size),</span><br><span class=\"line\">                          <span class=\"keyword\">new</span> Long(addr),</span><br><span class=\"line\">                          fd,</span><br><span class=\"line\">                          unmapper &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InstantiationException |</span><br><span class=\"line\">             IllegalAccessException |</span><br><span class=\"line\">             InvocationTargetException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dbb;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">initDBBRConstructor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Class&lt;?&gt; cl = Class.forName(<span class=\"string\">\"java.nio.DirectByteBufferR\"</span>);</span><br><span class=\"line\">                Constructor&lt;?&gt; ctor = cl.getDeclaredConstructor(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; <span class=\"keyword\">int</span>.class,</span><br><span class=\"line\">                                    <span class=\"keyword\">long</span>.class,</span><br><span class=\"line\">                                    FileDescriptor.class,</span><br><span class=\"line\">                                    Runnable.class &#125;);</span><br><span class=\"line\">                ctor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                directByteBufferRConstructor = ctor;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException |</span><br><span class=\"line\">                     NoSuchMethodException |</span><br><span class=\"line\">                     IllegalArgumentException |</span><br><span class=\"line\">                     ClassCastException x) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于FileChannelImpl和DirectByteBuffer不在同一个包中，并切DirectByteBuffer类是默认的访问权限，因此无法直接在FileChannelImpl的map函数中直接实例化DirectByteBuffer，通过Util.java类的newMappedByteBuffer()方法去实例化，在上面的代码中，实例化的核心逻辑就是通过AccessController获取DirectByteBuffer类的构造函数进行实例化。</p>\n<p>关于本地方法map0()，在JDK源码中找到了他的具体实现，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                                     jint prot, jlong off, jlong len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *mapAddress = <span class=\"number\">0</span>;</span><br><span class=\"line\">    jobject fdo = (*env)-&gt;GetObjectField(env, <span class=\"keyword\">this</span>, chan_fd);</span><br><span class=\"line\">    jint fd = fdval(env, fdo);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> protections = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prot == sun_nio_ch_FileChannelImpl_MAP_RO) &#123;</span><br><span class=\"line\">        protections = PROT_READ;</span><br><span class=\"line\">        flags = MAP_SHARED;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prot == sun_nio_ch_FileChannelImpl_MAP_RW) &#123;</span><br><span class=\"line\">        protections = PROT_WRITE | PROT_READ;</span><br><span class=\"line\">        flags = MAP_SHARED;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prot == sun_nio_ch_FileChannelImpl_MAP_PV) &#123;</span><br><span class=\"line\">        protections =  PROT_WRITE | PROT_READ;</span><br><span class=\"line\">        flags = MAP_PRIVATE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mapAddress = mmap64(</span><br><span class=\"line\">        <span class=\"number\">0</span>,                    <span class=\"comment\">/* Let OS decide location */</span></span><br><span class=\"line\">        len,                  <span class=\"comment\">/* Number of bytes to map */</span></span><br><span class=\"line\">        protections,          <span class=\"comment\">/* File permissions */</span></span><br><span class=\"line\">        flags,                <span class=\"comment\">/* Changes are shared */</span></span><br><span class=\"line\">        fd,                   <span class=\"comment\">/* File descriptor of mapped file */</span></span><br><span class=\"line\">        off);                 <span class=\"comment\">/* Offset into file */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mapAddress == MAP_FAILED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == ENOMEM) &#123;</span><br><span class=\"line\">            JNU_ThrowOutOfMemoryError(env, <span class=\"string\">\"Map failed\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> IOS_THROWN;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle(env, <span class=\"number\">-1</span>, <span class=\"string\">\"Map failed\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((jlong) (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>) mapAddress);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"get和put方法\"><a href=\"#get和put方法\" class=\"headerlink\" title=\"get和put方法\"></a>get和put方法</h4><p>调用get和put方法对数据进行读写，最终其实是调用DirectByteBuffer类的get和put方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">byte</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((unsafe.getByte(ix(nextGetIndex()))));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ByteBuffer <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">byte</span> x)</span> </span>&#123;</span><br><span class=\"line\">    unsafe.putByte(ix(nextPutIndex()), ((x)));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面的代码可以看出，底层都是通过调用Unsafe类的getByte和putByte方法来操作数据的。</p>\n<ul>\n<li><p>第一次访问address所指向的内存区域，导致缺页中断，中断响应函数会在交换区中查找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则从硬盘上将文件指定页读取到物理内存中（非jvm堆内存）。</p>\n</li>\n<li><p>如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘的虚拟内存中。</p>\n</li>\n</ul>\n<h4 id=\"性能分析\"><a href=\"#性能分析\" class=\"headerlink\" title=\"性能分析\"></a>性能分析</h4><p>从代码层面上看，从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，并且数据拷贝操作是由文件系统和硬件驱动实现的，理论上来说，拷贝数据的效率是一样的。<br> 但是通过内存映射的方法访问硬盘上的文件，效率要比read和write系统调用高，这是为什么？</p>\n<ul>\n<li>read()是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝；</li>\n<li>map()也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝。</li>\n</ul>\n<p>所以，采用内存映射的读写效率要比传统的read/write性能高。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li><p>MappedByteBuffer使用虚拟内存，因此分配(map)的内存大小不受JVM的-Xmx参数限制，但是也是有大小限制的。</p>\n</li>\n<li><p>如果当文件超出Integer.MAX_VALUE字节限制时，可以通过position参数重新map文件后面的内容。</p>\n</li>\n<li><p>MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。<br> javadoc中也提到：<em>A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected.</em></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在传统的文件读写方式中，会有两次数据拷贝，一次是从硬盘拷贝到操作系统内核，另一次是从操作系统内核拷贝到用户态的应用程序。而在内存映射文件中，一般情况下，只有一次拷贝，且内存分配在操作系统内核，应用程序访问的就是操作系统的内核内存空间，这显然要比普通的读写效率更高。</p>\n<p>内存映射文件的另一个重要特点是，它可以被多个不同的应用程序共享，多个程序可以映射同一个文件，映射到同一块内存区域，一个程序对内存的修改，可以让其他程序也看到，这使得它特别适合用于不同应用程序之间的通信。<strong>比普通的基于loopback接口的Socket要快10倍。</strong>那么在Java语言中是如何实现Memory Mapped File的呢？</p>\n</blockquote>","more":"<p>在Java nio包中引入了<code>MappedByteBuffer</code>来实现Memory Mapped File，从继承结构上来看MappedByteBuffer继承自ByteBuffer，内部维护了一个逻辑地址address。</p>\n<p>下面写个简单的示例来演示如何使用FileChannel和MappedByteBuffer：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Shuai Junlan[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> Created in 3:03 PM 12/8/18.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MmapTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"test.txt\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> file.exists() || file.createNewFile();</span><br><span class=\"line\">        FileChannel channel = <span class=\"keyword\">new</span> RandomAccessFile(file, <span class=\"string\">\"rw\"</span>).getChannel();</span><br><span class=\"line\">        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class=\"number\">0</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">            mappedByteBuffer.put((<span class=\"keyword\">byte</span>)i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mappedByteBuffer.position(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">            System.out.println(mappedByteBuffer.get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中可以看到，FileChannel通过调用map方法把文件映射到了虚拟内存，在Java中规定的最大映射大小为<strong>Integer.MAX_VALUE</strong>，如果文件太大可以进行分段映射，我们来分析一下map方法中各个参数的含义：</p>\n<p><strong>mode</strong>:内存映射文件访问的方式，包括以下三种：</p>\n<ul>\n<li><p>1.<code>MapMode.READ_ONLY</code>：只读，试图修改得到的缓冲区将导致抛出异常。</p>\n</li>\n<li><p>2.<code>MapMode.READ_WRITE</code>：读/写，对得到的缓冲区的更改最终将写入文件；但该更改对映射到同一文件的其他程序不一定是可见的。</p>\n</li>\n<li><p>3.<code>MapMode.PRIVATE</code>：私用，可读可写,但是修改的内容不会写入文件，只是buffer自身的改变，这种能力称之为<strong>copy on write</strong>。</p>\n</li>\n</ul>\n<p><strong>position</strong>:被映射文件的其实位置；</p>\n<p><strong>size</strong>:映射区域的大小，单位为byte，最大映射大小为<strong>Integer.MAX_VALUE</strong>；</p>\n<h4 id=\"进一步分析map过程的内部实现原理：\"><a href=\"#进一步分析map过程的内部实现原理：\" class=\"headerlink\" title=\"进一步分析map过程的内部实现原理：\"></a>进一步分析map过程的内部实现原理：</h4><h5 id=\"第一步，通过RandomAccessFile获取FileChannel：\"><a href=\"#第一步，通过RandomAccessFile获取FileChannel：\" class=\"headerlink\" title=\"第一步，通过RandomAccessFile获取FileChannel：\"></a>第一步，通过RandomAccessFile获取FileChannel：</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> FileChannel <span class=\"title\">getChannel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            channel = FileChannelImpl.open(fd, path, <span class=\"keyword\">true</span>, rw, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> channel;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法中使用了同步关键字，保证了多线程情况下只能初始化一个FileChannel实例。</p>\n<h5 id=\"第二步，使用FileChannel的map方法，把文件映射到用户虚拟内存空间，并返回逻辑地址\"><a href=\"#第二步，使用FileChannel的map方法，把文件映射到用户虚拟内存空间，并返回逻辑地址\" class=\"headerlink\" title=\"第二步，使用FileChannel的map方法，把文件映射到用户虚拟内存空间，并返回逻辑地址\"></a>第二步，使用FileChannel的map方法，把文件映射到用户虚拟内存空间，并返回逻辑地址</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> MappedByteBuffer <span class=\"title\">map</span><span class=\"params\">(MapMode mode, <span class=\"keyword\">long</span> position, <span class=\"keyword\">long</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\">      <span class=\"keyword\">throws</span> IOException</span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//省略参数检查</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">long</span> addr = -<span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> ti = -<span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          begin();</span><br><span class=\"line\">          ti = threads.add();</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">long</span> mapSize;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> pagePosition;</span><br><span class=\"line\">          <span class=\"comment\">//加锁，保证线程安全</span></span><br><span class=\"line\">          <span class=\"keyword\">synchronized</span> (positionLock) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">long</span> filesize;</span><br><span class=\"line\">              <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                  filesize = nd.size(fd);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">while</span> ((filesize == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果映射范围超出文件的大小且不可写，则抛出异常</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (filesize &lt; position + size) &#123; <span class=\"comment\">// Extend file size</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (!writable) &#123;</span><br><span class=\"line\">                      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Channel not open for writing \"</span> +</span><br><span class=\"line\">                          <span class=\"string\">\"- cannot extend file to required size\"</span>);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">int</span> rv;</span><br><span class=\"line\">                  <span class=\"comment\">//填充文件</span></span><br><span class=\"line\">                  <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                      rv = nd.allocate(fd, position + size);</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">while</span> ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">                      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">              pagePosition = (<span class=\"keyword\">int</span>)(position % allocationGranularity);</span><br><span class=\"line\">              <span class=\"keyword\">long</span> mapPosition = position - pagePosition;</span><br><span class=\"line\">              mapSize = size + pagePosition;</span><br><span class=\"line\">              <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// If map0 did not throw an exception, the address is valid</span></span><br><span class=\"line\">                  addr = map0(imode, mapPosition, mapSize);</span><br><span class=\"line\">              &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError x) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">// An OutOfMemoryError may indicate that we've exhausted</span></span><br><span class=\"line\">                  <span class=\"comment\">// memory so force gc and re-attempt map</span></span><br><span class=\"line\">                  System.gc();</span><br><span class=\"line\">                  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                      Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">catch</span> (InterruptedException y) &#123;</span><br><span class=\"line\">                      Thread.currentThread().interrupt();</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                      addr = map0(imode, mapPosition, mapSize);</span><br><span class=\"line\">                  &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError y) &#123;</span><br><span class=\"line\">                      <span class=\"comment\">// After a second OOME, fail</span></span><br><span class=\"line\">                      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Map failed\"</span>, y);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125; <span class=\"comment\">// synchronized</span></span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">// On Windows, and potentially other platforms, we need an open</span></span><br><span class=\"line\">          <span class=\"comment\">// file descriptor for some mapping operations.</span></span><br><span class=\"line\">          FileDescriptor mfd;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              mfd = nd.duplicateForMapping(fd);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">              unmap0(addr, mapSize);</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> ioe;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">assert</span> (IOStatus.checkAll(addr));</span><br><span class=\"line\">          <span class=\"keyword\">assert</span> (addr % allocationGranularity == <span class=\"number\">0</span>);</span><br><span class=\"line\">          <span class=\"keyword\">int</span> isize = (<span class=\"keyword\">int</span>)size;</span><br><span class=\"line\">          Unmapper um = <span class=\"keyword\">new</span> Unmapper(addr, mapSize, isize, mfd);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((!writable) || (imode == MAP_RO)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> Util.newMappedByteBufferR(isize,</span><br><span class=\"line\">                                               addr + pagePosition,</span><br><span class=\"line\">                                               mfd,</span><br><span class=\"line\">                                               um);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> Util.newMappedByteBuffer(isize,</span><br><span class=\"line\">                                              addr + pagePosition,</span><br><span class=\"line\">                                              mfd,</span><br><span class=\"line\">                                              um);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">          threads.remove(ti);</span><br><span class=\"line\">          end(IOStatus.checkAll(addr));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>map方法最终是通过调用native函数map0()完成文件映射：</p>\n<p>1.如果第一次文件映射导致OOM，则手动处罚垃圾回收，休眠100ms后再尝试映射，如果失败则抛出异常；</p>\n<p>2.通过<code>newMappedByteBuffer</code>（ReadWrite）或者<code>newMappedByteBufferR</code>（Read Only）方法初始化MappedByteBuffer实例，最终返回DirectByteBuffer的实例，该类是MappedByteBuffer的子类；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> MappedByteBuffer <span class=\"title\">newMappedByteBuffer</span><span class=\"params\">(<span class=\"keyword\">int</span> size, <span class=\"keyword\">long</span> addr,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                            FileDescriptor fd,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                            Runnable unmapper)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    MappedByteBuffer dbb;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (directByteBufferConstructor == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        initDBBConstructor();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        dbb = (MappedByteBuffer)directByteBufferConstructor.newInstance(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Object[] &#123; <span class=\"keyword\">new</span> Integer(size),</span><br><span class=\"line\">                          <span class=\"keyword\">new</span> Long(addr),</span><br><span class=\"line\">                          fd,</span><br><span class=\"line\">                          unmapper &#125;);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InstantiationException |</span><br><span class=\"line\">             IllegalAccessException |</span><br><span class=\"line\">             InvocationTargetException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dbb;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">initDBBRConstructor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    AccessController.doPrivileged(<span class=\"keyword\">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Class&lt;?&gt; cl = Class.forName(<span class=\"string\">\"java.nio.DirectByteBufferR\"</span>);</span><br><span class=\"line\">                Constructor&lt;?&gt; ctor = cl.getDeclaredConstructor(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; <span class=\"keyword\">int</span>.class,</span><br><span class=\"line\">                                    <span class=\"keyword\">long</span>.class,</span><br><span class=\"line\">                                    FileDescriptor.class,</span><br><span class=\"line\">                                    Runnable.class &#125;);</span><br><span class=\"line\">                ctor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                directByteBufferRConstructor = ctor;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException |</span><br><span class=\"line\">                     NoSuchMethodException |</span><br><span class=\"line\">                     IllegalArgumentException |</span><br><span class=\"line\">                     ClassCastException x) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InternalError(x);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于FileChannelImpl和DirectByteBuffer不在同一个包中，并切DirectByteBuffer类是默认的访问权限，因此无法直接在FileChannelImpl的map函数中直接实例化DirectByteBuffer，通过Util.java类的newMappedByteBuffer()方法去实例化，在上面的代码中，实例化的核心逻辑就是通过AccessController获取DirectByteBuffer类的构造函数进行实例化。</p>\n<p>关于本地方法map0()，在JDK源码中找到了他的具体实现，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                                     jint prot, jlong off, jlong len)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *mapAddress = <span class=\"number\">0</span>;</span><br><span class=\"line\">    jobject fdo = (*env)-&gt;GetObjectField(env, <span class=\"keyword\">this</span>, chan_fd);</span><br><span class=\"line\">    jint fd = fdval(env, fdo);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> protections = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> flags = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prot == sun_nio_ch_FileChannelImpl_MAP_RO) &#123;</span><br><span class=\"line\">        protections = PROT_READ;</span><br><span class=\"line\">        flags = MAP_SHARED;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prot == sun_nio_ch_FileChannelImpl_MAP_RW) &#123;</span><br><span class=\"line\">        protections = PROT_WRITE | PROT_READ;</span><br><span class=\"line\">        flags = MAP_SHARED;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (prot == sun_nio_ch_FileChannelImpl_MAP_PV) &#123;</span><br><span class=\"line\">        protections =  PROT_WRITE | PROT_READ;</span><br><span class=\"line\">        flags = MAP_PRIVATE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mapAddress = mmap64(</span><br><span class=\"line\">        <span class=\"number\">0</span>,                    <span class=\"comment\">/* Let OS decide location */</span></span><br><span class=\"line\">        len,                  <span class=\"comment\">/* Number of bytes to map */</span></span><br><span class=\"line\">        protections,          <span class=\"comment\">/* File permissions */</span></span><br><span class=\"line\">        flags,                <span class=\"comment\">/* Changes are shared */</span></span><br><span class=\"line\">        fd,                   <span class=\"comment\">/* File descriptor of mapped file */</span></span><br><span class=\"line\">        off);                 <span class=\"comment\">/* Offset into file */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mapAddress == MAP_FAILED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == ENOMEM) &#123;</span><br><span class=\"line\">            JNU_ThrowOutOfMemoryError(env, <span class=\"string\">\"Map failed\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> IOS_THROWN;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handle(env, <span class=\"number\">-1</span>, <span class=\"string\">\"Map failed\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((jlong) (<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>) mapAddress);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"get和put方法\"><a href=\"#get和put方法\" class=\"headerlink\" title=\"get和put方法\"></a>get和put方法</h4><p>调用get和put方法对数据进行读写，最终其实是调用DirectByteBuffer类的get和put方法，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">byte</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((unsafe.getByte(ix(nextGetIndex()))));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ByteBuffer <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">byte</span> x)</span> </span>&#123;</span><br><span class=\"line\">    unsafe.putByte(ix(nextPutIndex()), ((x)));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面的代码可以看出，底层都是通过调用Unsafe类的getByte和putByte方法来操作数据的。</p>\n<ul>\n<li><p>第一次访问address所指向的内存区域，导致缺页中断，中断响应函数会在交换区中查找相对应的页面，如果找不到（也就是该文件从来没有被读入内存的情况），则从硬盘上将文件指定页读取到物理内存中（非jvm堆内存）。</p>\n</li>\n<li><p>如果在拷贝数据时，发现物理内存不够用，则会通过虚拟内存机制（swap）将暂时不用的物理页面交换到硬盘的虚拟内存中。</p>\n</li>\n</ul>\n<h4 id=\"性能分析\"><a href=\"#性能分析\" class=\"headerlink\" title=\"性能分析\"></a>性能分析</h4><p>从代码层面上看，从硬盘上将文件读入内存，都要经过文件系统进行数据拷贝，并且数据拷贝操作是由文件系统和硬件驱动实现的，理论上来说，拷贝数据的效率是一样的。<br> 但是通过内存映射的方法访问硬盘上的文件，效率要比read和write系统调用高，这是为什么？</p>\n<ul>\n<li>read()是系统调用，首先将文件从硬盘拷贝到内核空间的一个缓冲区，再将这些数据拷贝到用户空间，实际上进行了两次数据拷贝；</li>\n<li>map()也是系统调用，但没有进行数据拷贝，当缺页中断发生时，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝。</li>\n</ul>\n<p>所以，采用内存映射的读写效率要比传统的read/write性能高。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li><p>MappedByteBuffer使用虚拟内存，因此分配(map)的内存大小不受JVM的-Xmx参数限制，但是也是有大小限制的。</p>\n</li>\n<li><p>如果当文件超出Integer.MAX_VALUE字节限制时，可以通过position参数重新map文件后面的内容。</p>\n</li>\n<li><p>MappedByteBuffer在处理大文件时的确性能很高，但也存在一些问题，如内存占用、文件关闭不确定，被其打开的文件只有在垃圾回收的才会被关闭，而且这个时间点是不确定的。<br> javadoc中也提到：<em>A mapped byte buffer and the file mapping that it represents remain valid until the buffer itself is garbage-collected.</em></p>\n</li>\n</ul>"},{"title":"配置KVM虚拟机网络的两种方式（Bridge模式和NAT模式）","date":"2016-11-16T02:07:15.000Z","_content":"\n* Bridge原理(桥接模式)\n    1. Bridge方式即虚拟网桥的网络连接方式，使客户机和子网里面的机器能够互相通信。可以使虚拟机成为网络中具有独立IP的主机。\n    桥接网络（也叫物理设备共享）被用作把一个物理设备复制到一台虚拟机。网桥多用作高级设置，特别是主机多个网络接口的情况。\n\n    <!-- more -->\n    2. 在bridged模式下，虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。同时，由于这个虚拟系统是局域网中的一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或路由器访问互联网。使用bridged模式的虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑。想让它们相互通讯，你就需要为虚拟系统配置IP地址和子网掩码，否则就无法通信（参考dhcp服务器是否开启，如果开启，则可以选择dhcp方式自动获取网络地址）。这种方式最简单，直接将虚拟网卡桥接到一个物理网卡上面，和linux下一个网卡绑定两个不同地址类似，实际上是将网卡设置为混杂模式，从而达到侦听多个IP的能力。在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。使用这种方式很简单，前提是你可以得到1个以上的地址。\n\n        ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/libvirt-kvm-bridge-network.png \"图片1\")\n\n    > 如上图，网桥的基本原理就是创建一个桥接接口br0，在物理网卡和虚拟网络接口之间传递数据。\n\n    * 基本步骤<br>\n        1. 安装完CentOS7.0， 在/etc/sysconfig/network-scripts/目录下面会生成两个默认网络配置文件。（如图）\n\n            ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/2.png \"图片1\")\n        2. 继续看文件里面的详细信息。\n            * ifcfg-eth0</br>\n            ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/1.png \"图片1\")\n            * ifcfg-lo</br>\n            ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/3.png \"图片1\")\n        3. 配置静态IP\n            * 在相同目录下面添加一个ifcfg-br0文件，并在文件中添加如下内容</br>\n            ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/4.png \"图片1\")\n            * 并且修改ifcfg-eth0文件</br>\n            ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/5.png \"图片1\")\n        4. 配置动态IP\n            * 在相同目录下面添加一个ifcfg-br0文件，并在文件中添加如下内容\n            ```xml\n            DEVICE=br0\n            TYPE=Bridge\n            NM_CONTROLLED=no\n            BOOTPROTO=dhcp\n            ONBOOT=yes\n            ```\n            * 并且修改ifcfg-eth0文件</br>\n            ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/5.png \"图片1\")\n        5. 申明\n* NAT原理(网络地址转换模式)\n\n    > 使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。很显然，如果你只有一个外网地址，此种方式很合适。\n\n    * virsh net-list\n        >查看当前活跃的网络，可以看到一个default网络，这个就是一个默认的Nat网络了。\n\n    * virsh net-dumpxml default\n        >查看网络配置\n\n        ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/default-nat.png \"图片1\")\n\n\n#### 持续更新中......\n-----\n\n* REFERENCES\n\n    1. <a href=\"https://www.chenyudong.com/archives/libvirt-kvm-bridge-network.html\" target=\"\\_blank\">libvirt kvm 虚拟机上网 – Bridge桥接</a>\n","source":"_posts/libvirt-kvm.md","raw":"---\ntitle: 配置KVM虚拟机网络的两种方式（Bridge模式和NAT模式）\ndate: 2016-11-16 10:07:15\ntags:\n    - 虚拟化\n    - KVM\n    - 网络配置\n    - Linux\n---\n\n* Bridge原理(桥接模式)\n    1. Bridge方式即虚拟网桥的网络连接方式，使客户机和子网里面的机器能够互相通信。可以使虚拟机成为网络中具有独立IP的主机。\n    桥接网络（也叫物理设备共享）被用作把一个物理设备复制到一台虚拟机。网桥多用作高级设置，特别是主机多个网络接口的情况。\n\n    <!-- more -->\n    2. 在bridged模式下，虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。同时，由于这个虚拟系统是局域网中的一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或路由器访问互联网。使用bridged模式的虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑。想让它们相互通讯，你就需要为虚拟系统配置IP地址和子网掩码，否则就无法通信（参考dhcp服务器是否开启，如果开启，则可以选择dhcp方式自动获取网络地址）。这种方式最简单，直接将虚拟网卡桥接到一个物理网卡上面，和linux下一个网卡绑定两个不同地址类似，实际上是将网卡设置为混杂模式，从而达到侦听多个IP的能力。在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。使用这种方式很简单，前提是你可以得到1个以上的地址。\n\n        ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/libvirt-kvm-bridge-network.png \"图片1\")\n\n    > 如上图，网桥的基本原理就是创建一个桥接接口br0，在物理网卡和虚拟网络接口之间传递数据。\n\n    * 基本步骤<br>\n        1. 安装完CentOS7.0， 在/etc/sysconfig/network-scripts/目录下面会生成两个默认网络配置文件。（如图）\n\n            ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/2.png \"图片1\")\n        2. 继续看文件里面的详细信息。\n            * ifcfg-eth0</br>\n            ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/1.png \"图片1\")\n            * ifcfg-lo</br>\n            ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/3.png \"图片1\")\n        3. 配置静态IP\n            * 在相同目录下面添加一个ifcfg-br0文件，并在文件中添加如下内容</br>\n            ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/4.png \"图片1\")\n            * 并且修改ifcfg-eth0文件</br>\n            ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/5.png \"图片1\")\n        4. 配置动态IP\n            * 在相同目录下面添加一个ifcfg-br0文件，并在文件中添加如下内容\n            ```xml\n            DEVICE=br0\n            TYPE=Bridge\n            NM_CONTROLLED=no\n            BOOTPROTO=dhcp\n            ONBOOT=yes\n            ```\n            * 并且修改ifcfg-eth0文件</br>\n            ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/5.png \"图片1\")\n        5. 申明\n* NAT原理(网络地址转换模式)\n\n    > 使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。很显然，如果你只有一个外网地址，此种方式很合适。\n\n    * virsh net-list\n        >查看当前活跃的网络，可以看到一个default网络，这个就是一个默认的Nat网络了。\n\n    * virsh net-dumpxml default\n        >查看网络配置\n\n        ![image](http://learningnotes-1251679769.costj.myqcloud.com/linux/default-nat.png \"图片1\")\n\n\n#### 持续更新中......\n-----\n\n* REFERENCES\n\n    1. <a href=\"https://www.chenyudong.com/archives/libvirt-kvm-bridge-network.html\" target=\"\\_blank\">libvirt kvm 虚拟机上网 – Bridge桥接</a>\n","slug":"libvirt-kvm","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5g0029zjiafti8s7ky","content":"<ul>\n<li><p>Bridge原理(桥接模式)</p>\n<ol>\n<li><p>Bridge方式即虚拟网桥的网络连接方式，使客户机和子网里面的机器能够互相通信。可以使虚拟机成为网络中具有独立IP的主机。<br>桥接网络（也叫物理设备共享）被用作把一个物理设备复制到一台虚拟机。网桥多用作高级设置，特别是主机多个网络接口的情况。</p>\n<a id=\"more\"></a></li>\n<li><p>在bridged模式下，虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。同时，由于这个虚拟系统是局域网中的一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或路由器访问互联网。使用bridged模式的虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑。想让它们相互通讯，你就需要为虚拟系统配置IP地址和子网掩码，否则就无法通信（参考dhcp服务器是否开启，如果开启，则可以选择dhcp方式自动获取网络地址）。这种方式最简单，直接将虚拟网卡桥接到一个物理网卡上面，和linux下一个网卡绑定两个不同地址类似，实际上是将网卡设置为混杂模式，从而达到侦听多个IP的能力。在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。使用这种方式很简单，前提是你可以得到1个以上的地址。</p>\n<p> <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/libvirt-kvm-bridge-network.png\" alt=\"image\" title=\"图片1\"></p>\n<blockquote>\n<p>如上图，网桥的基本原理就是创建一个桥接接口br0，在物理网卡和虚拟网络接口之间传递数据。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li><p>基本步骤<br></p>\n<ol>\n<li><p>安装完CentOS7.0， 在/etc/sysconfig/network-scripts/目录下面会生成两个默认网络配置文件。（如图）</p>\n<p> <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/2.png\" alt=\"image\" title=\"图片1\"></p>\n</li>\n<li>继续看文件里面的详细信息。<ul>\n<li>ifcfg-eth0<br><br><img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/1.png\" alt=\"image\" title=\"图片1\"></li>\n<li>ifcfg-lo<br><br><img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/3.png\" alt=\"image\" title=\"图片1\"></li>\n</ul>\n</li>\n<li>配置静态IP<ul>\n<li>在相同目录下面添加一个ifcfg-br0文件，并在文件中添加如下内容<br><br><img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/4.png\" alt=\"image\" title=\"图片1\"></li>\n<li>并且修改ifcfg-eth0文件<br><br><img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/5.png\" alt=\"image\" title=\"图片1\"></li>\n</ul>\n</li>\n<li><p>配置动态IP</p>\n<ul>\n<li><p>在相同目录下面添加一个ifcfg-br0文件，并在文件中添加如下内容</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEVICE=br0</span><br><span class=\"line\">TYPE=Bridge</span><br><span class=\"line\">NM_CONTROLLED=no</span><br><span class=\"line\">BOOTPROTO=dhcp</span><br><span class=\"line\">ONBOOT=yes</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>并且修改ifcfg-eth0文件<br><br><img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/5.png\" alt=\"image\" title=\"图片1\"></p>\n</li>\n</ul>\n</li>\n<li>申明</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>NAT原理(网络地址转换模式)</p>\n<blockquote>\n<p>使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。很显然，如果你只有一个外网地址，此种方式很合适。</p>\n</blockquote>\n<ul>\n<li><p>virsh net-list</p>\n<blockquote>\n<p>查看当前活跃的网络，可以看到一个default网络，这个就是一个默认的Nat网络了。</p>\n</blockquote>\n</li>\n<li><p>virsh net-dumpxml default</p>\n<blockquote>\n<p>查看网络配置</p>\n</blockquote>\n<p>  <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/default-nat.png\" alt=\"image\" title=\"图片1\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"持续更新中……\"><a href=\"#持续更新中……\" class=\"headerlink\" title=\"持续更新中……\"></a>持续更新中……</h4><hr>\n<ul>\n<li><p>REFERENCES</p>\n<ol>\n<li><a href=\"https://www.chenyudong.com/archives/libvirt-kvm-bridge-network.html\" target=\"\\_blank\">libvirt kvm 虚拟机上网 – Bridge桥接</a></li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><p>Bridge原理(桥接模式)</p>\n<ol>\n<li><p>Bridge方式即虚拟网桥的网络连接方式，使客户机和子网里面的机器能够互相通信。可以使虚拟机成为网络中具有独立IP的主机。<br>桥接网络（也叫物理设备共享）被用作把一个物理设备复制到一台虚拟机。网桥多用作高级设置，特别是主机多个网络接口的情况。</p>","more":"</li>\n<li><p>在bridged模式下，虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。同时，由于这个虚拟系统是局域网中的一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或路由器访问互联网。使用bridged模式的虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑。想让它们相互通讯，你就需要为虚拟系统配置IP地址和子网掩码，否则就无法通信（参考dhcp服务器是否开启，如果开启，则可以选择dhcp方式自动获取网络地址）。这种方式最简单，直接将虚拟网卡桥接到一个物理网卡上面，和linux下一个网卡绑定两个不同地址类似，实际上是将网卡设置为混杂模式，从而达到侦听多个IP的能力。在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。使用这种方式很简单，前提是你可以得到1个以上的地址。</p>\n<p> <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/libvirt-kvm-bridge-network.png\" alt=\"image\" title=\"图片1\"></p>\n<blockquote>\n<p>如上图，网桥的基本原理就是创建一个桥接接口br0，在物理网卡和虚拟网络接口之间传递数据。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li><p>基本步骤<br></p>\n<ol>\n<li><p>安装完CentOS7.0， 在/etc/sysconfig/network-scripts/目录下面会生成两个默认网络配置文件。（如图）</p>\n<p> <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/2.png\" alt=\"image\" title=\"图片1\"></p>\n</li>\n<li>继续看文件里面的详细信息。<ul>\n<li>ifcfg-eth0<br><br><img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/1.png\" alt=\"image\" title=\"图片1\"></li>\n<li>ifcfg-lo<br><br><img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/3.png\" alt=\"image\" title=\"图片1\"></li>\n</ul>\n</li>\n<li>配置静态IP<ul>\n<li>在相同目录下面添加一个ifcfg-br0文件，并在文件中添加如下内容<br><br><img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/4.png\" alt=\"image\" title=\"图片1\"></li>\n<li>并且修改ifcfg-eth0文件<br><br><img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/5.png\" alt=\"image\" title=\"图片1\"></li>\n</ul>\n</li>\n<li><p>配置动态IP</p>\n<ul>\n<li><p>在相同目录下面添加一个ifcfg-br0文件，并在文件中添加如下内容</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DEVICE=br0</span><br><span class=\"line\">TYPE=Bridge</span><br><span class=\"line\">NM_CONTROLLED=no</span><br><span class=\"line\">BOOTPROTO=dhcp</span><br><span class=\"line\">ONBOOT=yes</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>并且修改ifcfg-eth0文件<br><br><img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/5.png\" alt=\"image\" title=\"图片1\"></p>\n</li>\n</ul>\n</li>\n<li>申明</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>NAT原理(网络地址转换模式)</p>\n<blockquote>\n<p>使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。很显然，如果你只有一个外网地址，此种方式很合适。</p>\n</blockquote>\n<ul>\n<li><p>virsh net-list</p>\n<blockquote>\n<p>查看当前活跃的网络，可以看到一个default网络，这个就是一个默认的Nat网络了。</p>\n</blockquote>\n</li>\n<li><p>virsh net-dumpxml default</p>\n<blockquote>\n<p>查看网络配置</p>\n</blockquote>\n<p>  <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/linux/default-nat.png\" alt=\"image\" title=\"图片1\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"持续更新中……\"><a href=\"#持续更新中……\" class=\"headerlink\" title=\"持续更新中……\"></a>持续更新中……</h4><hr>\n<ul>\n<li><p>REFERENCES</p>\n<ol>\n<li><a href=\"https://www.chenyudong.com/archives/libvirt-kvm-bridge-network.html\" target=\"\\_blank\">libvirt kvm 虚拟机上网 – Bridge桥接</a></li>\n</ol>\n</li>\n</ul>"},{"title":"log4j初级配置教程","date":"2017-04-26T02:07:15.000Z","_content":"\n* 先来看个采用log4j输出日志的例子\n    > 添加依赖包\n\n    ```XML\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-log4j12</artifactId>\n        <version>1.7.7</version>\n    </dependency>\n    ```\n    <!-- more -->\n\n    > 添加配置文件log4j.properties放在/resources目录下面\n\n    ```properties\n    ### 设置###\n    log4j.rootLogger = DEBUG,error,debug,stdout\n    #log4j.rootLogger = INFO,stdout\n\n    ### 输出信息到控制台 ###\n    log4j.appender.stdout = org.apache.log4j.ConsoleAppender\n    #log4j.appender.stdout.Threshold = ERROR\n    log4j.appender.stdout.Target = System.out\n    log4j.appender.stdout.layout = org.apache.log4j.PatternLayout\n    log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n\n\n    ### 输出DEBUG 级别以上的日志到=E://logs/debug.log ###\n    log4j.appender.debug = org.apache.log4j.DailyRollingFileAppender\n    log4j.appender.debug.File = E://logs/debug.log\n    log4j.appender.debug.Append = true\n    ##Threshold是个全局的过滤器，它将把低于所设置的level的信息过滤不显示出来。\n    log4j.appender.debug.Threshold = DEBUG\n    log4j.appender.debug.layout = org.apache.log4j.PatternLayout\n    log4j.appender.debug.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n\n\n    ### 输出ERROR 级别以上的日志到=E://logs/error.log ###\n    log4j.appender.error = org.apache.log4j.DailyRollingFileAppender\n    log4j.appender.error.File =E://logs/error.log\n    log4j.appender.error.Append = true\n    log4j.appender.error.Threshold = ERROR\n    log4j.appender.error.layout = org.apache.log4j.PatternLayout\n    log4j.appender.error.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n\n    ```\n\n    > java代码\n\n    ```java\n    package com.sh.test;\n\n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n\n    /**\n     * Created by Mr SJL on 2016/11/26.\n     *\n     * @Author Junlan Shuai\n     */\n    public class App\n    {\n        public static void main(String[] args)\n        {\n            // 记录debug级别的信息\n            log.debug(\"This is debug message.\");\n            // 记录info级别的信息\n            log.info(\"This is info message.\");\n            // 记录error级别的信息\n            log.error(\"This is error message.\");\n\n        }\n    }\n    ```\n    > 控制台输出结果\n    ![image]( http://learningnotes-1251679769.costj.myqcloud.com/javabasis/1.png  \"结果\")\n\n* log4j主要组件\n\n    > Log4j有三个主要的组件：Loggers(记录器)，Appenders  (输出源)和Layouts(布局)。这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出。综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。\n\n    * Loggers\n\n        > Loggers组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR和FATAL。这五个级别是有顺序的，DEBUG < INFO < WARN < ERROR < FATAL，分别用来指定这条日志信息的重要程度，明白这一点很重要，Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。\n\n    * Appenders\n\n        > 禁用和使用日志请求只是Log4j的基本功能，Log4j日志系统还提供许多强大的功能，比如允许把日志输出到不同的地方，如控制台（Console）、文件（Files）等，可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。\n\n        > 常使用的类如下：\n\n        > org.apache.log4j.ConsoleAppender（控制台）</br>\n        org.apache.log4j.FileAppender（文件）</br>\n        org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</br>\n        org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</br>\n        org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） </br>\n\n    * Layouts\n\n        > 有时用户希望根据自己的喜好格式化自己的日志输出，Log4j可以在Appenders的后面附加Layouts来完成这个功能。 Layouts提供四种日志输出样式，如根据HTML样式、自由指定样式、包含日志级别与信息的样式和包含日志时间、线程、类别等信息的样式。\n\n        > 常使用的类如下：\n\n        > org.apache.log4j.HTMLLayout（以HTML表格形式布局）</br>\n        org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</br>\n        org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</br>\n        org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）</br>\n\n* log4j.properties配置文件详解\n\n    > 在实际应用中，要使Log4j在系统中运行须事先设定配置文件。配置文件事实上也就是对Logger、Appender及Layout进行相应设定。Log4j支持两种配置文件格式，一种是XML格式的文件，一种是properties属性文件。下面以properties属性文件为例介绍 log4j.properties的配置。\n\n    * 配置根Logger\n\n        > log4j.rootLogger = [ level ] , appenderName1, appenderName2, …</br>\n        log4j.additivity.org.apache=false：表示Logger不会在父Logger的appender里输出，默认为true。</br>\n        level ：设定日志记录的最低级别，可设的值有OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别，Log4j建议只使用中间四个级别。通过在这里设定级别，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO级别，则应用程序中所有DEBUG级别的日志信息将不会被打印出来。</br>\n        appenderName：就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。</br>\n        例如：log4j.rootLogger＝INFO,A1,B2,C3 </br>\n\n    * 配置控制台输出\n\n        ```properties\n        ### 输出信息到控制台 ###\n        log4j.appender.stdout = org.apache.log4j.ConsoleAppender\n        ### 输出ERROR级别以上的日志到控制台 ###\n        log4j.appender.stdout.Threshold = ERROR\n        log4j.appender.stdout.Target = System.out\n        log4j.appender.stdout.layout = org.apache.log4j.PatternLayout\n        log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n\n        ```\n\n    * 配置日志文件输出\n\n        ```properties\n        ### 输出DEBUG 级别以上的日志到=E://logs/debug.log ###\n        log4j.appender.debug = org.apache.log4j.DailyRollingFileAppender\n        log4j.appender.debug.File = E://logs/debug.log\n        log4j.appender.debug.Append = true\n        ##Threshold是个全局的过滤器，它将把低于所设置的level的信息过滤不显示出来。\n        log4j.appender.debug.Threshold = DEBUG\n        log4j.appender.debug.layout = org.apache.log4j.PatternLayout\n        log4j.appender.debug.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n\n        ```\n* REFERENCES\n\n    1. <a href=\"http://www.open-open.com/lib/view/open1393488356958.html\" target=\"\\_blank\">Log4j.properties配置详解</a>\n    2. <a href=\"http://www.codeceo.com/article/log4j-usage.html\" target=\"\\_blank\">最详细的Log4j使用教程</a>\n","source":"_posts/log4j-tutorial.md","raw":"---\ntitle: log4j初级配置教程\ndate: 2017-04-26 10:07:15\ntags:\n    - log4j\n---\n\n* 先来看个采用log4j输出日志的例子\n    > 添加依赖包\n\n    ```XML\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-log4j12</artifactId>\n        <version>1.7.7</version>\n    </dependency>\n    ```\n    <!-- more -->\n\n    > 添加配置文件log4j.properties放在/resources目录下面\n\n    ```properties\n    ### 设置###\n    log4j.rootLogger = DEBUG,error,debug,stdout\n    #log4j.rootLogger = INFO,stdout\n\n    ### 输出信息到控制台 ###\n    log4j.appender.stdout = org.apache.log4j.ConsoleAppender\n    #log4j.appender.stdout.Threshold = ERROR\n    log4j.appender.stdout.Target = System.out\n    log4j.appender.stdout.layout = org.apache.log4j.PatternLayout\n    log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n\n\n    ### 输出DEBUG 级别以上的日志到=E://logs/debug.log ###\n    log4j.appender.debug = org.apache.log4j.DailyRollingFileAppender\n    log4j.appender.debug.File = E://logs/debug.log\n    log4j.appender.debug.Append = true\n    ##Threshold是个全局的过滤器，它将把低于所设置的level的信息过滤不显示出来。\n    log4j.appender.debug.Threshold = DEBUG\n    log4j.appender.debug.layout = org.apache.log4j.PatternLayout\n    log4j.appender.debug.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n\n\n    ### 输出ERROR 级别以上的日志到=E://logs/error.log ###\n    log4j.appender.error = org.apache.log4j.DailyRollingFileAppender\n    log4j.appender.error.File =E://logs/error.log\n    log4j.appender.error.Append = true\n    log4j.appender.error.Threshold = ERROR\n    log4j.appender.error.layout = org.apache.log4j.PatternLayout\n    log4j.appender.error.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n\n    ```\n\n    > java代码\n\n    ```java\n    package com.sh.test;\n\n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n\n    /**\n     * Created by Mr SJL on 2016/11/26.\n     *\n     * @Author Junlan Shuai\n     */\n    public class App\n    {\n        public static void main(String[] args)\n        {\n            // 记录debug级别的信息\n            log.debug(\"This is debug message.\");\n            // 记录info级别的信息\n            log.info(\"This is info message.\");\n            // 记录error级别的信息\n            log.error(\"This is error message.\");\n\n        }\n    }\n    ```\n    > 控制台输出结果\n    ![image]( http://learningnotes-1251679769.costj.myqcloud.com/javabasis/1.png  \"结果\")\n\n* log4j主要组件\n\n    > Log4j有三个主要的组件：Loggers(记录器)，Appenders  (输出源)和Layouts(布局)。这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出。综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。\n\n    * Loggers\n\n        > Loggers组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR和FATAL。这五个级别是有顺序的，DEBUG < INFO < WARN < ERROR < FATAL，分别用来指定这条日志信息的重要程度，明白这一点很重要，Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。\n\n    * Appenders\n\n        > 禁用和使用日志请求只是Log4j的基本功能，Log4j日志系统还提供许多强大的功能，比如允许把日志输出到不同的地方，如控制台（Console）、文件（Files）等，可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。\n\n        > 常使用的类如下：\n\n        > org.apache.log4j.ConsoleAppender（控制台）</br>\n        org.apache.log4j.FileAppender（文件）</br>\n        org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</br>\n        org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</br>\n        org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） </br>\n\n    * Layouts\n\n        > 有时用户希望根据自己的喜好格式化自己的日志输出，Log4j可以在Appenders的后面附加Layouts来完成这个功能。 Layouts提供四种日志输出样式，如根据HTML样式、自由指定样式、包含日志级别与信息的样式和包含日志时间、线程、类别等信息的样式。\n\n        > 常使用的类如下：\n\n        > org.apache.log4j.HTMLLayout（以HTML表格形式布局）</br>\n        org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</br>\n        org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）</br>\n        org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）</br>\n\n* log4j.properties配置文件详解\n\n    > 在实际应用中，要使Log4j在系统中运行须事先设定配置文件。配置文件事实上也就是对Logger、Appender及Layout进行相应设定。Log4j支持两种配置文件格式，一种是XML格式的文件，一种是properties属性文件。下面以properties属性文件为例介绍 log4j.properties的配置。\n\n    * 配置根Logger\n\n        > log4j.rootLogger = [ level ] , appenderName1, appenderName2, …</br>\n        log4j.additivity.org.apache=false：表示Logger不会在父Logger的appender里输出，默认为true。</br>\n        level ：设定日志记录的最低级别，可设的值有OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别，Log4j建议只使用中间四个级别。通过在这里设定级别，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO级别，则应用程序中所有DEBUG级别的日志信息将不会被打印出来。</br>\n        appenderName：就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。</br>\n        例如：log4j.rootLogger＝INFO,A1,B2,C3 </br>\n\n    * 配置控制台输出\n\n        ```properties\n        ### 输出信息到控制台 ###\n        log4j.appender.stdout = org.apache.log4j.ConsoleAppender\n        ### 输出ERROR级别以上的日志到控制台 ###\n        log4j.appender.stdout.Threshold = ERROR\n        log4j.appender.stdout.Target = System.out\n        log4j.appender.stdout.layout = org.apache.log4j.PatternLayout\n        log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n\n        ```\n\n    * 配置日志文件输出\n\n        ```properties\n        ### 输出DEBUG 级别以上的日志到=E://logs/debug.log ###\n        log4j.appender.debug = org.apache.log4j.DailyRollingFileAppender\n        log4j.appender.debug.File = E://logs/debug.log\n        log4j.appender.debug.Append = true\n        ##Threshold是个全局的过滤器，它将把低于所设置的level的信息过滤不显示出来。\n        log4j.appender.debug.Threshold = DEBUG\n        log4j.appender.debug.layout = org.apache.log4j.PatternLayout\n        log4j.appender.debug.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n\n        ```\n* REFERENCES\n\n    1. <a href=\"http://www.open-open.com/lib/view/open1393488356958.html\" target=\"\\_blank\">Log4j.properties配置详解</a>\n    2. <a href=\"http://www.codeceo.com/article/log4j-usage.html\" target=\"\\_blank\">最详细的Log4j使用教程</a>\n","slug":"log4j-tutorial","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5h002bzjia0odrvt0s","content":"<ul>\n<li><p>先来看个采用log4j输出日志的例子</p>\n<blockquote>\n<p>添加依赖包</p>\n</blockquote>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n  <a id=\"more\"></a>\n<blockquote>\n<p>添加配置文件log4j.properties放在/resources目录下面</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 设置###</span><br><span class=\"line\">log4j.rootLogger = DEBUG,error,debug,stdout</span><br><span class=\"line\">#log4j.rootLogger = INFO,stdout</span><br><span class=\"line\"></span><br><span class=\"line\">### 输出信息到控制台 ###</span><br><span class=\"line\">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">#log4j.appender.stdout.Threshold = ERROR</span><br><span class=\"line\">log4j.appender.stdout.Target = System.out</span><br><span class=\"line\">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### 输出DEBUG 级别以上的日志到=E://logs/debug.log ###</span><br><span class=\"line\">log4j.appender.debug = org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.debug.File = E://logs/debug.log</span><br><span class=\"line\">log4j.appender.debug.Append = true</span><br><span class=\"line\">##Threshold是个全局的过滤器，它将把低于所设置的level的信息过滤不显示出来。</span><br><span class=\"line\">log4j.appender.debug.Threshold = DEBUG</span><br><span class=\"line\">log4j.appender.debug.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.debug.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### 输出ERROR 级别以上的日志到=E://logs/error.log ###</span><br><span class=\"line\">log4j.appender.error = org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.error.File =E://logs/error.log</span><br><span class=\"line\">log4j.appender.error.Append = true</span><br><span class=\"line\">log4j.appender.error.Threshold = ERROR</span><br><span class=\"line\">log4j.appender.error.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.error.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>java代码</p>\n</blockquote>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/26.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 记录debug级别的信息</span></span><br><span class=\"line\">        log.debug(<span class=\"string\">\"This is debug message.\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 记录info级别的信息</span></span><br><span class=\"line\">        log.info(<span class=\"string\">\"This is info message.\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 记录error级别的信息</span></span><br><span class=\"line\">        log.error(<span class=\"string\">\"This is error message.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>控制台输出结果<br>  <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/javabasis/1.png\" alt=\"image\" title=\"结果\"></p>\n</blockquote>\n</li>\n<li><p>log4j主要组件</p>\n<blockquote>\n<p>Log4j有三个主要的组件：Loggers(记录器)，Appenders  (输出源)和Layouts(布局)。这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出。综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。</p>\n</blockquote>\n<ul>\n<li><p>Loggers</p>\n<blockquote>\n<p>Loggers组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR和FATAL。这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，分别用来指定这条日志信息的重要程度，明白这一点很重要，Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。</p>\n</blockquote>\n</li>\n<li><p>Appenders</p>\n<blockquote>\n<p>禁用和使用日志请求只是Log4j的基本功能，Log4j日志系统还提供许多强大的功能，比如允许把日志输出到不同的地方，如控制台（Console）、文件（Files）等，可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。</p>\n<p>常使用的类如下：</p>\n<p>org.apache.log4j.ConsoleAppender（控制台）<br><br>  org.apache.log4j.FileAppender（文件）<br><br>  org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）<br><br>  org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）<br><br>  org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） <br></p>\n</blockquote>\n</li>\n<li><p>Layouts</p>\n<blockquote>\n<p>有时用户希望根据自己的喜好格式化自己的日志输出，Log4j可以在Appenders的后面附加Layouts来完成这个功能。 Layouts提供四种日志输出样式，如根据HTML样式、自由指定样式、包含日志级别与信息的样式和包含日志时间、线程、类别等信息的样式。</p>\n<p>常使用的类如下：</p>\n<p>org.apache.log4j.HTMLLayout（以HTML表格形式布局）<br><br>  org.apache.log4j.PatternLayout（可以灵活地指定布局模式）<br><br>  org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）<br><br>  org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）<br></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>log4j.properties配置文件详解</p>\n<blockquote>\n<p>在实际应用中，要使Log4j在系统中运行须事先设定配置文件。配置文件事实上也就是对Logger、Appender及Layout进行相应设定。Log4j支持两种配置文件格式，一种是XML格式的文件，一种是properties属性文件。下面以properties属性文件为例介绍 log4j.properties的配置。</p>\n</blockquote>\n<ul>\n<li><p>配置根Logger</p>\n<blockquote>\n<p>log4j.rootLogger = [ level ] , appenderName1, appenderName2, …<br><br>  log4j.additivity.org.apache=false：表示Logger不会在父Logger的appender里输出，默认为true。<br><br>  level ：设定日志记录的最低级别，可设的值有OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别，Log4j建议只使用中间四个级别。通过在这里设定级别，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO级别，则应用程序中所有DEBUG级别的日志信息将不会被打印出来。<br><br>  appenderName：就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。<br><br>  例如：log4j.rootLogger＝INFO,A1,B2,C3 <br></p>\n</blockquote>\n</li>\n<li><p>配置控制台输出</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 输出信息到控制台 ###</span><br><span class=\"line\">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">### 输出ERROR级别以上的日志到控制台 ###</span><br><span class=\"line\">log4j.appender.stdout.Threshold = ERROR</span><br><span class=\"line\">log4j.appender.stdout.Target = System.out</span><br><span class=\"line\">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置日志文件输出</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 输出DEBUG 级别以上的日志到=E://logs/debug.log ###</span><br><span class=\"line\">log4j.appender.debug = org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.debug.File = E://logs/debug.log</span><br><span class=\"line\">log4j.appender.debug.Append = true</span><br><span class=\"line\">##Threshold是个全局的过滤器，它将把低于所设置的level的信息过滤不显示出来。</span><br><span class=\"line\">log4j.appender.debug.Threshold = DEBUG</span><br><span class=\"line\">log4j.appender.debug.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.debug.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>REFERENCES</p>\n<ol>\n<li><a href=\"http://www.open-open.com/lib/view/open1393488356958.html\" target=\"\\_blank\">Log4j.properties配置详解</a></li>\n<li><a href=\"http://www.codeceo.com/article/log4j-usage.html\" target=\"\\_blank\">最详细的Log4j使用教程</a></li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><p>先来看个采用log4j输出日志的例子</p>\n<blockquote>\n<p>添加依赖包</p>\n</blockquote>\n  <figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.7<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>","more":"<blockquote>\n<p>添加配置文件log4j.properties放在/resources目录下面</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 设置###</span><br><span class=\"line\">log4j.rootLogger = DEBUG,error,debug,stdout</span><br><span class=\"line\">#log4j.rootLogger = INFO,stdout</span><br><span class=\"line\"></span><br><span class=\"line\">### 输出信息到控制台 ###</span><br><span class=\"line\">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">#log4j.appender.stdout.Threshold = ERROR</span><br><span class=\"line\">log4j.appender.stdout.Target = System.out</span><br><span class=\"line\">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### 输出DEBUG 级别以上的日志到=E://logs/debug.log ###</span><br><span class=\"line\">log4j.appender.debug = org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.debug.File = E://logs/debug.log</span><br><span class=\"line\">log4j.appender.debug.Append = true</span><br><span class=\"line\">##Threshold是个全局的过滤器，它将把低于所设置的level的信息过滤不显示出来。</span><br><span class=\"line\">log4j.appender.debug.Threshold = DEBUG</span><br><span class=\"line\">log4j.appender.debug.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.debug.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class=\"line\"></span><br><span class=\"line\">### 输出ERROR 级别以上的日志到=E://logs/error.log ###</span><br><span class=\"line\">log4j.appender.error = org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.error.File =E://logs/error.log</span><br><span class=\"line\">log4j.appender.error.Append = true</span><br><span class=\"line\">log4j.appender.error.Threshold = ERROR</span><br><span class=\"line\">log4j.appender.error.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.error.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>java代码</p>\n</blockquote>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.sh.test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Created by Mr SJL on 2016/11/26.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Author</span> Junlan Shuai</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 记录debug级别的信息</span></span><br><span class=\"line\">        log.debug(<span class=\"string\">\"This is debug message.\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 记录info级别的信息</span></span><br><span class=\"line\">        log.info(<span class=\"string\">\"This is info message.\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 记录error级别的信息</span></span><br><span class=\"line\">        log.error(<span class=\"string\">\"This is error message.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>控制台输出结果<br>  <img src=\"http://learningnotes-1251679769.costj.myqcloud.com/javabasis/1.png\" alt=\"image\" title=\"结果\"></p>\n</blockquote>\n</li>\n<li><p>log4j主要组件</p>\n<blockquote>\n<p>Log4j有三个主要的组件：Loggers(记录器)，Appenders  (输出源)和Layouts(布局)。这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出。综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。</p>\n</blockquote>\n<ul>\n<li><p>Loggers</p>\n<blockquote>\n<p>Loggers组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR和FATAL。这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，分别用来指定这条日志信息的重要程度，明白这一点很重要，Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。</p>\n</blockquote>\n</li>\n<li><p>Appenders</p>\n<blockquote>\n<p>禁用和使用日志请求只是Log4j的基本功能，Log4j日志系统还提供许多强大的功能，比如允许把日志输出到不同的地方，如控制台（Console）、文件（Files）等，可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。</p>\n<p>常使用的类如下：</p>\n<p>org.apache.log4j.ConsoleAppender（控制台）<br><br>  org.apache.log4j.FileAppender（文件）<br><br>  org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）<br><br>  org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）<br><br>  org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） <br></p>\n</blockquote>\n</li>\n<li><p>Layouts</p>\n<blockquote>\n<p>有时用户希望根据自己的喜好格式化自己的日志输出，Log4j可以在Appenders的后面附加Layouts来完成这个功能。 Layouts提供四种日志输出样式，如根据HTML样式、自由指定样式、包含日志级别与信息的样式和包含日志时间、线程、类别等信息的样式。</p>\n<p>常使用的类如下：</p>\n<p>org.apache.log4j.HTMLLayout（以HTML表格形式布局）<br><br>  org.apache.log4j.PatternLayout（可以灵活地指定布局模式）<br><br>  org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）<br><br>  org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息）<br></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>log4j.properties配置文件详解</p>\n<blockquote>\n<p>在实际应用中，要使Log4j在系统中运行须事先设定配置文件。配置文件事实上也就是对Logger、Appender及Layout进行相应设定。Log4j支持两种配置文件格式，一种是XML格式的文件，一种是properties属性文件。下面以properties属性文件为例介绍 log4j.properties的配置。</p>\n</blockquote>\n<ul>\n<li><p>配置根Logger</p>\n<blockquote>\n<p>log4j.rootLogger = [ level ] , appenderName1, appenderName2, …<br><br>  log4j.additivity.org.apache=false：表示Logger不会在父Logger的appender里输出，默认为true。<br><br>  level ：设定日志记录的最低级别，可设的值有OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别，Log4j建议只使用中间四个级别。通过在这里设定级别，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO级别，则应用程序中所有DEBUG级别的日志信息将不会被打印出来。<br><br>  appenderName：就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。<br><br>  例如：log4j.rootLogger＝INFO,A1,B2,C3 <br></p>\n</blockquote>\n</li>\n<li><p>配置控制台输出</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 输出信息到控制台 ###</span><br><span class=\"line\">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class=\"line\">### 输出ERROR级别以上的日志到控制台 ###</span><br><span class=\"line\">log4j.appender.stdout.Threshold = ERROR</span><br><span class=\"line\">log4j.appender.stdout.Target = System.out</span><br><span class=\"line\">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置日志文件输出</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 输出DEBUG 级别以上的日志到=E://logs/debug.log ###</span><br><span class=\"line\">log4j.appender.debug = org.apache.log4j.DailyRollingFileAppender</span><br><span class=\"line\">log4j.appender.debug.File = E://logs/debug.log</span><br><span class=\"line\">log4j.appender.debug.Append = true</span><br><span class=\"line\">##Threshold是个全局的过滤器，它将把低于所设置的level的信息过滤不显示出来。</span><br><span class=\"line\">log4j.appender.debug.Threshold = DEBUG</span><br><span class=\"line\">log4j.appender.debug.layout = org.apache.log4j.PatternLayout</span><br><span class=\"line\">log4j.appender.debug.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>REFERENCES</p>\n<ol>\n<li><a href=\"http://www.open-open.com/lib/view/open1393488356958.html\" target=\"\\_blank\">Log4j.properties配置详解</a></li>\n<li><a href=\"http://www.codeceo.com/article/log4j-usage.html\" target=\"\\_blank\">最详细的Log4j使用教程</a></li>\n</ol>\n</li>\n</ul>"},{"title":"Netty数据容器---ByteBuf","date":"2018-07-24T07:38:09.000Z","_content":"\n### ByteBuf工作原理\n\nByteBuf维护了两个不同的索引：一个用于读取，一个用于写入。当从ByteBuf读取数据时，它的readerINdex将会递增已被读取的字节数。同样的，当你写入ByteBuf的时候，它的writerIndex也会被递增。\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-07-24 16-02-04.png)\n\n上图中表示的是一个读索引和写索引都设置为0的16字节ByteBuf，若果试图访问超出writerIndex范围的数据将会触发一个IndexOutOfBoundsException异常。\n\n<!-- more -->\n\n### ByteBuf的使用模式\n\n#### 堆缓冲区\n\n最常用的ByteBuf模式是将数据存储在JVM的堆空间中，这种模式被称为`支撑数组（backing array）`，它能在没有使用池化的情况下提供快速的分配和释放。\n\n#### 直接缓冲区\n\n直接缓冲区是通过本地方法调用来分配堆外内存，这样可以避免在每次调用本地I/O操作之前（或者之后）将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。\n\n直接缓冲区的主要缺点是：相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。因为数据不在堆上，所以在操作数据之前不得不进行一次数据复制。\n\n#### 复合缓冲区\n\n复合缓冲区主要是为多个ByteBuf提供一个聚合视图，这是一个JDK的ByteBuffer实现完全缺失的特性。\n\n### 操作ByteBuf字节\n\n","source":"_posts/netty-bytebuf-data-container.md","raw":"---\ntitle: Netty数据容器---ByteBuf\ndate: 2018-07-24 15:38:09\ntags:\n    - Netty\n---\n\n### ByteBuf工作原理\n\nByteBuf维护了两个不同的索引：一个用于读取，一个用于写入。当从ByteBuf读取数据时，它的readerINdex将会递增已被读取的字节数。同样的，当你写入ByteBuf的时候，它的writerIndex也会被递增。\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-07-24 16-02-04.png)\n\n上图中表示的是一个读索引和写索引都设置为0的16字节ByteBuf，若果试图访问超出writerIndex范围的数据将会触发一个IndexOutOfBoundsException异常。\n\n<!-- more -->\n\n### ByteBuf的使用模式\n\n#### 堆缓冲区\n\n最常用的ByteBuf模式是将数据存储在JVM的堆空间中，这种模式被称为`支撑数组（backing array）`，它能在没有使用池化的情况下提供快速的分配和释放。\n\n#### 直接缓冲区\n\n直接缓冲区是通过本地方法调用来分配堆外内存，这样可以避免在每次调用本地I/O操作之前（或者之后）将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。\n\n直接缓冲区的主要缺点是：相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。因为数据不在堆上，所以在操作数据之前不得不进行一次数据复制。\n\n#### 复合缓冲区\n\n复合缓冲区主要是为多个ByteBuf提供一个聚合视图，这是一个JDK的ByteBuffer实现完全缺失的特性。\n\n### 操作ByteBuf字节\n\n","slug":"netty-bytebuf-data-container","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5i002ezjia3zq29o0p","content":"<h3 id=\"ByteBuf工作原理\"><a href=\"#ByteBuf工作原理\" class=\"headerlink\" title=\"ByteBuf工作原理\"></a>ByteBuf工作原理</h3><p>ByteBuf维护了两个不同的索引：一个用于读取，一个用于写入。当从ByteBuf读取数据时，它的readerINdex将会递增已被读取的字节数。同样的，当你写入ByteBuf的时候，它的writerIndex也会被递增。</p>\n<p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-07-24 16-02-04.png\" alt=\"\"></p>\n<p>上图中表示的是一个读索引和写索引都设置为0的16字节ByteBuf，若果试图访问超出writerIndex范围的数据将会触发一个IndexOutOfBoundsException异常。</p>\n<a id=\"more\"></a>\n<h3 id=\"ByteBuf的使用模式\"><a href=\"#ByteBuf的使用模式\" class=\"headerlink\" title=\"ByteBuf的使用模式\"></a>ByteBuf的使用模式</h3><h4 id=\"堆缓冲区\"><a href=\"#堆缓冲区\" class=\"headerlink\" title=\"堆缓冲区\"></a>堆缓冲区</h4><p>最常用的ByteBuf模式是将数据存储在JVM的堆空间中，这种模式被称为<code>支撑数组（backing array）</code>，它能在没有使用池化的情况下提供快速的分配和释放。</p>\n<h4 id=\"直接缓冲区\"><a href=\"#直接缓冲区\" class=\"headerlink\" title=\"直接缓冲区\"></a>直接缓冲区</h4><p>直接缓冲区是通过本地方法调用来分配堆外内存，这样可以避免在每次调用本地I/O操作之前（或者之后）将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。</p>\n<p>直接缓冲区的主要缺点是：相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。因为数据不在堆上，所以在操作数据之前不得不进行一次数据复制。</p>\n<h4 id=\"复合缓冲区\"><a href=\"#复合缓冲区\" class=\"headerlink\" title=\"复合缓冲区\"></a>复合缓冲区</h4><p>复合缓冲区主要是为多个ByteBuf提供一个聚合视图，这是一个JDK的ByteBuffer实现完全缺失的特性。</p>\n<h3 id=\"操作ByteBuf字节\"><a href=\"#操作ByteBuf字节\" class=\"headerlink\" title=\"操作ByteBuf字节\"></a>操作ByteBuf字节</h3>","site":{"data":{}},"excerpt":"<h3 id=\"ByteBuf工作原理\"><a href=\"#ByteBuf工作原理\" class=\"headerlink\" title=\"ByteBuf工作原理\"></a>ByteBuf工作原理</h3><p>ByteBuf维护了两个不同的索引：一个用于读取，一个用于写入。当从ByteBuf读取数据时，它的readerINdex将会递增已被读取的字节数。同样的，当你写入ByteBuf的时候，它的writerIndex也会被递增。</p>\n<p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-07-24 16-02-04.png\" alt=\"\"></p>\n<p>上图中表示的是一个读索引和写索引都设置为0的16字节ByteBuf，若果试图访问超出writerIndex范围的数据将会触发一个IndexOutOfBoundsException异常。</p>","more":"<h3 id=\"ByteBuf的使用模式\"><a href=\"#ByteBuf的使用模式\" class=\"headerlink\" title=\"ByteBuf的使用模式\"></a>ByteBuf的使用模式</h3><h4 id=\"堆缓冲区\"><a href=\"#堆缓冲区\" class=\"headerlink\" title=\"堆缓冲区\"></a>堆缓冲区</h4><p>最常用的ByteBuf模式是将数据存储在JVM的堆空间中，这种模式被称为<code>支撑数组（backing array）</code>，它能在没有使用池化的情况下提供快速的分配和释放。</p>\n<h4 id=\"直接缓冲区\"><a href=\"#直接缓冲区\" class=\"headerlink\" title=\"直接缓冲区\"></a>直接缓冲区</h4><p>直接缓冲区是通过本地方法调用来分配堆外内存，这样可以避免在每次调用本地I/O操作之前（或者之后）将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。</p>\n<p>直接缓冲区的主要缺点是：相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。因为数据不在堆上，所以在操作数据之前不得不进行一次数据复制。</p>\n<h4 id=\"复合缓冲区\"><a href=\"#复合缓冲区\" class=\"headerlink\" title=\"复合缓冲区\"></a>复合缓冲区</h4><p>复合缓冲区主要是为多个ByteBuf提供一个聚合视图，这是一个JDK的ByteBuffer实现完全缺失的特性。</p>\n<h3 id=\"操作ByteBuf字节\"><a href=\"#操作ByteBuf字节\" class=\"headerlink\" title=\"操作ByteBuf字节\"></a>操作ByteBuf字节</h3>"},{"title":"Netty组件介绍","date":"2018-07-20T11:48:01.000Z","_content":"\n下面将介绍Netty中所包含的各种组件，主要包括：Channel、EventLoop、ChannelFuture、ChannelHandler和ChannelPipeline等。\n\n### Channel、EventLoop和ChannelFuture\n\n\n\n![Channel-EventLoop-ChannelFuture](https://shuaijunlan.github.io/images/Screenshot from 2018-07-20 20-39-27.png)\n\n<!-- more -->\n\n* 一个EventLoopGroup可以包含一个或者多个EventLoop；\n* 一个EventLoop在它的生命周期内只和一个Thread绑定；\n* 所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理；\n* 一个Channel在它的生命周期内只能注册于一个EventLoop；\n* 一个EventLoop可能被分配给多个Channel；\n* 在Netty中所有的I/O操作都是异步的，因此可以通过ChannelFuture来获取响应结果；\n\n### ChannelHandler和ChannelPipeline\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-07-20 21-01-11.png)\n\n* ChannelPipeline提供了ChannelHandler链的容器，并定义了同于在该链上传播入站的出站的事件流的API；\n* 一个ChannelIninializer的实现被注册到ServerBootstrap中或这Client的BootStrap中；\n* 当 ChannelInitializer.initChannel() 方法被调用时，ChannelInitializer将在 ChannelPipeline 中安装一组自定义的 ChannelHandler ；\n* ChannelInitializer将它自己从 ChannelPipeline 中移除；\n* 从一个客户端应用程序角度来看，当事件的运动方向是从客户端到服务器，我们称之为出站，反之则称之为入站；\n* 数据出站运动，数据讲从ChannelOutboundHandler链的尾端开始流动，直到它到达链的头部为止，此时数据到达了网络传输层，通常情况下会触发一个写操作。\n\n### BootStrap和ServerBootstrap\n\n|         类别         |      Bootstrap       |  ServerBootstrap   |\n| :------------------: | :------------------: | :----------------: |\n|   网络编程中的作用   | 连接到远程主机和端口 | 绑定到一个本地端口 |\n| EventLoopGroup的数目 |          1           |   2（也可以1个）   |\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-07-20 21-52-02.png)\n\n上图中，客户端创建了一个EventLoopGroup，服务器端使用了两个EventLoopGroup，其中一个EventLoopGroup用来接收客户端发来的请求，另一个EventLoop用来处理连接任务。\n\n### 示例\n\n**服务器端**\n\n```java\nEventLoopGroup bossGroup = new EpollEventLoopGroup(1);\nEventLoopGroup workerGroup = new EpollEventLoopGroup(4);\ntry {\n    ServerBootstrap b = new ServerBootstrap();\n    b.group(bossGroup, workerGroup)\n            .channel(EpollServerSocketChannel.class)\n            //保持长连接状态\n            .childOption(ChannelOption.SO_KEEPALIVE, true)\n            .childOption(ChannelOption.TCP_NODELAY, true)\n            .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n            .childHandler(new HttpSnoopServerInitializer());\n\n    ChannelFuture ch = b.bind(PORT).sync();\n    if (ch.isSuccess()){\n        logger.info(\"Http server start on port :{}\", PORT );\n    }\n\n    ch.channel().closeFuture().sync();\n} finally {\n    bossGroup.shutdownGracefully();\n    workerGroup.shutdownGracefully();\n}\n```\n\n**客户端**\n\n```java\nEventLoopGroup eventLoopGroup = new EpollEventLoopGroup(8);\nBootstrap bootstrap = new Bootstrap()\n        .group(eventLoopGroup)\n        .option(ChannelOption.SO_KEEPALIVE, true)\n        .option(ChannelOption.TCP_NODELAY, true)\n        .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n        .channel(EpollSocketChannel.class)\n        .handler(new RpcClientInitializer());\nChannel channel = bootstrap.connect(\"127.0.0.1\", port).sync().channel();\n```\n\n","source":"_posts/netty-components-design.md","raw":"---\ntitle: Netty组件介绍\ndate: 2018-07-20 19:48:01\ntags:\n    - Netty\n---\n\n下面将介绍Netty中所包含的各种组件，主要包括：Channel、EventLoop、ChannelFuture、ChannelHandler和ChannelPipeline等。\n\n### Channel、EventLoop和ChannelFuture\n\n\n\n![Channel-EventLoop-ChannelFuture](https://shuaijunlan.github.io/images/Screenshot from 2018-07-20 20-39-27.png)\n\n<!-- more -->\n\n* 一个EventLoopGroup可以包含一个或者多个EventLoop；\n* 一个EventLoop在它的生命周期内只和一个Thread绑定；\n* 所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理；\n* 一个Channel在它的生命周期内只能注册于一个EventLoop；\n* 一个EventLoop可能被分配给多个Channel；\n* 在Netty中所有的I/O操作都是异步的，因此可以通过ChannelFuture来获取响应结果；\n\n### ChannelHandler和ChannelPipeline\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-07-20 21-01-11.png)\n\n* ChannelPipeline提供了ChannelHandler链的容器，并定义了同于在该链上传播入站的出站的事件流的API；\n* 一个ChannelIninializer的实现被注册到ServerBootstrap中或这Client的BootStrap中；\n* 当 ChannelInitializer.initChannel() 方法被调用时，ChannelInitializer将在 ChannelPipeline 中安装一组自定义的 ChannelHandler ；\n* ChannelInitializer将它自己从 ChannelPipeline 中移除；\n* 从一个客户端应用程序角度来看，当事件的运动方向是从客户端到服务器，我们称之为出站，反之则称之为入站；\n* 数据出站运动，数据讲从ChannelOutboundHandler链的尾端开始流动，直到它到达链的头部为止，此时数据到达了网络传输层，通常情况下会触发一个写操作。\n\n### BootStrap和ServerBootstrap\n\n|         类别         |      Bootstrap       |  ServerBootstrap   |\n| :------------------: | :------------------: | :----------------: |\n|   网络编程中的作用   | 连接到远程主机和端口 | 绑定到一个本地端口 |\n| EventLoopGroup的数目 |          1           |   2（也可以1个）   |\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-07-20 21-52-02.png)\n\n上图中，客户端创建了一个EventLoopGroup，服务器端使用了两个EventLoopGroup，其中一个EventLoopGroup用来接收客户端发来的请求，另一个EventLoop用来处理连接任务。\n\n### 示例\n\n**服务器端**\n\n```java\nEventLoopGroup bossGroup = new EpollEventLoopGroup(1);\nEventLoopGroup workerGroup = new EpollEventLoopGroup(4);\ntry {\n    ServerBootstrap b = new ServerBootstrap();\n    b.group(bossGroup, workerGroup)\n            .channel(EpollServerSocketChannel.class)\n            //保持长连接状态\n            .childOption(ChannelOption.SO_KEEPALIVE, true)\n            .childOption(ChannelOption.TCP_NODELAY, true)\n            .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n            .childHandler(new HttpSnoopServerInitializer());\n\n    ChannelFuture ch = b.bind(PORT).sync();\n    if (ch.isSuccess()){\n        logger.info(\"Http server start on port :{}\", PORT );\n    }\n\n    ch.channel().closeFuture().sync();\n} finally {\n    bossGroup.shutdownGracefully();\n    workerGroup.shutdownGracefully();\n}\n```\n\n**客户端**\n\n```java\nEventLoopGroup eventLoopGroup = new EpollEventLoopGroup(8);\nBootstrap bootstrap = new Bootstrap()\n        .group(eventLoopGroup)\n        .option(ChannelOption.SO_KEEPALIVE, true)\n        .option(ChannelOption.TCP_NODELAY, true)\n        .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)\n        .channel(EpollSocketChannel.class)\n        .handler(new RpcClientInitializer());\nChannel channel = bootstrap.connect(\"127.0.0.1\", port).sync().channel();\n```\n\n","slug":"netty-components-design","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5i002gzjiapfsppbx1","content":"<p>下面将介绍Netty中所包含的各种组件，主要包括：Channel、EventLoop、ChannelFuture、ChannelHandler和ChannelPipeline等。</p>\n<h3 id=\"Channel、EventLoop和ChannelFuture\"><a href=\"#Channel、EventLoop和ChannelFuture\" class=\"headerlink\" title=\"Channel、EventLoop和ChannelFuture\"></a>Channel、EventLoop和ChannelFuture</h3><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-07-20 20-39-27.png\" alt=\"Channel-EventLoop-ChannelFuture\"></p>\n<a id=\"more\"></a>\n<ul>\n<li>一个EventLoopGroup可以包含一个或者多个EventLoop；</li>\n<li>一个EventLoop在它的生命周期内只和一个Thread绑定；</li>\n<li>所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理；</li>\n<li>一个Channel在它的生命周期内只能注册于一个EventLoop；</li>\n<li>一个EventLoop可能被分配给多个Channel；</li>\n<li>在Netty中所有的I/O操作都是异步的，因此可以通过ChannelFuture来获取响应结果；</li>\n</ul>\n<h3 id=\"ChannelHandler和ChannelPipeline\"><a href=\"#ChannelHandler和ChannelPipeline\" class=\"headerlink\" title=\"ChannelHandler和ChannelPipeline\"></a>ChannelHandler和ChannelPipeline</h3><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-07-20 21-01-11.png\" alt=\"\"></p>\n<ul>\n<li>ChannelPipeline提供了ChannelHandler链的容器，并定义了同于在该链上传播入站的出站的事件流的API；</li>\n<li>一个ChannelIninializer的实现被注册到ServerBootstrap中或这Client的BootStrap中；</li>\n<li>当 ChannelInitializer.initChannel() 方法被调用时，ChannelInitializer将在 ChannelPipeline 中安装一组自定义的 ChannelHandler ；</li>\n<li>ChannelInitializer将它自己从 ChannelPipeline 中移除；</li>\n<li>从一个客户端应用程序角度来看，当事件的运动方向是从客户端到服务器，我们称之为出站，反之则称之为入站；</li>\n<li>数据出站运动，数据讲从ChannelOutboundHandler链的尾端开始流动，直到它到达链的头部为止，此时数据到达了网络传输层，通常情况下会触发一个写操作。</li>\n</ul>\n<h3 id=\"BootStrap和ServerBootstrap\"><a href=\"#BootStrap和ServerBootstrap\" class=\"headerlink\" title=\"BootStrap和ServerBootstrap\"></a>BootStrap和ServerBootstrap</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类别</th>\n<th style=\"text-align:center\">Bootstrap</th>\n<th style=\"text-align:center\">ServerBootstrap</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">网络编程中的作用</td>\n<td style=\"text-align:center\">连接到远程主机和端口</td>\n<td style=\"text-align:center\">绑定到一个本地端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">EventLoopGroup的数目</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">2（也可以1个）</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-07-20 21-52-02.png\" alt=\"\"></p>\n<p>上图中，客户端创建了一个EventLoopGroup，服务器端使用了两个EventLoopGroup，其中一个EventLoopGroup用来接收客户端发来的请求，另一个EventLoop用来处理连接任务。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p><strong>服务器端</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopGroup bossGroup = <span class=\"keyword\">new</span> EpollEventLoopGroup(<span class=\"number\">1</span>);</span><br><span class=\"line\">EventLoopGroup workerGroup = <span class=\"keyword\">new</span> EpollEventLoopGroup(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ServerBootstrap b = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">    b.group(bossGroup, workerGroup)</span><br><span class=\"line\">            .channel(EpollServerSocketChannel.class)</span><br><span class=\"line\">            <span class=\"comment\">//保持长连接状态</span></span><br><span class=\"line\">            .childOption(ChannelOption.SO_KEEPALIVE, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">            .childOption(ChannelOption.TCP_NODELAY, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">            .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class=\"line\">            .childHandler(<span class=\"keyword\">new</span> HttpSnoopServerInitializer());</span><br><span class=\"line\"></span><br><span class=\"line\">    ChannelFuture ch = b.bind(PORT).sync();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ch.isSuccess())&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"Http server start on port :&#123;&#125;\"</span>, PORT );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ch.channel().closeFuture().sync();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    bossGroup.shutdownGracefully();</span><br><span class=\"line\">    workerGroup.shutdownGracefully();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>客户端</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopGroup eventLoopGroup = <span class=\"keyword\">new</span> EpollEventLoopGroup(<span class=\"number\">8</span>);</span><br><span class=\"line\">Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap()</span><br><span class=\"line\">        .group(eventLoopGroup)</span><br><span class=\"line\">        .option(ChannelOption.SO_KEEPALIVE, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">        .option(ChannelOption.TCP_NODELAY, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">        .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class=\"line\">        .channel(EpollSocketChannel.class)</span><br><span class=\"line\">        .handler(<span class=\"keyword\">new</span> RpcClientInitializer());</span><br><span class=\"line\">Channel channel = bootstrap.connect(<span class=\"string\">\"127.0.0.1\"</span>, port).sync().channel();</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>下面将介绍Netty中所包含的各种组件，主要包括：Channel、EventLoop、ChannelFuture、ChannelHandler和ChannelPipeline等。</p>\n<h3 id=\"Channel、EventLoop和ChannelFuture\"><a href=\"#Channel、EventLoop和ChannelFuture\" class=\"headerlink\" title=\"Channel、EventLoop和ChannelFuture\"></a>Channel、EventLoop和ChannelFuture</h3><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-07-20 20-39-27.png\" alt=\"Channel-EventLoop-ChannelFuture\"></p>","more":"<ul>\n<li>一个EventLoopGroup可以包含一个或者多个EventLoop；</li>\n<li>一个EventLoop在它的生命周期内只和一个Thread绑定；</li>\n<li>所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理；</li>\n<li>一个Channel在它的生命周期内只能注册于一个EventLoop；</li>\n<li>一个EventLoop可能被分配给多个Channel；</li>\n<li>在Netty中所有的I/O操作都是异步的，因此可以通过ChannelFuture来获取响应结果；</li>\n</ul>\n<h3 id=\"ChannelHandler和ChannelPipeline\"><a href=\"#ChannelHandler和ChannelPipeline\" class=\"headerlink\" title=\"ChannelHandler和ChannelPipeline\"></a>ChannelHandler和ChannelPipeline</h3><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-07-20 21-01-11.png\" alt=\"\"></p>\n<ul>\n<li>ChannelPipeline提供了ChannelHandler链的容器，并定义了同于在该链上传播入站的出站的事件流的API；</li>\n<li>一个ChannelIninializer的实现被注册到ServerBootstrap中或这Client的BootStrap中；</li>\n<li>当 ChannelInitializer.initChannel() 方法被调用时，ChannelInitializer将在 ChannelPipeline 中安装一组自定义的 ChannelHandler ；</li>\n<li>ChannelInitializer将它自己从 ChannelPipeline 中移除；</li>\n<li>从一个客户端应用程序角度来看，当事件的运动方向是从客户端到服务器，我们称之为出站，反之则称之为入站；</li>\n<li>数据出站运动，数据讲从ChannelOutboundHandler链的尾端开始流动，直到它到达链的头部为止，此时数据到达了网络传输层，通常情况下会触发一个写操作。</li>\n</ul>\n<h3 id=\"BootStrap和ServerBootstrap\"><a href=\"#BootStrap和ServerBootstrap\" class=\"headerlink\" title=\"BootStrap和ServerBootstrap\"></a>BootStrap和ServerBootstrap</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类别</th>\n<th style=\"text-align:center\">Bootstrap</th>\n<th style=\"text-align:center\">ServerBootstrap</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">网络编程中的作用</td>\n<td style=\"text-align:center\">连接到远程主机和端口</td>\n<td style=\"text-align:center\">绑定到一个本地端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">EventLoopGroup的数目</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">2（也可以1个）</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-07-20 21-52-02.png\" alt=\"\"></p>\n<p>上图中，客户端创建了一个EventLoopGroup，服务器端使用了两个EventLoopGroup，其中一个EventLoopGroup用来接收客户端发来的请求，另一个EventLoop用来处理连接任务。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p><strong>服务器端</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopGroup bossGroup = <span class=\"keyword\">new</span> EpollEventLoopGroup(<span class=\"number\">1</span>);</span><br><span class=\"line\">EventLoopGroup workerGroup = <span class=\"keyword\">new</span> EpollEventLoopGroup(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ServerBootstrap b = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">    b.group(bossGroup, workerGroup)</span><br><span class=\"line\">            .channel(EpollServerSocketChannel.class)</span><br><span class=\"line\">            <span class=\"comment\">//保持长连接状态</span></span><br><span class=\"line\">            .childOption(ChannelOption.SO_KEEPALIVE, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">            .childOption(ChannelOption.TCP_NODELAY, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">            .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class=\"line\">            .childHandler(<span class=\"keyword\">new</span> HttpSnoopServerInitializer());</span><br><span class=\"line\"></span><br><span class=\"line\">    ChannelFuture ch = b.bind(PORT).sync();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ch.isSuccess())&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"Http server start on port :&#123;&#125;\"</span>, PORT );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ch.channel().closeFuture().sync();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    bossGroup.shutdownGracefully();</span><br><span class=\"line\">    workerGroup.shutdownGracefully();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>客户端</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopGroup eventLoopGroup = <span class=\"keyword\">new</span> EpollEventLoopGroup(<span class=\"number\">8</span>);</span><br><span class=\"line\">Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap()</span><br><span class=\"line\">        .group(eventLoopGroup)</span><br><span class=\"line\">        .option(ChannelOption.SO_KEEPALIVE, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">        .option(ChannelOption.TCP_NODELAY, <span class=\"keyword\">true</span>)</span><br><span class=\"line\">        .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class=\"line\">        .channel(EpollSocketChannel.class)</span><br><span class=\"line\">        .handler(<span class=\"keyword\">new</span> RpcClientInitializer());</span><br><span class=\"line\">Channel channel = bootstrap.connect(<span class=\"string\">\"127.0.0.1\"</span>, port).sync().channel();</span><br></pre></td></tr></table></figure>"},{"title":"Netty中Future与Promise的实现分析","date":"2018-09-06T07:53:53.000Z","_content":"\n从Java 1.5开始，JDK就提供了Callable和Future，通过它们可以在任务异步执行完毕之后获取任务的执行结果。\n\nNetty扩展了JDK中的Future机制，下面我们来看一张Netty中Future和Promise类关系图：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/DefaultPromise.png?raw=true)\n\n<!-- more -->\n\n最上面的Future是JDK提供的Future接口，我们看一下里面有哪些方法：\n\n```java\npackage java.util.concurrent;\n\n/**\n * A {@code Future} represents the result of an asynchronous\n * computation.  Methods are provided to check if the computation is\n * complete, to wait for its completion, and to retrieve the result of\n * the computation.  The result can only be retrieved using method\n * {@code get} when the computation has completed, blocking if\n * necessary until it is ready.  Cancellation is performed by the\n * {@code cancel} method.  Additional methods are provided to\n * determine if the task completed normally or was cancelled. Once a\n * computation has completed, the computation cannot be cancelled.\n * If you would like to use a {@code Future} for the sake\n * of cancellability but not provide a usable result, you can\n * declare types of the form {@code Future<?>} and\n * return {@code null} as a result of the underlying task.\n */\npublic interface Future<V> {\n\t//尝试取消执行的任务\n    boolean cancel(boolean mayInterruptIfRunning);\n\t//判断任务是否取消\n    boolean isCancelled();\n\t//判断任务是否执行完成\n    boolean isDone();\n\t//等待直到任务执行完成，并且返回结果\n    V get() throws InterruptedException, ExecutionException;\n\t//等待最大超时时间，如果执行完成则返回结果，否则抛出超时异常\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n```\n\n**并发编程中，我们通常会用到一组非阻塞的模型：Promise，Future 和 Callback。其中的 Future 表示一个可能还没有实际完成的异步任务的结果，针对这个结果可以添加 Callback 以便在任务执行成功或失败后做出对应的操作，而Promise交由任务执行者，任务执行者通过 Promise 可以标记任务完成或者失败。 这一套模型是很多异步非阻塞架构的基础。** 因为netty中也有类似`调用者和执行部件以异步的方式交互通信结果`的需求（要知道eventloop本质上是一个ScheduledExecutorService，ExecutorService是一种“提交-执行”模型实现，也存在线程间异步方式通信和线程安全问题），所以netty自己实现了一套。\n\nNetty中所有的IO操作都是异步的（比如write(Object)，因为Netty中一个EventLoop要服务于多个SocketChannel，所以通过`socketChannel.xx`只是提交一个任务，何时返回结果是不确定的），而不像传统的BIO那样阻塞等待操作完成，来获取执行结果。\n\n事实上，Netty Future的建议操作模式就是赤裸裸的通知，执行部件改变状态时，会执行注册在future上的Listener（变相的观察者模式）。\n\nscala在语言层面提供对Promise，Future和Callback模型的支持，`https://bitbucket.org/qiyi/commons-future.git`作者自定义实现了该模型，去除了Netty的Future模型对EventLoop的依赖。\n\n#### Netty中的Future\n\n下面的Netty Future继承jdk提供的Future接口，添加了一些自己的方法：\n\n```java\n/**\n * The result of an asynchronous operation.\n */\n@SuppressWarnings(\"ClassNameSameAsAncestorName\")\npublic interface Future<V> extends java.util.concurrent.Future<V> {\n\n    boolean isSuccess();\n\n    boolean isCancellable();\n\n    Throwable cause();\n\n    Future<V> addListener(GenericFutureListener<? extends Future<? super V>> listener);\n\n    Future<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners);\n\n    Future<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener);\n\n    Future<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners);\n\n    Future<V> sync() throws InterruptedException;\n\n    Future<V> syncUninterruptibly();\n\n    Future<V> await() throws InterruptedException;\n\n    Future<V> awaitUninterruptibly();\n\n    boolean await(long timeout, TimeUnit unit) throws InterruptedException;\n\n    boolean await(long timeoutMillis) throws InterruptedException;\n\n    boolean awaitUninterruptibly(long timeout, TimeUnit unit);\n\n    boolean awaitUninterruptibly(long timeoutMillis);\n\n    V getNow();\n\n    @Override\n    boolean cancel(boolean mayInterruptIfRunning);\n}\n```\n\n![](http://misc.linkedkeeper.com/misc/img/blog/201612/linkedkeeper0_c93937f4-f0f5-419e-a8b1-e71dc2288003.jpg)\n\na future is a read-only placeholder view of a variable, while a promise is a writable。Promise是可写的Future，提供写操作相关的接口，用于设置IO操作的结果。Future，Promise，callback抽象出一套调用者与执行部件间的通信模型（不只是netty中），**Future像是给调用者用的（拿结果），Promise像是给执行部件用的（设置结果），它们简化了调用者和执行部件对其的调用（调用者get，执行部件set），但本身要封装很多事**。比如Future必须是一个线程安全的类（大部分时候，调用者和执行部件身处两个线程），比如执行callback（或者listener）。\n\n#### Netty Promise执行Listener\n\nNetty中的Promise通常由EventLoop创建，也就是Promise通常会绑定executor。为何呢？**因为Netty保证Listener的执行，一定是在channel对应的EventLoop中**(????)。","source":"_posts/netty-future-and-promise.md","raw":"---\ntitle: Netty中Future与Promise的实现分析\ndate: 2018-09-06 15:53:53\ntags:\n    - Netty\n---\n\n从Java 1.5开始，JDK就提供了Callable和Future，通过它们可以在任务异步执行完毕之后获取任务的执行结果。\n\nNetty扩展了JDK中的Future机制，下面我们来看一张Netty中Future和Promise类关系图：\n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/DefaultPromise.png?raw=true)\n\n<!-- more -->\n\n最上面的Future是JDK提供的Future接口，我们看一下里面有哪些方法：\n\n```java\npackage java.util.concurrent;\n\n/**\n * A {@code Future} represents the result of an asynchronous\n * computation.  Methods are provided to check if the computation is\n * complete, to wait for its completion, and to retrieve the result of\n * the computation.  The result can only be retrieved using method\n * {@code get} when the computation has completed, blocking if\n * necessary until it is ready.  Cancellation is performed by the\n * {@code cancel} method.  Additional methods are provided to\n * determine if the task completed normally or was cancelled. Once a\n * computation has completed, the computation cannot be cancelled.\n * If you would like to use a {@code Future} for the sake\n * of cancellability but not provide a usable result, you can\n * declare types of the form {@code Future<?>} and\n * return {@code null} as a result of the underlying task.\n */\npublic interface Future<V> {\n\t//尝试取消执行的任务\n    boolean cancel(boolean mayInterruptIfRunning);\n\t//判断任务是否取消\n    boolean isCancelled();\n\t//判断任务是否执行完成\n    boolean isDone();\n\t//等待直到任务执行完成，并且返回结果\n    V get() throws InterruptedException, ExecutionException;\n\t//等待最大超时时间，如果执行完成则返回结果，否则抛出超时异常\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n```\n\n**并发编程中，我们通常会用到一组非阻塞的模型：Promise，Future 和 Callback。其中的 Future 表示一个可能还没有实际完成的异步任务的结果，针对这个结果可以添加 Callback 以便在任务执行成功或失败后做出对应的操作，而Promise交由任务执行者，任务执行者通过 Promise 可以标记任务完成或者失败。 这一套模型是很多异步非阻塞架构的基础。** 因为netty中也有类似`调用者和执行部件以异步的方式交互通信结果`的需求（要知道eventloop本质上是一个ScheduledExecutorService，ExecutorService是一种“提交-执行”模型实现，也存在线程间异步方式通信和线程安全问题），所以netty自己实现了一套。\n\nNetty中所有的IO操作都是异步的（比如write(Object)，因为Netty中一个EventLoop要服务于多个SocketChannel，所以通过`socketChannel.xx`只是提交一个任务，何时返回结果是不确定的），而不像传统的BIO那样阻塞等待操作完成，来获取执行结果。\n\n事实上，Netty Future的建议操作模式就是赤裸裸的通知，执行部件改变状态时，会执行注册在future上的Listener（变相的观察者模式）。\n\nscala在语言层面提供对Promise，Future和Callback模型的支持，`https://bitbucket.org/qiyi/commons-future.git`作者自定义实现了该模型，去除了Netty的Future模型对EventLoop的依赖。\n\n#### Netty中的Future\n\n下面的Netty Future继承jdk提供的Future接口，添加了一些自己的方法：\n\n```java\n/**\n * The result of an asynchronous operation.\n */\n@SuppressWarnings(\"ClassNameSameAsAncestorName\")\npublic interface Future<V> extends java.util.concurrent.Future<V> {\n\n    boolean isSuccess();\n\n    boolean isCancellable();\n\n    Throwable cause();\n\n    Future<V> addListener(GenericFutureListener<? extends Future<? super V>> listener);\n\n    Future<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners);\n\n    Future<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener);\n\n    Future<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners);\n\n    Future<V> sync() throws InterruptedException;\n\n    Future<V> syncUninterruptibly();\n\n    Future<V> await() throws InterruptedException;\n\n    Future<V> awaitUninterruptibly();\n\n    boolean await(long timeout, TimeUnit unit) throws InterruptedException;\n\n    boolean await(long timeoutMillis) throws InterruptedException;\n\n    boolean awaitUninterruptibly(long timeout, TimeUnit unit);\n\n    boolean awaitUninterruptibly(long timeoutMillis);\n\n    V getNow();\n\n    @Override\n    boolean cancel(boolean mayInterruptIfRunning);\n}\n```\n\n![](http://misc.linkedkeeper.com/misc/img/blog/201612/linkedkeeper0_c93937f4-f0f5-419e-a8b1-e71dc2288003.jpg)\n\na future is a read-only placeholder view of a variable, while a promise is a writable。Promise是可写的Future，提供写操作相关的接口，用于设置IO操作的结果。Future，Promise，callback抽象出一套调用者与执行部件间的通信模型（不只是netty中），**Future像是给调用者用的（拿结果），Promise像是给执行部件用的（设置结果），它们简化了调用者和执行部件对其的调用（调用者get，执行部件set），但本身要封装很多事**。比如Future必须是一个线程安全的类（大部分时候，调用者和执行部件身处两个线程），比如执行callback（或者listener）。\n\n#### Netty Promise执行Listener\n\nNetty中的Promise通常由EventLoop创建，也就是Promise通常会绑定executor。为何呢？**因为Netty保证Listener的执行，一定是在channel对应的EventLoop中**(????)。","slug":"netty-future-and-promise","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5j002jzjia67toukwh","content":"<p>从Java 1.5开始，JDK就提供了Callable和Future，通过它们可以在任务异步执行完毕之后获取任务的执行结果。</p>\n<p>Netty扩展了JDK中的Future机制，下面我们来看一张Netty中Future和Promise类关系图：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/DefaultPromise.png?raw=true\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>最上面的Future是JDK提供的Future接口，我们看一下里面有哪些方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util.concurrent;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A &#123;<span class=\"doctag\">@code</span> Future&#125; represents the result of an asynchronous</span></span><br><span class=\"line\"><span class=\"comment\"> * computation.  Methods are provided to check if the computation is</span></span><br><span class=\"line\"><span class=\"comment\"> * complete, to wait for its completion, and to retrieve the result of</span></span><br><span class=\"line\"><span class=\"comment\"> * the computation.  The result can only be retrieved using method</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> get&#125; when the computation has completed, blocking if</span></span><br><span class=\"line\"><span class=\"comment\"> * necessary until it is ready.  Cancellation is performed by the</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> cancel&#125; method.  Additional methods are provided to</span></span><br><span class=\"line\"><span class=\"comment\"> * determine if the task completed normally or was cancelled. Once a</span></span><br><span class=\"line\"><span class=\"comment\"> * computation has completed, the computation cannot be cancelled.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you would like to use a &#123;<span class=\"doctag\">@code</span> Future&#125; for the sake</span></span><br><span class=\"line\"><span class=\"comment\"> * of cancellability but not provide a usable result, you can</span></span><br><span class=\"line\"><span class=\"comment\"> * declare types of the form &#123;<span class=\"doctag\">@code</span> Future&lt;?&gt;&#125; and</span></span><br><span class=\"line\"><span class=\"comment\"> * return &#123;<span class=\"doctag\">@code</span> null&#125; as a result of the underlying task.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//尝试取消执行的任务</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//判断任务是否取消</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isCancelled</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//判断任务是否执行完成</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isDone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//等待直到任务执行完成，并且返回结果</span></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//等待最大超时时间，如果执行完成则返回结果，否则抛出超时异常</span></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>并发编程中，我们通常会用到一组非阻塞的模型：Promise，Future 和 Callback。其中的 Future 表示一个可能还没有实际完成的异步任务的结果，针对这个结果可以添加 Callback 以便在任务执行成功或失败后做出对应的操作，而Promise交由任务执行者，任务执行者通过 Promise 可以标记任务完成或者失败。 这一套模型是很多异步非阻塞架构的基础。</strong> 因为netty中也有类似<code>调用者和执行部件以异步的方式交互通信结果</code>的需求（要知道eventloop本质上是一个ScheduledExecutorService，ExecutorService是一种“提交-执行”模型实现，也存在线程间异步方式通信和线程安全问题），所以netty自己实现了一套。</p>\n<p>Netty中所有的IO操作都是异步的（比如write(Object)，因为Netty中一个EventLoop要服务于多个SocketChannel，所以通过<code>socketChannel.xx</code>只是提交一个任务，何时返回结果是不确定的），而不像传统的BIO那样阻塞等待操作完成，来获取执行结果。</p>\n<p>事实上，Netty Future的建议操作模式就是赤裸裸的通知，执行部件改变状态时，会执行注册在future上的Listener（变相的观察者模式）。</p>\n<p>scala在语言层面提供对Promise，Future和Callback模型的支持，<code>https://bitbucket.org/qiyi/commons-future.git</code>作者自定义实现了该模型，去除了Netty的Future模型对EventLoop的依赖。</p>\n<h4 id=\"Netty中的Future\"><a href=\"#Netty中的Future\" class=\"headerlink\" title=\"Netty中的Future\"></a>Netty中的Future</h4><p>下面的Netty Future继承jdk提供的Future接口，添加了一些自己的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The result of an asynchronous operation.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"ClassNameSameAsAncestorName\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">java</span>.<span class=\"title\">util</span>.<span class=\"title\">concurrent</span>.<span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSuccess</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isCancellable</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Throwable <span class=\"title\">cause</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">addListener</span><span class=\"params\">(GenericFutureListener&lt;? extends Future&lt;? <span class=\"keyword\">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">addListeners</span><span class=\"params\">(GenericFutureListener&lt;? extends Future&lt;? <span class=\"keyword\">super</span> V&gt;&gt;... listeners)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">removeListener</span><span class=\"params\">(GenericFutureListener&lt;? extends Future&lt;? <span class=\"keyword\">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">removeListeners</span><span class=\"params\">(GenericFutureListener&lt;? extends Future&lt;? <span class=\"keyword\">super</span> V&gt;&gt;... listeners)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">sync</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">syncUninterruptibly</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">awaitUninterruptibly</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> timeoutMillis)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">awaitUninterruptibly</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">awaitUninterruptibly</span><span class=\"params\">(<span class=\"keyword\">long</span> timeoutMillis)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">getNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://misc.linkedkeeper.com/misc/img/blog/201612/linkedkeeper0_c93937f4-f0f5-419e-a8b1-e71dc2288003.jpg\" alt=\"\"></p>\n<p>a future is a read-only placeholder view of a variable, while a promise is a writable。Promise是可写的Future，提供写操作相关的接口，用于设置IO操作的结果。Future，Promise，callback抽象出一套调用者与执行部件间的通信模型（不只是netty中），<strong>Future像是给调用者用的（拿结果），Promise像是给执行部件用的（设置结果），它们简化了调用者和执行部件对其的调用（调用者get，执行部件set），但本身要封装很多事</strong>。比如Future必须是一个线程安全的类（大部分时候，调用者和执行部件身处两个线程），比如执行callback（或者listener）。</p>\n<h4 id=\"Netty-Promise执行Listener\"><a href=\"#Netty-Promise执行Listener\" class=\"headerlink\" title=\"Netty Promise执行Listener\"></a>Netty Promise执行Listener</h4><p>Netty中的Promise通常由EventLoop创建，也就是Promise通常会绑定executor。为何呢？<strong>因为Netty保证Listener的执行，一定是在channel对应的EventLoop中</strong>(????)。</p>\n","site":{"data":{}},"excerpt":"<p>从Java 1.5开始，JDK就提供了Callable和Future，通过它们可以在任务异步执行完毕之后获取任务的执行结果。</p>\n<p>Netty扩展了JDK中的Future机制，下面我们来看一张Netty中Future和Promise类关系图：</p>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/DefaultPromise.png?raw=true\" alt=\"\"></p>","more":"<p>最上面的Future是JDK提供的Future接口，我们看一下里面有哪些方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> java.util.concurrent;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A &#123;<span class=\"doctag\">@code</span> Future&#125; represents the result of an asynchronous</span></span><br><span class=\"line\"><span class=\"comment\"> * computation.  Methods are provided to check if the computation is</span></span><br><span class=\"line\"><span class=\"comment\"> * complete, to wait for its completion, and to retrieve the result of</span></span><br><span class=\"line\"><span class=\"comment\"> * the computation.  The result can only be retrieved using method</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> get&#125; when the computation has completed, blocking if</span></span><br><span class=\"line\"><span class=\"comment\"> * necessary until it is ready.  Cancellation is performed by the</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@code</span> cancel&#125; method.  Additional methods are provided to</span></span><br><span class=\"line\"><span class=\"comment\"> * determine if the task completed normally or was cancelled. Once a</span></span><br><span class=\"line\"><span class=\"comment\"> * computation has completed, the computation cannot be cancelled.</span></span><br><span class=\"line\"><span class=\"comment\"> * If you would like to use a &#123;<span class=\"doctag\">@code</span> Future&#125; for the sake</span></span><br><span class=\"line\"><span class=\"comment\"> * of cancellability but not provide a usable result, you can</span></span><br><span class=\"line\"><span class=\"comment\"> * declare types of the form &#123;<span class=\"doctag\">@code</span> Future&lt;?&gt;&#125; and</span></span><br><span class=\"line\"><span class=\"comment\"> * return &#123;<span class=\"doctag\">@code</span> null&#125; as a result of the underlying task.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//尝试取消执行的任务</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//判断任务是否取消</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isCancelled</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//判断任务是否执行完成</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isDone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//等待直到任务执行完成，并且返回结果</span></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//等待最大超时时间，如果执行完成则返回结果，否则抛出超时异常</span></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>并发编程中，我们通常会用到一组非阻塞的模型：Promise，Future 和 Callback。其中的 Future 表示一个可能还没有实际完成的异步任务的结果，针对这个结果可以添加 Callback 以便在任务执行成功或失败后做出对应的操作，而Promise交由任务执行者，任务执行者通过 Promise 可以标记任务完成或者失败。 这一套模型是很多异步非阻塞架构的基础。</strong> 因为netty中也有类似<code>调用者和执行部件以异步的方式交互通信结果</code>的需求（要知道eventloop本质上是一个ScheduledExecutorService，ExecutorService是一种“提交-执行”模型实现，也存在线程间异步方式通信和线程安全问题），所以netty自己实现了一套。</p>\n<p>Netty中所有的IO操作都是异步的（比如write(Object)，因为Netty中一个EventLoop要服务于多个SocketChannel，所以通过<code>socketChannel.xx</code>只是提交一个任务，何时返回结果是不确定的），而不像传统的BIO那样阻塞等待操作完成，来获取执行结果。</p>\n<p>事实上，Netty Future的建议操作模式就是赤裸裸的通知，执行部件改变状态时，会执行注册在future上的Listener（变相的观察者模式）。</p>\n<p>scala在语言层面提供对Promise，Future和Callback模型的支持，<code>https://bitbucket.org/qiyi/commons-future.git</code>作者自定义实现了该模型，去除了Netty的Future模型对EventLoop的依赖。</p>\n<h4 id=\"Netty中的Future\"><a href=\"#Netty中的Future\" class=\"headerlink\" title=\"Netty中的Future\"></a>Netty中的Future</h4><p>下面的Netty Future继承jdk提供的Future接口，添加了一些自己的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The result of an asynchronous operation.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"ClassNameSameAsAncestorName\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">java</span>.<span class=\"title\">util</span>.<span class=\"title\">concurrent</span>.<span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSuccess</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isCancellable</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Throwable <span class=\"title\">cause</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">addListener</span><span class=\"params\">(GenericFutureListener&lt;? extends Future&lt;? <span class=\"keyword\">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">addListeners</span><span class=\"params\">(GenericFutureListener&lt;? extends Future&lt;? <span class=\"keyword\">super</span> V&gt;&gt;... listeners)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">removeListener</span><span class=\"params\">(GenericFutureListener&lt;? extends Future&lt;? <span class=\"keyword\">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">removeListeners</span><span class=\"params\">(GenericFutureListener&lt;? extends Future&lt;? <span class=\"keyword\">super</span> V&gt;&gt;... listeners)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">sync</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">syncUninterruptibly</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">Future&lt;V&gt; <span class=\"title\">awaitUninterruptibly</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> timeoutMillis)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">awaitUninterruptibly</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">awaitUninterruptibly</span><span class=\"params\">(<span class=\"keyword\">long</span> timeoutMillis)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">getNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://misc.linkedkeeper.com/misc/img/blog/201612/linkedkeeper0_c93937f4-f0f5-419e-a8b1-e71dc2288003.jpg\" alt=\"\"></p>\n<p>a future is a read-only placeholder view of a variable, while a promise is a writable。Promise是可写的Future，提供写操作相关的接口，用于设置IO操作的结果。Future，Promise，callback抽象出一套调用者与执行部件间的通信模型（不只是netty中），<strong>Future像是给调用者用的（拿结果），Promise像是给执行部件用的（设置结果），它们简化了调用者和执行部件对其的调用（调用者get，执行部件set），但本身要封装很多事</strong>。比如Future必须是一个线程安全的类（大部分时候，调用者和执行部件身处两个线程），比如执行callback（或者listener）。</p>\n<h4 id=\"Netty-Promise执行Listener\"><a href=\"#Netty-Promise执行Listener\" class=\"headerlink\" title=\"Netty Promise执行Listener\"></a>Netty Promise执行Listener</h4><p>Netty中的Promise通常由EventLoop创建，也就是Promise通常会绑定executor。为何呢？<strong>因为Netty保证Listener的执行，一定是在channel对应的EventLoop中</strong>(????)。</p>"},{"title":"Liunx中Direct IO机制","date":"2018-12-15T12:04:58.000Z","_content":"\n### 什么是Buffered I/O\n\n缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。缓存 I/O 有以下这些优点：\n\n- 缓存 I/O 使用了操作系统内核缓冲区，在一定程度上分离了应用程序空间和实际的物理设备。\n- 缓存 I/O 可以减少读盘的次数，从而提高性能。\n\n<!-- more -->\n\n当应用程序尝试读取某块数据的时候，如果这块数据已经存放在了页缓存中，那么这块数据就可以立即返回给应用程序，而不需要经过实际的物理读盘操作。当然，如果数据在应用程序读取之前并未被存放在页缓存中，那么就需要先将数据从磁盘读到页缓存中去。对于写操作来说，应用程序也会将数据先写到页缓存中去，数据是否被立即写到磁盘上去取决于应用程序所采用的写操作机制：如果用户采用的是同步写机制（ synchronous writes ）, 那么数据会立即被写回到磁盘上，应用程序会一直等到数据被写完为止；如果用户采用的是延迟写机制（ deferred writes ），那么应用程序就完全不需要等到数据全部被写回到磁盘，数据只要被写到页缓存中去就可以了。在延迟写机制的情况下，操作系统会定期地将放在页缓存中的数据刷到磁盘上。与异步写机制（ asynchronous writes ）不同的是，延迟写机制在数据完全写到磁盘上的时候不会通知应用程序，而异步写机制在数据完全写到磁盘上的时候是会返回给应用程序的。所以延迟写机制本身是存在数据丢失的风险的，而异步写机制则不会有这方面的担心。\n\n### 缓存I/O的特点\n\n在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样的话，数据在传输过程中需要在应用程序地址空间和页缓存之间进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。\n\n对于某些特殊的应用程序来说，避开操作系统内核缓冲区而直接在应用程序地址空间和磁盘之间传输数据会比使用操作系统内核缓冲区获取更好的性能，下边这一小节中提到的自缓存应用程序就是其中的一种。\n\n### 自缓存应用程序（ self-caching applications）\n\n对于某些应用程序来说，它会有它自己的数据缓存机制，比如，它会将数据缓存在应用程序地址空间，这类应用程序完全不需要使用操作系统内核中的高速缓冲存储器，这类应用程序就被称作是自缓存应用程序（ self-caching applications ）。数据库管理系统是这类应用程序的一个代表。自缓存应用程序倾向于使用数据的逻辑表达方式，而非物理表达方式；当系统内存较低的时候，自缓存应用程序会让这种数据的逻辑缓存被换出，而并非是磁盘上实际的数据被换出。自缓存应用程序对要操作的数据的语义了如指掌，所以它可以采用更加高效的缓存替换算法。自缓存应用程序有可能会在多台主机之间共享一块内存，那么自缓存应用程序就需要提供一种能够有效地将用户地址空间的缓存数据置为无效的机制，从而确保应用程序地址空间缓存数据的一致性。\n\n对于自缓存应用程序来说，缓存 I/O 明显不是一个好的选择。由此引出我们这篇文章着重要介绍的 Linux 中的直接 I/O 技术。Linux 中的直接 I/O 技术非常适用于自缓存这类应用程序，该技术省略掉缓存 I/O 技术中操作系统内核缓冲区的使用，数据直接在应用程序地址空间和磁盘之间进行传输，从而使得自缓存应用程序可以省略掉复杂的系统级别的缓存结构，而执行程序自己定义的数据读写管理，从而降低系统级别的管理对应用程序访问数据的影响。在下面一节中，我们会着重介绍 Linux 中提供的直接 I/O 机制的设计与实现，该机制为自缓存应用程序提供了很好的支持。\n\n### Linux中的Direct I/O技术\n\n所有的I/O操作都是通过读文件或者写文件来完成的。在这里，我们把所有的外围设备，包括键盘和显示器都看成是文件系统中的文件。Linux中提供的访问文件的方式多种多样，下面将列出Linux中支持的文件访问方式。\n\n#### 标准访问文件的方式\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-34-34.png?raw=true)\n\n#### 同步访问文件的方式\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-40-43.png?raw=true)\n\n#### 内存映射方式\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-41-44.png?raw=true)\n\n#### 直接I/O的方式\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-42-31.png?raw=true)\n\n#### 异步访问文件的方式\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-43-19.png?raw=true)\n\n","source":"_posts/linux-direct-io.md","raw":"---\n\ntitle: Liunx中Direct IO机制\ndate: 2018-12-15 20:04:58\ntags:\n    - Linux\n    - DirectIO\n---\n\n### 什么是Buffered I/O\n\n缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。缓存 I/O 有以下这些优点：\n\n- 缓存 I/O 使用了操作系统内核缓冲区，在一定程度上分离了应用程序空间和实际的物理设备。\n- 缓存 I/O 可以减少读盘的次数，从而提高性能。\n\n<!-- more -->\n\n当应用程序尝试读取某块数据的时候，如果这块数据已经存放在了页缓存中，那么这块数据就可以立即返回给应用程序，而不需要经过实际的物理读盘操作。当然，如果数据在应用程序读取之前并未被存放在页缓存中，那么就需要先将数据从磁盘读到页缓存中去。对于写操作来说，应用程序也会将数据先写到页缓存中去，数据是否被立即写到磁盘上去取决于应用程序所采用的写操作机制：如果用户采用的是同步写机制（ synchronous writes ）, 那么数据会立即被写回到磁盘上，应用程序会一直等到数据被写完为止；如果用户采用的是延迟写机制（ deferred writes ），那么应用程序就完全不需要等到数据全部被写回到磁盘，数据只要被写到页缓存中去就可以了。在延迟写机制的情况下，操作系统会定期地将放在页缓存中的数据刷到磁盘上。与异步写机制（ asynchronous writes ）不同的是，延迟写机制在数据完全写到磁盘上的时候不会通知应用程序，而异步写机制在数据完全写到磁盘上的时候是会返回给应用程序的。所以延迟写机制本身是存在数据丢失的风险的，而异步写机制则不会有这方面的担心。\n\n### 缓存I/O的特点\n\n在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样的话，数据在传输过程中需要在应用程序地址空间和页缓存之间进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。\n\n对于某些特殊的应用程序来说，避开操作系统内核缓冲区而直接在应用程序地址空间和磁盘之间传输数据会比使用操作系统内核缓冲区获取更好的性能，下边这一小节中提到的自缓存应用程序就是其中的一种。\n\n### 自缓存应用程序（ self-caching applications）\n\n对于某些应用程序来说，它会有它自己的数据缓存机制，比如，它会将数据缓存在应用程序地址空间，这类应用程序完全不需要使用操作系统内核中的高速缓冲存储器，这类应用程序就被称作是自缓存应用程序（ self-caching applications ）。数据库管理系统是这类应用程序的一个代表。自缓存应用程序倾向于使用数据的逻辑表达方式，而非物理表达方式；当系统内存较低的时候，自缓存应用程序会让这种数据的逻辑缓存被换出，而并非是磁盘上实际的数据被换出。自缓存应用程序对要操作的数据的语义了如指掌，所以它可以采用更加高效的缓存替换算法。自缓存应用程序有可能会在多台主机之间共享一块内存，那么自缓存应用程序就需要提供一种能够有效地将用户地址空间的缓存数据置为无效的机制，从而确保应用程序地址空间缓存数据的一致性。\n\n对于自缓存应用程序来说，缓存 I/O 明显不是一个好的选择。由此引出我们这篇文章着重要介绍的 Linux 中的直接 I/O 技术。Linux 中的直接 I/O 技术非常适用于自缓存这类应用程序，该技术省略掉缓存 I/O 技术中操作系统内核缓冲区的使用，数据直接在应用程序地址空间和磁盘之间进行传输，从而使得自缓存应用程序可以省略掉复杂的系统级别的缓存结构，而执行程序自己定义的数据读写管理，从而降低系统级别的管理对应用程序访问数据的影响。在下面一节中，我们会着重介绍 Linux 中提供的直接 I/O 机制的设计与实现，该机制为自缓存应用程序提供了很好的支持。\n\n### Linux中的Direct I/O技术\n\n所有的I/O操作都是通过读文件或者写文件来完成的。在这里，我们把所有的外围设备，包括键盘和显示器都看成是文件系统中的文件。Linux中提供的访问文件的方式多种多样，下面将列出Linux中支持的文件访问方式。\n\n#### 标准访问文件的方式\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-34-34.png?raw=true)\n\n#### 同步访问文件的方式\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-40-43.png?raw=true)\n\n#### 内存映射方式\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-41-44.png?raw=true)\n\n#### 直接I/O的方式\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-42-31.png?raw=true)\n\n#### 异步访问文件的方式\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-43-19.png?raw=true)\n\n","slug":"linux-direct-io","published":1,"updated":"2018-12-27T13:29:05.656Z","_id":"cjq6kwn5k002lzjiad4e9fzc8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"什么是Buffered-I-O\"><a href=\"#什么是Buffered-I-O\" class=\"headerlink\" title=\"什么是Buffered I/O\"></a>什么是Buffered I/O</h3><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。缓存 I/O 有以下这些优点：</p>\n<ul>\n<li>缓存 I/O 使用了操作系统内核缓冲区，在一定程度上分离了应用程序空间和实际的物理设备。</li>\n<li>缓存 I/O 可以减少读盘的次数，从而提高性能。</li>\n</ul>\n<a id=\"more\"></a>\n<p>当应用程序尝试读取某块数据的时候，如果这块数据已经存放在了页缓存中，那么这块数据就可以立即返回给应用程序，而不需要经过实际的物理读盘操作。当然，如果数据在应用程序读取之前并未被存放在页缓存中，那么就需要先将数据从磁盘读到页缓存中去。对于写操作来说，应用程序也会将数据先写到页缓存中去，数据是否被立即写到磁盘上去取决于应用程序所采用的写操作机制：如果用户采用的是同步写机制（ synchronous writes ）, 那么数据会立即被写回到磁盘上，应用程序会一直等到数据被写完为止；如果用户采用的是延迟写机制（ deferred writes ），那么应用程序就完全不需要等到数据全部被写回到磁盘，数据只要被写到页缓存中去就可以了。在延迟写机制的情况下，操作系统会定期地将放在页缓存中的数据刷到磁盘上。与异步写机制（ asynchronous writes ）不同的是，延迟写机制在数据完全写到磁盘上的时候不会通知应用程序，而异步写机制在数据完全写到磁盘上的时候是会返回给应用程序的。所以延迟写机制本身是存在数据丢失的风险的，而异步写机制则不会有这方面的担心。</p>\n<h3 id=\"缓存I-O的特点\"><a href=\"#缓存I-O的特点\" class=\"headerlink\" title=\"缓存I/O的特点\"></a>缓存I/O的特点</h3><p>在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样的话，数据在传输过程中需要在应用程序地址空间和页缓存之间进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>\n<p>对于某些特殊的应用程序来说，避开操作系统内核缓冲区而直接在应用程序地址空间和磁盘之间传输数据会比使用操作系统内核缓冲区获取更好的性能，下边这一小节中提到的自缓存应用程序就是其中的一种。</p>\n<h3 id=\"自缓存应用程序（-self-caching-applications）\"><a href=\"#自缓存应用程序（-self-caching-applications）\" class=\"headerlink\" title=\"自缓存应用程序（ self-caching applications）\"></a>自缓存应用程序（ self-caching applications）</h3><p>对于某些应用程序来说，它会有它自己的数据缓存机制，比如，它会将数据缓存在应用程序地址空间，这类应用程序完全不需要使用操作系统内核中的高速缓冲存储器，这类应用程序就被称作是自缓存应用程序（ self-caching applications ）。数据库管理系统是这类应用程序的一个代表。自缓存应用程序倾向于使用数据的逻辑表达方式，而非物理表达方式；当系统内存较低的时候，自缓存应用程序会让这种数据的逻辑缓存被换出，而并非是磁盘上实际的数据被换出。自缓存应用程序对要操作的数据的语义了如指掌，所以它可以采用更加高效的缓存替换算法。自缓存应用程序有可能会在多台主机之间共享一块内存，那么自缓存应用程序就需要提供一种能够有效地将用户地址空间的缓存数据置为无效的机制，从而确保应用程序地址空间缓存数据的一致性。</p>\n<p>对于自缓存应用程序来说，缓存 I/O 明显不是一个好的选择。由此引出我们这篇文章着重要介绍的 Linux 中的直接 I/O 技术。Linux 中的直接 I/O 技术非常适用于自缓存这类应用程序，该技术省略掉缓存 I/O 技术中操作系统内核缓冲区的使用，数据直接在应用程序地址空间和磁盘之间进行传输，从而使得自缓存应用程序可以省略掉复杂的系统级别的缓存结构，而执行程序自己定义的数据读写管理，从而降低系统级别的管理对应用程序访问数据的影响。在下面一节中，我们会着重介绍 Linux 中提供的直接 I/O 机制的设计与实现，该机制为自缓存应用程序提供了很好的支持。</p>\n<h3 id=\"Linux中的Direct-I-O技术\"><a href=\"#Linux中的Direct-I-O技术\" class=\"headerlink\" title=\"Linux中的Direct I/O技术\"></a>Linux中的Direct I/O技术</h3><p>所有的I/O操作都是通过读文件或者写文件来完成的。在这里，我们把所有的外围设备，包括键盘和显示器都看成是文件系统中的文件。Linux中提供的访问文件的方式多种多样，下面将列出Linux中支持的文件访问方式。</p>\n<h4 id=\"标准访问文件的方式\"><a href=\"#标准访问文件的方式\" class=\"headerlink\" title=\"标准访问文件的方式\"></a>标准访问文件的方式</h4><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-34-34.png?raw=true\" alt=\"\"></p>\n<h4 id=\"同步访问文件的方式\"><a href=\"#同步访问文件的方式\" class=\"headerlink\" title=\"同步访问文件的方式\"></a>同步访问文件的方式</h4><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-40-43.png?raw=true\" alt=\"\"></p>\n<h4 id=\"内存映射方式\"><a href=\"#内存映射方式\" class=\"headerlink\" title=\"内存映射方式\"></a>内存映射方式</h4><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-41-44.png?raw=true\" alt=\"\"></p>\n<h4 id=\"直接I-O的方式\"><a href=\"#直接I-O的方式\" class=\"headerlink\" title=\"直接I/O的方式\"></a>直接I/O的方式</h4><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-42-31.png?raw=true\" alt=\"\"></p>\n<h4 id=\"异步访问文件的方式\"><a href=\"#异步访问文件的方式\" class=\"headerlink\" title=\"异步访问文件的方式\"></a>异步访问文件的方式</h4><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-43-19.png?raw=true\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是Buffered-I-O\"><a href=\"#什么是Buffered-I-O\" class=\"headerlink\" title=\"什么是Buffered I/O\"></a>什么是Buffered I/O</h3><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。缓存 I/O 有以下这些优点：</p>\n<ul>\n<li>缓存 I/O 使用了操作系统内核缓冲区，在一定程度上分离了应用程序空间和实际的物理设备。</li>\n<li>缓存 I/O 可以减少读盘的次数，从而提高性能。</li>\n</ul>","more":"<p>当应用程序尝试读取某块数据的时候，如果这块数据已经存放在了页缓存中，那么这块数据就可以立即返回给应用程序，而不需要经过实际的物理读盘操作。当然，如果数据在应用程序读取之前并未被存放在页缓存中，那么就需要先将数据从磁盘读到页缓存中去。对于写操作来说，应用程序也会将数据先写到页缓存中去，数据是否被立即写到磁盘上去取决于应用程序所采用的写操作机制：如果用户采用的是同步写机制（ synchronous writes ）, 那么数据会立即被写回到磁盘上，应用程序会一直等到数据被写完为止；如果用户采用的是延迟写机制（ deferred writes ），那么应用程序就完全不需要等到数据全部被写回到磁盘，数据只要被写到页缓存中去就可以了。在延迟写机制的情况下，操作系统会定期地将放在页缓存中的数据刷到磁盘上。与异步写机制（ asynchronous writes ）不同的是，延迟写机制在数据完全写到磁盘上的时候不会通知应用程序，而异步写机制在数据完全写到磁盘上的时候是会返回给应用程序的。所以延迟写机制本身是存在数据丢失的风险的，而异步写机制则不会有这方面的担心。</p>\n<h3 id=\"缓存I-O的特点\"><a href=\"#缓存I-O的特点\" class=\"headerlink\" title=\"缓存I/O的特点\"></a>缓存I/O的特点</h3><p>在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样的话，数据在传输过程中需要在应用程序地址空间和页缓存之间进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>\n<p>对于某些特殊的应用程序来说，避开操作系统内核缓冲区而直接在应用程序地址空间和磁盘之间传输数据会比使用操作系统内核缓冲区获取更好的性能，下边这一小节中提到的自缓存应用程序就是其中的一种。</p>\n<h3 id=\"自缓存应用程序（-self-caching-applications）\"><a href=\"#自缓存应用程序（-self-caching-applications）\" class=\"headerlink\" title=\"自缓存应用程序（ self-caching applications）\"></a>自缓存应用程序（ self-caching applications）</h3><p>对于某些应用程序来说，它会有它自己的数据缓存机制，比如，它会将数据缓存在应用程序地址空间，这类应用程序完全不需要使用操作系统内核中的高速缓冲存储器，这类应用程序就被称作是自缓存应用程序（ self-caching applications ）。数据库管理系统是这类应用程序的一个代表。自缓存应用程序倾向于使用数据的逻辑表达方式，而非物理表达方式；当系统内存较低的时候，自缓存应用程序会让这种数据的逻辑缓存被换出，而并非是磁盘上实际的数据被换出。自缓存应用程序对要操作的数据的语义了如指掌，所以它可以采用更加高效的缓存替换算法。自缓存应用程序有可能会在多台主机之间共享一块内存，那么自缓存应用程序就需要提供一种能够有效地将用户地址空间的缓存数据置为无效的机制，从而确保应用程序地址空间缓存数据的一致性。</p>\n<p>对于自缓存应用程序来说，缓存 I/O 明显不是一个好的选择。由此引出我们这篇文章着重要介绍的 Linux 中的直接 I/O 技术。Linux 中的直接 I/O 技术非常适用于自缓存这类应用程序，该技术省略掉缓存 I/O 技术中操作系统内核缓冲区的使用，数据直接在应用程序地址空间和磁盘之间进行传输，从而使得自缓存应用程序可以省略掉复杂的系统级别的缓存结构，而执行程序自己定义的数据读写管理，从而降低系统级别的管理对应用程序访问数据的影响。在下面一节中，我们会着重介绍 Linux 中提供的直接 I/O 机制的设计与实现，该机制为自缓存应用程序提供了很好的支持。</p>\n<h3 id=\"Linux中的Direct-I-O技术\"><a href=\"#Linux中的Direct-I-O技术\" class=\"headerlink\" title=\"Linux中的Direct I/O技术\"></a>Linux中的Direct I/O技术</h3><p>所有的I/O操作都是通过读文件或者写文件来完成的。在这里，我们把所有的外围设备，包括键盘和显示器都看成是文件系统中的文件。Linux中提供的访问文件的方式多种多样，下面将列出Linux中支持的文件访问方式。</p>\n<h4 id=\"标准访问文件的方式\"><a href=\"#标准访问文件的方式\" class=\"headerlink\" title=\"标准访问文件的方式\"></a>标准访问文件的方式</h4><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-34-34.png?raw=true\" alt=\"\"></p>\n<h4 id=\"同步访问文件的方式\"><a href=\"#同步访问文件的方式\" class=\"headerlink\" title=\"同步访问文件的方式\"></a>同步访问文件的方式</h4><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-40-43.png?raw=true\" alt=\"\"></p>\n<h4 id=\"内存映射方式\"><a href=\"#内存映射方式\" class=\"headerlink\" title=\"内存映射方式\"></a>内存映射方式</h4><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-41-44.png?raw=true\" alt=\"\"></p>\n<h4 id=\"直接I-O的方式\"><a href=\"#直接I-O的方式\" class=\"headerlink\" title=\"直接I/O的方式\"></a>直接I/O的方式</h4><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-42-31.png?raw=true\" alt=\"\"></p>\n<h4 id=\"异步访问文件的方式\"><a href=\"#异步访问文件的方式\" class=\"headerlink\" title=\"异步访问文件的方式\"></a>异步访问文件的方式</h4><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-12-16 19-43-19.png?raw=true\" alt=\"\"></p>"},{"title":"Netty 入门","date":"2018-05-10T13:58:26.000Z","_content":"\n> Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server. \n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1526016569.png?raw=true)\n\n\n\n<!-- more -->\n\n### 特征\n\n* 不同的传输类型（blocking and non-blocking socket ）使用统一的API\n* 拥有灵活的易扩展的事件模型\n* 高低自定义的线程模型-single thread, one or more thread pools such as SEDA \n* 高吞吐量，低时延\n* 更少的资源占用\n* 最小化不必要的内存拷贝\n* 完全支持SSL/TLS和StartTLS\n\n### 入门示例\n\n#### 添加依赖\n\n```xml\n<dependency>\n    <groupId>io.netty</groupId>\n    <artifactId>netty-all</artifactId>\n    <version>4.1.23.Final</version>\n    <scope>compile</scope>\n</dependency>\n```\n\n#### Server端\n\n```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 13:44 2018/5/11.\n */\npublic class NettyServer {\n    public void start(Integer port) throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workGroup = new NioEventLoopGroup(4);\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workGroup).channel(NioServerSocketChannel.class)\n                .localAddress(port)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline()\n                                .addLast(new ObjectDecoder(1024*1024,\n                                        ClassResolvers.weakCachingConcurrentResolver(this.getClass().getClassLoader())) )\n                                .addLast(new ObjectEncoder())\n                                .addLast(new SimpleChannelInboundHandler<Object>() {\n                                    @Override\n                                    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                                        System.out.println(\"Receive message:\" + msg);\n                                        ctx.writeAndFlush(\"Hello \" + msg);\n                                    }\n                                });\n                    }\n                });\n        ChannelFuture channelFuture = bootstrap.bind().sync();\n        channelFuture.channel().closeFuture().sync();\n        bossGroup.shutdownGracefully().sync();\n        workGroup.shutdownGracefully().sync();\n    }\n\n    public static void main(String[] args) {\n        try {\n            NettyServer server = new NettyServer();\n            server.start(20000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n#### Client端\n\n```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 13:53 2018/5/11.\n */\npublic class NettyClient {\n    public Channel channel;\n    public void start(String host, Integer port) throws InterruptedException {\n        EventLoopGroup workGroup = new NioEventLoopGroup(4);\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(workGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        // Using Java Object serializable, you can also use other serializable frameworks like thrift, Protobuf and so on.\n                        ch.pipeline()\n                                .addLast(new ObjectDecoder(1024*1024,\n                                        ClassResolvers.weakCachingConcurrentResolver(this.getClass().getClassLoader())) )\n                                .addLast(new ObjectEncoder())\n                                .addLast(new SimpleChannelInboundHandler<Object>() {\n                                    @Override\n                                    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                                        System.out.println(\"Receive msg: \" + msg);\n                                    }\n                                });\n                    }\n                });\n        // Connect to the server sync\n        channel = bootstrap.connect(host, port).sync().channel();\n    }\n\n    public static void main(String[] args) {\n        try {\n            NettyClient nettyClient = new NettyClient();\n            nettyClient.start(\"127.0.0.1\", 20000);\n            if (nettyClient.channel != null && nettyClient.channel.isActive()){\n                System.out.println(\"Send message to server\");\n                nettyClient.channel.writeAndFlush(\"Junlan\");\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n","source":"_posts/netty-introduction.md","raw":"---\ntitle: Netty 入门\ndate: 2018-05-10 21:58:26\ntags:\n    - Netty\n---\n\n> Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server. \n\n![](https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1526016569.png?raw=true)\n\n\n\n<!-- more -->\n\n### 特征\n\n* 不同的传输类型（blocking and non-blocking socket ）使用统一的API\n* 拥有灵活的易扩展的事件模型\n* 高低自定义的线程模型-single thread, one or more thread pools such as SEDA \n* 高吞吐量，低时延\n* 更少的资源占用\n* 最小化不必要的内存拷贝\n* 完全支持SSL/TLS和StartTLS\n\n### 入门示例\n\n#### 添加依赖\n\n```xml\n<dependency>\n    <groupId>io.netty</groupId>\n    <artifactId>netty-all</artifactId>\n    <version>4.1.23.Final</version>\n    <scope>compile</scope>\n</dependency>\n```\n\n#### Server端\n\n```java\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 13:44 2018/5/11.\n */\npublic class NettyServer {\n    public void start(Integer port) throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup();\n        EventLoopGroup workGroup = new NioEventLoopGroup(4);\n\n        ServerBootstrap bootstrap = new ServerBootstrap();\n        bootstrap.group(bossGroup, workGroup).channel(NioServerSocketChannel.class)\n                .localAddress(port)\n                .childHandler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        ch.pipeline()\n                                .addLast(new ObjectDecoder(1024*1024,\n                                        ClassResolvers.weakCachingConcurrentResolver(this.getClass().getClassLoader())) )\n                                .addLast(new ObjectEncoder())\n                                .addLast(new SimpleChannelInboundHandler<Object>() {\n                                    @Override\n                                    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                                        System.out.println(\"Receive message:\" + msg);\n                                        ctx.writeAndFlush(\"Hello \" + msg);\n                                    }\n                                });\n                    }\n                });\n        ChannelFuture channelFuture = bootstrap.bind().sync();\n        channelFuture.channel().closeFuture().sync();\n        bossGroup.shutdownGracefully().sync();\n        workGroup.shutdownGracefully().sync();\n    }\n\n    public static void main(String[] args) {\n        try {\n            NettyServer server = new NettyServer();\n            server.start(20000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n#### Client端\n\n```java\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.*;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.serialization.ClassResolvers;\nimport io.netty.handler.codec.serialization.ObjectDecoder;\nimport io.netty.handler.codec.serialization.ObjectEncoder;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 13:53 2018/5/11.\n */\npublic class NettyClient {\n    public Channel channel;\n    public void start(String host, Integer port) throws InterruptedException {\n        EventLoopGroup workGroup = new NioEventLoopGroup(4);\n        Bootstrap bootstrap = new Bootstrap();\n        bootstrap.group(workGroup)\n                .channel(NioSocketChannel.class)\n                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000)\n                .handler(new ChannelInitializer<SocketChannel>() {\n                    @Override\n                    protected void initChannel(SocketChannel ch) throws Exception {\n                        // Using Java Object serializable, you can also use other serializable frameworks like thrift, Protobuf and so on.\n                        ch.pipeline()\n                                .addLast(new ObjectDecoder(1024*1024,\n                                        ClassResolvers.weakCachingConcurrentResolver(this.getClass().getClassLoader())) )\n                                .addLast(new ObjectEncoder())\n                                .addLast(new SimpleChannelInboundHandler<Object>() {\n                                    @Override\n                                    protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                                        System.out.println(\"Receive msg: \" + msg);\n                                    }\n                                });\n                    }\n                });\n        // Connect to the server sync\n        channel = bootstrap.connect(host, port).sync().channel();\n    }\n\n    public static void main(String[] args) {\n        try {\n            NettyClient nettyClient = new NettyClient();\n            nettyClient.start(\"127.0.0.1\", 20000);\n            if (nettyClient.channel != null && nettyClient.channel.isActive()){\n                System.out.println(\"Send message to server\");\n                nettyClient.channel.writeAndFlush(\"Junlan\");\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n","slug":"netty-introduction","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5l002ozjiavnfsoja6","content":"<blockquote>\n<p>Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server. </p>\n</blockquote>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1526016569.png?raw=true\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><ul>\n<li>不同的传输类型（blocking and non-blocking socket ）使用统一的API</li>\n<li>拥有灵活的易扩展的事件模型</li>\n<li>高低自定义的线程模型-single thread, one or more thread pools such as SEDA </li>\n<li>高吞吐量，低时延</li>\n<li>更少的资源占用</li>\n<li>最小化不必要的内存拷贝</li>\n<li>完全支持SSL/TLS和StartTLS</li>\n</ul>\n<h3 id=\"入门示例\"><a href=\"#入门示例\" class=\"headerlink\" title=\"入门示例\"></a>入门示例</h3><h4 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.netty<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>netty-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.1.23.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Server端\"><a href=\"#Server端\" class=\"headerlink\" title=\"Server端\"></a>Server端</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.serialization.ClassResolvers;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.serialization.ObjectDecoder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.serialization.ObjectEncoder;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 13:44 2018/5/11.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(Integer port)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        EventLoopGroup bossGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        EventLoopGroup workGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ServerBootstrap bootstrap = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">        bootstrap.group(bossGroup, workGroup).channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                .localAddress(port)</span><br><span class=\"line\">                .childHandler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        ch.pipeline()</span><br><span class=\"line\">                                .addLast(<span class=\"keyword\">new</span> ObjectDecoder(<span class=\"number\">1024</span>*<span class=\"number\">1024</span>,</span><br><span class=\"line\">                                        ClassResolvers.weakCachingConcurrentResolver(<span class=\"keyword\">this</span>.getClass().getClassLoader())) )</span><br><span class=\"line\">                                .addLast(<span class=\"keyword\">new</span> ObjectEncoder())</span><br><span class=\"line\">                                .addLast(<span class=\"keyword\">new</span> SimpleChannelInboundHandler&lt;Object&gt;() &#123;</span><br><span class=\"line\">                                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                                    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                        System.out.println(<span class=\"string\">\"Receive message:\"</span> + msg);</span><br><span class=\"line\">                                        ctx.writeAndFlush(<span class=\"string\">\"Hello \"</span> + msg);</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        ChannelFuture channelFuture = bootstrap.bind().sync();</span><br><span class=\"line\">        channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\">        bossGroup.shutdownGracefully().sync();</span><br><span class=\"line\">        workGroup.shutdownGracefully().sync();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            NettyServer server = <span class=\"keyword\">new</span> NettyServer();</span><br><span class=\"line\">            server.start(<span class=\"number\">20000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Client端\"><a href=\"#Client端\" class=\"headerlink\" title=\"Client端\"></a>Client端</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.serialization.ClassResolvers;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.serialization.ObjectDecoder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.serialization.ObjectEncoder;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 13:53 2018/5/11.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyClient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Channel channel;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(String host, Integer port)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        EventLoopGroup workGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">4</span>);</span><br><span class=\"line\">        Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">        bootstrap.group(workGroup)</span><br><span class=\"line\">                .channel(NioSocketChannel.class)</span><br><span class=\"line\">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class=\"number\">3000</span>)</span><br><span class=\"line\">                .handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Using Java Object serializable, you can also use other serializable frameworks like thrift, Protobuf and so on.</span></span><br><span class=\"line\">                        ch.pipeline()</span><br><span class=\"line\">                                .addLast(<span class=\"keyword\">new</span> ObjectDecoder(<span class=\"number\">1024</span>*<span class=\"number\">1024</span>,</span><br><span class=\"line\">                                        ClassResolvers.weakCachingConcurrentResolver(<span class=\"keyword\">this</span>.getClass().getClassLoader())) )</span><br><span class=\"line\">                                .addLast(<span class=\"keyword\">new</span> ObjectEncoder())</span><br><span class=\"line\">                                .addLast(<span class=\"keyword\">new</span> SimpleChannelInboundHandler&lt;Object&gt;() &#123;</span><br><span class=\"line\">                                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                                    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                        System.out.println(<span class=\"string\">\"Receive msg: \"</span> + msg);</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// Connect to the server sync</span></span><br><span class=\"line\">        channel = bootstrap.connect(host, port).sync().channel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            NettyClient nettyClient = <span class=\"keyword\">new</span> NettyClient();</span><br><span class=\"line\">            nettyClient.start(<span class=\"string\">\"127.0.0.1\"</span>, <span class=\"number\">20000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nettyClient.channel != <span class=\"keyword\">null</span> &amp;&amp; nettyClient.channel.isActive())&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Send message to server\"</span>);</span><br><span class=\"line\">                nettyClient.channel.writeAndFlush(<span class=\"string\">\"Junlan\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server. </p>\n</blockquote>\n<p><img src=\"https://github.com/shuaijunlan/shuaijunlan.github.io/blob/master/images/1526016569.png?raw=true\" alt=\"\"></p>","more":"<h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><ul>\n<li>不同的传输类型（blocking and non-blocking socket ）使用统一的API</li>\n<li>拥有灵活的易扩展的事件模型</li>\n<li>高低自定义的线程模型-single thread, one or more thread pools such as SEDA </li>\n<li>高吞吐量，低时延</li>\n<li>更少的资源占用</li>\n<li>最小化不必要的内存拷贝</li>\n<li>完全支持SSL/TLS和StartTLS</li>\n</ul>\n<h3 id=\"入门示例\"><a href=\"#入门示例\" class=\"headerlink\" title=\"入门示例\"></a>入门示例</h3><h4 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>io.netty<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>netty-all<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.1.23.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Server端\"><a href=\"#Server端\" class=\"headerlink\" title=\"Server端\"></a>Server端</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.serialization.ClassResolvers;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.serialization.ObjectDecoder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.serialization.ObjectEncoder;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 13:44 2018/5/11.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(Integer port)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        EventLoopGroup bossGroup = <span class=\"keyword\">new</span> NioEventLoopGroup();</span><br><span class=\"line\">        EventLoopGroup workGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">4</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ServerBootstrap bootstrap = <span class=\"keyword\">new</span> ServerBootstrap();</span><br><span class=\"line\">        bootstrap.group(bossGroup, workGroup).channel(NioServerSocketChannel.class)</span><br><span class=\"line\">                .localAddress(port)</span><br><span class=\"line\">                .childHandler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        ch.pipeline()</span><br><span class=\"line\">                                .addLast(<span class=\"keyword\">new</span> ObjectDecoder(<span class=\"number\">1024</span>*<span class=\"number\">1024</span>,</span><br><span class=\"line\">                                        ClassResolvers.weakCachingConcurrentResolver(<span class=\"keyword\">this</span>.getClass().getClassLoader())) )</span><br><span class=\"line\">                                .addLast(<span class=\"keyword\">new</span> ObjectEncoder())</span><br><span class=\"line\">                                .addLast(<span class=\"keyword\">new</span> SimpleChannelInboundHandler&lt;Object&gt;() &#123;</span><br><span class=\"line\">                                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                                    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                        System.out.println(<span class=\"string\">\"Receive message:\"</span> + msg);</span><br><span class=\"line\">                                        ctx.writeAndFlush(<span class=\"string\">\"Hello \"</span> + msg);</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        ChannelFuture channelFuture = bootstrap.bind().sync();</span><br><span class=\"line\">        channelFuture.channel().closeFuture().sync();</span><br><span class=\"line\">        bossGroup.shutdownGracefully().sync();</span><br><span class=\"line\">        workGroup.shutdownGracefully().sync();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            NettyServer server = <span class=\"keyword\">new</span> NettyServer();</span><br><span class=\"line\">            server.start(<span class=\"number\">20000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Client端\"><a href=\"#Client端\" class=\"headerlink\" title=\"Client端\"></a>Client端</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.serialization.ClassResolvers;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.serialization.ObjectDecoder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> io.netty.handler.codec.serialization.ObjectEncoder;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 13:53 2018/5/11.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyClient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Channel channel;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(String host, Integer port)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        EventLoopGroup workGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">4</span>);</span><br><span class=\"line\">        Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">        bootstrap.group(workGroup)</span><br><span class=\"line\">                .channel(NioSocketChannel.class)</span><br><span class=\"line\">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class=\"number\">3000</span>)</span><br><span class=\"line\">                .handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">// Using Java Object serializable, you can also use other serializable frameworks like thrift, Protobuf and so on.</span></span><br><span class=\"line\">                        ch.pipeline()</span><br><span class=\"line\">                                .addLast(<span class=\"keyword\">new</span> ObjectDecoder(<span class=\"number\">1024</span>*<span class=\"number\">1024</span>,</span><br><span class=\"line\">                                        ClassResolvers.weakCachingConcurrentResolver(<span class=\"keyword\">this</span>.getClass().getClassLoader())) )</span><br><span class=\"line\">                                .addLast(<span class=\"keyword\">new</span> ObjectEncoder())</span><br><span class=\"line\">                                .addLast(<span class=\"keyword\">new</span> SimpleChannelInboundHandler&lt;Object&gt;() &#123;</span><br><span class=\"line\">                                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                                    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                        System.out.println(<span class=\"string\">\"Receive msg: \"</span> + msg);</span><br><span class=\"line\">                                    &#125;</span><br><span class=\"line\">                                &#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// Connect to the server sync</span></span><br><span class=\"line\">        channel = bootstrap.connect(host, port).sync().channel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            NettyClient nettyClient = <span class=\"keyword\">new</span> NettyClient();</span><br><span class=\"line\">            nettyClient.start(<span class=\"string\">\"127.0.0.1\"</span>, <span class=\"number\">20000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nettyClient.channel != <span class=\"keyword\">null</span> &amp;&amp; nettyClient.channel.isActive())&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Send message to server\"</span>);</span><br><span class=\"line\">                nettyClient.channel.writeAndFlush(<span class=\"string\">\"Junlan\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Guide to the Java Phaser","date":"2018-11-08T10:43:24.000Z","_content":"\n> Java 7中新增了一个灵活的线程同步栅栏---**Phaser**，如果你需要在执行某些任务之前等待其他任务执行到某个状态，那么**Phaser**是一个很好的选择，这篇文章将介绍`java.util.concurrent.Phaser`，它和`CountDownLatch`具有相似的功能，但是**Phaser**更灵活。\n\n<!-- more -->\n\n### 基本术语\n\n在理解Phaser类的运行机制之前，我们先来了解Phaser类中的一些基本术语：\n\n* **Registration**\n\n  开篇我们讲过，Phaser比`CountDownLatch`和`CyclicBarrier`更灵活，因为它可以通过`register()`和`bulkRegister(int parties)`来动态调整注册任务的数量，任务也可以通过执行`arriveAndDeregister()`来注销任务，Phaser允许的最大任务注册数量为`65535`。\n\n* **Arrival**\n\n   正如Phaser类的名字所暗示，每个Phaser实例都会维护一个phase number，初始值为0。每当所有注册的任务都到达Phaser时，phase number累加，并在超过Integer.MAX_VALUE后清零。`arrive()`和`arriveAndDeregister()`方法用于记录到 达，`arriveAndAwaitAdvance()`方法用于记录到达，并且等待其它未到达的任务。\n\n* **Termination**\n\n   Phaser支持终止。Phaser终止之后，***调用`register()`和`bulkRegister(int parties)`方法没有任何效果***，`arriveAndAwaitAdvance()`方法也会立即返回。触发终止的时机是在`protected boolean onAdvance(int phase, int registeredParties)`方法返回时，如果该方法返回true，那么Phaser会被终止，默认实现是在注册任务数为0时返回true`（即 return registeredParties == 0;）`，我们也可以通过重写这个方法来自定义的终止逻辑。此外，`forceTermination()`方法用于强制终止，`isTerminated()`方法用于判断是否已经终止。\n\n* **Tiering**\n\n   Phaser支持层次结构，即通过构造函数`Phaser(Phaser parent)`和`Phaser(Phaser parent, int parties)`构造一个树形结构。这有助于减轻因在单个的Phaser上注册过多的任务而导致的竞争，从而提升吞吐量，代价是增加单个操作的开销。\n\n### 核心API\n\n* Phaser(int parties)，构造方法，与CountDownLatch一样，传入同步的线程数，也支持层次构造Phaser(Phaser parent)。\n\n* register()，bulkRegister(int Parties)，动态添加一个或多个参与者。\n\n* arriveAndDeregister()方法，动态撤销线程在phaser的注册，通知phaser对象，该线程已经结束该阶段且不参与后面阶段。\n\n* isTerminated()，当phaser没有参与同步的线程时（或者onAdvance返回true），phaser是终止态（如果phaser进入终止态arriveAndAwaitAdvance()和awaitAdvance()都会立即返回，不在等待）isTerminated返回true。\n\n* arrive()方法，通知phaser该线程已经完成该阶段，但不等待其他线程。\n\n* arriveAndAwaitAdvance()方法，类似await()方法，记录到达线程数，阻塞等待其他线程到达同步点后再继续执行。\n\n* awaitAdvance(int phase) /awaitAdvanceInterruptibly(int phase) 传入阶段数，只有当前阶段等于phase阶段时才阻塞等待。后者如果线程在休眠被中断会抛出InterruptedException异常（phaser的其他方法对中断都不会抛出异常）。\n\n* onAdvance(int phase, int registeredParties)方法。参数phase是阶段数，每经过一个阶段该数加1，registeredParties是当注册的线程数。此方法有2个作用：1、当每一个阶段执行完毕，此方法会被自动调用，因此，重载此方法写入的代码会在每个阶段执行完毕时执行，相当于CyclicBarrier的barrierAction。2、当此方法返回true时，意味着Phaser被终止，因此可以巧妙的设置此方法的返回值来终止所有线程。例如：若此方法返回值为 phase >= 3，其含义为当整个线程执行了3个阶段后，程序终止。\n\n* forceTermination()方法，强制phaser进入终止态。\n\n### 简单示例\n\n```java\n/**\n * @author Shuai Junlan[shuaijunlan@gmail.com].\n * @since Created in 2:26 PM 11/7/18.\n */\npublic class PhaserTest {\n    public static void main(String[] args) \n            throws InterruptedException {\n        final Phaser phaser = new Phaser(1);\n        for (int index = 1; index <= 10; index++){\n            phaser.register();\n            new Thread(\n                    new Player(phaser), \n                    \"Player\" + index).start();\n        }\n        System.out.println(\"Game start\");\n        phaser.arriveAndDeregister();\n\n        while (!phaser.isTerminated()){\n            Thread.sleep(100);\n        }\n        System.out.println(\"Game over\");\n    }\n}\nclass Player implements Runnable{\n    private final Phaser phaser;\n    Player(Phaser phaser){\n        this.phaser = phaser;\n    }\n    @Override\n    public void run() {\n        //First step, waiting for all threads be created\n        phaser.arriveAndAwaitAdvance();\n\n        try {\n            //Second step, waiting for all players be ready\n            Thread.sleep(\n                    new Random().nextInt(100) * 10L);\n            System.out.println(\n                    Thread.currentThread().getName() + \" ready\");\n            phaser.arriveAndAwaitAdvance();\n\n            /////////////////running////////////////////\n\n            //Third step, waiting for all players arrived, then competition finishing.\n            System.out.println(\n                    Thread.currentThread().getName() + \" arrived\");\n            phaser.arriveAndDeregister();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**输出结果：**\n\n```\nGame start\nPlayer10 ready\nPlayer4 ready\nPlayer9 ready\nPlayer1 ready\nPlayer7 ready\nPlayer6 ready\nPlayer8 ready\nPlayer5 ready\nPlayer2 ready\nPlayer3 ready\nPlayer3 arrived\nPlayer5 arrived\nPlayer6 arrived\nPlayer1 arrived\nPlayer4 arrived\nPlayer7 arrived\nPlayer8 arrived\nPlayer9 arrived\nPlayer10 arrived\nPlayer2 arrived\nGame over\n```\n\n","source":"_posts/java-phaser.md","raw":"---\ntitle: Guide to the Java Phaser\ndate: 2018-11-08 18:43:24\ntags:\n    - java\n---\n\n> Java 7中新增了一个灵活的线程同步栅栏---**Phaser**，如果你需要在执行某些任务之前等待其他任务执行到某个状态，那么**Phaser**是一个很好的选择，这篇文章将介绍`java.util.concurrent.Phaser`，它和`CountDownLatch`具有相似的功能，但是**Phaser**更灵活。\n\n<!-- more -->\n\n### 基本术语\n\n在理解Phaser类的运行机制之前，我们先来了解Phaser类中的一些基本术语：\n\n* **Registration**\n\n  开篇我们讲过，Phaser比`CountDownLatch`和`CyclicBarrier`更灵活，因为它可以通过`register()`和`bulkRegister(int parties)`来动态调整注册任务的数量，任务也可以通过执行`arriveAndDeregister()`来注销任务，Phaser允许的最大任务注册数量为`65535`。\n\n* **Arrival**\n\n   正如Phaser类的名字所暗示，每个Phaser实例都会维护一个phase number，初始值为0。每当所有注册的任务都到达Phaser时，phase number累加，并在超过Integer.MAX_VALUE后清零。`arrive()`和`arriveAndDeregister()`方法用于记录到 达，`arriveAndAwaitAdvance()`方法用于记录到达，并且等待其它未到达的任务。\n\n* **Termination**\n\n   Phaser支持终止。Phaser终止之后，***调用`register()`和`bulkRegister(int parties)`方法没有任何效果***，`arriveAndAwaitAdvance()`方法也会立即返回。触发终止的时机是在`protected boolean onAdvance(int phase, int registeredParties)`方法返回时，如果该方法返回true，那么Phaser会被终止，默认实现是在注册任务数为0时返回true`（即 return registeredParties == 0;）`，我们也可以通过重写这个方法来自定义的终止逻辑。此外，`forceTermination()`方法用于强制终止，`isTerminated()`方法用于判断是否已经终止。\n\n* **Tiering**\n\n   Phaser支持层次结构，即通过构造函数`Phaser(Phaser parent)`和`Phaser(Phaser parent, int parties)`构造一个树形结构。这有助于减轻因在单个的Phaser上注册过多的任务而导致的竞争，从而提升吞吐量，代价是增加单个操作的开销。\n\n### 核心API\n\n* Phaser(int parties)，构造方法，与CountDownLatch一样，传入同步的线程数，也支持层次构造Phaser(Phaser parent)。\n\n* register()，bulkRegister(int Parties)，动态添加一个或多个参与者。\n\n* arriveAndDeregister()方法，动态撤销线程在phaser的注册，通知phaser对象，该线程已经结束该阶段且不参与后面阶段。\n\n* isTerminated()，当phaser没有参与同步的线程时（或者onAdvance返回true），phaser是终止态（如果phaser进入终止态arriveAndAwaitAdvance()和awaitAdvance()都会立即返回，不在等待）isTerminated返回true。\n\n* arrive()方法，通知phaser该线程已经完成该阶段，但不等待其他线程。\n\n* arriveAndAwaitAdvance()方法，类似await()方法，记录到达线程数，阻塞等待其他线程到达同步点后再继续执行。\n\n* awaitAdvance(int phase) /awaitAdvanceInterruptibly(int phase) 传入阶段数，只有当前阶段等于phase阶段时才阻塞等待。后者如果线程在休眠被中断会抛出InterruptedException异常（phaser的其他方法对中断都不会抛出异常）。\n\n* onAdvance(int phase, int registeredParties)方法。参数phase是阶段数，每经过一个阶段该数加1，registeredParties是当注册的线程数。此方法有2个作用：1、当每一个阶段执行完毕，此方法会被自动调用，因此，重载此方法写入的代码会在每个阶段执行完毕时执行，相当于CyclicBarrier的barrierAction。2、当此方法返回true时，意味着Phaser被终止，因此可以巧妙的设置此方法的返回值来终止所有线程。例如：若此方法返回值为 phase >= 3，其含义为当整个线程执行了3个阶段后，程序终止。\n\n* forceTermination()方法，强制phaser进入终止态。\n\n### 简单示例\n\n```java\n/**\n * @author Shuai Junlan[shuaijunlan@gmail.com].\n * @since Created in 2:26 PM 11/7/18.\n */\npublic class PhaserTest {\n    public static void main(String[] args) \n            throws InterruptedException {\n        final Phaser phaser = new Phaser(1);\n        for (int index = 1; index <= 10; index++){\n            phaser.register();\n            new Thread(\n                    new Player(phaser), \n                    \"Player\" + index).start();\n        }\n        System.out.println(\"Game start\");\n        phaser.arriveAndDeregister();\n\n        while (!phaser.isTerminated()){\n            Thread.sleep(100);\n        }\n        System.out.println(\"Game over\");\n    }\n}\nclass Player implements Runnable{\n    private final Phaser phaser;\n    Player(Phaser phaser){\n        this.phaser = phaser;\n    }\n    @Override\n    public void run() {\n        //First step, waiting for all threads be created\n        phaser.arriveAndAwaitAdvance();\n\n        try {\n            //Second step, waiting for all players be ready\n            Thread.sleep(\n                    new Random().nextInt(100) * 10L);\n            System.out.println(\n                    Thread.currentThread().getName() + \" ready\");\n            phaser.arriveAndAwaitAdvance();\n\n            /////////////////running////////////////////\n\n            //Third step, waiting for all players arrived, then competition finishing.\n            System.out.println(\n                    Thread.currentThread().getName() + \" arrived\");\n            phaser.arriveAndDeregister();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n**输出结果：**\n\n```\nGame start\nPlayer10 ready\nPlayer4 ready\nPlayer9 ready\nPlayer1 ready\nPlayer7 ready\nPlayer6 ready\nPlayer8 ready\nPlayer5 ready\nPlayer2 ready\nPlayer3 ready\nPlayer3 arrived\nPlayer5 arrived\nPlayer6 arrived\nPlayer1 arrived\nPlayer4 arrived\nPlayer7 arrived\nPlayer8 arrived\nPlayer9 arrived\nPlayer10 arrived\nPlayer2 arrived\nGame over\n```\n\n","slug":"java-phaser","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5m002qzjia1e0k5wpf","content":"<blockquote>\n<p>Java 7中新增了一个灵活的线程同步栅栏—<strong>Phaser</strong>，如果你需要在执行某些任务之前等待其他任务执行到某个状态，那么<strong>Phaser</strong>是一个很好的选择，这篇文章将介绍<code>java.util.concurrent.Phaser</code>，它和<code>CountDownLatch</code>具有相似的功能，但是<strong>Phaser</strong>更灵活。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"基本术语\"><a href=\"#基本术语\" class=\"headerlink\" title=\"基本术语\"></a>基本术语</h3><p>在理解Phaser类的运行机制之前，我们先来了解Phaser类中的一些基本术语：</p>\n<ul>\n<li><p><strong>Registration</strong></p>\n<p>开篇我们讲过，Phaser比<code>CountDownLatch</code>和<code>CyclicBarrier</code>更灵活，因为它可以通过<code>register()</code>和<code>bulkRegister(int parties)</code>来动态调整注册任务的数量，任务也可以通过执行<code>arriveAndDeregister()</code>来注销任务，Phaser允许的最大任务注册数量为<code>65535</code>。</p>\n</li>\n<li><p><strong>Arrival</strong></p>\n<p> 正如Phaser类的名字所暗示，每个Phaser实例都会维护一个phase number，初始值为0。每当所有注册的任务都到达Phaser时，phase number累加，并在超过Integer.MAX_VALUE后清零。<code>arrive()</code>和<code>arriveAndDeregister()</code>方法用于记录到 达，<code>arriveAndAwaitAdvance()</code>方法用于记录到达，并且等待其它未到达的任务。</p>\n</li>\n<li><p><strong>Termination</strong></p>\n<p> Phaser支持终止。Phaser终止之后，<strong><em>调用<code>register()</code>和<code>bulkRegister(int parties)</code>方法没有任何效果</em></strong>，<code>arriveAndAwaitAdvance()</code>方法也会立即返回。触发终止的时机是在<code>protected boolean onAdvance(int phase, int registeredParties)</code>方法返回时，如果该方法返回true，那么Phaser会被终止，默认实现是在注册任务数为0时返回true<code>（即 return registeredParties == 0;）</code>，我们也可以通过重写这个方法来自定义的终止逻辑。此外，<code>forceTermination()</code>方法用于强制终止，<code>isTerminated()</code>方法用于判断是否已经终止。</p>\n</li>\n<li><p><strong>Tiering</strong></p>\n<p> Phaser支持层次结构，即通过构造函数<code>Phaser(Phaser parent)</code>和<code>Phaser(Phaser parent, int parties)</code>构造一个树形结构。这有助于减轻因在单个的Phaser上注册过多的任务而导致的竞争，从而提升吞吐量，代价是增加单个操作的开销。</p>\n</li>\n</ul>\n<h3 id=\"核心API\"><a href=\"#核心API\" class=\"headerlink\" title=\"核心API\"></a>核心API</h3><ul>\n<li><p>Phaser(int parties)，构造方法，与CountDownLatch一样，传入同步的线程数，也支持层次构造Phaser(Phaser parent)。</p>\n</li>\n<li><p>register()，bulkRegister(int Parties)，动态添加一个或多个参与者。</p>\n</li>\n<li><p>arriveAndDeregister()方法，动态撤销线程在phaser的注册，通知phaser对象，该线程已经结束该阶段且不参与后面阶段。</p>\n</li>\n<li><p>isTerminated()，当phaser没有参与同步的线程时（或者onAdvance返回true），phaser是终止态（如果phaser进入终止态arriveAndAwaitAdvance()和awaitAdvance()都会立即返回，不在等待）isTerminated返回true。</p>\n</li>\n<li><p>arrive()方法，通知phaser该线程已经完成该阶段，但不等待其他线程。</p>\n</li>\n<li><p>arriveAndAwaitAdvance()方法，类似await()方法，记录到达线程数，阻塞等待其他线程到达同步点后再继续执行。</p>\n</li>\n<li><p>awaitAdvance(int phase) /awaitAdvanceInterruptibly(int phase) 传入阶段数，只有当前阶段等于phase阶段时才阻塞等待。后者如果线程在休眠被中断会抛出InterruptedException异常（phaser的其他方法对中断都不会抛出异常）。</p>\n</li>\n<li><p>onAdvance(int phase, int registeredParties)方法。参数phase是阶段数，每经过一个阶段该数加1，registeredParties是当注册的线程数。此方法有2个作用：1、当每一个阶段执行完毕，此方法会被自动调用，因此，重载此方法写入的代码会在每个阶段执行完毕时执行，相当于CyclicBarrier的barrierAction。2、当此方法返回true时，意味着Phaser被终止，因此可以巧妙的设置此方法的返回值来终止所有线程。例如：若此方法返回值为 phase &gt;= 3，其含义为当整个线程执行了3个阶段后，程序终止。</p>\n</li>\n<li><p>forceTermination()方法，强制phaser进入终止态。</p>\n</li>\n</ul>\n<h3 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Shuai Junlan[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> Created in 2:26 PM 11/7/18.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhaserTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Phaser phaser = <span class=\"keyword\">new</span> Phaser(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">1</span>; index &lt;= <span class=\"number\">10</span>; index++)&#123;</span><br><span class=\"line\">            phaser.register();</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> Player(phaser), </span><br><span class=\"line\">                    <span class=\"string\">\"Player\"</span> + index).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Game start\"</span>);</span><br><span class=\"line\">        phaser.arriveAndDeregister();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!phaser.isTerminated())&#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Game over\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Phaser phaser;</span><br><span class=\"line\">    Player(Phaser phaser)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.phaser = phaser;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//First step, waiting for all threads be created</span></span><br><span class=\"line\">        phaser.arriveAndAwaitAdvance();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//Second step, waiting for all players be ready</span></span><br><span class=\"line\">            Thread.sleep(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">100</span>) * <span class=\"number\">10L</span>);</span><br><span class=\"line\">            System.out.println(</span><br><span class=\"line\">                    Thread.currentThread().getName() + <span class=\"string\">\" ready\"</span>);</span><br><span class=\"line\">            phaser.arriveAndAwaitAdvance();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/////////////////running////////////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//Third step, waiting for all players arrived, then competition finishing.</span></span><br><span class=\"line\">            System.out.println(</span><br><span class=\"line\">                    Thread.currentThread().getName() + <span class=\"string\">\" arrived\"</span>);</span><br><span class=\"line\">            phaser.arriveAndDeregister();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Game start</span><br><span class=\"line\">Player10 ready</span><br><span class=\"line\">Player4 ready</span><br><span class=\"line\">Player9 ready</span><br><span class=\"line\">Player1 ready</span><br><span class=\"line\">Player7 ready</span><br><span class=\"line\">Player6 ready</span><br><span class=\"line\">Player8 ready</span><br><span class=\"line\">Player5 ready</span><br><span class=\"line\">Player2 ready</span><br><span class=\"line\">Player3 ready</span><br><span class=\"line\">Player3 arrived</span><br><span class=\"line\">Player5 arrived</span><br><span class=\"line\">Player6 arrived</span><br><span class=\"line\">Player1 arrived</span><br><span class=\"line\">Player4 arrived</span><br><span class=\"line\">Player7 arrived</span><br><span class=\"line\">Player8 arrived</span><br><span class=\"line\">Player9 arrived</span><br><span class=\"line\">Player10 arrived</span><br><span class=\"line\">Player2 arrived</span><br><span class=\"line\">Game over</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Java 7中新增了一个灵活的线程同步栅栏—<strong>Phaser</strong>，如果你需要在执行某些任务之前等待其他任务执行到某个状态，那么<strong>Phaser</strong>是一个很好的选择，这篇文章将介绍<code>java.util.concurrent.Phaser</code>，它和<code>CountDownLatch</code>具有相似的功能，但是<strong>Phaser</strong>更灵活。</p>\n</blockquote>","more":"<h3 id=\"基本术语\"><a href=\"#基本术语\" class=\"headerlink\" title=\"基本术语\"></a>基本术语</h3><p>在理解Phaser类的运行机制之前，我们先来了解Phaser类中的一些基本术语：</p>\n<ul>\n<li><p><strong>Registration</strong></p>\n<p>开篇我们讲过，Phaser比<code>CountDownLatch</code>和<code>CyclicBarrier</code>更灵活，因为它可以通过<code>register()</code>和<code>bulkRegister(int parties)</code>来动态调整注册任务的数量，任务也可以通过执行<code>arriveAndDeregister()</code>来注销任务，Phaser允许的最大任务注册数量为<code>65535</code>。</p>\n</li>\n<li><p><strong>Arrival</strong></p>\n<p> 正如Phaser类的名字所暗示，每个Phaser实例都会维护一个phase number，初始值为0。每当所有注册的任务都到达Phaser时，phase number累加，并在超过Integer.MAX_VALUE后清零。<code>arrive()</code>和<code>arriveAndDeregister()</code>方法用于记录到 达，<code>arriveAndAwaitAdvance()</code>方法用于记录到达，并且等待其它未到达的任务。</p>\n</li>\n<li><p><strong>Termination</strong></p>\n<p> Phaser支持终止。Phaser终止之后，<strong><em>调用<code>register()</code>和<code>bulkRegister(int parties)</code>方法没有任何效果</em></strong>，<code>arriveAndAwaitAdvance()</code>方法也会立即返回。触发终止的时机是在<code>protected boolean onAdvance(int phase, int registeredParties)</code>方法返回时，如果该方法返回true，那么Phaser会被终止，默认实现是在注册任务数为0时返回true<code>（即 return registeredParties == 0;）</code>，我们也可以通过重写这个方法来自定义的终止逻辑。此外，<code>forceTermination()</code>方法用于强制终止，<code>isTerminated()</code>方法用于判断是否已经终止。</p>\n</li>\n<li><p><strong>Tiering</strong></p>\n<p> Phaser支持层次结构，即通过构造函数<code>Phaser(Phaser parent)</code>和<code>Phaser(Phaser parent, int parties)</code>构造一个树形结构。这有助于减轻因在单个的Phaser上注册过多的任务而导致的竞争，从而提升吞吐量，代价是增加单个操作的开销。</p>\n</li>\n</ul>\n<h3 id=\"核心API\"><a href=\"#核心API\" class=\"headerlink\" title=\"核心API\"></a>核心API</h3><ul>\n<li><p>Phaser(int parties)，构造方法，与CountDownLatch一样，传入同步的线程数，也支持层次构造Phaser(Phaser parent)。</p>\n</li>\n<li><p>register()，bulkRegister(int Parties)，动态添加一个或多个参与者。</p>\n</li>\n<li><p>arriveAndDeregister()方法，动态撤销线程在phaser的注册，通知phaser对象，该线程已经结束该阶段且不参与后面阶段。</p>\n</li>\n<li><p>isTerminated()，当phaser没有参与同步的线程时（或者onAdvance返回true），phaser是终止态（如果phaser进入终止态arriveAndAwaitAdvance()和awaitAdvance()都会立即返回，不在等待）isTerminated返回true。</p>\n</li>\n<li><p>arrive()方法，通知phaser该线程已经完成该阶段，但不等待其他线程。</p>\n</li>\n<li><p>arriveAndAwaitAdvance()方法，类似await()方法，记录到达线程数，阻塞等待其他线程到达同步点后再继续执行。</p>\n</li>\n<li><p>awaitAdvance(int phase) /awaitAdvanceInterruptibly(int phase) 传入阶段数，只有当前阶段等于phase阶段时才阻塞等待。后者如果线程在休眠被中断会抛出InterruptedException异常（phaser的其他方法对中断都不会抛出异常）。</p>\n</li>\n<li><p>onAdvance(int phase, int registeredParties)方法。参数phase是阶段数，每经过一个阶段该数加1，registeredParties是当注册的线程数。此方法有2个作用：1、当每一个阶段执行完毕，此方法会被自动调用，因此，重载此方法写入的代码会在每个阶段执行完毕时执行，相当于CyclicBarrier的barrierAction。2、当此方法返回true时，意味着Phaser被终止，因此可以巧妙的设置此方法的返回值来终止所有线程。例如：若此方法返回值为 phase &gt;= 3，其含义为当整个线程执行了3个阶段后，程序终止。</p>\n</li>\n<li><p>forceTermination()方法，强制phaser进入终止态。</p>\n</li>\n</ul>\n<h3 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Shuai Junlan[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> Created in 2:26 PM 11/7/18.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhaserTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Phaser phaser = <span class=\"keyword\">new</span> Phaser(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">1</span>; index &lt;= <span class=\"number\">10</span>; index++)&#123;</span><br><span class=\"line\">            phaser.register();</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> Player(phaser), </span><br><span class=\"line\">                    <span class=\"string\">\"Player\"</span> + index).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Game start\"</span>);</span><br><span class=\"line\">        phaser.arriveAndDeregister();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!phaser.isTerminated())&#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Game over\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Phaser phaser;</span><br><span class=\"line\">    Player(Phaser phaser)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.phaser = phaser;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//First step, waiting for all threads be created</span></span><br><span class=\"line\">        phaser.arriveAndAwaitAdvance();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//Second step, waiting for all players be ready</span></span><br><span class=\"line\">            Thread.sleep(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> Random().nextInt(<span class=\"number\">100</span>) * <span class=\"number\">10L</span>);</span><br><span class=\"line\">            System.out.println(</span><br><span class=\"line\">                    Thread.currentThread().getName() + <span class=\"string\">\" ready\"</span>);</span><br><span class=\"line\">            phaser.arriveAndAwaitAdvance();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/////////////////running////////////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//Third step, waiting for all players arrived, then competition finishing.</span></span><br><span class=\"line\">            System.out.println(</span><br><span class=\"line\">                    Thread.currentThread().getName() + <span class=\"string\">\" arrived\"</span>);</span><br><span class=\"line\">            phaser.arriveAndDeregister();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>输出结果：</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Game start</span><br><span class=\"line\">Player10 ready</span><br><span class=\"line\">Player4 ready</span><br><span class=\"line\">Player9 ready</span><br><span class=\"line\">Player1 ready</span><br><span class=\"line\">Player7 ready</span><br><span class=\"line\">Player6 ready</span><br><span class=\"line\">Player8 ready</span><br><span class=\"line\">Player5 ready</span><br><span class=\"line\">Player2 ready</span><br><span class=\"line\">Player3 ready</span><br><span class=\"line\">Player3 arrived</span><br><span class=\"line\">Player5 arrived</span><br><span class=\"line\">Player6 arrived</span><br><span class=\"line\">Player1 arrived</span><br><span class=\"line\">Player4 arrived</span><br><span class=\"line\">Player7 arrived</span><br><span class=\"line\">Player8 arrived</span><br><span class=\"line\">Player9 arrived</span><br><span class=\"line\">Player10 arrived</span><br><span class=\"line\">Player2 arrived</span><br><span class=\"line\">Game over</span><br></pre></td></tr></table></figure>"},{"title":"Netty线程模型分析","date":"2018-06-26T02:07:15.000Z","_content":"\n","source":"_posts/netty-thread-model.md","raw":"---\ntitle: Netty线程模型分析\ndate: 2018-06-26 10:07:15\ntags:\n    - Netty\n---\n\n","slug":"netty-thread-model","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5n002tzjiaiuc9ed2m","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Netty内置传输方式","date":"2018-07-22T08:19:51.000Z","_content":"Netty中内置的传输方式主要包括：NIO、Epoll、OIO、Local和Embedded等方式，总结如下：\n\n\n| 名称     | 包名                             | 描述                                                         |\n| -------- | -------------------------------- | ------------------------------------------------------------ |\n| NIO      | io.netty.channel.socket.io       | 使用java.nio.channels包作为基础，基于选择器的方式            |\n| Epoll    | io.netty.channel.epoll           | 由JNI驱动的epoll()和非阻塞IO，这种传输只有Linux才支持，比NIO传输速度更快，而且是完全非阻塞的 |\n| OIO      | io.netty.channel.socket.oio      | 使用java.net包作为基础                                       |\n| Local    | io.netty.channel.local           | 可以在VM内部通过管道进行通信的本地传输                       |\n| Embedded | io.netty.channel.socket.embedded | Embedded 传输，允许使用 ChannelHandler 而又不需要一个真正的基于网络的传输，测试ChannelHandler实现的时候非常有用 |\n\n<!-- more -->\n\n### 基于NIO的传输\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-07-21 17-33-12.png)\n\n### Epoll---基于Linux的本地非阻塞传输\n\n在Linux内核版2.5.44之后就引入了epoll，提供了比旧的POSIX select和poll系统调用更好的性能。如何应用程序运行在Linux系统智商，则可以利用基于Epoll的方式传输，只需要在代码中将`NioEventLoopGroup`替换为`EpollEventLoopGroup`，并且将`NioServerSocketChannel.class`替换为`EpollServerSocketChannel.class`。或者用如下方式判断系统是否支持Epoll：\n\n```java\nEventLoopGroup workGroup = Epoll.isAvailable() ? new EpollEventLoopGroup(4) : new NioEventLoopGroup(4);\nBootstrap bootstrap = new Bootstrap();\nbootstrap.group(workGroup)\n        .channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class)\n        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000)\n        .handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                // Using Java Object serializable, you can also use other serializable frameworks like thrift, Protobuf and so on.\n                ch.pipeline()\n                        .addLast(new ObjectDecoder(1024*1024,\n                                ClassResolvers.weakCachingConcurrentResolver(this.getClass().getClassLoader())) )\n                        .addLast(new ObjectEncoder())\n                        .addLast(new SimpleChannelInboundHandler<Object>() {\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                                System.out.println(\"Receive msg: \" + msg);\n                            }\n                        });\n            }\n        });\n// Connect to the server sync\nchannel = bootstrap.connect(host, port).sync().channel();\n```\n\n### OIO---阻塞I/O\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-07-21 19-41-49.png)\n\n","source":"_posts/netty-transport-methods.md","raw":"---\ntitle: Netty内置传输方式\ndate: 2018-07-22 16:19:51\ntags:\n    - Netty\n---\nNetty中内置的传输方式主要包括：NIO、Epoll、OIO、Local和Embedded等方式，总结如下：\n\n\n| 名称     | 包名                             | 描述                                                         |\n| -------- | -------------------------------- | ------------------------------------------------------------ |\n| NIO      | io.netty.channel.socket.io       | 使用java.nio.channels包作为基础，基于选择器的方式            |\n| Epoll    | io.netty.channel.epoll           | 由JNI驱动的epoll()和非阻塞IO，这种传输只有Linux才支持，比NIO传输速度更快，而且是完全非阻塞的 |\n| OIO      | io.netty.channel.socket.oio      | 使用java.net包作为基础                                       |\n| Local    | io.netty.channel.local           | 可以在VM内部通过管道进行通信的本地传输                       |\n| Embedded | io.netty.channel.socket.embedded | Embedded 传输，允许使用 ChannelHandler 而又不需要一个真正的基于网络的传输，测试ChannelHandler实现的时候非常有用 |\n\n<!-- more -->\n\n### 基于NIO的传输\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-07-21 17-33-12.png)\n\n### Epoll---基于Linux的本地非阻塞传输\n\n在Linux内核版2.5.44之后就引入了epoll，提供了比旧的POSIX select和poll系统调用更好的性能。如何应用程序运行在Linux系统智商，则可以利用基于Epoll的方式传输，只需要在代码中将`NioEventLoopGroup`替换为`EpollEventLoopGroup`，并且将`NioServerSocketChannel.class`替换为`EpollServerSocketChannel.class`。或者用如下方式判断系统是否支持Epoll：\n\n```java\nEventLoopGroup workGroup = Epoll.isAvailable() ? new EpollEventLoopGroup(4) : new NioEventLoopGroup(4);\nBootstrap bootstrap = new Bootstrap();\nbootstrap.group(workGroup)\n        .channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class)\n        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000)\n        .handler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception {\n                // Using Java Object serializable, you can also use other serializable frameworks like thrift, Protobuf and so on.\n                ch.pipeline()\n                        .addLast(new ObjectDecoder(1024*1024,\n                                ClassResolvers.weakCachingConcurrentResolver(this.getClass().getClassLoader())) )\n                        .addLast(new ObjectEncoder())\n                        .addLast(new SimpleChannelInboundHandler<Object>() {\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {\n                                System.out.println(\"Receive msg: \" + msg);\n                            }\n                        });\n            }\n        });\n// Connect to the server sync\nchannel = bootstrap.connect(host, port).sync().channel();\n```\n\n### OIO---阻塞I/O\n\n![](https://shuaijunlan.github.io/images/Screenshot from 2018-07-21 19-41-49.png)\n\n","slug":"netty-transport-methods","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5n002vzjiati0ysslh","content":"<p>Netty中内置的传输方式主要包括：NIO、Epoll、OIO、Local和Embedded等方式，总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>包名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NIO</td>\n<td>io.netty.channel.socket.io</td>\n<td>使用java.nio.channels包作为基础，基于选择器的方式</td>\n</tr>\n<tr>\n<td>Epoll</td>\n<td>io.netty.channel.epoll</td>\n<td>由JNI驱动的epoll()和非阻塞IO，这种传输只有Linux才支持，比NIO传输速度更快，而且是完全非阻塞的</td>\n</tr>\n<tr>\n<td>OIO</td>\n<td>io.netty.channel.socket.oio</td>\n<td>使用java.net包作为基础</td>\n</tr>\n<tr>\n<td>Local</td>\n<td>io.netty.channel.local</td>\n<td>可以在VM内部通过管道进行通信的本地传输</td>\n</tr>\n<tr>\n<td>Embedded</td>\n<td>io.netty.channel.socket.embedded</td>\n<td>Embedded 传输，允许使用 ChannelHandler 而又不需要一个真正的基于网络的传输，测试ChannelHandler实现的时候非常有用</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h3 id=\"基于NIO的传输\"><a href=\"#基于NIO的传输\" class=\"headerlink\" title=\"基于NIO的传输\"></a>基于NIO的传输</h3><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-07-21 17-33-12.png\" alt=\"\"></p>\n<h3 id=\"Epoll—基于Linux的本地非阻塞传输\"><a href=\"#Epoll—基于Linux的本地非阻塞传输\" class=\"headerlink\" title=\"Epoll—基于Linux的本地非阻塞传输\"></a>Epoll—基于Linux的本地非阻塞传输</h3><p>在Linux内核版2.5.44之后就引入了epoll，提供了比旧的POSIX select和poll系统调用更好的性能。如何应用程序运行在Linux系统智商，则可以利用基于Epoll的方式传输，只需要在代码中将<code>NioEventLoopGroup</code>替换为<code>EpollEventLoopGroup</code>，并且将<code>NioServerSocketChannel.class</code>替换为<code>EpollServerSocketChannel.class</code>。或者用如下方式判断系统是否支持Epoll：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopGroup workGroup = Epoll.isAvailable() ? <span class=\"keyword\">new</span> EpollEventLoopGroup(<span class=\"number\">4</span>) : <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">4</span>);</span><br><span class=\"line\">Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">bootstrap.group(workGroup)</span><br><span class=\"line\">        .channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class)</span><br><span class=\"line\">        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class=\"number\">3000</span>)</span><br><span class=\"line\">        .handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// Using Java Object serializable, you can also use other serializable frameworks like thrift, Protobuf and so on.</span></span><br><span class=\"line\">                ch.pipeline()</span><br><span class=\"line\">                        .addLast(<span class=\"keyword\">new</span> ObjectDecoder(<span class=\"number\">1024</span>*<span class=\"number\">1024</span>,</span><br><span class=\"line\">                                ClassResolvers.weakCachingConcurrentResolver(<span class=\"keyword\">this</span>.getClass().getClassLoader())) )</span><br><span class=\"line\">                        .addLast(<span class=\"keyword\">new</span> ObjectEncoder())</span><br><span class=\"line\">                        .addLast(<span class=\"keyword\">new</span> SimpleChannelInboundHandler&lt;Object&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                System.out.println(<span class=\"string\">\"Receive msg: \"</span> + msg);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"><span class=\"comment\">// Connect to the server sync</span></span><br><span class=\"line\">channel = bootstrap.connect(host, port).sync().channel();</span><br></pre></td></tr></table></figure>\n<h3 id=\"OIO—阻塞I-O\"><a href=\"#OIO—阻塞I-O\" class=\"headerlink\" title=\"OIO—阻塞I/O\"></a>OIO—阻塞I/O</h3><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-07-21 19-41-49.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>Netty中内置的传输方式主要包括：NIO、Epoll、OIO、Local和Embedded等方式，总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>包名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NIO</td>\n<td>io.netty.channel.socket.io</td>\n<td>使用java.nio.channels包作为基础，基于选择器的方式</td>\n</tr>\n<tr>\n<td>Epoll</td>\n<td>io.netty.channel.epoll</td>\n<td>由JNI驱动的epoll()和非阻塞IO，这种传输只有Linux才支持，比NIO传输速度更快，而且是完全非阻塞的</td>\n</tr>\n<tr>\n<td>OIO</td>\n<td>io.netty.channel.socket.oio</td>\n<td>使用java.net包作为基础</td>\n</tr>\n<tr>\n<td>Local</td>\n<td>io.netty.channel.local</td>\n<td>可以在VM内部通过管道进行通信的本地传输</td>\n</tr>\n<tr>\n<td>Embedded</td>\n<td>io.netty.channel.socket.embedded</td>\n<td>Embedded 传输，允许使用 ChannelHandler 而又不需要一个真正的基于网络的传输，测试ChannelHandler实现的时候非常有用</td>\n</tr>\n</tbody>\n</table>","more":"<h3 id=\"基于NIO的传输\"><a href=\"#基于NIO的传输\" class=\"headerlink\" title=\"基于NIO的传输\"></a>基于NIO的传输</h3><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-07-21 17-33-12.png\" alt=\"\"></p>\n<h3 id=\"Epoll—基于Linux的本地非阻塞传输\"><a href=\"#Epoll—基于Linux的本地非阻塞传输\" class=\"headerlink\" title=\"Epoll—基于Linux的本地非阻塞传输\"></a>Epoll—基于Linux的本地非阻塞传输</h3><p>在Linux内核版2.5.44之后就引入了epoll，提供了比旧的POSIX select和poll系统调用更好的性能。如何应用程序运行在Linux系统智商，则可以利用基于Epoll的方式传输，只需要在代码中将<code>NioEventLoopGroup</code>替换为<code>EpollEventLoopGroup</code>，并且将<code>NioServerSocketChannel.class</code>替换为<code>EpollServerSocketChannel.class</code>。或者用如下方式判断系统是否支持Epoll：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventLoopGroup workGroup = Epoll.isAvailable() ? <span class=\"keyword\">new</span> EpollEventLoopGroup(<span class=\"number\">4</span>) : <span class=\"keyword\">new</span> NioEventLoopGroup(<span class=\"number\">4</span>);</span><br><span class=\"line\">Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap();</span><br><span class=\"line\">bootstrap.group(workGroup)</span><br><span class=\"line\">        .channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class)</span><br><span class=\"line\">        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class=\"number\">3000</span>)</span><br><span class=\"line\">        .handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(SocketChannel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// Using Java Object serializable, you can also use other serializable frameworks like thrift, Protobuf and so on.</span></span><br><span class=\"line\">                ch.pipeline()</span><br><span class=\"line\">                        .addLast(<span class=\"keyword\">new</span> ObjectDecoder(<span class=\"number\">1024</span>*<span class=\"number\">1024</span>,</span><br><span class=\"line\">                                ClassResolvers.weakCachingConcurrentResolver(<span class=\"keyword\">this</span>.getClass().getClassLoader())) )</span><br><span class=\"line\">                        .addLast(<span class=\"keyword\">new</span> ObjectEncoder())</span><br><span class=\"line\">                        .addLast(<span class=\"keyword\">new</span> SimpleChannelInboundHandler&lt;Object&gt;() &#123;</span><br><span class=\"line\">                            <span class=\"meta\">@Override</span></span><br><span class=\"line\">                            <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">channelRead0</span><span class=\"params\">(ChannelHandlerContext ctx, Object msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                                System.out.println(<span class=\"string\">\"Receive msg: \"</span> + msg);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"><span class=\"comment\">// Connect to the server sync</span></span><br><span class=\"line\">channel = bootstrap.connect(host, port).sync().channel();</span><br></pre></td></tr></table></figure>\n<h3 id=\"OIO—阻塞I-O\"><a href=\"#OIO—阻塞I-O\" class=\"headerlink\" title=\"OIO—阻塞I/O\"></a>OIO—阻塞I/O</h3><p><img src=\"https://shuaijunlan.github.io/images/Screenshot from 2018-07-21 19-41-49.png\" alt=\"\"></p>"},{"title":"基于Spring Cloud搭建微服务架构完整示例","date":"2018-07-25T02:18:35.000Z","_content":"\nddd\n\n\n\n","source":"_posts/spring-cloud-microservice-demo.md","raw":"---\ntitle: 基于Spring Cloud搭建微服务架构完整示例\ndate: 2018-07-25 10:18:35\ntags:\n    - Spring Cloud\n    - Micro Service\n---\n\nddd\n\n\n\n","slug":"spring-cloud-microservice-demo","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5o002yzjiatflgnrdz","content":"<p>ddd</p>\n","site":{"data":{}},"excerpt":"","more":"<p>ddd</p>\n"},{"title":"User Thread and Daemon Thread in Java","date":"2018-07-04T01:44:27.000Z","_content":"\n> 在Java当中有两种线程，一种是`User Thread`，另一种是`Daemon Thread`。一般来说`User Thread`具有较高的优先级，它主要运行在前台，然而，`Daemon Thread`具有较低的优先级，主要运行在后台。\n\n#### User Thread\n\nUser Thread通常由应用或者用户创建的，JVM Instance等待所有的User Thread执行完成Tasks，直到所有的User Thread执行完成JVM才会退出。\n\n#### Daemon Thread\n\nDaemon Thread通常由JVM创建， 这些线程在后台运行，运行一些后台任务（包括，垃圾回收、内务任务等）。JVM 不会等待所有的Daemon Thrad执行完Tasks，只要所有的User Thread执行完Tasks，JVM就会退出。\n\n<!-- more -->\n\n#### User Thread VS Daemon Thread In Java\n\n| **User Threads**                                             | **Daemon Threads**                                           |\n| ------------------------------------------------------------ | :----------------------------------------------------------- |\n| JVM waits for user threads to finish their work. It will not exit until all user threads finish their work. | JVM will not wait for daemon threads to finish their work. It will exit as soon as all user threads finish their work. |\n| User threads are foreground threads.                         | Daemon threads are background threads.                       |\n| User threads are high priority threads.                      | Daemon threads are low priority threads.                     |\n| User threads are created by the application.                 | Daemon threads, in most of time, are created by the JVM.     |\n| User threads are mainly designed to do some specific task.   | Daemon threads are designed to support the user threads.     |\n| JVM will not force the user threads to terminate. It will wait for user threads to terminate themselves. | JVM will force the daemon threads to terminate if all user threads have finished their work. |\n\n![user threads vs daemon threads](https://javaconceptoftheday.com/wp-content/uploads/2015/06/UserVsDaemon.png?x70034)\n\n#### Some Things-To-Remember about user threads and daemon threads In Java :\n\n- You can convert user thread into daemon thread explicitly by calling setDaemon() method of the thread.\n\n```java\npublic class ThreadsInJava {\n\n    //Main Thread\n    public static void main(String[] args) {\n        UserThread userThread = new UserThread();   //Creating the UserThread\n        userThread.setDaemon(true);        //Changing the thread as Daemon\n        userThread.start();               //Starting the thread\n    }\n}\n\nclass UserThread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"This is an user thread....\");\n        }\n    }\n}\n```\n\n- You can’t set a daemon property after starting the thread. If you try to set the daemon property when the thread is active, It will throw a IllegalThreadStateException at run time.\n\n```java\nclass UserThread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"This is an user thread....\");\n        }\n    }\n}\n\npublic class ThreadsInJava {\n    public static void main(String[] args) {\n        UserThread userThread = new UserThread();   //Creating the UserThread\n\n        userThread.start();               //Starting the thread\n\n        userThread.setDaemon(true);        //This statement will throw IllegalThreadStateException\n    }\n}\n```\n\n- You can check whether the thread is user thread or a daemon thread by using isDaemon() method of Thread class. This method returns “true” for a daemon thread and “false” for a user thread.\n\n```java\nclass UserThread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"This is an user thread....\");\n        }\n    }\n}\n\npublic class ThreadsInJava {\n    public static void main(String[] args) {\n        UserThread userThread = new UserThread();   //Creating the UserThread\n\n        System.out.println(userThread.isDaemon());    //Output : false\n\n        userThread.setDaemon(true);         //changing the thread as Daemon\n\n        userThread.start();                 //Starting the thread\n\n        System.out.println(userThread.isDaemon());      //Output : true\n    }\n}\n```\n\n- Daemon property of a thread is inherited from it’s parent thread. i.e The thread created by user thread will be user thread and the thread created by daemon thread will be a daemon thread.\n\n```java\nclass Thread1 extends Thread {\n    @Override\n    public void run() {\n        Thread t = new Thread();      //Creating a child thread\n\n        System.out.println(t.isDaemon());   //Checking the Daemon property of a child thread\n    }\n}\n\npublic class ThreadsInJava {\n    public static void main(String[] args) {\n        Thread1 t1 = new Thread1();   //Creating the Thread1\n\n        t1.start();                 //Starting the thread\n\n        Thread1 t2 = new Thread1();   //Creating the Thread1\n\n        t2.setDaemon(true);         //changing the thread as Daemon\n\n        t2.start();          //Starting the thread\n    }\n}\n```\n\n- **The main thread or primary thread created by JVM is an user thread.**\n\n- **Demonstration of User thread and daemon thread  :**  In the below program, The task of daemon thread will not be completed. Program terminates as soon as user thread finishes it’s task. It will not wait for daemon thread to finish it’s task.\n\n```java\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 10:32 AM 2018/07/06.\n */\nclass UserThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"This is a user thread.....\");\n    }\n}\n\nclass DaemonThread extends Thread {\n    public DaemonThread() {\n        setDaemon(true);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"This is daemon thread.....\" + i);\n        }\n    }\n}\n\npublic class ThreadsInJava {\n    public static void main(String[] args) {\n        DaemonThread daemon = new DaemonThread();   //Creating the DaemonThread\n\n        daemon.start();                 //Starting the daemon thread\n\n        UserThread userThread = new UserThread();   //Creating the UserThread\n\n        userThread.start();          //Starting the user thread\n    }\n}\n```\n\n#### Conclusion\n\n1) User threads are created by the **application** (user) to perform some specific task. Where as daemon threads are mostly created by the **JVM** to perform some background tasks like garbage collection.\n\n2) JVM will wait for user threads to finish their tasks. JVM will not exit until all user threads finish their tasks. On the other side, JVM will not wait for daemon threads to finish their tasks. It will exit as soon as all user threads finish their tasks.\n\n3) User threads are **high priority** threads, They are designed mainly to execute some important task in an application. Where as daemon threads are **less priority** threads. They are designed to serve the user threads.\n\n4) User threads are **foreground threads**. They always run in foreground and perform some specific task assigned to them. Where as daemon threads are **background threads**. They always run in background and act in a supporting role to user threads.\n\n5) JVM will not force the user threads to terminate. It will wait for user threads to terminate themselves. On the other hand, JVM will force the daemon threads to terminate if all the user threads have finished their task.\n\n6) User threads are chosen to do the core work of an application. The application is very much dependent on the user threads for it’s smooth execution. Where as daemon threads are chosen to do some supporting tasks. The application is less dependent on the daemon threads for it’s smooth running.\n\n#### REFERENCES\n\n* [Types Of Threads In Java](https://javaconceptoftheday.com/types-threads-java/)\n* [Difference Between User Threads Vs Daemon Threads In Java](https://javaconceptoftheday.com/difference-between-used-threads-vs-daemon-threads-in-java/)\n\n","source":"_posts/user-thread-and-daemon-thread.md","raw":"---\ntitle: User Thread and Daemon Thread in Java\ndate: 2018-07-04 09:44:27\ntags:\n    - java\n---\n\n> 在Java当中有两种线程，一种是`User Thread`，另一种是`Daemon Thread`。一般来说`User Thread`具有较高的优先级，它主要运行在前台，然而，`Daemon Thread`具有较低的优先级，主要运行在后台。\n\n#### User Thread\n\nUser Thread通常由应用或者用户创建的，JVM Instance等待所有的User Thread执行完成Tasks，直到所有的User Thread执行完成JVM才会退出。\n\n#### Daemon Thread\n\nDaemon Thread通常由JVM创建， 这些线程在后台运行，运行一些后台任务（包括，垃圾回收、内务任务等）。JVM 不会等待所有的Daemon Thrad执行完Tasks，只要所有的User Thread执行完Tasks，JVM就会退出。\n\n<!-- more -->\n\n#### User Thread VS Daemon Thread In Java\n\n| **User Threads**                                             | **Daemon Threads**                                           |\n| ------------------------------------------------------------ | :----------------------------------------------------------- |\n| JVM waits for user threads to finish their work. It will not exit until all user threads finish their work. | JVM will not wait for daemon threads to finish their work. It will exit as soon as all user threads finish their work. |\n| User threads are foreground threads.                         | Daemon threads are background threads.                       |\n| User threads are high priority threads.                      | Daemon threads are low priority threads.                     |\n| User threads are created by the application.                 | Daemon threads, in most of time, are created by the JVM.     |\n| User threads are mainly designed to do some specific task.   | Daemon threads are designed to support the user threads.     |\n| JVM will not force the user threads to terminate. It will wait for user threads to terminate themselves. | JVM will force the daemon threads to terminate if all user threads have finished their work. |\n\n![user threads vs daemon threads](https://javaconceptoftheday.com/wp-content/uploads/2015/06/UserVsDaemon.png?x70034)\n\n#### Some Things-To-Remember about user threads and daemon threads In Java :\n\n- You can convert user thread into daemon thread explicitly by calling setDaemon() method of the thread.\n\n```java\npublic class ThreadsInJava {\n\n    //Main Thread\n    public static void main(String[] args) {\n        UserThread userThread = new UserThread();   //Creating the UserThread\n        userThread.setDaemon(true);        //Changing the thread as Daemon\n        userThread.start();               //Starting the thread\n    }\n}\n\nclass UserThread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"This is an user thread....\");\n        }\n    }\n}\n```\n\n- You can’t set a daemon property after starting the thread. If you try to set the daemon property when the thread is active, It will throw a IllegalThreadStateException at run time.\n\n```java\nclass UserThread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"This is an user thread....\");\n        }\n    }\n}\n\npublic class ThreadsInJava {\n    public static void main(String[] args) {\n        UserThread userThread = new UserThread();   //Creating the UserThread\n\n        userThread.start();               //Starting the thread\n\n        userThread.setDaemon(true);        //This statement will throw IllegalThreadStateException\n    }\n}\n```\n\n- You can check whether the thread is user thread or a daemon thread by using isDaemon() method of Thread class. This method returns “true” for a daemon thread and “false” for a user thread.\n\n```java\nclass UserThread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"This is an user thread....\");\n        }\n    }\n}\n\npublic class ThreadsInJava {\n    public static void main(String[] args) {\n        UserThread userThread = new UserThread();   //Creating the UserThread\n\n        System.out.println(userThread.isDaemon());    //Output : false\n\n        userThread.setDaemon(true);         //changing the thread as Daemon\n\n        userThread.start();                 //Starting the thread\n\n        System.out.println(userThread.isDaemon());      //Output : true\n    }\n}\n```\n\n- Daemon property of a thread is inherited from it’s parent thread. i.e The thread created by user thread will be user thread and the thread created by daemon thread will be a daemon thread.\n\n```java\nclass Thread1 extends Thread {\n    @Override\n    public void run() {\n        Thread t = new Thread();      //Creating a child thread\n\n        System.out.println(t.isDaemon());   //Checking the Daemon property of a child thread\n    }\n}\n\npublic class ThreadsInJava {\n    public static void main(String[] args) {\n        Thread1 t1 = new Thread1();   //Creating the Thread1\n\n        t1.start();                 //Starting the thread\n\n        Thread1 t2 = new Thread1();   //Creating the Thread1\n\n        t2.setDaemon(true);         //changing the thread as Daemon\n\n        t2.start();          //Starting the thread\n    }\n}\n```\n\n- **The main thread or primary thread created by JVM is an user thread.**\n\n- **Demonstration of User thread and daemon thread  :**  In the below program, The task of daemon thread will not be completed. Program terminates as soon as user thread finishes it’s task. It will not wait for daemon thread to finish it’s task.\n\n```java\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 10:32 AM 2018/07/06.\n */\nclass UserThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"This is a user thread.....\");\n    }\n}\n\nclass DaemonThread extends Thread {\n    public DaemonThread() {\n        setDaemon(true);\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 1000; i++) {\n            System.out.println(\"This is daemon thread.....\" + i);\n        }\n    }\n}\n\npublic class ThreadsInJava {\n    public static void main(String[] args) {\n        DaemonThread daemon = new DaemonThread();   //Creating the DaemonThread\n\n        daemon.start();                 //Starting the daemon thread\n\n        UserThread userThread = new UserThread();   //Creating the UserThread\n\n        userThread.start();          //Starting the user thread\n    }\n}\n```\n\n#### Conclusion\n\n1) User threads are created by the **application** (user) to perform some specific task. Where as daemon threads are mostly created by the **JVM** to perform some background tasks like garbage collection.\n\n2) JVM will wait for user threads to finish their tasks. JVM will not exit until all user threads finish their tasks. On the other side, JVM will not wait for daemon threads to finish their tasks. It will exit as soon as all user threads finish their tasks.\n\n3) User threads are **high priority** threads, They are designed mainly to execute some important task in an application. Where as daemon threads are **less priority** threads. They are designed to serve the user threads.\n\n4) User threads are **foreground threads**. They always run in foreground and perform some specific task assigned to them. Where as daemon threads are **background threads**. They always run in background and act in a supporting role to user threads.\n\n5) JVM will not force the user threads to terminate. It will wait for user threads to terminate themselves. On the other hand, JVM will force the daemon threads to terminate if all the user threads have finished their task.\n\n6) User threads are chosen to do the core work of an application. The application is very much dependent on the user threads for it’s smooth execution. Where as daemon threads are chosen to do some supporting tasks. The application is less dependent on the daemon threads for it’s smooth running.\n\n#### REFERENCES\n\n* [Types Of Threads In Java](https://javaconceptoftheday.com/types-threads-java/)\n* [Difference Between User Threads Vs Daemon Threads In Java](https://javaconceptoftheday.com/difference-between-used-threads-vs-daemon-threads-in-java/)\n\n","slug":"user-thread-and-daemon-thread","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5p0030zjiaof5ly35u","content":"<blockquote>\n<p>在Java当中有两种线程，一种是<code>User Thread</code>，另一种是<code>Daemon Thread</code>。一般来说<code>User Thread</code>具有较高的优先级，它主要运行在前台，然而，<code>Daemon Thread</code>具有较低的优先级，主要运行在后台。</p>\n</blockquote>\n<h4 id=\"User-Thread\"><a href=\"#User-Thread\" class=\"headerlink\" title=\"User Thread\"></a>User Thread</h4><p>User Thread通常由应用或者用户创建的，JVM Instance等待所有的User Thread执行完成Tasks，直到所有的User Thread执行完成JVM才会退出。</p>\n<h4 id=\"Daemon-Thread\"><a href=\"#Daemon-Thread\" class=\"headerlink\" title=\"Daemon Thread\"></a>Daemon Thread</h4><p>Daemon Thread通常由JVM创建， 这些线程在后台运行，运行一些后台任务（包括，垃圾回收、内务任务等）。JVM 不会等待所有的Daemon Thrad执行完Tasks，只要所有的User Thread执行完Tasks，JVM就会退出。</p>\n<a id=\"more\"></a>\n<h4 id=\"User-Thread-VS-Daemon-Thread-In-Java\"><a href=\"#User-Thread-VS-Daemon-Thread-In-Java\" class=\"headerlink\" title=\"User Thread VS Daemon Thread In Java\"></a>User Thread VS Daemon Thread In Java</h4><table>\n<thead>\n<tr>\n<th><strong>User Threads</strong></th>\n<th style=\"text-align:left\"><strong>Daemon Threads</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JVM waits for user threads to finish their work. It will not exit until all user threads finish their work.</td>\n<td style=\"text-align:left\">JVM will not wait for daemon threads to finish their work. It will exit as soon as all user threads finish their work.</td>\n</tr>\n<tr>\n<td>User threads are foreground threads.</td>\n<td style=\"text-align:left\">Daemon threads are background threads.</td>\n</tr>\n<tr>\n<td>User threads are high priority threads.</td>\n<td style=\"text-align:left\">Daemon threads are low priority threads.</td>\n</tr>\n<tr>\n<td>User threads are created by the application.</td>\n<td style=\"text-align:left\">Daemon threads, in most of time, are created by the JVM.</td>\n</tr>\n<tr>\n<td>User threads are mainly designed to do some specific task.</td>\n<td style=\"text-align:left\">Daemon threads are designed to support the user threads.</td>\n</tr>\n<tr>\n<td>JVM will not force the user threads to terminate. It will wait for user threads to terminate themselves.</td>\n<td style=\"text-align:left\">JVM will force the daemon threads to terminate if all user threads have finished their work.</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://javaconceptoftheday.com/wp-content/uploads/2015/06/UserVsDaemon.png?x70034\" alt=\"user threads vs daemon threads\"></p>\n<h4 id=\"Some-Things-To-Remember-about-user-threads-and-daemon-threads-In-Java\"><a href=\"#Some-Things-To-Remember-about-user-threads-and-daemon-threads-In-Java\" class=\"headerlink\" title=\"Some Things-To-Remember about user threads and daemon threads In Java :\"></a>Some Things-To-Remember about user threads and daemon threads In Java :</h4><ul>\n<li>You can convert user thread into daemon thread explicitly by calling setDaemon() method of the thread.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadsInJava</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Main Thread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        UserThread userThread = <span class=\"keyword\">new</span> UserThread();   <span class=\"comment\">//Creating the UserThread</span></span><br><span class=\"line\">        userThread.setDaemon(<span class=\"keyword\">true</span>);        <span class=\"comment\">//Changing the thread as Daemon</span></span><br><span class=\"line\">        userThread.start();               <span class=\"comment\">//Starting the thread</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"This is an user thread....\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>You can’t set a daemon property after starting the thread. If you try to set the daemon property when the thread is active, It will throw a IllegalThreadStateException at run time.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"This is an user thread....\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadsInJava</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        UserThread userThread = <span class=\"keyword\">new</span> UserThread();   <span class=\"comment\">//Creating the UserThread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        userThread.start();               <span class=\"comment\">//Starting the thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        userThread.setDaemon(<span class=\"keyword\">true</span>);        <span class=\"comment\">//This statement will throw IllegalThreadStateException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>You can check whether the thread is user thread or a daemon thread by using isDaemon() method of Thread class. This method returns “true” for a daemon thread and “false” for a user thread.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"This is an user thread....\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadsInJava</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        UserThread userThread = <span class=\"keyword\">new</span> UserThread();   <span class=\"comment\">//Creating the UserThread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(userThread.isDaemon());    <span class=\"comment\">//Output : false</span></span><br><span class=\"line\"></span><br><span class=\"line\">        userThread.setDaemon(<span class=\"keyword\">true</span>);         <span class=\"comment\">//changing the thread as Daemon</span></span><br><span class=\"line\"></span><br><span class=\"line\">        userThread.start();                 <span class=\"comment\">//Starting the thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(userThread.isDaemon());      <span class=\"comment\">//Output : true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Daemon property of a thread is inherited from it’s parent thread. i.e The thread created by user thread will be user thread and the thread created by daemon thread will be a daemon thread.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread();      <span class=\"comment\">//Creating a child thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(t.isDaemon());   <span class=\"comment\">//Checking the Daemon property of a child thread</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadsInJava</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread1 t1 = <span class=\"keyword\">new</span> Thread1();   <span class=\"comment\">//Creating the Thread1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        t1.start();                 <span class=\"comment\">//Starting the thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Thread1 t2 = <span class=\"keyword\">new</span> Thread1();   <span class=\"comment\">//Creating the Thread1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        t2.setDaemon(<span class=\"keyword\">true</span>);         <span class=\"comment\">//changing the thread as Daemon</span></span><br><span class=\"line\"></span><br><span class=\"line\">        t2.start();          <span class=\"comment\">//Starting the thread</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>The main thread or primary thread created by JVM is an user thread.</strong></p>\n</li>\n<li><p><strong>Demonstration of User thread and daemon thread  :</strong>  In the below program, The task of daemon thread will not be completed. Program terminates as soon as user thread finishes it’s task. It will not wait for daemon thread to finish it’s task.</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 10:32 AM 2018/07/06.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"This is a user thread.....\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaemonThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DaemonThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"This is daemon thread.....\"</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadsInJava</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        DaemonThread daemon = <span class=\"keyword\">new</span> DaemonThread();   <span class=\"comment\">//Creating the DaemonThread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        daemon.start();                 <span class=\"comment\">//Starting the daemon thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        UserThread userThread = <span class=\"keyword\">new</span> UserThread();   <span class=\"comment\">//Creating the UserThread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        userThread.start();          <span class=\"comment\">//Starting the user thread</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h4><p>1) User threads are created by the <strong>application</strong> (user) to perform some specific task. Where as daemon threads are mostly created by the <strong>JVM</strong> to perform some background tasks like garbage collection.</p>\n<p>2) JVM will wait for user threads to finish their tasks. JVM will not exit until all user threads finish their tasks. On the other side, JVM will not wait for daemon threads to finish their tasks. It will exit as soon as all user threads finish their tasks.</p>\n<p>3) User threads are <strong>high priority</strong> threads, They are designed mainly to execute some important task in an application. Where as daemon threads are <strong>less priority</strong> threads. They are designed to serve the user threads.</p>\n<p>4) User threads are <strong>foreground threads</strong>. They always run in foreground and perform some specific task assigned to them. Where as daemon threads are <strong>background threads</strong>. They always run in background and act in a supporting role to user threads.</p>\n<p>5) JVM will not force the user threads to terminate. It will wait for user threads to terminate themselves. On the other hand, JVM will force the daemon threads to terminate if all the user threads have finished their task.</p>\n<p>6) User threads are chosen to do the core work of an application. The application is very much dependent on the user threads for it’s smooth execution. Where as daemon threads are chosen to do some supporting tasks. The application is less dependent on the daemon threads for it’s smooth running.</p>\n<h4 id=\"REFERENCES\"><a href=\"#REFERENCES\" class=\"headerlink\" title=\"REFERENCES\"></a>REFERENCES</h4><ul>\n<li><a href=\"https://javaconceptoftheday.com/types-threads-java/\" target=\"_blank\" rel=\"noopener\">Types Of Threads In Java</a></li>\n<li><a href=\"https://javaconceptoftheday.com/difference-between-used-threads-vs-daemon-threads-in-java/\" target=\"_blank\" rel=\"noopener\">Difference Between User Threads Vs Daemon Threads In Java</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在Java当中有两种线程，一种是<code>User Thread</code>，另一种是<code>Daemon Thread</code>。一般来说<code>User Thread</code>具有较高的优先级，它主要运行在前台，然而，<code>Daemon Thread</code>具有较低的优先级，主要运行在后台。</p>\n</blockquote>\n<h4 id=\"User-Thread\"><a href=\"#User-Thread\" class=\"headerlink\" title=\"User Thread\"></a>User Thread</h4><p>User Thread通常由应用或者用户创建的，JVM Instance等待所有的User Thread执行完成Tasks，直到所有的User Thread执行完成JVM才会退出。</p>\n<h4 id=\"Daemon-Thread\"><a href=\"#Daemon-Thread\" class=\"headerlink\" title=\"Daemon Thread\"></a>Daemon Thread</h4><p>Daemon Thread通常由JVM创建， 这些线程在后台运行，运行一些后台任务（包括，垃圾回收、内务任务等）。JVM 不会等待所有的Daemon Thrad执行完Tasks，只要所有的User Thread执行完Tasks，JVM就会退出。</p>","more":"<h4 id=\"User-Thread-VS-Daemon-Thread-In-Java\"><a href=\"#User-Thread-VS-Daemon-Thread-In-Java\" class=\"headerlink\" title=\"User Thread VS Daemon Thread In Java\"></a>User Thread VS Daemon Thread In Java</h4><table>\n<thead>\n<tr>\n<th><strong>User Threads</strong></th>\n<th style=\"text-align:left\"><strong>Daemon Threads</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>JVM waits for user threads to finish their work. It will not exit until all user threads finish their work.</td>\n<td style=\"text-align:left\">JVM will not wait for daemon threads to finish their work. It will exit as soon as all user threads finish their work.</td>\n</tr>\n<tr>\n<td>User threads are foreground threads.</td>\n<td style=\"text-align:left\">Daemon threads are background threads.</td>\n</tr>\n<tr>\n<td>User threads are high priority threads.</td>\n<td style=\"text-align:left\">Daemon threads are low priority threads.</td>\n</tr>\n<tr>\n<td>User threads are created by the application.</td>\n<td style=\"text-align:left\">Daemon threads, in most of time, are created by the JVM.</td>\n</tr>\n<tr>\n<td>User threads are mainly designed to do some specific task.</td>\n<td style=\"text-align:left\">Daemon threads are designed to support the user threads.</td>\n</tr>\n<tr>\n<td>JVM will not force the user threads to terminate. It will wait for user threads to terminate themselves.</td>\n<td style=\"text-align:left\">JVM will force the daemon threads to terminate if all user threads have finished their work.</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://javaconceptoftheday.com/wp-content/uploads/2015/06/UserVsDaemon.png?x70034\" alt=\"user threads vs daemon threads\"></p>\n<h4 id=\"Some-Things-To-Remember-about-user-threads-and-daemon-threads-In-Java\"><a href=\"#Some-Things-To-Remember-about-user-threads-and-daemon-threads-In-Java\" class=\"headerlink\" title=\"Some Things-To-Remember about user threads and daemon threads In Java :\"></a>Some Things-To-Remember about user threads and daemon threads In Java :</h4><ul>\n<li>You can convert user thread into daemon thread explicitly by calling setDaemon() method of the thread.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadsInJava</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Main Thread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        UserThread userThread = <span class=\"keyword\">new</span> UserThread();   <span class=\"comment\">//Creating the UserThread</span></span><br><span class=\"line\">        userThread.setDaemon(<span class=\"keyword\">true</span>);        <span class=\"comment\">//Changing the thread as Daemon</span></span><br><span class=\"line\">        userThread.start();               <span class=\"comment\">//Starting the thread</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"This is an user thread....\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>You can’t set a daemon property after starting the thread. If you try to set the daemon property when the thread is active, It will throw a IllegalThreadStateException at run time.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"This is an user thread....\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadsInJava</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        UserThread userThread = <span class=\"keyword\">new</span> UserThread();   <span class=\"comment\">//Creating the UserThread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        userThread.start();               <span class=\"comment\">//Starting the thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        userThread.setDaemon(<span class=\"keyword\">true</span>);        <span class=\"comment\">//This statement will throw IllegalThreadStateException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>You can check whether the thread is user thread or a daemon thread by using isDaemon() method of Thread class. This method returns “true” for a daemon thread and “false” for a user thread.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"This is an user thread....\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadsInJava</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        UserThread userThread = <span class=\"keyword\">new</span> UserThread();   <span class=\"comment\">//Creating the UserThread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(userThread.isDaemon());    <span class=\"comment\">//Output : false</span></span><br><span class=\"line\"></span><br><span class=\"line\">        userThread.setDaemon(<span class=\"keyword\">true</span>);         <span class=\"comment\">//changing the thread as Daemon</span></span><br><span class=\"line\"></span><br><span class=\"line\">        userThread.start();                 <span class=\"comment\">//Starting the thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(userThread.isDaemon());      <span class=\"comment\">//Output : true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Daemon property of a thread is inherited from it’s parent thread. i.e The thread created by user thread will be user thread and the thread created by daemon thread will be a daemon thread.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> Thread();      <span class=\"comment\">//Creating a child thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(t.isDaemon());   <span class=\"comment\">//Checking the Daemon property of a child thread</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadsInJava</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Thread1 t1 = <span class=\"keyword\">new</span> Thread1();   <span class=\"comment\">//Creating the Thread1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        t1.start();                 <span class=\"comment\">//Starting the thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Thread1 t2 = <span class=\"keyword\">new</span> Thread1();   <span class=\"comment\">//Creating the Thread1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        t2.setDaemon(<span class=\"keyword\">true</span>);         <span class=\"comment\">//changing the thread as Daemon</span></span><br><span class=\"line\"></span><br><span class=\"line\">        t2.start();          <span class=\"comment\">//Starting the thread</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>The main thread or primary thread created by JVM is an user thread.</strong></p>\n</li>\n<li><p><strong>Demonstration of User thread and daemon thread  :</strong>  In the below program, The task of daemon thread will not be completed. Program terminates as soon as user thread finishes it’s task. It will not wait for daemon thread to finish it’s task.</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 10:32 AM 2018/07/06.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"This is a user thread.....\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaemonThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DaemonThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        setDaemon(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"This is daemon thread.....\"</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadsInJava</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        DaemonThread daemon = <span class=\"keyword\">new</span> DaemonThread();   <span class=\"comment\">//Creating the DaemonThread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        daemon.start();                 <span class=\"comment\">//Starting the daemon thread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        UserThread userThread = <span class=\"keyword\">new</span> UserThread();   <span class=\"comment\">//Creating the UserThread</span></span><br><span class=\"line\"></span><br><span class=\"line\">        userThread.start();          <span class=\"comment\">//Starting the user thread</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h4><p>1) User threads are created by the <strong>application</strong> (user) to perform some specific task. Where as daemon threads are mostly created by the <strong>JVM</strong> to perform some background tasks like garbage collection.</p>\n<p>2) JVM will wait for user threads to finish their tasks. JVM will not exit until all user threads finish their tasks. On the other side, JVM will not wait for daemon threads to finish their tasks. It will exit as soon as all user threads finish their tasks.</p>\n<p>3) User threads are <strong>high priority</strong> threads, They are designed mainly to execute some important task in an application. Where as daemon threads are <strong>less priority</strong> threads. They are designed to serve the user threads.</p>\n<p>4) User threads are <strong>foreground threads</strong>. They always run in foreground and perform some specific task assigned to them. Where as daemon threads are <strong>background threads</strong>. They always run in background and act in a supporting role to user threads.</p>\n<p>5) JVM will not force the user threads to terminate. It will wait for user threads to terminate themselves. On the other hand, JVM will force the daemon threads to terminate if all the user threads have finished their task.</p>\n<p>6) User threads are chosen to do the core work of an application. The application is very much dependent on the user threads for it’s smooth execution. Where as daemon threads are chosen to do some supporting tasks. The application is less dependent on the daemon threads for it’s smooth running.</p>\n<h4 id=\"REFERENCES\"><a href=\"#REFERENCES\" class=\"headerlink\" title=\"REFERENCES\"></a>REFERENCES</h4><ul>\n<li><a href=\"https://javaconceptoftheday.com/types-threads-java/\" target=\"_blank\" rel=\"noopener\">Types Of Threads In Java</a></li>\n<li><a href=\"https://javaconceptoftheday.com/difference-between-used-threads-vs-daemon-threads-in-java/\" target=\"_blank\" rel=\"noopener\">Difference Between User Threads Vs Daemon Threads In Java</a></li>\n</ul>"},{"title":"CentOS7中配置KVM教程","date":"2016-11-20T02:07:15.000Z","_content":"\n> 基本环境：CentOS7.0\n\n1. [[root@localhost /]# ]()egrep '(vmx|svm)' /proc/cpuinfo  \n    > 和 Xen 不同，KVM 需要有 CPU 的支持（Intel VT 或 AMD SVM），在安装 KVM 之前检查一下 CPU 是否提供了虚拟技术的支持,可以通过下面命令查询是否支持，如果输出有相关的vmx或者svm，表明CPU支持，否则就不支持。\n\n<!-- more -->\n\n2. [[root@localhost /]# ]()yum install qemu-kvm qemu-img virt-manager libvirt libvirt-python python-virtinst libvirt-client virt-install virt-viewer\n\n    > kvm相关安装包及其作用（按需选择安装）\n    > * qemu-kvm：qemu模拟器,主要的KVM程序包\n    > * qemu-img：qemu磁盘image管理器\n    > * virt-install：基于libvirt服务的虚拟机创建命令，用来创建虚拟机的命令行工具\n    > * libvirt：提供libvirtd daemon来管理虚拟机和控制hypervisor\n    > * libvirt-client：提供客户端API用来访问server和提供管理虚拟机命令行工具的virsh实体\n    > * python-virtinst：创建虚拟机所需要的命令行工具和程序库\n    > * virt-manager：GUI虚拟机管理工具\n    > * virt-top：虚拟机统计命令\n    > * virt-viewer：GUI连接程序，连接到已配置好的虚拟机\n    > * bridge-utils：创建和管理桥接设备的工具\n\n3. 验证是否安装成功\n\n    * 验证内核模块是否加载\n        > [[root@localhost /]# ]()lsmod | grep kvm\n\n    * 启动服务(同时设置了开机自启)\n\n        > [[root@localhost /]# ]()systemctl start libvirtd.service\n\n    * 重启服务\n\n        > [[root@localhost /]# ]()systemctl restart libvirtd.service\n\n    * 设置可用\n\n        > [[root@localhost /]# ]()systemctl enable libvirtd.service\n\n    * 查看服务基本信息\n\n        > [[root@localhost /]# ]()systemctl status libvirtd.service\n\n    ![](http://learningnotes-1251679769.costj.myqcloud.com/virtual/6.png)\n\n3. 配置虚拟机网络\n\n    > 见<a href=\"http://www.blog.shuaijunlan.cn/2016/12/07/libvirt%20kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/\" target=\"\\_blank\">《libvirt kvm虚拟机网络配置》</a>一文\n\n4. 在CentOS上安装vnc服务，通过vnc客户端远程连接CentOS，通过图形化界面在宿主机上安装客户机，安装教程见《使用VNC工具初级教程》一文\n\n5. 最后安装客户机\n\n    > * 下载虚拟机要安装的ISO系统镜像文件，之后需创建存储池，指定在宿主机上虚拟机磁盘的存储位置，创建存储目录：(目录随便设定，按照自己的需求设定)\n        * [[root@localhost /]# ]()mkdir -p /home/kvm1\n\n    > * 定义一个储存池和绑定目录：\n        * [[root@localhost /]# ]()virsh pool-define-as vmspool --type dir --target /home/kvm1\n\n    > * 建立并激活存储池：\n        * [[root@localhost /]# ]()virsh pool-build vmspool\n        * [[root@localhost /]# ]()virsh pool-start vmspool\n\n    > * virsh-install:\n        * 1、输入虚拟机名称\n        * 2、分配多少内存\n        * 3、处理器的个数\n        * 4、此步可以直接输入iso的位置或是url\n        * 5、虚拟机类型KVM\n        * 6、定义虚拟机磁盘映像的位置\n        * 7、磁盘的大小\n        * 6、指定哪个桥或者可以指定多个桥\n        * 7、额外的控制台和KS文件\n        * 8、连接到系统参数\n        * 参数说明注意每行都要空格\n        * -n 虚拟机名称\n        * -r 分配虚拟机内存大小\n        * --vcpus 分配虚拟cpu个数\n        * -c 镜像文件位置\n        * --vnc --vncport=5901 --vnclisten=0.0.0.0 启动图形安装界面\n        * --virt-type 虚拟机模式\n        * -f 虚拟机系统文件存储目录\n        * -s 分配磁盘大小（GB）\n        * -w 联网方式（birdge bridge:br0/nat bridge:virbr0）\n        * --os-type='windows' --os-variant=win2k3 安装windows最好加上这个否则会报错\n        * virt-install工具安装虚拟机后，在目录/etc/libvirt/qemu/下生成xml配置文件\n        * -s 用来指定虚拟磁盘的大小单位为GB\n        * -m 指定虚拟网卡的硬件地址默认virt-install自动产生\n        * -p 以半虚拟化方式建立虚拟机\n        * -l 指定安装来源\n        * -x EXTRA, --extra-args=EXTRA当执行从\"--location\"选项指定位置的客户机安装时，附加内核命令行参数到安装程序。\n        * -v, --hvm 设置全虚拟化\n        </br>\n        </br>\n\n    > * 创建第一个guest：\n        * [[root@localhost /]# ]()virt-install --name=CentOS7-1 --ram=4096 --vcpus=1 --cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso --virt-type=kvm --disk  path=/home/kvm1/centos7-1.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=250 --graphics vnc,listen=0.0.0.0,port=5920,password=123456 --network bridge:br0 --accelerate --force --autostart\n\n    > * 创建第二个guest：\n        * [[root@localhost /]# ]()virt-install --name=CentOS7-2 --ram=7168 --vcpus=2,maxvcpus=4 --cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso --virt-type=kvm --disk  path=/home/kvm1/centos7-2.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 --graphics vnc,listen=0.0.0.0,port=5921,password=123456 --network bridge:br0 --accelerate --force --autostart\n\n    > * 创建第三个guest：\n        * [[root@localhost /]# ]()virt-install --name=CentOS7-3 --ram=7168 --vcpus=6,maxvcpus=9 --cpuset=6,7,8,9,10,11 --cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso --virt-type=kvm --disk  path=/home/kvm1/centos7-3.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 --graphics vnc,listen=0.0.0.0,port=5922,password=123456 --network bridge:br0 --accelerate --force --autostart\n\n    > * 创建第四个guest：\n        * [[root@localhost /]# ]()virt-install --name=CentOS7-4 --ram=7168 --vcpus=6,maxvcpus=9 --cpuset=12,13,14,15,16,17 --cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso --virt-type=kvm --disk  path=/home/kvm1/centos7-4.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 --graphics vnc,listen=0.0.0.0,port=5923,password=123456 --network bridge:br0 --accelerate --force --autostart\n\n#### 持续更新中......\n-----\n\n* REFERENCES\n\n    1. <a href=\"http://blog.csdn.net/chdhust/article/details/7931717\" target=\"\\_blank\">KVM虚拟机创建功能详细讲解</a>\n    2. <a href=\"http://blog.csdn.net/zhaihaifei/article/details/51163750\" target=\"\\_blank\">绑定KVM虚拟机的vcpu与物理CPU</a>\n    3. <a href=\"https://www.teakki.com/p/57dbd24a1b9882de17e7fd37\" target=\"\\_blank\">基于Linux命令行KVM虚拟机的安装配置与基本使用</a>\n    4. <a href=\"http://kulezhaizhuren.lofter.com/post/1cca7553_7e20b47\" target=\"\\_blank\">CENTOS7 安装KVM笔记之安装</a>\n    5. <a href=\"https://www.52os.net/articles/linux-kvm-install-virtual-machines.html\" target=\"\\_blank\">linux下配置和安装KVM虚拟机</a>\n","source":"_posts/CentOS7-kvm.md","raw":"---\ntitle: CentOS7中配置KVM教程\ndate: 2016-11-20 10:07:15\ntags:\n    - KVM\n    - CentOS\n---\n\n> 基本环境：CentOS7.0\n\n1. [[root@localhost /]# ]()egrep '(vmx|svm)' /proc/cpuinfo  \n    > 和 Xen 不同，KVM 需要有 CPU 的支持（Intel VT 或 AMD SVM），在安装 KVM 之前检查一下 CPU 是否提供了虚拟技术的支持,可以通过下面命令查询是否支持，如果输出有相关的vmx或者svm，表明CPU支持，否则就不支持。\n\n<!-- more -->\n\n2. [[root@localhost /]# ]()yum install qemu-kvm qemu-img virt-manager libvirt libvirt-python python-virtinst libvirt-client virt-install virt-viewer\n\n    > kvm相关安装包及其作用（按需选择安装）\n    > * qemu-kvm：qemu模拟器,主要的KVM程序包\n    > * qemu-img：qemu磁盘image管理器\n    > * virt-install：基于libvirt服务的虚拟机创建命令，用来创建虚拟机的命令行工具\n    > * libvirt：提供libvirtd daemon来管理虚拟机和控制hypervisor\n    > * libvirt-client：提供客户端API用来访问server和提供管理虚拟机命令行工具的virsh实体\n    > * python-virtinst：创建虚拟机所需要的命令行工具和程序库\n    > * virt-manager：GUI虚拟机管理工具\n    > * virt-top：虚拟机统计命令\n    > * virt-viewer：GUI连接程序，连接到已配置好的虚拟机\n    > * bridge-utils：创建和管理桥接设备的工具\n\n3. 验证是否安装成功\n\n    * 验证内核模块是否加载\n        > [[root@localhost /]# ]()lsmod | grep kvm\n\n    * 启动服务(同时设置了开机自启)\n\n        > [[root@localhost /]# ]()systemctl start libvirtd.service\n\n    * 重启服务\n\n        > [[root@localhost /]# ]()systemctl restart libvirtd.service\n\n    * 设置可用\n\n        > [[root@localhost /]# ]()systemctl enable libvirtd.service\n\n    * 查看服务基本信息\n\n        > [[root@localhost /]# ]()systemctl status libvirtd.service\n\n    ![](http://learningnotes-1251679769.costj.myqcloud.com/virtual/6.png)\n\n3. 配置虚拟机网络\n\n    > 见<a href=\"http://www.blog.shuaijunlan.cn/2016/12/07/libvirt%20kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/\" target=\"\\_blank\">《libvirt kvm虚拟机网络配置》</a>一文\n\n4. 在CentOS上安装vnc服务，通过vnc客户端远程连接CentOS，通过图形化界面在宿主机上安装客户机，安装教程见《使用VNC工具初级教程》一文\n\n5. 最后安装客户机\n\n    > * 下载虚拟机要安装的ISO系统镜像文件，之后需创建存储池，指定在宿主机上虚拟机磁盘的存储位置，创建存储目录：(目录随便设定，按照自己的需求设定)\n        * [[root@localhost /]# ]()mkdir -p /home/kvm1\n\n    > * 定义一个储存池和绑定目录：\n        * [[root@localhost /]# ]()virsh pool-define-as vmspool --type dir --target /home/kvm1\n\n    > * 建立并激活存储池：\n        * [[root@localhost /]# ]()virsh pool-build vmspool\n        * [[root@localhost /]# ]()virsh pool-start vmspool\n\n    > * virsh-install:\n        * 1、输入虚拟机名称\n        * 2、分配多少内存\n        * 3、处理器的个数\n        * 4、此步可以直接输入iso的位置或是url\n        * 5、虚拟机类型KVM\n        * 6、定义虚拟机磁盘映像的位置\n        * 7、磁盘的大小\n        * 6、指定哪个桥或者可以指定多个桥\n        * 7、额外的控制台和KS文件\n        * 8、连接到系统参数\n        * 参数说明注意每行都要空格\n        * -n 虚拟机名称\n        * -r 分配虚拟机内存大小\n        * --vcpus 分配虚拟cpu个数\n        * -c 镜像文件位置\n        * --vnc --vncport=5901 --vnclisten=0.0.0.0 启动图形安装界面\n        * --virt-type 虚拟机模式\n        * -f 虚拟机系统文件存储目录\n        * -s 分配磁盘大小（GB）\n        * -w 联网方式（birdge bridge:br0/nat bridge:virbr0）\n        * --os-type='windows' --os-variant=win2k3 安装windows最好加上这个否则会报错\n        * virt-install工具安装虚拟机后，在目录/etc/libvirt/qemu/下生成xml配置文件\n        * -s 用来指定虚拟磁盘的大小单位为GB\n        * -m 指定虚拟网卡的硬件地址默认virt-install自动产生\n        * -p 以半虚拟化方式建立虚拟机\n        * -l 指定安装来源\n        * -x EXTRA, --extra-args=EXTRA当执行从\"--location\"选项指定位置的客户机安装时，附加内核命令行参数到安装程序。\n        * -v, --hvm 设置全虚拟化\n        </br>\n        </br>\n\n    > * 创建第一个guest：\n        * [[root@localhost /]# ]()virt-install --name=CentOS7-1 --ram=4096 --vcpus=1 --cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso --virt-type=kvm --disk  path=/home/kvm1/centos7-1.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=250 --graphics vnc,listen=0.0.0.0,port=5920,password=123456 --network bridge:br0 --accelerate --force --autostart\n\n    > * 创建第二个guest：\n        * [[root@localhost /]# ]()virt-install --name=CentOS7-2 --ram=7168 --vcpus=2,maxvcpus=4 --cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso --virt-type=kvm --disk  path=/home/kvm1/centos7-2.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 --graphics vnc,listen=0.0.0.0,port=5921,password=123456 --network bridge:br0 --accelerate --force --autostart\n\n    > * 创建第三个guest：\n        * [[root@localhost /]# ]()virt-install --name=CentOS7-3 --ram=7168 --vcpus=6,maxvcpus=9 --cpuset=6,7,8,9,10,11 --cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso --virt-type=kvm --disk  path=/home/kvm1/centos7-3.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 --graphics vnc,listen=0.0.0.0,port=5922,password=123456 --network bridge:br0 --accelerate --force --autostart\n\n    > * 创建第四个guest：\n        * [[root@localhost /]# ]()virt-install --name=CentOS7-4 --ram=7168 --vcpus=6,maxvcpus=9 --cpuset=12,13,14,15,16,17 --cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso --virt-type=kvm --disk  path=/home/kvm1/centos7-4.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 --graphics vnc,listen=0.0.0.0,port=5923,password=123456 --network bridge:br0 --accelerate --force --autostart\n\n#### 持续更新中......\n-----\n\n* REFERENCES\n\n    1. <a href=\"http://blog.csdn.net/chdhust/article/details/7931717\" target=\"\\_blank\">KVM虚拟机创建功能详细讲解</a>\n    2. <a href=\"http://blog.csdn.net/zhaihaifei/article/details/51163750\" target=\"\\_blank\">绑定KVM虚拟机的vcpu与物理CPU</a>\n    3. <a href=\"https://www.teakki.com/p/57dbd24a1b9882de17e7fd37\" target=\"\\_blank\">基于Linux命令行KVM虚拟机的安装配置与基本使用</a>\n    4. <a href=\"http://kulezhaizhuren.lofter.com/post/1cca7553_7e20b47\" target=\"\\_blank\">CENTOS7 安装KVM笔记之安装</a>\n    5. <a href=\"https://www.52os.net/articles/linux-kvm-install-virtual-machines.html\" target=\"\\_blank\">linux下配置和安装KVM虚拟机</a>\n","slug":"CentOS7-kvm","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5q0032zjia6g5felp5","content":"<blockquote>\n<p>基本环境：CentOS7.0</p>\n</blockquote>\n<ol>\n<li><a href=\"\">[root@localhost /]# </a>egrep ‘(vmx|svm)’ /proc/cpuinfo  <blockquote>\n<p>和 Xen 不同，KVM 需要有 CPU 的支持（Intel VT 或 AMD SVM），在安装 KVM 之前检查一下 CPU 是否提供了虚拟技术的支持,可以通过下面命令查询是否支持，如果输出有相关的vmx或者svm，表明CPU支持，否则就不支持。</p>\n</blockquote>\n</li>\n</ol>\n<a id=\"more\"></a>\n<ol>\n<li><p><a href=\"\">[root@localhost /]# </a>yum install qemu-kvm qemu-img virt-manager libvirt libvirt-python python-virtinst libvirt-client virt-install virt-viewer</p>\n<blockquote>\n<p>kvm相关安装包及其作用（按需选择安装）</p>\n<ul>\n<li>qemu-kvm：qemu模拟器,主要的KVM程序包</li>\n<li>qemu-img：qemu磁盘image管理器</li>\n<li>virt-install：基于libvirt服务的虚拟机创建命令，用来创建虚拟机的命令行工具</li>\n<li>libvirt：提供libvirtd daemon来管理虚拟机和控制hypervisor</li>\n<li>libvirt-client：提供客户端API用来访问server和提供管理虚拟机命令行工具的virsh实体</li>\n<li>python-virtinst：创建虚拟机所需要的命令行工具和程序库</li>\n<li>virt-manager：GUI虚拟机管理工具</li>\n<li>virt-top：虚拟机统计命令</li>\n<li>virt-viewer：GUI连接程序，连接到已配置好的虚拟机</li>\n<li>bridge-utils：创建和管理桥接设备的工具</li>\n</ul>\n</blockquote>\n</li>\n<li><p>验证是否安装成功</p>\n<ul>\n<li><p>验证内核模块是否加载</p>\n<blockquote>\n<p><a href=\"\">[root@localhost /]# </a>lsmod | grep kvm</p>\n</blockquote>\n</li>\n<li><p>启动服务(同时设置了开机自启)</p>\n<blockquote>\n<p><a href=\"\">[root@localhost /]# </a>systemctl start libvirtd.service</p>\n</blockquote>\n</li>\n<li><p>重启服务</p>\n<blockquote>\n<p><a href=\"\">[root@localhost /]# </a>systemctl restart libvirtd.service</p>\n</blockquote>\n</li>\n<li><p>设置可用</p>\n<blockquote>\n<p><a href=\"\">[root@localhost /]# </a>systemctl enable libvirtd.service</p>\n</blockquote>\n</li>\n<li><p>查看服务基本信息</p>\n<blockquote>\n<p><a href=\"\">[root@localhost /]# </a>systemctl status libvirtd.service</p>\n</blockquote>\n<p><img src=\"http://learningnotes-1251679769.costj.myqcloud.com/virtual/6.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li><p>配置虚拟机网络</p>\n<blockquote>\n<p>见<a href=\"http://www.blog.shuaijunlan.cn/2016/12/07/libvirt%20kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/\" target=\"\\_blank\">《libvirt kvm虚拟机网络配置》</a>一文</p>\n</blockquote>\n</li>\n<li><p>在CentOS上安装vnc服务，通过vnc客户端远程连接CentOS，通过图形化界面在宿主机上安装客户机，安装教程见《使用VNC工具初级教程》一文</p>\n</li>\n<li><p>最后安装客户机</p>\n<blockquote>\n<ul>\n<li><p>下载虚拟机要安装的ISO系统镜像文件，之后需创建存储池，指定在宿主机上虚拟机磁盘的存储位置，创建存储目录：(目录随便设定，按照自己的需求设定)</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>mkdir -p /home/kvm1</li>\n</ul>\n</li>\n<li><p>定义一个储存池和绑定目录：</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>virsh pool-define-as vmspool –type dir –target /home/kvm1</li>\n</ul>\n</li>\n<li><p>建立并激活存储池：</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>virsh pool-build vmspool</li>\n<li><a href=\"\">[root@localhost /]# </a>virsh pool-start vmspool</li>\n</ul>\n</li>\n<li><p>virsh-install:</p>\n<ul>\n<li>1、输入虚拟机名称</li>\n<li>2、分配多少内存</li>\n<li>3、处理器的个数</li>\n<li>4、此步可以直接输入iso的位置或是url</li>\n<li>5、虚拟机类型KVM</li>\n<li>6、定义虚拟机磁盘映像的位置</li>\n<li>7、磁盘的大小</li>\n<li>6、指定哪个桥或者可以指定多个桥</li>\n<li>7、额外的控制台和KS文件</li>\n<li>8、连接到系统参数</li>\n<li>参数说明注意每行都要空格</li>\n<li>-n 虚拟机名称</li>\n<li>-r 分配虚拟机内存大小</li>\n<li>–vcpus 分配虚拟cpu个数</li>\n<li>-c 镜像文件位置</li>\n<li>–vnc –vncport=5901 –vnclisten=0.0.0.0 启动图形安装界面</li>\n<li>–virt-type 虚拟机模式</li>\n<li>-f 虚拟机系统文件存储目录</li>\n<li>-s 分配磁盘大小（GB）</li>\n<li>-w 联网方式（birdge bridge:br0/nat bridge:virbr0）</li>\n<li>–os-type=’windows’ –os-variant=win2k3 安装windows最好加上这个否则会报错</li>\n<li>virt-install工具安装虚拟机后，在目录/etc/libvirt/qemu/下生成xml配置文件</li>\n<li>-s 用来指定虚拟磁盘的大小单位为GB</li>\n<li>-m 指定虚拟网卡的硬件地址默认virt-install自动产生</li>\n<li>-p 以半虚拟化方式建立虚拟机</li>\n<li>-l 指定安装来源</li>\n<li>-x EXTRA, –extra-args=EXTRA当执行从”–location”选项指定位置的客户机安装时，附加内核命令行参数到安装程序。</li>\n<li>-v, –hvm 设置全虚拟化<br><br><br><br></li>\n</ul>\n</li>\n<li><p>创建第一个guest：</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>virt-install –name=CentOS7-1 –ram=4096 –vcpus=1 –cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso –virt-type=kvm –disk  path=/home/kvm1/centos7-1.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=250 –graphics vnc,listen=0.0.0.0,port=5920,password=123456 –network bridge:br0 –accelerate –force –autostart</li>\n</ul>\n</li>\n<li><p>创建第二个guest：</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>virt-install –name=CentOS7-2 –ram=7168 –vcpus=2,maxvcpus=4 –cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso –virt-type=kvm –disk  path=/home/kvm1/centos7-2.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 –graphics vnc,listen=0.0.0.0,port=5921,password=123456 –network bridge:br0 –accelerate –force –autostart</li>\n</ul>\n</li>\n<li><p>创建第三个guest：</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>virt-install –name=CentOS7-3 –ram=7168 –vcpus=6,maxvcpus=9 –cpuset=6,7,8,9,10,11 –cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso –virt-type=kvm –disk  path=/home/kvm1/centos7-3.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 –graphics vnc,listen=0.0.0.0,port=5922,password=123456 –network bridge:br0 –accelerate –force –autostart</li>\n</ul>\n</li>\n<li><p>创建第四个guest：</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>virt-install –name=CentOS7-4 –ram=7168 –vcpus=6,maxvcpus=9 –cpuset=12,13,14,15,16,17 –cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso –virt-type=kvm –disk  path=/home/kvm1/centos7-4.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 –graphics vnc,listen=0.0.0.0,port=5923,password=123456 –network bridge:br0 –accelerate –force –autostart</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"持续更新中……\"><a href=\"#持续更新中……\" class=\"headerlink\" title=\"持续更新中……\"></a>持续更新中……</h4><hr>\n<ul>\n<li><p>REFERENCES</p>\n<ol>\n<li><a href=\"http://blog.csdn.net/chdhust/article/details/7931717\" target=\"\\_blank\">KVM虚拟机创建功能详细讲解</a></li>\n<li><a href=\"http://blog.csdn.net/zhaihaifei/article/details/51163750\" target=\"\\_blank\">绑定KVM虚拟机的vcpu与物理CPU</a></li>\n<li><a href=\"https://www.teakki.com/p/57dbd24a1b9882de17e7fd37\" target=\"\\_blank\">基于Linux命令行KVM虚拟机的安装配置与基本使用</a></li>\n<li><a href=\"http://kulezhaizhuren.lofter.com/post/1cca7553_7e20b47\" target=\"\\_blank\">CENTOS7 安装KVM笔记之安装</a></li>\n<li><a href=\"https://www.52os.net/articles/linux-kvm-install-virtual-machines.html\" target=\"\\_blank\">linux下配置和安装KVM虚拟机</a></li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>基本环境：CentOS7.0</p>\n</blockquote>\n<ol>\n<li><a href=\"\">[root@localhost /]# </a>egrep ‘(vmx|svm)’ /proc/cpuinfo  <blockquote>\n<p>和 Xen 不同，KVM 需要有 CPU 的支持（Intel VT 或 AMD SVM），在安装 KVM 之前检查一下 CPU 是否提供了虚拟技术的支持,可以通过下面命令查询是否支持，如果输出有相关的vmx或者svm，表明CPU支持，否则就不支持。</p>\n</blockquote>\n</li>\n</ol>","more":"<ol>\n<li><p><a href=\"\">[root@localhost /]# </a>yum install qemu-kvm qemu-img virt-manager libvirt libvirt-python python-virtinst libvirt-client virt-install virt-viewer</p>\n<blockquote>\n<p>kvm相关安装包及其作用（按需选择安装）</p>\n<ul>\n<li>qemu-kvm：qemu模拟器,主要的KVM程序包</li>\n<li>qemu-img：qemu磁盘image管理器</li>\n<li>virt-install：基于libvirt服务的虚拟机创建命令，用来创建虚拟机的命令行工具</li>\n<li>libvirt：提供libvirtd daemon来管理虚拟机和控制hypervisor</li>\n<li>libvirt-client：提供客户端API用来访问server和提供管理虚拟机命令行工具的virsh实体</li>\n<li>python-virtinst：创建虚拟机所需要的命令行工具和程序库</li>\n<li>virt-manager：GUI虚拟机管理工具</li>\n<li>virt-top：虚拟机统计命令</li>\n<li>virt-viewer：GUI连接程序，连接到已配置好的虚拟机</li>\n<li>bridge-utils：创建和管理桥接设备的工具</li>\n</ul>\n</blockquote>\n</li>\n<li><p>验证是否安装成功</p>\n<ul>\n<li><p>验证内核模块是否加载</p>\n<blockquote>\n<p><a href=\"\">[root@localhost /]# </a>lsmod | grep kvm</p>\n</blockquote>\n</li>\n<li><p>启动服务(同时设置了开机自启)</p>\n<blockquote>\n<p><a href=\"\">[root@localhost /]# </a>systemctl start libvirtd.service</p>\n</blockquote>\n</li>\n<li><p>重启服务</p>\n<blockquote>\n<p><a href=\"\">[root@localhost /]# </a>systemctl restart libvirtd.service</p>\n</blockquote>\n</li>\n<li><p>设置可用</p>\n<blockquote>\n<p><a href=\"\">[root@localhost /]# </a>systemctl enable libvirtd.service</p>\n</blockquote>\n</li>\n<li><p>查看服务基本信息</p>\n<blockquote>\n<p><a href=\"\">[root@localhost /]# </a>systemctl status libvirtd.service</p>\n</blockquote>\n<p><img src=\"http://learningnotes-1251679769.costj.myqcloud.com/virtual/6.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li><p>配置虚拟机网络</p>\n<blockquote>\n<p>见<a href=\"http://www.blog.shuaijunlan.cn/2016/12/07/libvirt%20kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/\" target=\"\\_blank\">《libvirt kvm虚拟机网络配置》</a>一文</p>\n</blockquote>\n</li>\n<li><p>在CentOS上安装vnc服务，通过vnc客户端远程连接CentOS，通过图形化界面在宿主机上安装客户机，安装教程见《使用VNC工具初级教程》一文</p>\n</li>\n<li><p>最后安装客户机</p>\n<blockquote>\n<ul>\n<li><p>下载虚拟机要安装的ISO系统镜像文件，之后需创建存储池，指定在宿主机上虚拟机磁盘的存储位置，创建存储目录：(目录随便设定，按照自己的需求设定)</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>mkdir -p /home/kvm1</li>\n</ul>\n</li>\n<li><p>定义一个储存池和绑定目录：</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>virsh pool-define-as vmspool –type dir –target /home/kvm1</li>\n</ul>\n</li>\n<li><p>建立并激活存储池：</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>virsh pool-build vmspool</li>\n<li><a href=\"\">[root@localhost /]# </a>virsh pool-start vmspool</li>\n</ul>\n</li>\n<li><p>virsh-install:</p>\n<ul>\n<li>1、输入虚拟机名称</li>\n<li>2、分配多少内存</li>\n<li>3、处理器的个数</li>\n<li>4、此步可以直接输入iso的位置或是url</li>\n<li>5、虚拟机类型KVM</li>\n<li>6、定义虚拟机磁盘映像的位置</li>\n<li>7、磁盘的大小</li>\n<li>6、指定哪个桥或者可以指定多个桥</li>\n<li>7、额外的控制台和KS文件</li>\n<li>8、连接到系统参数</li>\n<li>参数说明注意每行都要空格</li>\n<li>-n 虚拟机名称</li>\n<li>-r 分配虚拟机内存大小</li>\n<li>–vcpus 分配虚拟cpu个数</li>\n<li>-c 镜像文件位置</li>\n<li>–vnc –vncport=5901 –vnclisten=0.0.0.0 启动图形安装界面</li>\n<li>–virt-type 虚拟机模式</li>\n<li>-f 虚拟机系统文件存储目录</li>\n<li>-s 分配磁盘大小（GB）</li>\n<li>-w 联网方式（birdge bridge:br0/nat bridge:virbr0）</li>\n<li>–os-type=’windows’ –os-variant=win2k3 安装windows最好加上这个否则会报错</li>\n<li>virt-install工具安装虚拟机后，在目录/etc/libvirt/qemu/下生成xml配置文件</li>\n<li>-s 用来指定虚拟磁盘的大小单位为GB</li>\n<li>-m 指定虚拟网卡的硬件地址默认virt-install自动产生</li>\n<li>-p 以半虚拟化方式建立虚拟机</li>\n<li>-l 指定安装来源</li>\n<li>-x EXTRA, –extra-args=EXTRA当执行从”–location”选项指定位置的客户机安装时，附加内核命令行参数到安装程序。</li>\n<li>-v, –hvm 设置全虚拟化<br><br><br><br></li>\n</ul>\n</li>\n<li><p>创建第一个guest：</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>virt-install –name=CentOS7-1 –ram=4096 –vcpus=1 –cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso –virt-type=kvm –disk  path=/home/kvm1/centos7-1.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=250 –graphics vnc,listen=0.0.0.0,port=5920,password=123456 –network bridge:br0 –accelerate –force –autostart</li>\n</ul>\n</li>\n<li><p>创建第二个guest：</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>virt-install –name=CentOS7-2 –ram=7168 –vcpus=2,maxvcpus=4 –cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso –virt-type=kvm –disk  path=/home/kvm1/centos7-2.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 –graphics vnc,listen=0.0.0.0,port=5921,password=123456 –network bridge:br0 –accelerate –force –autostart</li>\n</ul>\n</li>\n<li><p>创建第三个guest：</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>virt-install –name=CentOS7-3 –ram=7168 –vcpus=6,maxvcpus=9 –cpuset=6,7,8,9,10,11 –cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso –virt-type=kvm –disk  path=/home/kvm1/centos7-3.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 –graphics vnc,listen=0.0.0.0,port=5922,password=123456 –network bridge:br0 –accelerate –force –autostart</li>\n</ul>\n</li>\n<li><p>创建第四个guest：</p>\n<ul>\n<li><a href=\"\">[root@localhost /]# </a>virt-install –name=CentOS7-4 –ram=7168 –vcpus=6,maxvcpus=9 –cpuset=12,13,14,15,16,17 –cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso –virt-type=kvm –disk  path=/home/kvm1/centos7-4.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 –graphics vnc,listen=0.0.0.0,port=5923,password=123456 –network bridge:br0 –accelerate –force –autostart</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"持续更新中……\"><a href=\"#持续更新中……\" class=\"headerlink\" title=\"持续更新中……\"></a>持续更新中……</h4><hr>\n<ul>\n<li><p>REFERENCES</p>\n<ol>\n<li><a href=\"http://blog.csdn.net/chdhust/article/details/7931717\" target=\"\\_blank\">KVM虚拟机创建功能详细讲解</a></li>\n<li><a href=\"http://blog.csdn.net/zhaihaifei/article/details/51163750\" target=\"\\_blank\">绑定KVM虚拟机的vcpu与物理CPU</a></li>\n<li><a href=\"https://www.teakki.com/p/57dbd24a1b9882de17e7fd37\" target=\"\\_blank\">基于Linux命令行KVM虚拟机的安装配置与基本使用</a></li>\n<li><a href=\"http://kulezhaizhuren.lofter.com/post/1cca7553_7e20b47\" target=\"\\_blank\">CENTOS7 安装KVM笔记之安装</a></li>\n<li><a href=\"https://www.52os.net/articles/linux-kvm-install-virtual-machines.html\" target=\"\\_blank\">linux下配置和安装KVM虚拟机</a></li>\n</ol>\n</li>\n</ul>"},{"title":"analyse the source code of Timer","date":"2017-07-26T02:58:57.000Z","_content":"\n## Timer Class Introduction\n\n> 在JDK库中Timer类主要负责计划任务的功能，也就是在指定的时间开始执行某任务。\n\n<!-- more -->\n\n## A Simple Example\n\n```java\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 9:53 2017/7/26.\n */\npublic class TimerTest {\n    //  define a timer\n    private static Timer timer = new Timer();\n    \n    // define MyTask class\n    static public class MyTask extends TimerTask{\n        private String str;\n        public MyTask(String str){\n            this.str = str;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(this.str + \"running:\" + new Date());\n        }\n    }\n    //  test main\n    public static void main(String[] args) throws ParseException {\n        MyTask myTask1 = new MyTask(\"task1\");\n        MyTask myTask2 = new MyTask(\"task2\");\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n\n        String dateString1 = \"2017-07-26 10:06:01\";\n        Date date1 = sdf.parse(dateString1);\n\n        String dateString2 = \"2017-07-26 10:05:01\";\n        Date date2 = sdf.parse(dateString2);\n\n        timer.schedule(myTask1, date1);\n        timer.schedule(myTask2, date2);\n    }\n}\n```\n> 在这个例子中，定义了两个TimerTask，并且设定执行时间，调用Timer的schedule()方法，传入任务和时间，执行正确。\n\n## Timer源码分析\n> 首先我们以timer.schedule()方法为入口，进一步剖析整个执行流程。看看Timer的schedule()的源码：</br>\n\n```java\npublic void schedule(TimerTask task, Date time) {\n    sched(task, time.getTime(), 0);\n}\n```\n\n> 再进一步看sched()方法的源码</br>\n\n```java\nprivate void sched(TimerTask task, long time, long period) {\n    if (time < 0)\n        throw new IllegalArgumentException(\"Illegal execution time.\");\n\n    // Constrain value of period sufficiently to prevent numeric\n    // overflow while still being effectively infinitely large.\n    if (Math.abs(period) > (Long.MAX_VALUE >> 1))\n        period >>= 1;\n\n    synchronized(queue) {\n        if (!thread.newTasksMayBeScheduled)\n            throw new IllegalStateException(\"Timer already cancelled.\");\n\n        synchronized(task.lock) {\n            if (task.state != TimerTask.VIRGIN)\n                throw new IllegalStateException(\n                    \"Task already scheduled or cancelled\");\n            task.nextExecutionTime = time;\n            task.period = period;\n            task.state = TimerTask.SCHEDULED;\n        }\n\n        queue.add(task);\n        if (queue.getMin() == task)\n            queue.notify();\n    }\n}\n```\n\n* 在这个函数里面涉及到了两个重要的变量（queue和task）；\n* 首先是获取queue同步锁，设置task的基本属性，包括nextExecutionTime、perid、state；\n* 将task添加到queue中，等待task被执行；\n\n## TaskQueue源码分析\n* 底层是定义了一个**private TimerTask[] queue = new TimerTask[128];**数组，用来存储TimerTask，默认值为128；\n* TaskQueue是直接定义在Timer.java的类，是一个优先级队列，是根据nextExecutionTime排序的；最小的nextExecutionTime\n* 如果queue不是空的，最小的TimeTask.nextExecutionTime就是queue[1]；\n* 主要理解两个函数：fixUp()和fixDown();\n\n```java\nprivate void fixUp(int k) {\n    while (k > 1) {\n        int j = k >> 1;\n        if (queue[j].nextExecutionTime <= queue[k].nextExecutionTime)\n            break;\n        TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;\n        k = j;\n    }\n}\n\nprivate void fixDown(int k) {\n    int j;\n    while ((j = k << 1) <= size && j > 0) {\n        if (j < size &&\n            queue[j].nextExecutionTime > queue[j+1].nextExecutionTime)\n            j++; // j indexes smallest kid\n        if (queue[k].nextExecutionTime <= queue[j].nextExecutionTime)\n            break;\n        TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;\n        k = j;\n    }\n}\n```\n\n* 每次调用add()方法，先将任务添加到quene的最后一个，然后调用fixUp()方法，调整整个queue，将拥有最小nextExecutionTime的TimerTask调整到queue[1]位置，如果位置不够，则需要扩容，按照原来容量的两倍扩容；\n\n","source":"_posts/analyse-the-source-code-of-Timer.md","raw":"---\ntitle: analyse the source code of Timer\ndate: 2017-07-26 10:58:57\ntags:\n    - java\ncategories: \n    - java\n---\n\n## Timer Class Introduction\n\n> 在JDK库中Timer类主要负责计划任务的功能，也就是在指定的时间开始执行某任务。\n\n<!-- more -->\n\n## A Simple Example\n\n```java\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 9:53 2017/7/26.\n */\npublic class TimerTest {\n    //  define a timer\n    private static Timer timer = new Timer();\n    \n    // define MyTask class\n    static public class MyTask extends TimerTask{\n        private String str;\n        public MyTask(String str){\n            this.str = str;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(this.str + \"running:\" + new Date());\n        }\n    }\n    //  test main\n    public static void main(String[] args) throws ParseException {\n        MyTask myTask1 = new MyTask(\"task1\");\n        MyTask myTask2 = new MyTask(\"task2\");\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n\n        String dateString1 = \"2017-07-26 10:06:01\";\n        Date date1 = sdf.parse(dateString1);\n\n        String dateString2 = \"2017-07-26 10:05:01\";\n        Date date2 = sdf.parse(dateString2);\n\n        timer.schedule(myTask1, date1);\n        timer.schedule(myTask2, date2);\n    }\n}\n```\n> 在这个例子中，定义了两个TimerTask，并且设定执行时间，调用Timer的schedule()方法，传入任务和时间，执行正确。\n\n## Timer源码分析\n> 首先我们以timer.schedule()方法为入口，进一步剖析整个执行流程。看看Timer的schedule()的源码：</br>\n\n```java\npublic void schedule(TimerTask task, Date time) {\n    sched(task, time.getTime(), 0);\n}\n```\n\n> 再进一步看sched()方法的源码</br>\n\n```java\nprivate void sched(TimerTask task, long time, long period) {\n    if (time < 0)\n        throw new IllegalArgumentException(\"Illegal execution time.\");\n\n    // Constrain value of period sufficiently to prevent numeric\n    // overflow while still being effectively infinitely large.\n    if (Math.abs(period) > (Long.MAX_VALUE >> 1))\n        period >>= 1;\n\n    synchronized(queue) {\n        if (!thread.newTasksMayBeScheduled)\n            throw new IllegalStateException(\"Timer already cancelled.\");\n\n        synchronized(task.lock) {\n            if (task.state != TimerTask.VIRGIN)\n                throw new IllegalStateException(\n                    \"Task already scheduled or cancelled\");\n            task.nextExecutionTime = time;\n            task.period = period;\n            task.state = TimerTask.SCHEDULED;\n        }\n\n        queue.add(task);\n        if (queue.getMin() == task)\n            queue.notify();\n    }\n}\n```\n\n* 在这个函数里面涉及到了两个重要的变量（queue和task）；\n* 首先是获取queue同步锁，设置task的基本属性，包括nextExecutionTime、perid、state；\n* 将task添加到queue中，等待task被执行；\n\n## TaskQueue源码分析\n* 底层是定义了一个**private TimerTask[] queue = new TimerTask[128];**数组，用来存储TimerTask，默认值为128；\n* TaskQueue是直接定义在Timer.java的类，是一个优先级队列，是根据nextExecutionTime排序的；最小的nextExecutionTime\n* 如果queue不是空的，最小的TimeTask.nextExecutionTime就是queue[1]；\n* 主要理解两个函数：fixUp()和fixDown();\n\n```java\nprivate void fixUp(int k) {\n    while (k > 1) {\n        int j = k >> 1;\n        if (queue[j].nextExecutionTime <= queue[k].nextExecutionTime)\n            break;\n        TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;\n        k = j;\n    }\n}\n\nprivate void fixDown(int k) {\n    int j;\n    while ((j = k << 1) <= size && j > 0) {\n        if (j < size &&\n            queue[j].nextExecutionTime > queue[j+1].nextExecutionTime)\n            j++; // j indexes smallest kid\n        if (queue[k].nextExecutionTime <= queue[j].nextExecutionTime)\n            break;\n        TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;\n        k = j;\n    }\n}\n```\n\n* 每次调用add()方法，先将任务添加到quene的最后一个，然后调用fixUp()方法，调整整个queue，将拥有最小nextExecutionTime的TimerTask调整到queue[1]位置，如果位置不够，则需要扩容，按照原来容量的两倍扩容；\n\n","slug":"analyse-the-source-code-of-Timer","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn5r0034zjiaat8s04cb","content":"<h2 id=\"Timer-Class-Introduction\"><a href=\"#Timer-Class-Introduction\" class=\"headerlink\" title=\"Timer Class Introduction\"></a>Timer Class Introduction</h2><blockquote>\n<p>在JDK库中Timer类主要负责计划任务的功能，也就是在指定的时间开始执行某任务。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"A-Simple-Example\"><a href=\"#A-Simple-Example\" class=\"headerlink\" title=\"A Simple Example\"></a>A Simple Example</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.ParseException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.text.SimpleDateFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Timer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.TimerTask;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 9:53 2017/7/26.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//  define a timer</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Timer timer = <span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// define MyTask class</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimerTask</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String str;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyTask</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.str = str;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">this</span>.str + <span class=\"string\">\"running:\"</span> + <span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  test main</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ParseException </span>&#123;</span><br><span class=\"line\">        MyTask myTask1 = <span class=\"keyword\">new</span> MyTask(<span class=\"string\">\"task1\"</span>);</span><br><span class=\"line\">        MyTask myTask2 = <span class=\"keyword\">new</span> MyTask(<span class=\"string\">\"task2\"</span>);</span><br><span class=\"line\">        SimpleDateFormat sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        String dateString1 = <span class=\"string\">\"2017-07-26 10:06:01\"</span>;</span><br><span class=\"line\">        Date date1 = sdf.parse(dateString1);</span><br><span class=\"line\"></span><br><span class=\"line\">        String dateString2 = <span class=\"string\">\"2017-07-26 10:05:01\"</span>;</span><br><span class=\"line\">        Date date2 = sdf.parse(dateString2);</span><br><span class=\"line\"></span><br><span class=\"line\">        timer.schedule(myTask1, date1);</span><br><span class=\"line\">        timer.schedule(myTask2, date2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在这个例子中，定义了两个TimerTask，并且设定执行时间，调用Timer的schedule()方法，传入任务和时间，执行正确。</p>\n</blockquote>\n<h2 id=\"Timer源码分析\"><a href=\"#Timer源码分析\" class=\"headerlink\" title=\"Timer源码分析\"></a>Timer源码分析</h2><blockquote>\n<p>首先我们以timer.schedule()方法为入口，进一步剖析整个执行流程。看看Timer的schedule()的源码：<br></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">(TimerTask task, Date time)</span> </span>&#123;</span><br><span class=\"line\">    sched(task, time.getTime(), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>再进一步看sched()方法的源码<br></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sched</span><span class=\"params\">(TimerTask task, <span class=\"keyword\">long</span> time, <span class=\"keyword\">long</span> period)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal execution time.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Constrain value of period sufficiently to prevent numeric</span></span><br><span class=\"line\">    <span class=\"comment\">// overflow while still being effectively infinitely large.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class=\"number\">1</span>))</span><br><span class=\"line\">        period &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(queue) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!thread.newTasksMayBeScheduled)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Timer already cancelled.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(task.lock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (task.state != TimerTask.VIRGIN)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                    <span class=\"string\">\"Task already scheduled or cancelled\"</span>);</span><br><span class=\"line\">            task.nextExecutionTime = time;</span><br><span class=\"line\">            task.period = period;</span><br><span class=\"line\">            task.state = TimerTask.SCHEDULED;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue.add(task);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue.getMin() == task)</span><br><span class=\"line\">            queue.notify();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在这个函数里面涉及到了两个重要的变量（queue和task）；</li>\n<li>首先是获取queue同步锁，设置task的基本属性，包括nextExecutionTime、perid、state；</li>\n<li>将task添加到queue中，等待task被执行；</li>\n</ul>\n<h2 id=\"TaskQueue源码分析\"><a href=\"#TaskQueue源码分析\" class=\"headerlink\" title=\"TaskQueue源码分析\"></a>TaskQueue源码分析</h2><ul>\n<li>底层是定义了一个<strong>private TimerTask[] queue = new TimerTask[128];</strong>数组，用来存储TimerTask，默认值为128；</li>\n<li>TaskQueue是直接定义在Timer.java的类，是一个优先级队列，是根据nextExecutionTime排序的；最小的nextExecutionTime</li>\n<li>如果queue不是空的，最小的TimeTask.nextExecutionTime就是queue[1]；</li>\n<li>主要理解两个函数：fixUp()和fixDown();</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fixUp</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = k &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</span><br><span class=\"line\">        k = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fixDown</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((j = k &lt;&lt; <span class=\"number\">1</span>) &lt;= size &amp;&amp; j &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &lt; size &amp;&amp;</span><br><span class=\"line\">            queue[j].nextExecutionTime &gt; queue[j+<span class=\"number\">1</span>].nextExecutionTime)</span><br><span class=\"line\">            j++; <span class=\"comment\">// j indexes smallest kid</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</span><br><span class=\"line\">        k = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>每次调用add()方法，先将任务添加到quene的最后一个，然后调用fixUp()方法，调整整个queue，将拥有最小nextExecutionTime的TimerTask调整到queue[1]位置，如果位置不够，则需要扩容，按照原来容量的两倍扩容；</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Timer-Class-Introduction\"><a href=\"#Timer-Class-Introduction\" class=\"headerlink\" title=\"Timer Class Introduction\"></a>Timer Class Introduction</h2><blockquote>\n<p>在JDK库中Timer类主要负责计划任务的功能，也就是在指定的时间开始执行某任务。</p>\n</blockquote>","more":"<h2 id=\"A-Simple-Example\"><a href=\"#A-Simple-Example\" class=\"headerlink\" title=\"A Simple Example\"></a>A Simple Example</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.ParseException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.text.SimpleDateFormat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Timer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.TimerTask;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 9:53 2017/7/26.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//  define a timer</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Timer timer = <span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// define MyTask class</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimerTask</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String str;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyTask</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.str = str;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">this</span>.str + <span class=\"string\">\"running:\"</span> + <span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//  test main</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ParseException </span>&#123;</span><br><span class=\"line\">        MyTask myTask1 = <span class=\"keyword\">new</span> MyTask(<span class=\"string\">\"task1\"</span>);</span><br><span class=\"line\">        MyTask myTask2 = <span class=\"keyword\">new</span> MyTask(<span class=\"string\">\"task2\"</span>);</span><br><span class=\"line\">        SimpleDateFormat sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        String dateString1 = <span class=\"string\">\"2017-07-26 10:06:01\"</span>;</span><br><span class=\"line\">        Date date1 = sdf.parse(dateString1);</span><br><span class=\"line\"></span><br><span class=\"line\">        String dateString2 = <span class=\"string\">\"2017-07-26 10:05:01\"</span>;</span><br><span class=\"line\">        Date date2 = sdf.parse(dateString2);</span><br><span class=\"line\"></span><br><span class=\"line\">        timer.schedule(myTask1, date1);</span><br><span class=\"line\">        timer.schedule(myTask2, date2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在这个例子中，定义了两个TimerTask，并且设定执行时间，调用Timer的schedule()方法，传入任务和时间，执行正确。</p>\n</blockquote>\n<h2 id=\"Timer源码分析\"><a href=\"#Timer源码分析\" class=\"headerlink\" title=\"Timer源码分析\"></a>Timer源码分析</h2><blockquote>\n<p>首先我们以timer.schedule()方法为入口，进一步剖析整个执行流程。看看Timer的schedule()的源码：<br></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">(TimerTask task, Date time)</span> </span>&#123;</span><br><span class=\"line\">    sched(task, time.getTime(), <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>再进一步看sched()方法的源码<br></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sched</span><span class=\"params\">(TimerTask task, <span class=\"keyword\">long</span> time, <span class=\"keyword\">long</span> period)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (time &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal execution time.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Constrain value of period sufficiently to prevent numeric</span></span><br><span class=\"line\">    <span class=\"comment\">// overflow while still being effectively infinitely large.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class=\"number\">1</span>))</span><br><span class=\"line\">        period &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(queue) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!thread.newTasksMayBeScheduled)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Timer already cancelled.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(task.lock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (task.state != TimerTask.VIRGIN)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">                    <span class=\"string\">\"Task already scheduled or cancelled\"</span>);</span><br><span class=\"line\">            task.nextExecutionTime = time;</span><br><span class=\"line\">            task.period = period;</span><br><span class=\"line\">            task.state = TimerTask.SCHEDULED;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue.add(task);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue.getMin() == task)</span><br><span class=\"line\">            queue.notify();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在这个函数里面涉及到了两个重要的变量（queue和task）；</li>\n<li>首先是获取queue同步锁，设置task的基本属性，包括nextExecutionTime、perid、state；</li>\n<li>将task添加到queue中，等待task被执行；</li>\n</ul>\n<h2 id=\"TaskQueue源码分析\"><a href=\"#TaskQueue源码分析\" class=\"headerlink\" title=\"TaskQueue源码分析\"></a>TaskQueue源码分析</h2><ul>\n<li>底层是定义了一个<strong>private TimerTask[] queue = new TimerTask[128];</strong>数组，用来存储TimerTask，默认值为128；</li>\n<li>TaskQueue是直接定义在Timer.java的类，是一个优先级队列，是根据nextExecutionTime排序的；最小的nextExecutionTime</li>\n<li>如果queue不是空的，最小的TimeTask.nextExecutionTime就是queue[1]；</li>\n<li>主要理解两个函数：fixUp()和fixDown();</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fixUp</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = k &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</span><br><span class=\"line\">        k = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fixDown</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((j = k &lt;&lt; <span class=\"number\">1</span>) &lt;= size &amp;&amp; j &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &lt; size &amp;&amp;</span><br><span class=\"line\">            queue[j].nextExecutionTime &gt; queue[j+<span class=\"number\">1</span>].nextExecutionTime)</span><br><span class=\"line\">            j++; <span class=\"comment\">// j indexes smallest kid</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        TimerTask tmp = queue[j];  queue[j] = queue[k]; queue[k] = tmp;</span><br><span class=\"line\">        k = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>每次调用add()方法，先将任务添加到quene的最后一个，然后调用fixUp()方法，调整整个queue，将拥有最小nextExecutionTime的TimerTask调整到queue[1]位置，如果位置不够，则需要扩容，按照原来容量的两倍扩容；</li>\n</ul>"},{"title":"Dubbo消费者调用过程源码分析","date":"2018-08-05T06:11:36.000Z","_content":"\n在分析Dubbo RPC服务调用过程之前，我们先写一个基于Dubbo实现的[**Consumer-Provider的Demo**](https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo)，通过这个Demo来分析具体的RPC调用栈。\n\n先定义一个接口：\n\n```java\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 11:02 AM 2018/07/19.\n */\npublic interface ITestService {\n    String sayHello(String msg);\n}\n```\n\n我们基于zookeeper注册中心，服务端配置如下：\n\n```xml\n<dubbo:application name=\"dubbo-server\" owner=\"Junlan\" />\n<dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/>\n<!--protocal configuration-->\n<dubbo:protocol name=\"dubbo\" port=\"20881\"/>\n<dubbo:provider server=\"netty\"/>\n<!--service configuration-->\n<dubbo:service interface=\"cn.shuaijunlan.dubbo.learning.service.ITestService\" ref=\"testService\" protocol=\"dubbo\" loadbalance=\"roundrobin\"/>\n<bean class=\"cn.shuaijunlan.dubbo.learning.service.impl.TestServiceImpl\" name=\"testService\" />\n```\n\n客户端配置如下：\n\n```xml\n<dubbo:application name=\"dubbo-client\" owner=\"Junlan\"/>\n<dubbo:consumer client=\"netty\"/>\n<dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/>\n<dubbo:reference interface=\"cn.shuaijunlan.dubbo.learning.service.ITestService\" id=\"testService\" check=\"false\"/>\n```\n\n<!-- more -->\n\n项目的部分依赖如下：\n\n```xml\n<dependency>\n    <groupId>org.apache.dubbo</groupId>\n    <artifactId>dubbo</artifactId>\n    <version>2.7.0-SNAPSHOT</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-framework</artifactId>\n    <version>2.12.0</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.zookeeper</groupId>\n    <artifactId>zookeeper</artifactId>\n    <version>3.4.9</version>\n</dependency>\n```\n\n具体的服务提供者实现参照[**service-provider-a**](https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo/service-provider-a) ，服务消费者实现参照[**dubbo-client-demo**](https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo/dubbo-client-demo)。\n\n先启动服务提供者服务，下面分析在哪打断点：\n\n我们看下`org.apache.dubbo.remoting.transport.netty4.NettyChannel`的`send`方法：\n\n```java\n@Override\npublic void send(Object message, boolean sent) throws RemotingException {\n    super.send(message, sent);\n\n    boolean success = true;\n    int timeout = 0;\n    try {\n        //向远程服务发送消息，因此我们在这句打个断点\n        ChannelFuture future = channel.writeAndFlush(message);\n        if (sent) {\n            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n            success = future.await(timeout);\n        }\n        Throwable cause = future.cause();\n        if (cause != null) {\n            throw cause;\n        }\n    } catch (Throwable e) {\n        throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress() + \", cause: \" + e.getMessage(), e);\n    }\n\n    if (!success) {\n        throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress()\n                                    + \"in timeout(\" + timeout + \"ms) limit\");\n    }\n}\n```\n\n我们在`ChannelFuture future = channel.writeAndFlush(message);`这句打个断点，Debug服务消费者，得到如下线程栈信息：\n\n```\n\"main@1\" prio=5 tid=0x1 nid=NA runnable\n  java.lang.Thread.State: RUNNABLE\n\t  at org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:101)\n\t  at org.apache.dubbo.remoting.transport.AbstractClient.send(AbstractClient.java:265)\n\t  at org.apache.dubbo.remoting.transport.AbstractPeer.send(AbstractPeer.java:53)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.request(HeaderExchangeChannel.java:116)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeClient.request(HeaderExchangeClient.java:90)\n\t  at org.apache.dubbo.rpc.protocol.dubbo.ReferenceCountExchangeClient.request(ReferenceCountExchangeClient.java:83)\n\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:108)\n\t  at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:154)\n\t  at org.apache.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:77)\n\t  at org.apache.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)\n\t  at org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:47)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)\n\t  at org.apache.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:50)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)\n\t  at org.apache.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:56)\n\t  at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:78)\n\t  at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:243)\n\t  at org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:75)\n\t  at org.apache.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:70)\n\t  at org.apache.dubbo.common.bytecode.proxy0.sayHello(proxy0.java:-1)\n\t  at cn.shuaijunlan.dubbo.learning.main.Main.main(Main.java:16)\n```\n\n自底向上，可以直观的看到服务消费者调用要经过的类和方法，下面将进行一步步分析，对每一个类的创建过程和调用过程做出解析：\n\n* 第一行栈信息\n\n```\nat cn.shuaijunlan.dubbo.learning.main.Main.main(Main.java:16)\n```\n\nMain.java 类是消费者端的启动类，可以忽略。\n\n* 第二行栈信息\n\n```\nat org.apache.dubbo.common.bytecode.proxy0.sayHello(proxy0.java:-1)\n```\n\n`org.apache.dubbo.common.bytecode.proxy0`类是一个代理类，它代理了所有RPC服务接口的方法调用。这个类实例是什么时候创建的？类代码是怎样的？\n\n**Dubbo基于Spring的构建分析**（参考文章[**《基于Spring构建Dubbo源码分析》**](https://shuaijunlan.github.io/2018/08/13/dubbo-basing-on-spring-framework-analysis/)）， 代理类的创建是由ReferenceBean类的\n\n```java\npublic Object getObject() throws Exception {\n    return get();\n}\n```\n\n方法里触发的，具体的实现在ReferenceConfig类createProxy方法里\n\n```java\n@SuppressWarnings({\"unchecked\", \"rawtypes\", \"deprecation\"})\nprivate T createProxy(Map<String, String> map) {\n    // ...\n    // 用于生成invoker的逻辑，关于invoker生成逻辑这里先忽略，后面会说到\n    // ...\n    // create service proxy\n    return (T) proxyFactory.getProxy(invoker);\n}\n```\n\nproxyFactory变量赋值为\n\n```java\nprivate static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n```\n\n**Dubbo SPI机制**(参考文章[**《Dubbo SPI机制源码分析》**](https://shuaijunlan.github.io/2018/08/09/dubbo-spi-analysis/))里可以得到ProxyFactory接口的Adaptive类的getProxy方法源码如下：\n\n```java\npackage org.apache.dubbo.rpc;\n\nimport org.apache.dubbo.common.extension.ExtensionLoader;\n\npublic class ProxyFactory$Adaptive implements org.apache.dubbo.rpc.ProxyFactory {\n    public java.lang.Object getProxy(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException {\n        if (arg0 == null) throw new IllegalArgumentException(\"org.apache.dubbo.rpc.Invoker argument == null\");\n        if (arg0.getUrl() == null)\n            throw new IllegalArgumentException(\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\");\n        org.apache.dubbo.common.URL url = arg0.getUrl();\n        String extName = url.getParameter(\"proxy\", \"javassist\");\n        if (extName == null)\n            throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n        return extension.getProxy(arg0);\n    }\n\n    public java.lang.Object getProxy(org.apache.dubbo.rpc.Invoker arg0, boolean arg1) throws org.apache.dubbo.rpc.RpcException {\n        if (arg0 == null) throw new IllegalArgumentException(\"org.apache.dubbo.rpc.Invoker argument == null\");\n        if (arg0.getUrl() == null)\n            throw new IllegalArgumentException(\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\");\n        org.apache.dubbo.common.URL url = arg0.getUrl();\n        String extName = url.getParameter(\"proxy\", \"javassist\");\n        if (extName == null)\n            throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n        return extension.getProxy(arg0, arg1);\n    }\n\n    public org.apache.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2) throws org.apache.dubbo.rpc.RpcException {\n        if (arg2 == null) throw new IllegalArgumentException(\"url == null\");\n        org.apache.dubbo.common.URL url = arg2;\n        String extName = url.getParameter(\"proxy\", \"javassist\");\n        if (extName == null)\n            throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n        return extension.getInvoker(arg0, arg1, arg2);\n    }\n}\n```\n\n在如上`ProxyFactory$Adaptive`类中，调用`getProxy(org.apache.dubbo.rpc.Invoker arg0) `方法，其中：\n\n```java\nString extName = url.getParameter(\"proxy\", \"javassist\");\norg.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n```\n\n默认获取ProxyFactory接口的javassist扩展类JavassistProxyFactory，先调用`JavassitProxyFactory`的父类ProxyFactory的`getProxy(Invoker<T> invoker)`方法和`getProxy(Invoker<T> invoker, boolean generic)`方法：\n\n```java\n@Override\npublic <T> T getProxy(Invoker<T> invoker) throws RpcException {\n    return getProxy(invoker, false);\n}\n```\n\n再调用`JavassistProxyFactory`类的`getProxy(Invoker<T> invoker, Class<?>[] interfaces)`方法：\n\n```java\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n    return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n}\n```\n\n再到**生成代理类的Proxy类**（具体过程在另一篇文章中详细分析）\n\n```java\n/**\n     * Get proxy.\n     *\n     * @param ics interface class array.\n     * @return Proxy instance.\n     */\npublic static Proxy getProxy(Class<?>... ics) {\n    return getProxy(ClassHelper.getClassLoader(Proxy.class), ics);\n}\n```\n\n这里直接贴出**通过代码hack生成的代理类**源码，这里动态生成了两个类：\n\n```java\npackage com.alibaba.dubbo.common.bytecode;\n\nimport com.alibaba.dubbo.common.bytecode.ClassGenerator.DC;\n\nimport java.lang.reflect.InvocationHandler;\n\npublic class Proxy0 extends Proxy implements DC {\n    public Object newInstance(InvocationHandler var1) {\n        return new proxy01(var1);\n    }\n\n    public Proxy0_my() {\n    }\n}\n```\n\n这个类继承抽象类Proxy，实现了它的抽象方法newInstance，**接口DC是Dubbo内部作为动态类标示的接口**；\n\n还有一个proxy01，就是在开始方法栈里看到的代理类，源码如下：\n\n```java\npackage com.alibaba.dubbo.common.bytecode;\n\nimport com.alibaba.dubbo.rpc.service.EchoService;\nimport demo.dubbo.api.DemoService;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class proxy01 implements ClassGenerator.DC, EchoService, DemoService {\n    public static Method[] methods;\n    private InvocationHandler handler;\n    //实现了接口方法\n    public String sayHello(String var1) {\n        Object[] var2 = new Object[]{var1};\n        Object var3 = null;\n        try {\n            var3 = this.handler.invoke(this, methods[1], var2);\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n        }\n        return (String)var3;\n    }\n\n    public Object $echo(Object var1) {\n        Object[] var2 = new Object[]{var1};\n        Object var3 = null;\n        try {\n            var3 = this.handler.invoke(this, methods[3], var2);\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n        }\n        return (Object)var3;\n    }\n\n    public proxy01() {\n    }\n    //public 构造函数，这里handler是\n    //由Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker))语句传入的InvokerInvocationHandler对象\n    public proxy01(InvocationHandler var1) {\n        this.handler = var1;\n    }\n}\n```\n\n可以看到代理类实现类三个接口，`ClassGeneratr.DC`是Dubbo动态类标识接口，`DemoService`是实际的业务接口，这样代理就可以调用服务方法了，`EchoService`是回显测试接口，只有一个`$echo(Object var1)`法。\n\n```java\npackage org.apache.dubbo.rpc.service;\n\n/**\n * Echo service.\n * @export\n */\npublic interface EchoService {\n\n    /**\n     * echo test.\n     *\n     * @param message message.\n     * @return message.\n     */\n    Object $echo(Object message);\n\n}\n```\n\n它能为所有的Dubbo RPC服务加上一个回显测试方法。\n\n```java\n// 通过类型强制转换为EchoService，可以测试\nEchoService echoService = (EchoService) service;\nSystem.out.println(echoService.$echo(\"hello\"));\n```\n\n到这可以了解代理类生成的整个过程，可以看到sayHello方法的调用其实是调用`this.handler.invoke(this, methods[1], var2);`，因此这也解释了**线程栈中第三行信息**：\n\n```\nat org.apache.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:70)\n```\n\n再往下看`org.apache.dubbo.rpc.proxy.InvokerInvocationHandler`类：\n\n```java\npublic class InvokerInvocationHandler implements InvocationHandler {\n\n    private final Invoker<?> invoker;\n\t//通过构造函数传入invoker\n    public InvokerInvocationHandler(Invoker<?> handler) {\n        this.invoker = handler;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        String methodName = method.getName();\n        Class<?>[] parameterTypes = method.getParameterTypes();\n        // 如果是Object类方法\n        if (method.getDeclaringClass() == Object.class) {\n            //反射调用\n            return method.invoke(invoker, args);\n        }\n        // 对toString、hashCode、equals三个方法做了处理\n        if (\"toString\".equals(methodName) && parameterTypes.length == 0) {\n            return invoker.toString();\n        }\n        if (\"hashCode\".equals(methodName) && parameterTypes.length == 0) {\n            return invoker.hashCode();\n        }\n        if (\"equals\".equals(methodName) && parameterTypes.length == 1) {\n            return invoker.equals(args[0]);\n        }\n\n        RpcInvocation invocation;\n        if (RpcUtils.hasGeneratedFuture(method)) {\n            Class<?> clazz = method.getDeclaringClass();\n            String syncMethodName = methodName.substring(0, methodName.length() - Constants.ASYNC_SUFFIX.length());\n            Method syncMethod = clazz.getMethod(syncMethodName, method.getParameterTypes());\n            invocation = new RpcInvocation(syncMethod, args);\n            invocation.setAttachment(Constants.FUTURE_GENERATED_KEY, \"true\");\n            invocation.setAttachment(Constants.ASYNC_KEY, \"true\");\n        } else {\n            invocation = new RpcInvocation(method, args);\n            if (RpcUtils.hasFutureReturnType(method)) {\n                invocation.setAttachment(Constants.FUTURE_RETURNTYPE_KEY, \"true\");\n                invocation.setAttachment(Constants.ASYNC_KEY, \"true\");\n            }\n        }\n        return invoker.invoke(invocation).recreate();\n    }\n\n\n}\n```\n\n在这里的invoker对象，是通过InvokerInvocationHandler构造方法传入，而且InvokerInvocationHandler对象是由JavassistProxyFactory类的`getProxy(Invoker<T> invoker, Class<?>[] interfaces)`方法创建，回到调用`proxyFactory.getProxy(invoker);`的地方，即ReferenceConfig类的`createProxy(Map<String, String> map)`方法，以下部分是生成invoker的过程：\n\n```java\nif (isJvmRefer) {\n    URL url = new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);\n    invoker = refprotocol.refer(interfaceClass, url);\n    if (logger.isInfoEnabled()) {\n        logger.info(\"Using injvm service \" + interfaceClass.getName());\n    }\n} else {\n    if (url != null && url.length() > 0) { // user specified URL, could be peer-to-peer address, or register center's address.\n        String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);\n        if (us != null && us.length > 0) {\n            for (String u : us) {\n                URL url = URL.valueOf(u);\n                if (url.getPath() == null || url.getPath().length() == 0) {\n                    url = url.setPath(interfaceName);\n                }\n                if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n                    urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n                } else {\n                    urls.add(ClusterUtils.mergeUrl(url, map));\n                }\n            }\n        }\n    } else { // assemble URL from register center's configuration\n        //从注册中心获取配置URL\n        List<URL> us = loadRegistries(false);\n        if (us != null && !us.isEmpty()) {\n            for (URL u : us) {\n                URL monitorUrl = loadMonitor(u);\n                if (monitorUrl != null) {\n                    map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\n                }\n                urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n            }\n        }\n        if (urls.isEmpty()) {\n            throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\n        }\n    }\n    //只有一个直连地址或者一个注册中心配置地址\n    if (urls.size() == 1) {\n        //这里的urls.get(0)，可能是直连地址（默认为dubbo协议），也可能是register注册地址（zookeeper协议）\n        //示例中使用了zookeeper注册中心，因此会执行这一步\n        invoker = refprotocol.refer(interfaceClass, urls.get(0));\n    } else {//多个直连地址或者多个注册中心，甚至是两者的结合，执行这一步\n        List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();\n        URL registryURL = null;\n        for (URL url : urls) {\n            //创建invoker放入invokers\n            invokers.add(refprotocol.refer(interfaceClass, url));\n            if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n                registryURL = url; // use last registry url\n            }\n        }\n        if (registryURL != null) { // registry url is available\n            // use AvailableCluster only when register's cluster is available\n            //这其中包括直连和注册中心混合或者都是注册中心两种情况，默认使用AvailableCluster集群策略\n            URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n            invoker = cluster.join(new StaticDirectory(u, invokers));\n        } else { // not a registry url\n            //多个直连的URL\n            invoker = cluster.join(new StaticDirectory(invokers));\n        }\n    }\n}\n```\n\n经过上面的分析，可以发现invoker是通过`refprotocol.refer(interfaceClass, urls.get(0));`、`cluster.join(new StaticDirectory(u, invokers));`和`cluster.join(new StaticDirectory(invokers));`三种构建语句其中之一生成的，这里是经过第一种方式生成invoker的，下面来分析第一种生成invoker的情况，根据SPI机制这里refprotocol对象是`Protocol$Adpative`实例，具体refer实现是：\n\n```java\npublic org.apache.dubbo.rpc.Invoker refer(java.lang.Class arg0, org.apache.dubbo.common.URL arg1) throws org.apache.dubbo.rpc.RpcException {\n    if (arg1 == null) throw new IllegalArgumentException(\"url == null\");\n    org.apache.dubbo.common.URL url = arg1;\n    String extName = (url.getProtocol() == null ? \"MEAT-INF.dubbo\" : url.getProtocol());\n    if (extName == null)\n        throw new IllegalStateException(\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n    org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n    return extension.refer(arg0, arg1);\n}\n```\n\n示例中是通过注册中心，因此这里protocol是register，会走RegistryProtocol类的refer方法\n\n```java\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n    //通过register可以获取具体注册中心协议，这里是zookeeper，因此url的协议值被设置为zookeeper\n    url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);\n    //获取zookeeper Registry实现，即ZookeeperRegistryFactory，并调用getRegistry方法实现\n    //获取zookeeper类型的registry对象\n    Registry registry = registryFactory.getRegistry(url);\n    if (RegistryService.class.equals(type)) {\n        return proxyFactory.getInvoker((T) registry, type, url);\n    }\n\n    // group=\"a,b\" or group=\"*\"\n    Map<String, String> qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));\n    String group = qs.get(Constants.GROUP_KEY);\n    if (group != null && group.length() > 0) {\n        if ((Constants.COMMA_SPLIT_PATTERN.split(group)).length > 1\n            || \"*\".equals(group)) {\n            return doRefer(getMergeableCluster(), registry, type, url);\n        }\n    }\n    //根据Dubbo SPI机制，给setXxx方法对应的属性赋值为Xxx$Adaptive，这里就是Cluster$Adaptive\n    return doRefer(cluster, registry, type, url);\n}\nprivate <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {\n    //这里的RegistryDirectory和StaticDirectory相对应的，前者是动态从注册中心获取url目录对象，后者是静态指定url目录\n    RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);\n    directory.setRegistry(registry);\n    directory.setProtocol(protocol);\n    // all attributes of REFER_KEY\n    Map<String, String> parameters = new HashMap<String, String>(directory.getUrl().getParameters());\n    URL subscribeUrl = new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);\n    if (!Constants.ANY_VALUE.equals(url.getServiceInterface())\n        && url.getParameter(Constants.REGISTER_KEY, true)) {\n        registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,\n                                                     Constants.CHECK_KEY, String.valueOf(false)));\n    }\n    //订阅注册中心，可以获取服务提供方地址等信息\n    directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,\n                                                  Constants.PROVIDERS_CATEGORY\n                                                  + \",\" + Constants.CONFIGURATORS_CATEGORY\n                                                  + \",\" + Constants.ROUTERS_CATEGORY));\n    //通过调用Cluster$Adpative类的join方法返回Invoker对象(基于Dubbo SPI机制实现setXX()方法自动注入属性)\n    Invoker invoker = cluster.join(directory);\n    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);\n    return invoker;\n}\n```\n\n这里看下`Cluster$Adpative`类的join方法实现\n\n```java\npackage org.apache.dubbo.rpc.cluster;\n\nimport org.apache.dubbo.common.extension.ExtensionLoader;\n\npublic class Cluster$Adaptive implements org.apache.dubbo.rpc.cluster.Cluster {\n    private static final org.apache.dubbo.common.logger.Logger logger = org.apache.dubbo.common.logger.LoggerFactory.getLogger(ExtensionLoader.class);\n    private java.util.concurrent.atomic.AtomicInteger count = new java.util.concurrent.atomic.AtomicInteger(0);\n\n    public org.apache.dubbo.rpc.Invoker join(org.apache.dubbo.rpc.cluster.Directory arg0) throws org.apache.dubbo.rpc.RpcException {\n        if (arg0 == null) throw new IllegalArgumentException(\"org.apache.dubbo.rpc.cluster.Directory argument == null\");\n        if (arg0.getUrl() == null)\n            throw new IllegalArgumentException(\"org.apache.dubbo.rpc.cluster.Directory argument getUrl() == null\");\n        org.apache.dubbo.common.URL url = arg0.getUrl();\n        String extName = url.getParameter(\"cluster\", \"failover\");\n        if (extName == null)\n            throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.rpc.cluster.Cluster) name from url(\" + url.toString() + \") use keys([cluster])\");\n        org.apache.dubbo.rpc.cluster.Cluster extension = null;\n        try {\n            extension = (org.apache.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.cluster.Cluster.class).getExtension(extName);\n        } catch (Exception e) {\n            if (count.incrementAndGet() == 1) {\n                logger.warn(\"Failed to find extension named \" + extName + \" for type org.apache.dubbo.rpc.cluster.Cluster, will use default extension failover instead.\", e);\n            }\n            extension = (org.apache.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.cluster.Cluster.class).getExtension(\"failover\");\n        }\n        return extension.join(arg0);\n    }\n}\n```\n\n再看下FailoverCluster的join方法：\n\n```java\n@Override\npublic <T> Invoker<T> join(Directory<T> directory) throws RpcException {\n    return new FailoverClusterInvoker<T>(directory);\n}\n```\n\n由于Cluster SPI实现中有个MockClusterWrapper是包装类，这里牵扯到**Dubbo的AOP机制(后期详细分析)**，这里先调用它的join方法：\n\n```java\n@Override\npublic <T> Invoker<T> join(Directory<T> directory) throws RpcException {\n    return new MockClusterInvoker<T>(directory,\n                                     this.cluster.join(directory));\n}\n```\n\n生成MockClusterInvoker之后，由于FailoverClusterInvoker是AbstractClusterInvoker的子类，它的invoke方法实现在其父类中，接下来的调用链是`MockClusterInvoker.invoke()->AbstractClusterInvoker.invoke()->FailoverClusterInvoker.doInvoke()`，下面来一步步分析，首先来看MockClusterInvoker类的invoke()方法：\n\n```java\n@Override\npublic Result invoke(Invocation invocation) throws RpcException {\n    Result result = null;\n\n    String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();\n    if (value.length() == 0 || value.equalsIgnoreCase(\"false\")) {\n        //no mock\n        result = this.invoker.invoke(invocation);\n    } else if (value.startsWith(\"force\")) {\n        if (logger.isWarnEnabled()) {\n            logger.warn(\"force-mock: \" + invocation.getMethodName() + \" force-mock enabled , url : \" + directory.getUrl());\n        }\n        //force:direct mock\n        result = doMockInvoke(invocation, null);\n    } else {\n        //fail-mock\n        try {\n            result = this.invoker.invoke(invocation);\n        } catch (RpcException e) {\n            if (e.isBiz()) {\n                throw e;\n            } else {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\"fail-mock: \" + invocation.getMethodName() + \" fail-mock enabled , url : \" + directory.getUrl(), e);\n                }\n                result = doMockInvoke(invocation, e);\n            }\n        }\n    }\n    return result;\n}\n```\n\n然后调用AbstractClusterInvoker的invoke()方法：\n\n```java\n@Override\npublic Result invoke(final Invocation invocation) throws RpcException {\n    checkWhetherDestroyed();\n\n    // binding attachments into invocation.\n    Map<String, String> contextAttachments = RpcContext.getContext().getAttachments();\n    if (contextAttachments != null && contextAttachments.size() != 0) {\n        ((RpcInvocation) invocation).addAttachments(contextAttachments);\n    }\n\n    List<Invoker<T>> invokers = list(invocation);\n    LoadBalance loadbalance = initLoadBalance(invokers, invocation);\n    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);\n    return doInvoke(invocation, invokers, loadbalance);\n}\n```\n\n最后调用FailoverClusterInvoker的doInvoke()方法：\n\n```java\n@Override\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    List<Invoker<T>> copyinvokers = invokers;\n    checkInvokers(copyinvokers, invocation);\n    String methodName = RpcUtils.getMethodName(invocation);\n    //设置重试次数\n    int len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;\n    if (len <= 0) {\n        len = 1;\n    }\n    // retry loop.\n    RpcException le = null; // last exception.\n    List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyinvokers.size()); // invoked invokers.\n    Set<String> providers = new HashSet<String>(len);\n    for (int i = 0; i < len; i++) {\n        //Reselect before retry to avoid a change of candidate `invokers`.\n        //NOTE: if `invokers` changed, then `invoked` also lose accuracy.\n        if (i > 0) {\n            checkWhetherDestroyed();\n            copyinvokers = list(invocation);\n            // check again\n            checkInvokers(copyinvokers, invocation);\n        }\n        //根据负载均衡策略选择调用者\n        Invoker<T> invoker = select(loadbalance, invocation, copyinvokers, invoked);\n        //将使用过的invoker放入invoked\n        invoked.add(invoker);\n        RpcContext.getContext().setInvokers((List) invoked);\n        try {\n            Result result = invoker.invoke(invocation);\n            if (le != null && logger.isWarnEnabled()) {\n                logger.warn(\"Although retry the method \" + methodName\n                            + \" in the service \" + getInterface().getName()\n                            + \" was successful by the provider \" + invoker.getUrl().getAddress()\n                            + \", but there have been failed providers \" + providers\n                            + \" (\" + providers.size() + \"/\" + copyinvokers.size()\n                            + \") from the registry \" + directory.getUrl().getAddress()\n                            + \" on the consumer \" + NetUtils.getLocalHost()\n                            + \" using the dubbo version \" + Version.getVersion() + \". Last error is: \"\n                            + le.getMessage(), le);\n            }\n            return result;\n        } catch (RpcException e) {\n            if (e.isBiz()) { // biz exception.\n                throw e;\n            }\n            le = e;\n        } catch (Throwable e) {\n            le = new RpcException(e.getMessage(), e);\n        } finally {\n            providers.add(invoker.getUrl().getAddress());\n        }\n    }\n    throw new RpcException(le.getCode(), \"Failed to invoke the method \"\n                           + methodName + \" in the service \" + getInterface().getName()\n                           + \". Tried \" + len + \" times of the providers \" + providers\n                           + \" (\" + providers.size() + \"/\" + copyinvokers.size()\n                           + \") from the registry \" + directory.getUrl().getAddress()\n                           + \" on the consumer \" + NetUtils.getLocalHost() + \" using the dubbo version \"\n                           + Version.getVersion() + \". Last error is: \"\n                           + le.getMessage(), le.getCause() != null ? le.getCause() : le);\n}\n```\n\n所以会有如下的线程栈信息：\n\n```\nat org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:78)\nat org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:243)\nat org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:75)\n```\n\n这些类都是关于**Dubbo的集群容错机制**（将会写一篇关于Dubbo的集群容错机制）。\n\n再往下看invokers是如何生成的呢？又回到AbstractClusterInvoker的invoke方法实现：\n\n```java\n@Override\npublic Result invoke(final Invocation invocation) throws RpcException {\n    checkWhetherDestroyed();\n    LoadBalance loadbalance = null;\n\n    // binding attachments into invocation.\n    Map<String, String> contextAttachments = RpcContext.getContext().getAttachments();\n    if (contextAttachments != null && contextAttachments.size() != 0) {\n        ((RpcInvocation) invocation).addAttachments(contextAttachments);\n    }\n\t//会调用directory的list方法 返回要调用invokers集合。\n    //其实是AbstractDirectory的list方法，这个方法里就是利用路由规则（如果有），从所有\n    //提供者中，遴选出符合规则的提供者,接下里才是，集群容错和负载均衡。\n    List<Invoker<T>> invokers = list(invocation);\n    if (invokers != null && !invokers.isEmpty()) {\n        //通过key（loadbalance）从url中取值，默认值为random\n        loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl()                                                                                .getMethodParameter(RpcUtils.getMethodName(invocation), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));\n    }\n    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);\n    return doInvoke(invocation, invokers, loadbalance);\n}\n```\n\n再来看一下list方法：\n\n```java\nprotected List<Invoker<T>> list(Invocation invocation) throws RpcException {\n    //directory.list(invocation)获取invokers，这里directory是RegistryDirectory\n    List<Invoker<T>> invokers = directory.list(invocation);\n    return invokers;\n}\n```\n\n跟到RegistryDirectory类的list方法，实现在其父类AbstractDirectory中，主要是**生成路由规则**（将会在另一篇文章中详细讲解，敬请期待）：\n\n```java\n@Override\npublic List<Invoker<T>> list(Invocation invocation) throws RpcException {\n    if (destroyed) {\n        throw new RpcException(\"Directory already destroyed .url: \" + getUrl());\n    }\n    //获取所有的提供者\n    List<Invoker<T>> invokers = doList(invocation);\n    //本地路由规则\n    List<Router> localRouters = this.routers; // local reference\n    if (localRouters != null && !localRouters.isEmpty()) {\n        for (Router router : localRouters) {\n            try {\n                if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {\n                    //Router接口，实现route的方法，路由获取服务提供者\n                    invokers = router.route(invokers, getConsumerUrl(), invocation);\n                }\n            } catch (Throwable t) {\n                logger.error(\"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(), t);\n            }\n        }\n    }\n    return invokers;\n}\n```\n\n再来看一下doList方法，它是个抽象方法具体实现在RegistryDirectory类中：\n\n```java\n@Override\npublic List<Invoker<T>> doList(Invocation invocation) {\n    //没有服务提供者或者服务提供者被禁用\n    if (forbidden) {\n        // 1. No service provider 2. Service providers are disabled\n        throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,\n                               \"No provider available from registry \" + getUrl().getAddress() + \" for service \" + getConsumerUrl().getServiceKey() + \" on consumer \" + NetUtils.getLocalHost()\n                               + \" use dubbo version \" + Version.getVersion() + \", please check status of providers(disabled, not registered or in blacklist).\");\n    }\n    List<Invoker<T>> invokers = null;\n    //从这里搜索methodInvokerMap赋值，在refreshInvoker方法里\n    Map<String, List<Invoker<T>>> localMethodInvokerMap = this.methodInvokerMap; // local reference\n    if (localMethodInvokerMap != null && localMethodInvokerMap.size() > 0) {\n        String methodName = RpcUtils.getMethodName(invocation);\n        Object[] args = RpcUtils.getArguments(invocation);\n        if (args != null && args.length > 0 && args[0] != null\n            && (args[0] instanceof String || args[0].getClass().isEnum())) {\n            invokers = localMethodInvokerMap.get(methodName + \".\" + args[0]); // The routing can be enumerated according to the first parameter\n        }\n        if (invokers == null) {\n            invokers = localMethodInvokerMap.get(methodName);\n        }\n        if (invokers == null) {\n            invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);\n        }\n        if (invokers == null) {\n            Iterator<List<Invoker<T>>> iterator = localMethodInvokerMap.values().iterator();\n            if (iterator.hasNext()) {\n                invokers = iterator.next();\n            }\n        }\n    }\n    return invokers == null ? new ArrayList<Invoker<T>>(0) : invokers;\n}\n```\n\n下面是`refreshInvoker(List<URL> invokerUrls)`方法的实现：\n\n```java\n/**\n     * Convert the invokerURL list to the Invoker Map. The rules of the conversion are as follows:\n     * 1.If URL has been converted to invoker, it is no longer re-referenced and obtained directly from the cache, and notice that any parameter changes in the URL will be re-referenced.\n     * 2.If the incoming invoker list is not empty, it means that it is the latest invoker list\n     * 3.If the list of incoming invokerUrl is empty, It means that the rule is only a override rule or a route rule, which needs to be re-contrasted to decide whether to re-reference.\n     *\n     * @param invokerUrls this parameter can't be null\n     */\n// TODO: 2017/8/31 FIXME The thread pool should be used to refresh the address, otherwise the task may be accumulated.\nprivate void refreshInvoker(List<URL> invokerUrls) {\n    if (invokerUrls != null && invokerUrls.size() == 1 && invokerUrls.get(0) != null\n        && Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {\n        //禁止访问\n        this.forbidden = true; // Forbid to access\n        //置空列表\n        this.methodInvokerMap = null; // Set the method invoker map to null\n        //关闭所有invokers\n        destroyAllInvokers(); // Close all invokers\n    } else {\n        //允许访问\n        this.forbidden = false; // Allow to access\n        Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap; // local reference\n        if (invokerUrls.isEmpty() && this.cachedInvokerUrls != null) {\n            invokerUrls.addAll(this.cachedInvokerUrls);\n        } else {\n            this.cachedInvokerUrls = new HashSet<URL>();\n            //缓存invokerUrls列表，便于交叉对比\n            this.cachedInvokerUrls.addAll(invokerUrls);//Cached invoker urls, convenient for comparison\n        }\n        if (invokerUrls.isEmpty()) {\n            return;\n        }\n        //生成invoker方法 toInvokers\n        //将url列表转换成invoker列表\n        Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map\n        //换方法名映射invoker列表\n        Map<String, List<Invoker<T>>> newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); // Change method name to map Invoker Map\n        // state change\n        // If the calculation is wrong, it is not processed.\n        //如果计算错误则不进行处理\n        if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {\n            logger.error(new IllegalStateException(\"urls to invokers error .invokerUrls.size :\" + invokerUrls.size() + \", invoker.size :0. urls :\" + invokerUrls.toString()));\n            return;\n        }\n        this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;\n        this.urlInvokerMap = newUrlInvokerMap;\n        try {\n            //关闭不使用的invoker\n            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker\n        } catch (Exception e) {\n            logger.warn(\"destroyUnusedInvokers error. \", e);\n        }\n    }\n}\n```\n\n可以知道refreshInvoker()方法会在RegistryDirectory类的notify()方法里调用，这个方法是**订阅注册中心的回调方法**。下面来看一下toInvokers()的方法实现：\n\n```java\n/**\n     * Turn urls into invokers, and if url has been refer, will not re-reference.\n     * 将urls转换成invokers，如果url已经被refer过则不在重新引用\n     * @param urls\n     * @return invokers\n     */\nprivate Map<String, Invoker<T>> toInvokers(List<URL> urls) {\n    Map<String, Invoker<T>> newUrlInvokerMap = new HashMap<String, Invoker<T>>();\n    if (urls == null || urls.isEmpty()) {\n        return newUrlInvokerMap;\n    }\n    Set<String> keys = new HashSet<String>();\n    String queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY);\n    for (URL providerUrl : urls) {\n        // If protocol is configured at the reference side, only the matching protocol is selected\n        //若果reference端配置了protocol，则只选择匹配的protocol\n        if (queryProtocols != null && queryProtocols.length() > 0) {\n            boolean accept = false;\n            String[] acceptProtocols = queryProtocols.split(\",\");\n            for (String acceptProtocol : acceptProtocols) {\n                if (providerUrl.getProtocol().equals(acceptProtocol)) {\n                    accept = true;\n                    break;\n                }\n            }\n            if (!accept) {\n                continue;\n            }\n        }\n        if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {\n            continue;\n        }\n        if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {\n            logger.error(new IllegalStateException(\"Unsupported protocol \" + providerUrl.getProtocol() + \" in notified url: \" + providerUrl + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost()\n                                                   + \", supported protocol: \" + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));\n            continue;\n        }\n        URL url = mergeUrl(providerUrl);\n\t\t//url参数是排序的\n        String key = url.toFullString(); // The parameter urls are sorted\n        //跳过重复的url\n        if (keys.contains(key)) { // Repeated url\n            continue;\n        }\n        keys.add(key);\n        // Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again\n        //缓存key为没有合并消费端参数的URL，不管消费端如何合并参数，如果服务端URL发生变化，则重新refer\n        Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap; // local reference\n        Invoker<T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);\n        if (invoker == null) { // Not in the cache, refer again\n            try {\n                boolean enabled = true;\n                if (url.hasParameter(Constants.DISABLED_KEY)) {\n                    enabled = !url.getParameter(Constants.DISABLED_KEY, false);\n                } else {\n                    enabled = url.getParameter(Constants.ENABLED_KEY, true);\n                }\n                if (enabled) {\n                    //创建invoker（这里创建invoker）\n                    invoker = new InvokerDelegate<T>(protocol.refer(serviceType, url), url, providerUrl);\n                }\n            } catch (Throwable t) {\n                logger.error(\"Failed to refer invoker for interface:\" + serviceType + \",url:(\" + url + \")\" + t.getMessage(), t);\n            }\n            if (invoker != null) { // Put new invoker in cache\n                //将新的引用放入缓存\n                newUrlInvokerMap.put(key, invoker);\n            }\n        } else {\n            newUrlInvokerMap.put(key, invoker);\n        }\n    }\n    keys.clear();\n    return newUrlInvokerMap;\n}\n```\n\n找到了invoker的创建地方，来看下InvokerDelegate，它是RegistryDirectory的内部类：\n\n```java\n/**\n     * The delegate class, which is mainly used to store the URL address sent by the registry,and can be reassembled on the basis of providerURL queryMap overrideMap for re-refer.\n     * 代理类，主要用于存储注册中心下发的URL地址\n     * 用于重新refer时能够根据providerURL queryMap overrideMap重新组装\n     * @param <T>\n     */\nprivate static class InvokerDelegate<T> extends InvokerWrapper<T> {\n    private URL providerUrl;\n\n    public InvokerDelegate(Invoker<T> invoker, URL url, URL providerUrl) {\n        //调用父类构造方法\n        super(invoker, url);\n        this.providerUrl = providerUrl;\n    }\n\n    public URL getProviderUrl() {\n        return providerUrl;\n    }\n}\n```\n\ninvoke方法在父类InvokerWrapper里实现的：\n\n```java\n@Override\npublic Result invoke(Invocation invocation) throws RpcException {\n    //这里的invoker是从它的构造方法里传入的\n    return invoker.invoke(invocation);\n}\n```\n\n所以在调用栈里可以看到如下一条信息：\n\n```\nat org.apache.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:56)\n```\n\nInvokerDelegete构造方法调用的父类InvokerWrapper的构造方法并传入invoker实例，回头看`new InvokerDelegate<T>(protocol.refer(serviceType, url), url, providerUrl);`这句，可知上面的invoker的是由`protocol.refer(serviceType, url)`创建的。\n\n通过debug可得知这里的protocol是Protocol$Adaptive类型的，这里的url的protocol是dubbo，通过Dubbo SPI机制可以得到这里最后走DubboProtocol类的refer()方法，但是由于Protocol接口实现中由两个包装类：\n\n```\nfilter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper\nlistener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper\n```\n\n所以这里先执行ProtocolFilterWrapper的refer方法，再执行ProtocolListenerWrapper的refer方法，最后才执行DubboProtocol类的refer方法，ProtocolFilterWrapper类的refer方法如下：\n\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n        return protocol.refer(type, url);\n    }\n    return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);\n}\n```\n\n方法里调用了buildInvokerChain()方法：\n\n```java\nprivate static <T> Invoker<T> buildInvokerChain(final Invoker<T> invoker, String key, String group) {\n    Invoker<T> last = invoker;\n    //先获取激活的过滤器，我们这里手动配置了monitor MonitorFilter过滤器\n    //另外两个自动激活的过滤器是FutureFilter，ConsumerContextFilter\n    //这里需要看SPI机制的getActivateExtension方法的相关代码\n    List<Filter> filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);\n    if (!filters.isEmpty()) {\n        for (int i = filters.size() - 1; i >= 0; i--) {\n            final Filter filter = filters.get(i);\n            final Invoker<T> next = last;\n            last = new Invoker<T>() {\n\n                @Override\n                public Class<T> getInterface() {\n                    return invoker.getInterface();\n                }\n\n                @Override\n                public URL getUrl() {\n                    return invoker.getUrl();\n                }\n\n                @Override\n                public boolean isAvailable() {\n                    return invoker.isAvailable();\n                }\n\t\t\t\t//实现invoker的invoke方法\n                @Override\n                public Result invoke(Invocation invocation) throws RpcException {\n                    //嵌套进过滤器链\n                    return filter.invoke(next, invocation);\n                }\n\n                @Override\n                public void destroy() {\n                    invoker.destroy();\n                }\n\n                @Override\n                public String toString() {\n                    return invoker.toString();\n                }\n            };\n        }\n    }\n    return last;\n}\n```\n\n所以有如下的调用栈信息：\n\n```\nat org.apache.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75)\nat org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)\nat org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:47)\nat org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)\nat org.apache.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:50)\nat org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)\n```\n\n接着ProtocolListenerWrapper的refer方法：\n\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n        return protocol.refer(type, url);\n    }\n    //获取激活的监听器，目前dubbo没有提供合适的监听器，只有一个DeprecatedInvokerListener实现类，并且还是Deprecated的\n    return new ListenerInvokerWrapper<T>(protocol.refer(type, url),\n                                         Collections.unmodifiableList(\n                                             ExtensionLoader.getExtensionLoader(InvokerListener.class)\n                                             .getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)));\n}\n```\n\n所以会出现如下栈信息：\n\n```\nat org.apache.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:77)\n```\n\n\n\n最后看一下DubboProtocol类的refer方法，这里创建了DubboInvoker对象：\n\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {\n    optimizeSerialization(url);\n    // create rpc invoker.\n    DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);\n    invokers.add(invoker);\n    return invoker;\n}\n```\n\nDubboInvoker的父类AbstractInvoker实现了invoke方法：\n\n```java\n@Override\npublic Result invoke(Invocation inv) throws RpcException {\n    if (destroyed.get()) {\n        throw new RpcException(\"Rpc invoker for service \" + this + \" on consumer \" + NetUtils.getLocalHost()\n                               + \" use dubbo version \" + Version.getVersion()\n                               + \" is DESTROYED, can not be invoked any more!\");\n    }\n    RpcInvocation invocation = (RpcInvocation) inv;\n    invocation.setInvoker(this);\n    if (attachment != null && attachment.size() > 0) {\n        invocation.addAttachmentsIfAbsent(attachment);\n    }\n    Map<String, String> contextAttachments = RpcContext.getContext().getAttachments();\n    if (contextAttachments != null && contextAttachments.size() != 0) {\n        /**\n             * invocation.addAttachmentsIfAbsent(context){@link RpcInvocation#addAttachmentsIfAbsent(Map)}should not be used here,\n             * because the {@link RpcContext#setAttachment(String, String)} is passed in the Filter when the call is triggered\n             * by the built-in retry mechanism of the Dubbo. The attachment to update RpcContext will no longer work, which is\n             * a mistake in most cases (for example, through Filter to RpcContext output traceId and spanId and other information).\n             */\n        invocation.addAttachments(contextAttachments);\n    }\n    if (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false)) {\n        invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());\n    }\n    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);\n\n\n    try {\n        //doInvoke()方法具体实现在子类中\n        return doInvoke(invocation);\n    } catch (InvocationTargetException e) { // biz exception\n        Throwable te = e.getTargetException();\n        if (te == null) {\n            return new RpcResult(e);\n        } else {\n            if (te instanceof RpcException) {\n                ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);\n            }\n            return new RpcResult(te);\n        }\n    } catch (RpcException e) {\n        if (e.isBiz()) {\n            return new RpcResult(e);\n        } else {\n            throw e;\n        }\n    } catch (Throwable e) {\n        return new RpcResult(e);\n    }\n}\n```\n\n看一下DubboInvoker实现的doInvoke方法：\n\n```java\n@Override\nprotected Result doInvoke(final Invocation invocation) throws Throwable {\n    RpcInvocation inv = (RpcInvocation) invocation;\n    final String methodName = RpcUtils.getMethodName(invocation);\n    inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());\n    inv.setAttachment(Constants.VERSION_KEY, version);\n\n    ExchangeClient currentClient;\n    if (clients.length == 1) {\n        currentClient = clients[0];\n    } else {\n        currentClient = clients[index.getAndIncrement() % clients.length];\n    }\n    try {\n        boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);\n        boolean isAsyncFuture = RpcUtils.isGeneratedFuture(inv) || RpcUtils.isFutureReturnType(inv);\n        boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);\n        int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n        if (isOneway) {\n            boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);\n            currentClient.send(inv, isSent);\n            RpcContext.getContext().setFuture(null);\n            return new RpcResult();\n        } else if (isAsync) {\n            ResponseFuture future = currentClient.request(inv, timeout);\n            // For compatibility\n            FutureAdapter<Object> futureAdapter = new FutureAdapter<>(future);\n            RpcContext.getContext().setFuture(futureAdapter);\n\n            Result result;\n            if (isAsyncFuture) {\n                // register resultCallback, sometimes we need the asyn result being processed by the filter chain.\n                result = new AsyncRpcResult(futureAdapter, futureAdapter.getResultFuture(), false);\n            } else {\n                result = new SimpleAsyncRpcResult(futureAdapter, futureAdapter.getResultFuture(), false);\n            }\n            return result;\n        } else {\n            RpcContext.getContext().setFuture(null);\n            return (Result) currentClient.request(inv, timeout).get();\n        }\n    } catch (TimeoutException e) {\n        throw new RpcException(RpcException.TIMEOUT_EXCEPTION, \"Invoke remote method timeout. method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e);\n    } catch (RemotingException e) {\n        throw new RpcException(RpcException.NETWORK_EXCEPTION, \"Failed to invoke remote method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e);\n    }\n}\n```\n\n所以会有这两句线程栈输出：\n\n```\nat org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:108)\nat org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:154)\n```\n\n接下来就是用于发送请求的currentClient对象的实现了，它的逻辑可以追踪到DubboProtocol类的refer方法里：\n\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {\n    optimizeSerialization(url);\n    // create rpc invoker.\n    DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);\n    invokers.add(invoker);\n    return invoker;\n}\n```\n\n具体的获取逻辑在getClients()方法中：\n\n```java\nprivate ExchangeClient[] getClients(URL url) {\n    // whether to share connection\n    //是否共享连接\n    boolean service_share_connect = false;\n    int connections = url.getParameter(Constants.CONNECTIONS_KEY, 0);\n    // if not configured, connection is shared, otherwise, one connection for one service\n    //如果没有配置connection，那么就创建共享连接，否则一个服务一个连接？\n    if (connections == 0) {\n        service_share_connect = true;\n        connections = 1;\n    }\n\n    ExchangeClient[] clients = new ExchangeClient[connections];\n    for (int i = 0; i < clients.length; i++) {\n        if (service_share_connect) {\n            clients[i] = getSharedClient(url);\n        } else {\n            clients[i] = initClient(url);\n        }\n    }\n    return clients;\n}\n/**\n     * Get shared connection\n     */\nprivate ExchangeClient getSharedClient(URL url) {\n    String key = url.getAddress();\n    ReferenceCountExchangeClient client = referenceClientMap.get(key);\n    if (client != null) {\n        if (!client.isClosed()) {\n            client.incrementAndGetCount();\n            return client;\n        } else {\n            referenceClientMap.remove(key);\n        }\n    }\n\n    locks.putIfAbsent(key, new Object());\n    synchronized (locks.get(key)) {\n        if (referenceClientMap.containsKey(key)) {\n            return referenceClientMap.get(key);\n        }\n\n        ExchangeClient exchangeClient = initClient(url);\n        client = new ReferenceCountExchangeClient(exchangeClient, ghostClientMap);\n        referenceClientMap.put(key, client);\n        ghostClientMap.remove(key);\n        locks.remove(key);\n        return client;\n    }\n}\n/**\n     * Create new connection\n     */\nprivate ExchangeClient initClient(URL url) {\n\n    // client type setting.\n    String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));\n\n    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);\n    // enable heartbeat by default\n    //默认开启heartbeat\n    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));\n\n    // BIO is not allowed since it has severe performance issue.\n    //BIO存在严重的性能问题，因此不能使用\n    if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {\n        throw new RpcException(\"Unsupported client type: \" + str + \",\" +\n                               \" supported client type is \" + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), \" \"));\n    }\n\n    ExchangeClient client;\n    try {\n        // connection should be lazy\n        if (url.getParameter(Constants.LAZY_CONNECT_KEY, false)) {\n            client = new LazyConnectExchangeClient(url, requestHandler);\n        } else {\n            //通过 Exchangers.connect(url, requestHandler); 构建client ，接下来跟踪Exchangers.connect方法\n\t\t    //这里会传入一个requestHandler，这个是客户端解救服务端方法返回回调的\n            client = Exchangers.connect(url, requestHandler);\n        }\n    } catch (RemotingException e) {\n        throw new RpcException(\"Fail to create remoting client for service(\" + url + \"): \" + e.getMessage(), e);\n    }\n    return client;\n}\n```\n\n这里用到了**Facade设计模式，Exchangers是个门面类**，封装了具体查找合适的Exchanger实现，并调用connect方法返回ExchangeClient的过程，相关代码如下：\n\n```java\npublic static ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {\n    if (url == null) {\n        throw new IllegalArgumentException(\"url == null\");\n    }\n    if (handler == null) {\n        throw new IllegalArgumentException(\"handler == null\");\n    }\n    url = url.addParameterIfAbsent(Constants.CODEC_KEY, \"exchange\");\n    //把codec key设置为exchange\n    return getExchanger(url).connect(url, handler);\n}\n\npublic static Exchanger getExchanger(URL url) {\n    String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);\n    //通过exchanger key 获取 Exchanger的spi实现，默认是header，这里是HeaderExchanger类\n    return getExchanger(type);\n}\n\npublic static Exchanger getExchanger(String type) {\n    //这里返回Exchanger接口的header扩展类的HeaderExchanger\n    return ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);\n}\n```\n\n看一下HeaderExchanger类的connect方法：\n\n```java\n//客户端的连接操作\n@Override\npublic ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {\n    return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true);\n}\n```\n\n所以有栈信息：\n\n```\nat org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeClient.request(HeaderExchangeClient.java:90)\n```\n\n再来看HeaderExchnageClient的request()方法：\n\n```java\npublic HeaderExchangeClient(Client client, boolean needHeartbeat) {\n    if (client == null) {\n        throw new IllegalArgumentException(\"client == null\");\n    }\n    this.client = client;\n    //初始化HeaderExchangeChannel\n    this.channel = new HeaderExchangeChannel(client);\n    String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);\n    this.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != null && dubbo.startsWith(\"1.0.\") ? Constants.DEFAULT_HEARTBEAT : 0);\n    this.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * 3);\n    if (heartbeatTimeout < heartbeat * 2) {\n        throw new IllegalStateException(\"heartbeatTimeout < heartbeatInterval * 2\");\n    }\n    if (needHeartbeat) {\n        startHeartbeatTimer();\n    }\n}\n\n@Override\npublic ResponseFuture request(Object request) throws RemotingException {\n    //调用Channel的request方法\n    return channel.request(request);\n}\n```\n\n因此会有如下的栈信息：\n\n```\nat org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.request(HeaderExchangeChannel.java:116)\n```\n\n再来看一下HeaderExchangeChannel的request方法：\n\n```java\n@Override\npublic ResponseFuture request(Object request) throws RemotingException {\n    return request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));\n}\n\n@Override\npublic ResponseFuture request(Object request, int timeout) throws RemotingException {\n    if (closed) {\n        throw new RemotingException(this.getLocalAddress(), null, \"Failed to send request \" + request + \", cause: The channel \" + this + \" is closed!\");\n    }\n    // create request.\n    Request req = new Request();\n    req.setVersion(Version.getProtocolVersion());\n    req.setTwoWay(true);\n    req.setData(request);\n    DefaultFuture future = new DefaultFuture(channel, req, timeout);\n    try {\n        //发送请求\n        channel.send(req);\n    } catch (RemotingException e) {\n        future.cancel();\n        throw e;\n    }\n    return future;\n}\n```\n\n`channel.send(req);`中channel实例是通过`HeaderExchangeChannel(Channel channel)`构造函数初始化的，继续往上看是通过构造函数`public HeaderExchangeClient(Client client, boolean needHeartbeat)`传进来的，最终生成channel的代码是在类`HeaderExchanger`中：\n\n```java\n@Override\npublic ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {\n    return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true);\n}\n```\n\n调用`Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler)))`生成channel实例，**这里Transporters也是个门面类，是Facade设计模式的实现**，继续分析Transporters的connect方法：\n\n```Java\npublic static Client connect(URL url, ChannelHandler... handlers) throws RemotingException {\n    if (url == null) {\n        throw new IllegalArgumentException(\"url == null\");\n    }\n    ChannelHandler handler;\n    if (handlers == null || handlers.length == 0) {\n        handler = new ChannelHandlerAdapter();\n    } else if (handlers.length == 1) {\n        handler = handlers[0];\n    } else {\n        handler = new ChannelHandlerDispatcher(handlers);\n    }\n    //所以这里默认返回的NettyClient\n    return getTransporter().connect(url, handler);\n}\n//这个方法根据spi返回NettyTransporter扩展类\npublic static Transporter getTransporter() {\n    //生成Transporter$Adaptive类\n    return ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();\n}\n```\n\n所以最后是通过NettyClient类实例的send方法发送具体请求，NettyClient类的send方法在其祖先类AbstractPeer中：\n\n```java\n@Override\npublic void send(Object message) throws RemotingException {\n    send(message, url.getParameter(Constants.SENT_KEY, false));\n}\n```\n\n这个实现又调用NettyClient父类AbstractClient的send方法实现：\n\n```Java\n@Override\npublic void send(Object message, boolean sent) throws RemotingException {\n    if (send_reconnect && !isConnected()) {\n        connect();\n    }\n    //获取具体的channel实例\n    Channel channel = getChannel();\n    //TODO Can the value returned by getChannel() be null? need improvement.\n    if (channel == null || !channel.isConnected()) {\n        throw new RemotingException(this, \"message can not send, because channel is closed . url:\" + getUrl());\n    }\n    channel.send(message, sent);\n}\n```\n\n这里的getChannel()方法由NettyClient自身实现，如下：\n\n```java\n@Override\nprotected org.apache.dubbo.remoting.Channel getChannel() {\n    Channel c = channel;\n    if (c == null || !c.isActive())\n        return null;\n    return NettyChannel.getOrAddChannel(c, getUrl(), this);\n}\n```\n\n所以有如下栈信息：\n\n```\nat org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:101)\nat org.apache.dubbo.remoting.transport.AbstractClient.send(AbstractClient.java:265)\nat org.apache.dubbo.remoting.transport.AbstractPeer.send(AbstractPeer.java:53)\n```\n\n最后就走到NettyChannel的send方法，即到了断点处：\n\n```java\n@Override\npublic void send(Object message, boolean sent) throws RemotingException {\n    super.send(message, sent);\n\n    boolean success = true;\n    int timeout = 0;\n    try {\n        //断点处\n        ChannelFuture future = channel.writeAndFlush(message);\n        if (sent) {\n            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n            success = future.await(timeout);\n        }\n        Throwable cause = future.cause();\n        if (cause != null) {\n            throw cause;\n        }\n    } catch (Throwable e) {\n        throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress() + \", cause: \" + e.getMessage(), e);\n    }\n\n    if (!success) {\n        throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress()\n                                    + \"in timeout(\" + timeout + \"ms) limit\");\n    }\n}\n```\n\n到此，整个消费者调用过程就分析完了，文章中提到的一些关于Dubbo的核心feature将会写文章进一步分析，敬请期待。\n","source":"_posts/dubbo-consumer-calling-process-source-code-analysis.md","raw":"---\ntitle: Dubbo消费者调用过程源码分析\ndate: 2018-08-05 14:11:36\ntags:\n    - dubbo\n---\n\n在分析Dubbo RPC服务调用过程之前，我们先写一个基于Dubbo实现的[**Consumer-Provider的Demo**](https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo)，通过这个Demo来分析具体的RPC调用栈。\n\n先定义一个接口：\n\n```java\n/**\n * @author Junlan Shuai[shuaijunlan@gmail.com].\n * @date Created on 11:02 AM 2018/07/19.\n */\npublic interface ITestService {\n    String sayHello(String msg);\n}\n```\n\n我们基于zookeeper注册中心，服务端配置如下：\n\n```xml\n<dubbo:application name=\"dubbo-server\" owner=\"Junlan\" />\n<dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/>\n<!--protocal configuration-->\n<dubbo:protocol name=\"dubbo\" port=\"20881\"/>\n<dubbo:provider server=\"netty\"/>\n<!--service configuration-->\n<dubbo:service interface=\"cn.shuaijunlan.dubbo.learning.service.ITestService\" ref=\"testService\" protocol=\"dubbo\" loadbalance=\"roundrobin\"/>\n<bean class=\"cn.shuaijunlan.dubbo.learning.service.impl.TestServiceImpl\" name=\"testService\" />\n```\n\n客户端配置如下：\n\n```xml\n<dubbo:application name=\"dubbo-client\" owner=\"Junlan\"/>\n<dubbo:consumer client=\"netty\"/>\n<dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/>\n<dubbo:reference interface=\"cn.shuaijunlan.dubbo.learning.service.ITestService\" id=\"testService\" check=\"false\"/>\n```\n\n<!-- more -->\n\n项目的部分依赖如下：\n\n```xml\n<dependency>\n    <groupId>org.apache.dubbo</groupId>\n    <artifactId>dubbo</artifactId>\n    <version>2.7.0-SNAPSHOT</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.curator</groupId>\n    <artifactId>curator-framework</artifactId>\n    <version>2.12.0</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.zookeeper</groupId>\n    <artifactId>zookeeper</artifactId>\n    <version>3.4.9</version>\n</dependency>\n```\n\n具体的服务提供者实现参照[**service-provider-a**](https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo/service-provider-a) ，服务消费者实现参照[**dubbo-client-demo**](https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo/dubbo-client-demo)。\n\n先启动服务提供者服务，下面分析在哪打断点：\n\n我们看下`org.apache.dubbo.remoting.transport.netty4.NettyChannel`的`send`方法：\n\n```java\n@Override\npublic void send(Object message, boolean sent) throws RemotingException {\n    super.send(message, sent);\n\n    boolean success = true;\n    int timeout = 0;\n    try {\n        //向远程服务发送消息，因此我们在这句打个断点\n        ChannelFuture future = channel.writeAndFlush(message);\n        if (sent) {\n            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n            success = future.await(timeout);\n        }\n        Throwable cause = future.cause();\n        if (cause != null) {\n            throw cause;\n        }\n    } catch (Throwable e) {\n        throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress() + \", cause: \" + e.getMessage(), e);\n    }\n\n    if (!success) {\n        throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress()\n                                    + \"in timeout(\" + timeout + \"ms) limit\");\n    }\n}\n```\n\n我们在`ChannelFuture future = channel.writeAndFlush(message);`这句打个断点，Debug服务消费者，得到如下线程栈信息：\n\n```\n\"main@1\" prio=5 tid=0x1 nid=NA runnable\n  java.lang.Thread.State: RUNNABLE\n\t  at org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:101)\n\t  at org.apache.dubbo.remoting.transport.AbstractClient.send(AbstractClient.java:265)\n\t  at org.apache.dubbo.remoting.transport.AbstractPeer.send(AbstractPeer.java:53)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.request(HeaderExchangeChannel.java:116)\n\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeClient.request(HeaderExchangeClient.java:90)\n\t  at org.apache.dubbo.rpc.protocol.dubbo.ReferenceCountExchangeClient.request(ReferenceCountExchangeClient.java:83)\n\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:108)\n\t  at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:154)\n\t  at org.apache.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:77)\n\t  at org.apache.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)\n\t  at org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:47)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)\n\t  at org.apache.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:50)\n\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)\n\t  at org.apache.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:56)\n\t  at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:78)\n\t  at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:243)\n\t  at org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:75)\n\t  at org.apache.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:70)\n\t  at org.apache.dubbo.common.bytecode.proxy0.sayHello(proxy0.java:-1)\n\t  at cn.shuaijunlan.dubbo.learning.main.Main.main(Main.java:16)\n```\n\n自底向上，可以直观的看到服务消费者调用要经过的类和方法，下面将进行一步步分析，对每一个类的创建过程和调用过程做出解析：\n\n* 第一行栈信息\n\n```\nat cn.shuaijunlan.dubbo.learning.main.Main.main(Main.java:16)\n```\n\nMain.java 类是消费者端的启动类，可以忽略。\n\n* 第二行栈信息\n\n```\nat org.apache.dubbo.common.bytecode.proxy0.sayHello(proxy0.java:-1)\n```\n\n`org.apache.dubbo.common.bytecode.proxy0`类是一个代理类，它代理了所有RPC服务接口的方法调用。这个类实例是什么时候创建的？类代码是怎样的？\n\n**Dubbo基于Spring的构建分析**（参考文章[**《基于Spring构建Dubbo源码分析》**](https://shuaijunlan.github.io/2018/08/13/dubbo-basing-on-spring-framework-analysis/)）， 代理类的创建是由ReferenceBean类的\n\n```java\npublic Object getObject() throws Exception {\n    return get();\n}\n```\n\n方法里触发的，具体的实现在ReferenceConfig类createProxy方法里\n\n```java\n@SuppressWarnings({\"unchecked\", \"rawtypes\", \"deprecation\"})\nprivate T createProxy(Map<String, String> map) {\n    // ...\n    // 用于生成invoker的逻辑，关于invoker生成逻辑这里先忽略，后面会说到\n    // ...\n    // create service proxy\n    return (T) proxyFactory.getProxy(invoker);\n}\n```\n\nproxyFactory变量赋值为\n\n```java\nprivate static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();\n```\n\n**Dubbo SPI机制**(参考文章[**《Dubbo SPI机制源码分析》**](https://shuaijunlan.github.io/2018/08/09/dubbo-spi-analysis/))里可以得到ProxyFactory接口的Adaptive类的getProxy方法源码如下：\n\n```java\npackage org.apache.dubbo.rpc;\n\nimport org.apache.dubbo.common.extension.ExtensionLoader;\n\npublic class ProxyFactory$Adaptive implements org.apache.dubbo.rpc.ProxyFactory {\n    public java.lang.Object getProxy(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException {\n        if (arg0 == null) throw new IllegalArgumentException(\"org.apache.dubbo.rpc.Invoker argument == null\");\n        if (arg0.getUrl() == null)\n            throw new IllegalArgumentException(\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\");\n        org.apache.dubbo.common.URL url = arg0.getUrl();\n        String extName = url.getParameter(\"proxy\", \"javassist\");\n        if (extName == null)\n            throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n        return extension.getProxy(arg0);\n    }\n\n    public java.lang.Object getProxy(org.apache.dubbo.rpc.Invoker arg0, boolean arg1) throws org.apache.dubbo.rpc.RpcException {\n        if (arg0 == null) throw new IllegalArgumentException(\"org.apache.dubbo.rpc.Invoker argument == null\");\n        if (arg0.getUrl() == null)\n            throw new IllegalArgumentException(\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\");\n        org.apache.dubbo.common.URL url = arg0.getUrl();\n        String extName = url.getParameter(\"proxy\", \"javassist\");\n        if (extName == null)\n            throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n        return extension.getProxy(arg0, arg1);\n    }\n\n    public org.apache.dubbo.rpc.Invoker getInvoker(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2) throws org.apache.dubbo.rpc.RpcException {\n        if (arg2 == null) throw new IllegalArgumentException(\"url == null\");\n        org.apache.dubbo.common.URL url = arg2;\n        String extName = url.getParameter(\"proxy\", \"javassist\");\n        if (extName == null)\n            throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.rpc.ProxyFactory) name from url(\" + url.toString() + \") use keys([proxy])\");\n        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n        return extension.getInvoker(arg0, arg1, arg2);\n    }\n}\n```\n\n在如上`ProxyFactory$Adaptive`类中，调用`getProxy(org.apache.dubbo.rpc.Invoker arg0) `方法，其中：\n\n```java\nString extName = url.getParameter(\"proxy\", \"javassist\");\norg.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);\n```\n\n默认获取ProxyFactory接口的javassist扩展类JavassistProxyFactory，先调用`JavassitProxyFactory`的父类ProxyFactory的`getProxy(Invoker<T> invoker)`方法和`getProxy(Invoker<T> invoker, boolean generic)`方法：\n\n```java\n@Override\npublic <T> T getProxy(Invoker<T> invoker) throws RpcException {\n    return getProxy(invoker, false);\n}\n```\n\n再调用`JavassistProxyFactory`类的`getProxy(Invoker<T> invoker, Class<?>[] interfaces)`方法：\n\n```java\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T getProxy(Invoker<T> invoker, Class<?>[] interfaces) {\n    return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n}\n```\n\n再到**生成代理类的Proxy类**（具体过程在另一篇文章中详细分析）\n\n```java\n/**\n     * Get proxy.\n     *\n     * @param ics interface class array.\n     * @return Proxy instance.\n     */\npublic static Proxy getProxy(Class<?>... ics) {\n    return getProxy(ClassHelper.getClassLoader(Proxy.class), ics);\n}\n```\n\n这里直接贴出**通过代码hack生成的代理类**源码，这里动态生成了两个类：\n\n```java\npackage com.alibaba.dubbo.common.bytecode;\n\nimport com.alibaba.dubbo.common.bytecode.ClassGenerator.DC;\n\nimport java.lang.reflect.InvocationHandler;\n\npublic class Proxy0 extends Proxy implements DC {\n    public Object newInstance(InvocationHandler var1) {\n        return new proxy01(var1);\n    }\n\n    public Proxy0_my() {\n    }\n}\n```\n\n这个类继承抽象类Proxy，实现了它的抽象方法newInstance，**接口DC是Dubbo内部作为动态类标示的接口**；\n\n还有一个proxy01，就是在开始方法栈里看到的代理类，源码如下：\n\n```java\npackage com.alibaba.dubbo.common.bytecode;\n\nimport com.alibaba.dubbo.rpc.service.EchoService;\nimport demo.dubbo.api.DemoService;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n\npublic class proxy01 implements ClassGenerator.DC, EchoService, DemoService {\n    public static Method[] methods;\n    private InvocationHandler handler;\n    //实现了接口方法\n    public String sayHello(String var1) {\n        Object[] var2 = new Object[]{var1};\n        Object var3 = null;\n        try {\n            var3 = this.handler.invoke(this, methods[1], var2);\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n        }\n        return (String)var3;\n    }\n\n    public Object $echo(Object var1) {\n        Object[] var2 = new Object[]{var1};\n        Object var3 = null;\n        try {\n            var3 = this.handler.invoke(this, methods[3], var2);\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n        }\n        return (Object)var3;\n    }\n\n    public proxy01() {\n    }\n    //public 构造函数，这里handler是\n    //由Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker))语句传入的InvokerInvocationHandler对象\n    public proxy01(InvocationHandler var1) {\n        this.handler = var1;\n    }\n}\n```\n\n可以看到代理类实现类三个接口，`ClassGeneratr.DC`是Dubbo动态类标识接口，`DemoService`是实际的业务接口，这样代理就可以调用服务方法了，`EchoService`是回显测试接口，只有一个`$echo(Object var1)`法。\n\n```java\npackage org.apache.dubbo.rpc.service;\n\n/**\n * Echo service.\n * @export\n */\npublic interface EchoService {\n\n    /**\n     * echo test.\n     *\n     * @param message message.\n     * @return message.\n     */\n    Object $echo(Object message);\n\n}\n```\n\n它能为所有的Dubbo RPC服务加上一个回显测试方法。\n\n```java\n// 通过类型强制转换为EchoService，可以测试\nEchoService echoService = (EchoService) service;\nSystem.out.println(echoService.$echo(\"hello\"));\n```\n\n到这可以了解代理类生成的整个过程，可以看到sayHello方法的调用其实是调用`this.handler.invoke(this, methods[1], var2);`，因此这也解释了**线程栈中第三行信息**：\n\n```\nat org.apache.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:70)\n```\n\n再往下看`org.apache.dubbo.rpc.proxy.InvokerInvocationHandler`类：\n\n```java\npublic class InvokerInvocationHandler implements InvocationHandler {\n\n    private final Invoker<?> invoker;\n\t//通过构造函数传入invoker\n    public InvokerInvocationHandler(Invoker<?> handler) {\n        this.invoker = handler;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        String methodName = method.getName();\n        Class<?>[] parameterTypes = method.getParameterTypes();\n        // 如果是Object类方法\n        if (method.getDeclaringClass() == Object.class) {\n            //反射调用\n            return method.invoke(invoker, args);\n        }\n        // 对toString、hashCode、equals三个方法做了处理\n        if (\"toString\".equals(methodName) && parameterTypes.length == 0) {\n            return invoker.toString();\n        }\n        if (\"hashCode\".equals(methodName) && parameterTypes.length == 0) {\n            return invoker.hashCode();\n        }\n        if (\"equals\".equals(methodName) && parameterTypes.length == 1) {\n            return invoker.equals(args[0]);\n        }\n\n        RpcInvocation invocation;\n        if (RpcUtils.hasGeneratedFuture(method)) {\n            Class<?> clazz = method.getDeclaringClass();\n            String syncMethodName = methodName.substring(0, methodName.length() - Constants.ASYNC_SUFFIX.length());\n            Method syncMethod = clazz.getMethod(syncMethodName, method.getParameterTypes());\n            invocation = new RpcInvocation(syncMethod, args);\n            invocation.setAttachment(Constants.FUTURE_GENERATED_KEY, \"true\");\n            invocation.setAttachment(Constants.ASYNC_KEY, \"true\");\n        } else {\n            invocation = new RpcInvocation(method, args);\n            if (RpcUtils.hasFutureReturnType(method)) {\n                invocation.setAttachment(Constants.FUTURE_RETURNTYPE_KEY, \"true\");\n                invocation.setAttachment(Constants.ASYNC_KEY, \"true\");\n            }\n        }\n        return invoker.invoke(invocation).recreate();\n    }\n\n\n}\n```\n\n在这里的invoker对象，是通过InvokerInvocationHandler构造方法传入，而且InvokerInvocationHandler对象是由JavassistProxyFactory类的`getProxy(Invoker<T> invoker, Class<?>[] interfaces)`方法创建，回到调用`proxyFactory.getProxy(invoker);`的地方，即ReferenceConfig类的`createProxy(Map<String, String> map)`方法，以下部分是生成invoker的过程：\n\n```java\nif (isJvmRefer) {\n    URL url = new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);\n    invoker = refprotocol.refer(interfaceClass, url);\n    if (logger.isInfoEnabled()) {\n        logger.info(\"Using injvm service \" + interfaceClass.getName());\n    }\n} else {\n    if (url != null && url.length() > 0) { // user specified URL, could be peer-to-peer address, or register center's address.\n        String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);\n        if (us != null && us.length > 0) {\n            for (String u : us) {\n                URL url = URL.valueOf(u);\n                if (url.getPath() == null || url.getPath().length() == 0) {\n                    url = url.setPath(interfaceName);\n                }\n                if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n                    urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n                } else {\n                    urls.add(ClusterUtils.mergeUrl(url, map));\n                }\n            }\n        }\n    } else { // assemble URL from register center's configuration\n        //从注册中心获取配置URL\n        List<URL> us = loadRegistries(false);\n        if (us != null && !us.isEmpty()) {\n            for (URL u : us) {\n                URL monitorUrl = loadMonitor(u);\n                if (monitorUrl != null) {\n                    map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\n                }\n                urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n            }\n        }\n        if (urls.isEmpty()) {\n            throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config <dubbo:registry address=\\\"...\\\" /> to your spring config.\");\n        }\n    }\n    //只有一个直连地址或者一个注册中心配置地址\n    if (urls.size() == 1) {\n        //这里的urls.get(0)，可能是直连地址（默认为dubbo协议），也可能是register注册地址（zookeeper协议）\n        //示例中使用了zookeeper注册中心，因此会执行这一步\n        invoker = refprotocol.refer(interfaceClass, urls.get(0));\n    } else {//多个直连地址或者多个注册中心，甚至是两者的结合，执行这一步\n        List<Invoker<?>> invokers = new ArrayList<Invoker<?>>();\n        URL registryURL = null;\n        for (URL url : urls) {\n            //创建invoker放入invokers\n            invokers.add(refprotocol.refer(interfaceClass, url));\n            if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n                registryURL = url; // use last registry url\n            }\n        }\n        if (registryURL != null) { // registry url is available\n            // use AvailableCluster only when register's cluster is available\n            //这其中包括直连和注册中心混合或者都是注册中心两种情况，默认使用AvailableCluster集群策略\n            URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n            invoker = cluster.join(new StaticDirectory(u, invokers));\n        } else { // not a registry url\n            //多个直连的URL\n            invoker = cluster.join(new StaticDirectory(invokers));\n        }\n    }\n}\n```\n\n经过上面的分析，可以发现invoker是通过`refprotocol.refer(interfaceClass, urls.get(0));`、`cluster.join(new StaticDirectory(u, invokers));`和`cluster.join(new StaticDirectory(invokers));`三种构建语句其中之一生成的，这里是经过第一种方式生成invoker的，下面来分析第一种生成invoker的情况，根据SPI机制这里refprotocol对象是`Protocol$Adpative`实例，具体refer实现是：\n\n```java\npublic org.apache.dubbo.rpc.Invoker refer(java.lang.Class arg0, org.apache.dubbo.common.URL arg1) throws org.apache.dubbo.rpc.RpcException {\n    if (arg1 == null) throw new IllegalArgumentException(\"url == null\");\n    org.apache.dubbo.common.URL url = arg1;\n    String extName = (url.getProtocol() == null ? \"MEAT-INF.dubbo\" : url.getProtocol());\n    if (extName == null)\n        throw new IllegalStateException(\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.Protocol) name from url(\" + url.toString() + \") use keys([protocol])\");\n    org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);\n    return extension.refer(arg0, arg1);\n}\n```\n\n示例中是通过注册中心，因此这里protocol是register，会走RegistryProtocol类的refer方法\n\n```java\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n    //通过register可以获取具体注册中心协议，这里是zookeeper，因此url的协议值被设置为zookeeper\n    url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);\n    //获取zookeeper Registry实现，即ZookeeperRegistryFactory，并调用getRegistry方法实现\n    //获取zookeeper类型的registry对象\n    Registry registry = registryFactory.getRegistry(url);\n    if (RegistryService.class.equals(type)) {\n        return proxyFactory.getInvoker((T) registry, type, url);\n    }\n\n    // group=\"a,b\" or group=\"*\"\n    Map<String, String> qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));\n    String group = qs.get(Constants.GROUP_KEY);\n    if (group != null && group.length() > 0) {\n        if ((Constants.COMMA_SPLIT_PATTERN.split(group)).length > 1\n            || \"*\".equals(group)) {\n            return doRefer(getMergeableCluster(), registry, type, url);\n        }\n    }\n    //根据Dubbo SPI机制，给setXxx方法对应的属性赋值为Xxx$Adaptive，这里就是Cluster$Adaptive\n    return doRefer(cluster, registry, type, url);\n}\nprivate <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {\n    //这里的RegistryDirectory和StaticDirectory相对应的，前者是动态从注册中心获取url目录对象，后者是静态指定url目录\n    RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);\n    directory.setRegistry(registry);\n    directory.setProtocol(protocol);\n    // all attributes of REFER_KEY\n    Map<String, String> parameters = new HashMap<String, String>(directory.getUrl().getParameters());\n    URL subscribeUrl = new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);\n    if (!Constants.ANY_VALUE.equals(url.getServiceInterface())\n        && url.getParameter(Constants.REGISTER_KEY, true)) {\n        registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,\n                                                     Constants.CHECK_KEY, String.valueOf(false)));\n    }\n    //订阅注册中心，可以获取服务提供方地址等信息\n    directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,\n                                                  Constants.PROVIDERS_CATEGORY\n                                                  + \",\" + Constants.CONFIGURATORS_CATEGORY\n                                                  + \",\" + Constants.ROUTERS_CATEGORY));\n    //通过调用Cluster$Adpative类的join方法返回Invoker对象(基于Dubbo SPI机制实现setXX()方法自动注入属性)\n    Invoker invoker = cluster.join(directory);\n    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);\n    return invoker;\n}\n```\n\n这里看下`Cluster$Adpative`类的join方法实现\n\n```java\npackage org.apache.dubbo.rpc.cluster;\n\nimport org.apache.dubbo.common.extension.ExtensionLoader;\n\npublic class Cluster$Adaptive implements org.apache.dubbo.rpc.cluster.Cluster {\n    private static final org.apache.dubbo.common.logger.Logger logger = org.apache.dubbo.common.logger.LoggerFactory.getLogger(ExtensionLoader.class);\n    private java.util.concurrent.atomic.AtomicInteger count = new java.util.concurrent.atomic.AtomicInteger(0);\n\n    public org.apache.dubbo.rpc.Invoker join(org.apache.dubbo.rpc.cluster.Directory arg0) throws org.apache.dubbo.rpc.RpcException {\n        if (arg0 == null) throw new IllegalArgumentException(\"org.apache.dubbo.rpc.cluster.Directory argument == null\");\n        if (arg0.getUrl() == null)\n            throw new IllegalArgumentException(\"org.apache.dubbo.rpc.cluster.Directory argument getUrl() == null\");\n        org.apache.dubbo.common.URL url = arg0.getUrl();\n        String extName = url.getParameter(\"cluster\", \"failover\");\n        if (extName == null)\n            throw new IllegalStateException(\"Fail to get extension(org.apache.dubbo.rpc.cluster.Cluster) name from url(\" + url.toString() + \") use keys([cluster])\");\n        org.apache.dubbo.rpc.cluster.Cluster extension = null;\n        try {\n            extension = (org.apache.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.cluster.Cluster.class).getExtension(extName);\n        } catch (Exception e) {\n            if (count.incrementAndGet() == 1) {\n                logger.warn(\"Failed to find extension named \" + extName + \" for type org.apache.dubbo.rpc.cluster.Cluster, will use default extension failover instead.\", e);\n            }\n            extension = (org.apache.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.cluster.Cluster.class).getExtension(\"failover\");\n        }\n        return extension.join(arg0);\n    }\n}\n```\n\n再看下FailoverCluster的join方法：\n\n```java\n@Override\npublic <T> Invoker<T> join(Directory<T> directory) throws RpcException {\n    return new FailoverClusterInvoker<T>(directory);\n}\n```\n\n由于Cluster SPI实现中有个MockClusterWrapper是包装类，这里牵扯到**Dubbo的AOP机制(后期详细分析)**，这里先调用它的join方法：\n\n```java\n@Override\npublic <T> Invoker<T> join(Directory<T> directory) throws RpcException {\n    return new MockClusterInvoker<T>(directory,\n                                     this.cluster.join(directory));\n}\n```\n\n生成MockClusterInvoker之后，由于FailoverClusterInvoker是AbstractClusterInvoker的子类，它的invoke方法实现在其父类中，接下来的调用链是`MockClusterInvoker.invoke()->AbstractClusterInvoker.invoke()->FailoverClusterInvoker.doInvoke()`，下面来一步步分析，首先来看MockClusterInvoker类的invoke()方法：\n\n```java\n@Override\npublic Result invoke(Invocation invocation) throws RpcException {\n    Result result = null;\n\n    String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();\n    if (value.length() == 0 || value.equalsIgnoreCase(\"false\")) {\n        //no mock\n        result = this.invoker.invoke(invocation);\n    } else if (value.startsWith(\"force\")) {\n        if (logger.isWarnEnabled()) {\n            logger.warn(\"force-mock: \" + invocation.getMethodName() + \" force-mock enabled , url : \" + directory.getUrl());\n        }\n        //force:direct mock\n        result = doMockInvoke(invocation, null);\n    } else {\n        //fail-mock\n        try {\n            result = this.invoker.invoke(invocation);\n        } catch (RpcException e) {\n            if (e.isBiz()) {\n                throw e;\n            } else {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\"fail-mock: \" + invocation.getMethodName() + \" fail-mock enabled , url : \" + directory.getUrl(), e);\n                }\n                result = doMockInvoke(invocation, e);\n            }\n        }\n    }\n    return result;\n}\n```\n\n然后调用AbstractClusterInvoker的invoke()方法：\n\n```java\n@Override\npublic Result invoke(final Invocation invocation) throws RpcException {\n    checkWhetherDestroyed();\n\n    // binding attachments into invocation.\n    Map<String, String> contextAttachments = RpcContext.getContext().getAttachments();\n    if (contextAttachments != null && contextAttachments.size() != 0) {\n        ((RpcInvocation) invocation).addAttachments(contextAttachments);\n    }\n\n    List<Invoker<T>> invokers = list(invocation);\n    LoadBalance loadbalance = initLoadBalance(invokers, invocation);\n    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);\n    return doInvoke(invocation, invokers, loadbalance);\n}\n```\n\n最后调用FailoverClusterInvoker的doInvoke()方法：\n\n```java\n@Override\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {\n    List<Invoker<T>> copyinvokers = invokers;\n    checkInvokers(copyinvokers, invocation);\n    String methodName = RpcUtils.getMethodName(invocation);\n    //设置重试次数\n    int len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;\n    if (len <= 0) {\n        len = 1;\n    }\n    // retry loop.\n    RpcException le = null; // last exception.\n    List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyinvokers.size()); // invoked invokers.\n    Set<String> providers = new HashSet<String>(len);\n    for (int i = 0; i < len; i++) {\n        //Reselect before retry to avoid a change of candidate `invokers`.\n        //NOTE: if `invokers` changed, then `invoked` also lose accuracy.\n        if (i > 0) {\n            checkWhetherDestroyed();\n            copyinvokers = list(invocation);\n            // check again\n            checkInvokers(copyinvokers, invocation);\n        }\n        //根据负载均衡策略选择调用者\n        Invoker<T> invoker = select(loadbalance, invocation, copyinvokers, invoked);\n        //将使用过的invoker放入invoked\n        invoked.add(invoker);\n        RpcContext.getContext().setInvokers((List) invoked);\n        try {\n            Result result = invoker.invoke(invocation);\n            if (le != null && logger.isWarnEnabled()) {\n                logger.warn(\"Although retry the method \" + methodName\n                            + \" in the service \" + getInterface().getName()\n                            + \" was successful by the provider \" + invoker.getUrl().getAddress()\n                            + \", but there have been failed providers \" + providers\n                            + \" (\" + providers.size() + \"/\" + copyinvokers.size()\n                            + \") from the registry \" + directory.getUrl().getAddress()\n                            + \" on the consumer \" + NetUtils.getLocalHost()\n                            + \" using the dubbo version \" + Version.getVersion() + \". Last error is: \"\n                            + le.getMessage(), le);\n            }\n            return result;\n        } catch (RpcException e) {\n            if (e.isBiz()) { // biz exception.\n                throw e;\n            }\n            le = e;\n        } catch (Throwable e) {\n            le = new RpcException(e.getMessage(), e);\n        } finally {\n            providers.add(invoker.getUrl().getAddress());\n        }\n    }\n    throw new RpcException(le.getCode(), \"Failed to invoke the method \"\n                           + methodName + \" in the service \" + getInterface().getName()\n                           + \". Tried \" + len + \" times of the providers \" + providers\n                           + \" (\" + providers.size() + \"/\" + copyinvokers.size()\n                           + \") from the registry \" + directory.getUrl().getAddress()\n                           + \" on the consumer \" + NetUtils.getLocalHost() + \" using the dubbo version \"\n                           + Version.getVersion() + \". Last error is: \"\n                           + le.getMessage(), le.getCause() != null ? le.getCause() : le);\n}\n```\n\n所以会有如下的线程栈信息：\n\n```\nat org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:78)\nat org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:243)\nat org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:75)\n```\n\n这些类都是关于**Dubbo的集群容错机制**（将会写一篇关于Dubbo的集群容错机制）。\n\n再往下看invokers是如何生成的呢？又回到AbstractClusterInvoker的invoke方法实现：\n\n```java\n@Override\npublic Result invoke(final Invocation invocation) throws RpcException {\n    checkWhetherDestroyed();\n    LoadBalance loadbalance = null;\n\n    // binding attachments into invocation.\n    Map<String, String> contextAttachments = RpcContext.getContext().getAttachments();\n    if (contextAttachments != null && contextAttachments.size() != 0) {\n        ((RpcInvocation) invocation).addAttachments(contextAttachments);\n    }\n\t//会调用directory的list方法 返回要调用invokers集合。\n    //其实是AbstractDirectory的list方法，这个方法里就是利用路由规则（如果有），从所有\n    //提供者中，遴选出符合规则的提供者,接下里才是，集群容错和负载均衡。\n    List<Invoker<T>> invokers = list(invocation);\n    if (invokers != null && !invokers.isEmpty()) {\n        //通过key（loadbalance）从url中取值，默认值为random\n        loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl()                                                                                .getMethodParameter(RpcUtils.getMethodName(invocation), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));\n    }\n    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);\n    return doInvoke(invocation, invokers, loadbalance);\n}\n```\n\n再来看一下list方法：\n\n```java\nprotected List<Invoker<T>> list(Invocation invocation) throws RpcException {\n    //directory.list(invocation)获取invokers，这里directory是RegistryDirectory\n    List<Invoker<T>> invokers = directory.list(invocation);\n    return invokers;\n}\n```\n\n跟到RegistryDirectory类的list方法，实现在其父类AbstractDirectory中，主要是**生成路由规则**（将会在另一篇文章中详细讲解，敬请期待）：\n\n```java\n@Override\npublic List<Invoker<T>> list(Invocation invocation) throws RpcException {\n    if (destroyed) {\n        throw new RpcException(\"Directory already destroyed .url: \" + getUrl());\n    }\n    //获取所有的提供者\n    List<Invoker<T>> invokers = doList(invocation);\n    //本地路由规则\n    List<Router> localRouters = this.routers; // local reference\n    if (localRouters != null && !localRouters.isEmpty()) {\n        for (Router router : localRouters) {\n            try {\n                if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) {\n                    //Router接口，实现route的方法，路由获取服务提供者\n                    invokers = router.route(invokers, getConsumerUrl(), invocation);\n                }\n            } catch (Throwable t) {\n                logger.error(\"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(), t);\n            }\n        }\n    }\n    return invokers;\n}\n```\n\n再来看一下doList方法，它是个抽象方法具体实现在RegistryDirectory类中：\n\n```java\n@Override\npublic List<Invoker<T>> doList(Invocation invocation) {\n    //没有服务提供者或者服务提供者被禁用\n    if (forbidden) {\n        // 1. No service provider 2. Service providers are disabled\n        throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,\n                               \"No provider available from registry \" + getUrl().getAddress() + \" for service \" + getConsumerUrl().getServiceKey() + \" on consumer \" + NetUtils.getLocalHost()\n                               + \" use dubbo version \" + Version.getVersion() + \", please check status of providers(disabled, not registered or in blacklist).\");\n    }\n    List<Invoker<T>> invokers = null;\n    //从这里搜索methodInvokerMap赋值，在refreshInvoker方法里\n    Map<String, List<Invoker<T>>> localMethodInvokerMap = this.methodInvokerMap; // local reference\n    if (localMethodInvokerMap != null && localMethodInvokerMap.size() > 0) {\n        String methodName = RpcUtils.getMethodName(invocation);\n        Object[] args = RpcUtils.getArguments(invocation);\n        if (args != null && args.length > 0 && args[0] != null\n            && (args[0] instanceof String || args[0].getClass().isEnum())) {\n            invokers = localMethodInvokerMap.get(methodName + \".\" + args[0]); // The routing can be enumerated according to the first parameter\n        }\n        if (invokers == null) {\n            invokers = localMethodInvokerMap.get(methodName);\n        }\n        if (invokers == null) {\n            invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);\n        }\n        if (invokers == null) {\n            Iterator<List<Invoker<T>>> iterator = localMethodInvokerMap.values().iterator();\n            if (iterator.hasNext()) {\n                invokers = iterator.next();\n            }\n        }\n    }\n    return invokers == null ? new ArrayList<Invoker<T>>(0) : invokers;\n}\n```\n\n下面是`refreshInvoker(List<URL> invokerUrls)`方法的实现：\n\n```java\n/**\n     * Convert the invokerURL list to the Invoker Map. The rules of the conversion are as follows:\n     * 1.If URL has been converted to invoker, it is no longer re-referenced and obtained directly from the cache, and notice that any parameter changes in the URL will be re-referenced.\n     * 2.If the incoming invoker list is not empty, it means that it is the latest invoker list\n     * 3.If the list of incoming invokerUrl is empty, It means that the rule is only a override rule or a route rule, which needs to be re-contrasted to decide whether to re-reference.\n     *\n     * @param invokerUrls this parameter can't be null\n     */\n// TODO: 2017/8/31 FIXME The thread pool should be used to refresh the address, otherwise the task may be accumulated.\nprivate void refreshInvoker(List<URL> invokerUrls) {\n    if (invokerUrls != null && invokerUrls.size() == 1 && invokerUrls.get(0) != null\n        && Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {\n        //禁止访问\n        this.forbidden = true; // Forbid to access\n        //置空列表\n        this.methodInvokerMap = null; // Set the method invoker map to null\n        //关闭所有invokers\n        destroyAllInvokers(); // Close all invokers\n    } else {\n        //允许访问\n        this.forbidden = false; // Allow to access\n        Map<String, Invoker<T>> oldUrlInvokerMap = this.urlInvokerMap; // local reference\n        if (invokerUrls.isEmpty() && this.cachedInvokerUrls != null) {\n            invokerUrls.addAll(this.cachedInvokerUrls);\n        } else {\n            this.cachedInvokerUrls = new HashSet<URL>();\n            //缓存invokerUrls列表，便于交叉对比\n            this.cachedInvokerUrls.addAll(invokerUrls);//Cached invoker urls, convenient for comparison\n        }\n        if (invokerUrls.isEmpty()) {\n            return;\n        }\n        //生成invoker方法 toInvokers\n        //将url列表转换成invoker列表\n        Map<String, Invoker<T>> newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map\n        //换方法名映射invoker列表\n        Map<String, List<Invoker<T>>> newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); // Change method name to map Invoker Map\n        // state change\n        // If the calculation is wrong, it is not processed.\n        //如果计算错误则不进行处理\n        if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) {\n            logger.error(new IllegalStateException(\"urls to invokers error .invokerUrls.size :\" + invokerUrls.size() + \", invoker.size :0. urls :\" + invokerUrls.toString()));\n            return;\n        }\n        this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;\n        this.urlInvokerMap = newUrlInvokerMap;\n        try {\n            //关闭不使用的invoker\n            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker\n        } catch (Exception e) {\n            logger.warn(\"destroyUnusedInvokers error. \", e);\n        }\n    }\n}\n```\n\n可以知道refreshInvoker()方法会在RegistryDirectory类的notify()方法里调用，这个方法是**订阅注册中心的回调方法**。下面来看一下toInvokers()的方法实现：\n\n```java\n/**\n     * Turn urls into invokers, and if url has been refer, will not re-reference.\n     * 将urls转换成invokers，如果url已经被refer过则不在重新引用\n     * @param urls\n     * @return invokers\n     */\nprivate Map<String, Invoker<T>> toInvokers(List<URL> urls) {\n    Map<String, Invoker<T>> newUrlInvokerMap = new HashMap<String, Invoker<T>>();\n    if (urls == null || urls.isEmpty()) {\n        return newUrlInvokerMap;\n    }\n    Set<String> keys = new HashSet<String>();\n    String queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY);\n    for (URL providerUrl : urls) {\n        // If protocol is configured at the reference side, only the matching protocol is selected\n        //若果reference端配置了protocol，则只选择匹配的protocol\n        if (queryProtocols != null && queryProtocols.length() > 0) {\n            boolean accept = false;\n            String[] acceptProtocols = queryProtocols.split(\",\");\n            for (String acceptProtocol : acceptProtocols) {\n                if (providerUrl.getProtocol().equals(acceptProtocol)) {\n                    accept = true;\n                    break;\n                }\n            }\n            if (!accept) {\n                continue;\n            }\n        }\n        if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {\n            continue;\n        }\n        if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {\n            logger.error(new IllegalStateException(\"Unsupported protocol \" + providerUrl.getProtocol() + \" in notified url: \" + providerUrl + \" from registry \" + getUrl().getAddress() + \" to consumer \" + NetUtils.getLocalHost()\n                                                   + \", supported protocol: \" + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));\n            continue;\n        }\n        URL url = mergeUrl(providerUrl);\n\t\t//url参数是排序的\n        String key = url.toFullString(); // The parameter urls are sorted\n        //跳过重复的url\n        if (keys.contains(key)) { // Repeated url\n            continue;\n        }\n        keys.add(key);\n        // Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again\n        //缓存key为没有合并消费端参数的URL，不管消费端如何合并参数，如果服务端URL发生变化，则重新refer\n        Map<String, Invoker<T>> localUrlInvokerMap = this.urlInvokerMap; // local reference\n        Invoker<T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);\n        if (invoker == null) { // Not in the cache, refer again\n            try {\n                boolean enabled = true;\n                if (url.hasParameter(Constants.DISABLED_KEY)) {\n                    enabled = !url.getParameter(Constants.DISABLED_KEY, false);\n                } else {\n                    enabled = url.getParameter(Constants.ENABLED_KEY, true);\n                }\n                if (enabled) {\n                    //创建invoker（这里创建invoker）\n                    invoker = new InvokerDelegate<T>(protocol.refer(serviceType, url), url, providerUrl);\n                }\n            } catch (Throwable t) {\n                logger.error(\"Failed to refer invoker for interface:\" + serviceType + \",url:(\" + url + \")\" + t.getMessage(), t);\n            }\n            if (invoker != null) { // Put new invoker in cache\n                //将新的引用放入缓存\n                newUrlInvokerMap.put(key, invoker);\n            }\n        } else {\n            newUrlInvokerMap.put(key, invoker);\n        }\n    }\n    keys.clear();\n    return newUrlInvokerMap;\n}\n```\n\n找到了invoker的创建地方，来看下InvokerDelegate，它是RegistryDirectory的内部类：\n\n```java\n/**\n     * The delegate class, which is mainly used to store the URL address sent by the registry,and can be reassembled on the basis of providerURL queryMap overrideMap for re-refer.\n     * 代理类，主要用于存储注册中心下发的URL地址\n     * 用于重新refer时能够根据providerURL queryMap overrideMap重新组装\n     * @param <T>\n     */\nprivate static class InvokerDelegate<T> extends InvokerWrapper<T> {\n    private URL providerUrl;\n\n    public InvokerDelegate(Invoker<T> invoker, URL url, URL providerUrl) {\n        //调用父类构造方法\n        super(invoker, url);\n        this.providerUrl = providerUrl;\n    }\n\n    public URL getProviderUrl() {\n        return providerUrl;\n    }\n}\n```\n\ninvoke方法在父类InvokerWrapper里实现的：\n\n```java\n@Override\npublic Result invoke(Invocation invocation) throws RpcException {\n    //这里的invoker是从它的构造方法里传入的\n    return invoker.invoke(invocation);\n}\n```\n\n所以在调用栈里可以看到如下一条信息：\n\n```\nat org.apache.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:56)\n```\n\nInvokerDelegete构造方法调用的父类InvokerWrapper的构造方法并传入invoker实例，回头看`new InvokerDelegate<T>(protocol.refer(serviceType, url), url, providerUrl);`这句，可知上面的invoker的是由`protocol.refer(serviceType, url)`创建的。\n\n通过debug可得知这里的protocol是Protocol$Adaptive类型的，这里的url的protocol是dubbo，通过Dubbo SPI机制可以得到这里最后走DubboProtocol类的refer()方法，但是由于Protocol接口实现中由两个包装类：\n\n```\nfilter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper\nlistener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper\n```\n\n所以这里先执行ProtocolFilterWrapper的refer方法，再执行ProtocolListenerWrapper的refer方法，最后才执行DubboProtocol类的refer方法，ProtocolFilterWrapper类的refer方法如下：\n\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n        return protocol.refer(type, url);\n    }\n    return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);\n}\n```\n\n方法里调用了buildInvokerChain()方法：\n\n```java\nprivate static <T> Invoker<T> buildInvokerChain(final Invoker<T> invoker, String key, String group) {\n    Invoker<T> last = invoker;\n    //先获取激活的过滤器，我们这里手动配置了monitor MonitorFilter过滤器\n    //另外两个自动激活的过滤器是FutureFilter，ConsumerContextFilter\n    //这里需要看SPI机制的getActivateExtension方法的相关代码\n    List<Filter> filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);\n    if (!filters.isEmpty()) {\n        for (int i = filters.size() - 1; i >= 0; i--) {\n            final Filter filter = filters.get(i);\n            final Invoker<T> next = last;\n            last = new Invoker<T>() {\n\n                @Override\n                public Class<T> getInterface() {\n                    return invoker.getInterface();\n                }\n\n                @Override\n                public URL getUrl() {\n                    return invoker.getUrl();\n                }\n\n                @Override\n                public boolean isAvailable() {\n                    return invoker.isAvailable();\n                }\n\t\t\t\t//实现invoker的invoke方法\n                @Override\n                public Result invoke(Invocation invocation) throws RpcException {\n                    //嵌套进过滤器链\n                    return filter.invoke(next, invocation);\n                }\n\n                @Override\n                public void destroy() {\n                    invoker.destroy();\n                }\n\n                @Override\n                public String toString() {\n                    return invoker.toString();\n                }\n            };\n        }\n    }\n    return last;\n}\n```\n\n所以有如下的调用栈信息：\n\n```\nat org.apache.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75)\nat org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)\nat org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:47)\nat org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)\nat org.apache.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:50)\nat org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)\n```\n\n接着ProtocolListenerWrapper的refer方法：\n\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {\n    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {\n        return protocol.refer(type, url);\n    }\n    //获取激活的监听器，目前dubbo没有提供合适的监听器，只有一个DeprecatedInvokerListener实现类，并且还是Deprecated的\n    return new ListenerInvokerWrapper<T>(protocol.refer(type, url),\n                                         Collections.unmodifiableList(\n                                             ExtensionLoader.getExtensionLoader(InvokerListener.class)\n                                             .getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)));\n}\n```\n\n所以会出现如下栈信息：\n\n```\nat org.apache.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:77)\n```\n\n\n\n最后看一下DubboProtocol类的refer方法，这里创建了DubboInvoker对象：\n\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {\n    optimizeSerialization(url);\n    // create rpc invoker.\n    DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);\n    invokers.add(invoker);\n    return invoker;\n}\n```\n\nDubboInvoker的父类AbstractInvoker实现了invoke方法：\n\n```java\n@Override\npublic Result invoke(Invocation inv) throws RpcException {\n    if (destroyed.get()) {\n        throw new RpcException(\"Rpc invoker for service \" + this + \" on consumer \" + NetUtils.getLocalHost()\n                               + \" use dubbo version \" + Version.getVersion()\n                               + \" is DESTROYED, can not be invoked any more!\");\n    }\n    RpcInvocation invocation = (RpcInvocation) inv;\n    invocation.setInvoker(this);\n    if (attachment != null && attachment.size() > 0) {\n        invocation.addAttachmentsIfAbsent(attachment);\n    }\n    Map<String, String> contextAttachments = RpcContext.getContext().getAttachments();\n    if (contextAttachments != null && contextAttachments.size() != 0) {\n        /**\n             * invocation.addAttachmentsIfAbsent(context){@link RpcInvocation#addAttachmentsIfAbsent(Map)}should not be used here,\n             * because the {@link RpcContext#setAttachment(String, String)} is passed in the Filter when the call is triggered\n             * by the built-in retry mechanism of the Dubbo. The attachment to update RpcContext will no longer work, which is\n             * a mistake in most cases (for example, through Filter to RpcContext output traceId and spanId and other information).\n             */\n        invocation.addAttachments(contextAttachments);\n    }\n    if (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false)) {\n        invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());\n    }\n    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);\n\n\n    try {\n        //doInvoke()方法具体实现在子类中\n        return doInvoke(invocation);\n    } catch (InvocationTargetException e) { // biz exception\n        Throwable te = e.getTargetException();\n        if (te == null) {\n            return new RpcResult(e);\n        } else {\n            if (te instanceof RpcException) {\n                ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);\n            }\n            return new RpcResult(te);\n        }\n    } catch (RpcException e) {\n        if (e.isBiz()) {\n            return new RpcResult(e);\n        } else {\n            throw e;\n        }\n    } catch (Throwable e) {\n        return new RpcResult(e);\n    }\n}\n```\n\n看一下DubboInvoker实现的doInvoke方法：\n\n```java\n@Override\nprotected Result doInvoke(final Invocation invocation) throws Throwable {\n    RpcInvocation inv = (RpcInvocation) invocation;\n    final String methodName = RpcUtils.getMethodName(invocation);\n    inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());\n    inv.setAttachment(Constants.VERSION_KEY, version);\n\n    ExchangeClient currentClient;\n    if (clients.length == 1) {\n        currentClient = clients[0];\n    } else {\n        currentClient = clients[index.getAndIncrement() % clients.length];\n    }\n    try {\n        boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);\n        boolean isAsyncFuture = RpcUtils.isGeneratedFuture(inv) || RpcUtils.isFutureReturnType(inv);\n        boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);\n        int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n        if (isOneway) {\n            boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);\n            currentClient.send(inv, isSent);\n            RpcContext.getContext().setFuture(null);\n            return new RpcResult();\n        } else if (isAsync) {\n            ResponseFuture future = currentClient.request(inv, timeout);\n            // For compatibility\n            FutureAdapter<Object> futureAdapter = new FutureAdapter<>(future);\n            RpcContext.getContext().setFuture(futureAdapter);\n\n            Result result;\n            if (isAsyncFuture) {\n                // register resultCallback, sometimes we need the asyn result being processed by the filter chain.\n                result = new AsyncRpcResult(futureAdapter, futureAdapter.getResultFuture(), false);\n            } else {\n                result = new SimpleAsyncRpcResult(futureAdapter, futureAdapter.getResultFuture(), false);\n            }\n            return result;\n        } else {\n            RpcContext.getContext().setFuture(null);\n            return (Result) currentClient.request(inv, timeout).get();\n        }\n    } catch (TimeoutException e) {\n        throw new RpcException(RpcException.TIMEOUT_EXCEPTION, \"Invoke remote method timeout. method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e);\n    } catch (RemotingException e) {\n        throw new RpcException(RpcException.NETWORK_EXCEPTION, \"Failed to invoke remote method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e);\n    }\n}\n```\n\n所以会有这两句线程栈输出：\n\n```\nat org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:108)\nat org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:154)\n```\n\n接下来就是用于发送请求的currentClient对象的实现了，它的逻辑可以追踪到DubboProtocol类的refer方法里：\n\n```java\n@Override\npublic <T> Invoker<T> refer(Class<T> serviceType, URL url) throws RpcException {\n    optimizeSerialization(url);\n    // create rpc invoker.\n    DubboInvoker<T> invoker = new DubboInvoker<T>(serviceType, url, getClients(url), invokers);\n    invokers.add(invoker);\n    return invoker;\n}\n```\n\n具体的获取逻辑在getClients()方法中：\n\n```java\nprivate ExchangeClient[] getClients(URL url) {\n    // whether to share connection\n    //是否共享连接\n    boolean service_share_connect = false;\n    int connections = url.getParameter(Constants.CONNECTIONS_KEY, 0);\n    // if not configured, connection is shared, otherwise, one connection for one service\n    //如果没有配置connection，那么就创建共享连接，否则一个服务一个连接？\n    if (connections == 0) {\n        service_share_connect = true;\n        connections = 1;\n    }\n\n    ExchangeClient[] clients = new ExchangeClient[connections];\n    for (int i = 0; i < clients.length; i++) {\n        if (service_share_connect) {\n            clients[i] = getSharedClient(url);\n        } else {\n            clients[i] = initClient(url);\n        }\n    }\n    return clients;\n}\n/**\n     * Get shared connection\n     */\nprivate ExchangeClient getSharedClient(URL url) {\n    String key = url.getAddress();\n    ReferenceCountExchangeClient client = referenceClientMap.get(key);\n    if (client != null) {\n        if (!client.isClosed()) {\n            client.incrementAndGetCount();\n            return client;\n        } else {\n            referenceClientMap.remove(key);\n        }\n    }\n\n    locks.putIfAbsent(key, new Object());\n    synchronized (locks.get(key)) {\n        if (referenceClientMap.containsKey(key)) {\n            return referenceClientMap.get(key);\n        }\n\n        ExchangeClient exchangeClient = initClient(url);\n        client = new ReferenceCountExchangeClient(exchangeClient, ghostClientMap);\n        referenceClientMap.put(key, client);\n        ghostClientMap.remove(key);\n        locks.remove(key);\n        return client;\n    }\n}\n/**\n     * Create new connection\n     */\nprivate ExchangeClient initClient(URL url) {\n\n    // client type setting.\n    String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));\n\n    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);\n    // enable heartbeat by default\n    //默认开启heartbeat\n    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));\n\n    // BIO is not allowed since it has severe performance issue.\n    //BIO存在严重的性能问题，因此不能使用\n    if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {\n        throw new RpcException(\"Unsupported client type: \" + str + \",\" +\n                               \" supported client type is \" + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), \" \"));\n    }\n\n    ExchangeClient client;\n    try {\n        // connection should be lazy\n        if (url.getParameter(Constants.LAZY_CONNECT_KEY, false)) {\n            client = new LazyConnectExchangeClient(url, requestHandler);\n        } else {\n            //通过 Exchangers.connect(url, requestHandler); 构建client ，接下来跟踪Exchangers.connect方法\n\t\t    //这里会传入一个requestHandler，这个是客户端解救服务端方法返回回调的\n            client = Exchangers.connect(url, requestHandler);\n        }\n    } catch (RemotingException e) {\n        throw new RpcException(\"Fail to create remoting client for service(\" + url + \"): \" + e.getMessage(), e);\n    }\n    return client;\n}\n```\n\n这里用到了**Facade设计模式，Exchangers是个门面类**，封装了具体查找合适的Exchanger实现，并调用connect方法返回ExchangeClient的过程，相关代码如下：\n\n```java\npublic static ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {\n    if (url == null) {\n        throw new IllegalArgumentException(\"url == null\");\n    }\n    if (handler == null) {\n        throw new IllegalArgumentException(\"handler == null\");\n    }\n    url = url.addParameterIfAbsent(Constants.CODEC_KEY, \"exchange\");\n    //把codec key设置为exchange\n    return getExchanger(url).connect(url, handler);\n}\n\npublic static Exchanger getExchanger(URL url) {\n    String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);\n    //通过exchanger key 获取 Exchanger的spi实现，默认是header，这里是HeaderExchanger类\n    return getExchanger(type);\n}\n\npublic static Exchanger getExchanger(String type) {\n    //这里返回Exchanger接口的header扩展类的HeaderExchanger\n    return ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);\n}\n```\n\n看一下HeaderExchanger类的connect方法：\n\n```java\n//客户端的连接操作\n@Override\npublic ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {\n    return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true);\n}\n```\n\n所以有栈信息：\n\n```\nat org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeClient.request(HeaderExchangeClient.java:90)\n```\n\n再来看HeaderExchnageClient的request()方法：\n\n```java\npublic HeaderExchangeClient(Client client, boolean needHeartbeat) {\n    if (client == null) {\n        throw new IllegalArgumentException(\"client == null\");\n    }\n    this.client = client;\n    //初始化HeaderExchangeChannel\n    this.channel = new HeaderExchangeChannel(client);\n    String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);\n    this.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != null && dubbo.startsWith(\"1.0.\") ? Constants.DEFAULT_HEARTBEAT : 0);\n    this.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * 3);\n    if (heartbeatTimeout < heartbeat * 2) {\n        throw new IllegalStateException(\"heartbeatTimeout < heartbeatInterval * 2\");\n    }\n    if (needHeartbeat) {\n        startHeartbeatTimer();\n    }\n}\n\n@Override\npublic ResponseFuture request(Object request) throws RemotingException {\n    //调用Channel的request方法\n    return channel.request(request);\n}\n```\n\n因此会有如下的栈信息：\n\n```\nat org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.request(HeaderExchangeChannel.java:116)\n```\n\n再来看一下HeaderExchangeChannel的request方法：\n\n```java\n@Override\npublic ResponseFuture request(Object request) throws RemotingException {\n    return request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));\n}\n\n@Override\npublic ResponseFuture request(Object request, int timeout) throws RemotingException {\n    if (closed) {\n        throw new RemotingException(this.getLocalAddress(), null, \"Failed to send request \" + request + \", cause: The channel \" + this + \" is closed!\");\n    }\n    // create request.\n    Request req = new Request();\n    req.setVersion(Version.getProtocolVersion());\n    req.setTwoWay(true);\n    req.setData(request);\n    DefaultFuture future = new DefaultFuture(channel, req, timeout);\n    try {\n        //发送请求\n        channel.send(req);\n    } catch (RemotingException e) {\n        future.cancel();\n        throw e;\n    }\n    return future;\n}\n```\n\n`channel.send(req);`中channel实例是通过`HeaderExchangeChannel(Channel channel)`构造函数初始化的，继续往上看是通过构造函数`public HeaderExchangeClient(Client client, boolean needHeartbeat)`传进来的，最终生成channel的代码是在类`HeaderExchanger`中：\n\n```java\n@Override\npublic ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException {\n    return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true);\n}\n```\n\n调用`Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler)))`生成channel实例，**这里Transporters也是个门面类，是Facade设计模式的实现**，继续分析Transporters的connect方法：\n\n```Java\npublic static Client connect(URL url, ChannelHandler... handlers) throws RemotingException {\n    if (url == null) {\n        throw new IllegalArgumentException(\"url == null\");\n    }\n    ChannelHandler handler;\n    if (handlers == null || handlers.length == 0) {\n        handler = new ChannelHandlerAdapter();\n    } else if (handlers.length == 1) {\n        handler = handlers[0];\n    } else {\n        handler = new ChannelHandlerDispatcher(handlers);\n    }\n    //所以这里默认返回的NettyClient\n    return getTransporter().connect(url, handler);\n}\n//这个方法根据spi返回NettyTransporter扩展类\npublic static Transporter getTransporter() {\n    //生成Transporter$Adaptive类\n    return ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();\n}\n```\n\n所以最后是通过NettyClient类实例的send方法发送具体请求，NettyClient类的send方法在其祖先类AbstractPeer中：\n\n```java\n@Override\npublic void send(Object message) throws RemotingException {\n    send(message, url.getParameter(Constants.SENT_KEY, false));\n}\n```\n\n这个实现又调用NettyClient父类AbstractClient的send方法实现：\n\n```Java\n@Override\npublic void send(Object message, boolean sent) throws RemotingException {\n    if (send_reconnect && !isConnected()) {\n        connect();\n    }\n    //获取具体的channel实例\n    Channel channel = getChannel();\n    //TODO Can the value returned by getChannel() be null? need improvement.\n    if (channel == null || !channel.isConnected()) {\n        throw new RemotingException(this, \"message can not send, because channel is closed . url:\" + getUrl());\n    }\n    channel.send(message, sent);\n}\n```\n\n这里的getChannel()方法由NettyClient自身实现，如下：\n\n```java\n@Override\nprotected org.apache.dubbo.remoting.Channel getChannel() {\n    Channel c = channel;\n    if (c == null || !c.isActive())\n        return null;\n    return NettyChannel.getOrAddChannel(c, getUrl(), this);\n}\n```\n\n所以有如下栈信息：\n\n```\nat org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:101)\nat org.apache.dubbo.remoting.transport.AbstractClient.send(AbstractClient.java:265)\nat org.apache.dubbo.remoting.transport.AbstractPeer.send(AbstractPeer.java:53)\n```\n\n最后就走到NettyChannel的send方法，即到了断点处：\n\n```java\n@Override\npublic void send(Object message, boolean sent) throws RemotingException {\n    super.send(message, sent);\n\n    boolean success = true;\n    int timeout = 0;\n    try {\n        //断点处\n        ChannelFuture future = channel.writeAndFlush(message);\n        if (sent) {\n            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n            success = future.await(timeout);\n        }\n        Throwable cause = future.cause();\n        if (cause != null) {\n            throw cause;\n        }\n    } catch (Throwable e) {\n        throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress() + \", cause: \" + e.getMessage(), e);\n    }\n\n    if (!success) {\n        throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress()\n                                    + \"in timeout(\" + timeout + \"ms) limit\");\n    }\n}\n```\n\n到此，整个消费者调用过程就分析完了，文章中提到的一些关于Dubbo的核心feature将会写文章进一步分析，敬请期待。\n","slug":"dubbo-consumer-calling-process-source-code-analysis","published":1,"updated":"2018-11-21T08:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjq6kwn6m004ezjiafzijorx4","content":"<p>在分析Dubbo RPC服务调用过程之前，我们先写一个基于Dubbo实现的<a href=\"https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo\" target=\"_blank\" rel=\"noopener\"><strong>Consumer-Provider的Demo</strong></a>，通过这个Demo来分析具体的RPC调用栈。</p>\n<p>先定义一个接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 11:02 AM 2018/07/19.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ITestService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">sayHello</span><span class=\"params\">(String msg)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们基于zookeeper注册中心，服务端配置如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dubbo-server\"</span> <span class=\"attr\">owner</span>=<span class=\"string\">\"Junlan\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">address</span>=<span class=\"string\">\"zookeeper://127.0.0.1:2181\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--protocal configuration--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dubbo\"</span> <span class=\"attr\">port</span>=<span class=\"string\">\"20881\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">server</span>=<span class=\"string\">\"netty\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--service configuration--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">\"cn.shuaijunlan.dubbo.learning.service.ITestService\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"testService\"</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"dubbo\"</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">\"roundrobin\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cn.shuaijunlan.dubbo.learning.service.impl.TestServiceImpl\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"testService\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>客户端配置如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dubbo-client\"</span> <span class=\"attr\">owner</span>=<span class=\"string\">\"Junlan\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">client</span>=<span class=\"string\">\"netty\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">address</span>=<span class=\"string\">\"zookeeper://127.0.0.1:2181\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">interface</span>=<span class=\"string\">\"cn.shuaijunlan.dubbo.learning.service.ITestService\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testService\"</span> <span class=\"attr\">check</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>项目的部分依赖如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-framework<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.zookeeper<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>zookeeper<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.4.9<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>具体的服务提供者实现参照<a href=\"https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo/service-provider-a\" target=\"_blank\" rel=\"noopener\"><strong>service-provider-a</strong></a> ，服务消费者实现参照<a href=\"https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo/dubbo-client-demo\" target=\"_blank\" rel=\"noopener\"><strong>dubbo-client-demo</strong></a>。</p>\n<p>先启动服务提供者服务，下面分析在哪打断点：</p>\n<p>我们看下<code>org.apache.dubbo.remoting.transport.netty4.NettyChannel</code>的<code>send</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Object message, <span class=\"keyword\">boolean</span> sent)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.send(message, sent);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> success = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> timeout = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//向远程服务发送消息，因此我们在这句打个断点</span></span><br><span class=\"line\">        ChannelFuture future = channel.writeAndFlush(message);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sent) &#123;</span><br><span class=\"line\">            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class=\"line\">            success = future.await(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Throwable cause = future.cause();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cause != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> cause;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(<span class=\"keyword\">this</span>, <span class=\"string\">\"Failed to send message \"</span> + message + <span class=\"string\">\" to \"</span> + getRemoteAddress() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(<span class=\"keyword\">this</span>, <span class=\"string\">\"Failed to send message \"</span> + message + <span class=\"string\">\" to \"</span> + getRemoteAddress()</span><br><span class=\"line\">                                    + <span class=\"string\">\"in timeout(\"</span> + timeout + <span class=\"string\">\"ms) limit\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在<code>ChannelFuture future = channel.writeAndFlush(message);</code>这句打个断点，Debug服务消费者，得到如下线程栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main@1&quot; prio=5 tid=0x1 nid=NA runnable</span><br><span class=\"line\">  java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:101)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.AbstractClient.send(AbstractClient.java:265)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.AbstractPeer.send(AbstractPeer.java:53)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.request(HeaderExchangeChannel.java:116)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeClient.request(HeaderExchangeClient.java:90)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.dubbo.ReferenceCountExchangeClient.request(ReferenceCountExchangeClient.java:83)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:108)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:154)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:77)</span><br><span class=\"line\">\t  at org.apache.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:47)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:50)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:56)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:78)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:243)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:75)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:70)</span><br><span class=\"line\">\t  at org.apache.dubbo.common.bytecode.proxy0.sayHello(proxy0.java:-1)</span><br><span class=\"line\">\t  at cn.shuaijunlan.dubbo.learning.main.Main.main(Main.java:16)</span><br></pre></td></tr></table></figure>\n<p>自底向上，可以直观的看到服务消费者调用要经过的类和方法，下面将进行一步步分析，对每一个类的创建过程和调用过程做出解析：</p>\n<ul>\n<li>第一行栈信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at cn.shuaijunlan.dubbo.learning.main.Main.main(Main.java:16)</span><br></pre></td></tr></table></figure>\n<p>Main.java 类是消费者端的启动类，可以忽略。</p>\n<ul>\n<li>第二行栈信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.common.bytecode.proxy0.sayHello(proxy0.java:-1)</span><br></pre></td></tr></table></figure>\n<p><code>org.apache.dubbo.common.bytecode.proxy0</code>类是一个代理类，它代理了所有RPC服务接口的方法调用。这个类实例是什么时候创建的？类代码是怎样的？</p>\n<p><strong>Dubbo基于Spring的构建分析</strong>（参考文章<a href=\"https://shuaijunlan.github.io/2018/08/13/dubbo-basing-on-spring-framework-analysis/\"><strong>《基于Spring构建Dubbo源码分析》</strong></a>）， 代理类的创建是由ReferenceBean类的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法里触发的，具体的实现在ReferenceConfig类createProxy方法里</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>, <span class=\"string\">\"deprecation\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">createProxy</span><span class=\"params\">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于生成invoker的逻辑，关于invoker生成逻辑这里先忽略，后面会说到</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// create service proxy</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) proxyFactory.getProxy(invoker);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>proxyFactory变量赋值为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>\n<p><strong>Dubbo SPI机制</strong>(参考文章<a href=\"https://shuaijunlan.github.io/2018/08/09/dubbo-spi-analysis/\"><strong>《Dubbo SPI机制源码分析》</strong></a>)里可以得到ProxyFactory接口的Adaptive类的getProxy方法源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.apache.dubbo.rpc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyFactory</span>$<span class=\"title\">Adaptive</span> <span class=\"keyword\">implements</span> <span class=\"title\">org</span>.<span class=\"title\">apache</span>.<span class=\"title\">dubbo</span>.<span class=\"title\">rpc</span>.<span class=\"title\">ProxyFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> java.lang.<span class=\"function\">Object <span class=\"title\">getProxy</span><span class=\"params\">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.Invoker argument == null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0.getUrl() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class=\"line\">        String extName = url.getParameter(<span class=\"string\">\"proxy\"</span>, <span class=\"string\">\"javassist\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.rpc.ProxyFactory) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([proxy])\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension.getProxy(arg0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> java.lang.<span class=\"function\">Object <span class=\"title\">getProxy</span><span class=\"params\">(org.apache.dubbo.rpc.Invoker arg0, <span class=\"keyword\">boolean</span> arg1)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.Invoker argument == null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0.getUrl() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class=\"line\">        String extName = url.getParameter(<span class=\"string\">\"proxy\"</span>, <span class=\"string\">\"javassist\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.rpc.ProxyFactory) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([proxy])\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension.getProxy(arg0, arg1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Invoker <span class=\"title\">getInvoker</span><span class=\"params\">(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.common.URL url = arg2;</span><br><span class=\"line\">        String extName = url.getParameter(<span class=\"string\">\"proxy\"</span>, <span class=\"string\">\"javassist\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.rpc.ProxyFactory) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([proxy])\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension.getInvoker(arg0, arg1, arg2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在如上<code>ProxyFactory$Adaptive</code>类中，调用<code>getProxy(org.apache.dubbo.rpc.Invoker arg0)</code>方法，其中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String extName = url.getParameter(<span class=\"string\">\"proxy\"</span>, <span class=\"string\">\"javassist\"</span>);</span><br><span class=\"line\">org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br></pre></td></tr></table></figure>\n<p>默认获取ProxyFactory接口的javassist扩展类JavassistProxyFactory，先调用<code>JavassitProxyFactory</code>的父类ProxyFactory的<code>getProxy(Invoker&lt;T&gt; invoker)</code>方法和<code>getProxy(Invoker&lt;T&gt; invoker, boolean generic)</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getProxy</span><span class=\"params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getProxy(invoker, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再调用<code>JavassistProxyFactory</code>类的<code>getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getProxy</span><span class=\"params\">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class=\"keyword\">new</span> InvokerInvocationHandler(invoker));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再到<strong>生成代理类的Proxy类</strong>（具体过程在另一篇文章中详细分析）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Get proxy.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ics interface class array.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Proxy instance.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Proxy <span class=\"title\">getProxy</span><span class=\"params\">(Class&lt;?&gt;... ics)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getProxy(ClassHelper.getClassLoader(Proxy.class), ics);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里直接贴出<strong>通过代码hack生成的代理类</strong>源码，这里动态生成了两个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.common.bytecode.ClassGenerator.DC;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy0</span> <span class=\"keyword\">extends</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">DC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">newInstance</span><span class=\"params\">(InvocationHandler var1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> proxy01(var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Proxy0_my</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个类继承抽象类Proxy，实现了它的抽象方法newInstance，<strong>接口DC是Dubbo内部作为动态类标示的接口</strong>；</p>\n<p>还有一个proxy01，就是在开始方法栈里看到的代理类，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.rpc.service.EchoService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> demo.dubbo.api.DemoService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">proxy01</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClassGenerator</span>.<span class=\"title\">DC</span>, <span class=\"title\">EchoService</span>, <span class=\"title\">DemoService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Method[] methods;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> InvocationHandler handler;</span><br><span class=\"line\">    <span class=\"comment\">//实现了接口方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sayHello</span><span class=\"params\">(String var1)</span> </span>&#123;</span><br><span class=\"line\">        Object[] var2 = <span class=\"keyword\">new</span> Object[]&#123;var1&#125;;</span><br><span class=\"line\">        Object var3 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            var3 = <span class=\"keyword\">this</span>.handler.invoke(<span class=\"keyword\">this</span>, methods[<span class=\"number\">1</span>], var2);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable throwable) &#123;</span><br><span class=\"line\">            throwable.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (String)var3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object $echo(Object var1) &#123;</span><br><span class=\"line\">        Object[] var2 = <span class=\"keyword\">new</span> Object[]&#123;var1&#125;;</span><br><span class=\"line\">        Object var3 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            var3 = <span class=\"keyword\">this</span>.handler.invoke(<span class=\"keyword\">this</span>, methods[<span class=\"number\">3</span>], var2);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable throwable) &#123;</span><br><span class=\"line\">            throwable.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Object)var3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">proxy01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//public 构造函数，这里handler是</span></span><br><span class=\"line\">    <span class=\"comment\">//由Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker))语句传入的InvokerInvocationHandler对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">proxy01</span><span class=\"params\">(InvocationHandler var1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handler = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到代理类实现类三个接口，<code>ClassGeneratr.DC</code>是Dubbo动态类标识接口，<code>DemoService</code>是实际的业务接口，这样代理就可以调用服务方法了，<code>EchoService</code>是回显测试接口，只有一个<code>$echo(Object var1)</code>法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.apache.dubbo.rpc.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Echo service.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@export</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">EchoService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * echo test.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> message message.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> message.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Object $echo(Object message);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它能为所有的Dubbo RPC服务加上一个回显测试方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过类型强制转换为EchoService，可以测试</span></span><br><span class=\"line\">EchoService echoService = (EchoService) service;</span><br><span class=\"line\">System.out.println(echoService.$echo(<span class=\"string\">\"hello\"</span>));</span><br></pre></td></tr></table></figure>\n<p>到这可以了解代理类生成的整个过程，可以看到sayHello方法的调用其实是调用<code>this.handler.invoke(this, methods[1], var2);</code>，因此这也解释了<strong>线程栈中第三行信息</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:70)</span><br></pre></td></tr></table></figure>\n<p>再往下看<code>org.apache.dubbo.rpc.proxy.InvokerInvocationHandler</code>类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InvokerInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Invoker&lt;?&gt; invoker;</span><br><span class=\"line\">\t<span class=\"comment\">//通过构造函数传入invoker</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InvokerInvocationHandler</span><span class=\"params\">(Invoker&lt;?&gt; handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.invoker = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        String methodName = method.getName();</span><br><span class=\"line\">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class=\"line\">        <span class=\"comment\">// 如果是Object类方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//反射调用</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> method.invoke(invoker, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 对toString、hashCode、equals三个方法做了处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"toString\"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> invoker.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"hashCode\"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> invoker.hashCode();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"equals\"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> invoker.equals(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        RpcInvocation invocation;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (RpcUtils.hasGeneratedFuture(method)) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; clazz = method.getDeclaringClass();</span><br><span class=\"line\">            String syncMethodName = methodName.substring(<span class=\"number\">0</span>, methodName.length() - Constants.ASYNC_SUFFIX.length());</span><br><span class=\"line\">            Method syncMethod = clazz.getMethod(syncMethodName, method.getParameterTypes());</span><br><span class=\"line\">            invocation = <span class=\"keyword\">new</span> RpcInvocation(syncMethod, args);</span><br><span class=\"line\">            invocation.setAttachment(Constants.FUTURE_GENERATED_KEY, <span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">            invocation.setAttachment(Constants.ASYNC_KEY, <span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            invocation = <span class=\"keyword\">new</span> RpcInvocation(method, args);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (RpcUtils.hasFutureReturnType(method)) &#123;</span><br><span class=\"line\">                invocation.setAttachment(Constants.FUTURE_RETURNTYPE_KEY, <span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">                invocation.setAttachment(Constants.ASYNC_KEY, <span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoker.invoke(invocation).recreate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里的invoker对象，是通过InvokerInvocationHandler构造方法传入，而且InvokerInvocationHandler对象是由JavassistProxyFactory类的<code>getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</code>方法创建，回到调用<code>proxyFactory.getProxy(invoker);</code>的地方，即ReferenceConfig类的<code>createProxy(Map&lt;String, String&gt; map)</code>方法，以下部分是生成invoker的过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isJvmRefer) &#123;</span><br><span class=\"line\">    URL url = <span class=\"keyword\">new</span> URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, <span class=\"number\">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class=\"line\">    invoker = refprotocol.refer(interfaceClass, url);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"Using injvm service \"</span> + interfaceClass.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url != <span class=\"keyword\">null</span> &amp;&amp; url.length() &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// user specified URL, could be peer-to-peer address, or register center's address.</span></span><br><span class=\"line\">        String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (us != <span class=\"keyword\">null</span> &amp;&amp; us.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String u : us) &#123;</span><br><span class=\"line\">                URL url = URL.valueOf(u);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (url.getPath() == <span class=\"keyword\">null</span> || url.getPath().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    url = url.setPath(interfaceName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">                    urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// assemble URL from register center's configuration</span></span><br><span class=\"line\">        <span class=\"comment\">//从注册中心获取配置URL</span></span><br><span class=\"line\">        List&lt;URL&gt; us = loadRegistries(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (us != <span class=\"keyword\">null</span> &amp;&amp; !us.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (URL u : us) &#123;</span><br><span class=\"line\">                URL monitorUrl = loadMonitor(u);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (monitorUrl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (urls.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"No such any registry to reference \"</span> + interfaceName + <span class=\"string\">\" on the consumer \"</span> + NetUtils.getLocalHost() + <span class=\"string\">\" use dubbo version \"</span> + Version.getVersion() + <span class=\"string\">\", please config &lt;dubbo:registry address=\\\"...\\\" /&gt; to your spring config.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//只有一个直连地址或者一个注册中心配置地址</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls.size() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这里的urls.get(0)，可能是直连地址（默认为dubbo协议），也可能是register注册地址（zookeeper协议）</span></span><br><span class=\"line\">        <span class=\"comment\">//示例中使用了zookeeper注册中心，因此会执行这一步</span></span><br><span class=\"line\">        invoker = refprotocol.refer(interfaceClass, urls.get(<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//多个直连地址或者多个注册中心，甚至是两者的结合，执行这一步</span></span><br><span class=\"line\">        List&lt;Invoker&lt;?&gt;&gt; invokers = <span class=\"keyword\">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class=\"line\">        URL registryURL = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (URL url : urls) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建invoker放入invokers</span></span><br><span class=\"line\">            invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">                registryURL = url; <span class=\"comment\">// use last registry url</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registryURL != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// registry url is available</span></span><br><span class=\"line\">            <span class=\"comment\">// use AvailableCluster only when register's cluster is available</span></span><br><span class=\"line\">            <span class=\"comment\">//这其中包括直连和注册中心混合或者都是注册中心两种情况，默认使用AvailableCluster集群策略</span></span><br><span class=\"line\">            URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);</span><br><span class=\"line\">            invoker = cluster.join(<span class=\"keyword\">new</span> StaticDirectory(u, invokers));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// not a registry url</span></span><br><span class=\"line\">            <span class=\"comment\">//多个直连的URL</span></span><br><span class=\"line\">            invoker = cluster.join(<span class=\"keyword\">new</span> StaticDirectory(invokers));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过上面的分析，可以发现invoker是通过<code>refprotocol.refer(interfaceClass, urls.get(0));</code>、<code>cluster.join(new StaticDirectory(u, invokers));</code>和<code>cluster.join(new StaticDirectory(invokers));</code>三种构建语句其中之一生成的，这里是经过第一种方式生成invoker的，下面来分析第一种生成invoker的情况，根据SPI机制这里refprotocol对象是<code>Protocol$Adpative</code>实例，具体refer实现是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Invoker <span class=\"title\">refer</span><span class=\"params\">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.common.URL url = arg1;</span><br><span class=\"line\">    String extName = (url.getProtocol() == <span class=\"keyword\">null</span> ? <span class=\"string\">\"MEAT-INF.dubbo\"</span> : url.getProtocol());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([protocol])\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extension.refer(arg0, arg1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例中是通过注册中心，因此这里protocol是register，会走RegistryProtocol类的refer方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过register可以获取具体注册中心协议，这里是zookeeper，因此url的协议值被设置为zookeeper</span></span><br><span class=\"line\">    url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);</span><br><span class=\"line\">    <span class=\"comment\">//获取zookeeper Registry实现，即ZookeeperRegistryFactory，并调用getRegistry方法实现</span></span><br><span class=\"line\">    <span class=\"comment\">//获取zookeeper类型的registry对象</span></span><br><span class=\"line\">    Registry registry = registryFactory.getRegistry(url);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// group=\"a,b\" or group=\"*\"</span></span><br><span class=\"line\">    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));</span><br><span class=\"line\">    String group = qs.get(Constants.GROUP_KEY);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (group != <span class=\"keyword\">null</span> &amp;&amp; group.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((Constants.COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class=\"number\">1</span></span><br><span class=\"line\">            || <span class=\"string\">\"*\"</span>.equals(group)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//根据Dubbo SPI机制，给setXxx方法对应的属性赋值为Xxx$Adaptive，这里就是Cluster$Adaptive</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> doRefer(cluster, registry, type, url);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doRefer</span><span class=\"params\">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里的RegistryDirectory和StaticDirectory相对应的，前者是动态从注册中心获取url目录对象，后者是静态指定url目录</span></span><br><span class=\"line\">    RegistryDirectory&lt;T&gt; directory = <span class=\"keyword\">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class=\"line\">    directory.setRegistry(registry);</span><br><span class=\"line\">    directory.setProtocol(protocol);</span><br><span class=\"line\">    <span class=\"comment\">// all attributes of REFER_KEY</span></span><br><span class=\"line\">    Map&lt;String, String&gt; parameters = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class=\"line\">    URL subscribeUrl = <span class=\"keyword\">new</span> URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), <span class=\"number\">0</span>, type.getName(), parameters);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Constants.ANY_VALUE.equals(url.getServiceInterface())</span><br><span class=\"line\">        &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">        registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,</span><br><span class=\"line\">                                                     Constants.CHECK_KEY, String.valueOf(<span class=\"keyword\">false</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//订阅注册中心，可以获取服务提供方地址等信息</span></span><br><span class=\"line\">    directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,</span><br><span class=\"line\">                                                  Constants.PROVIDERS_CATEGORY</span><br><span class=\"line\">                                                  + <span class=\"string\">\",\"</span> + Constants.CONFIGURATORS_CATEGORY</span><br><span class=\"line\">                                                  + <span class=\"string\">\",\"</span> + Constants.ROUTERS_CATEGORY));</span><br><span class=\"line\">    <span class=\"comment\">//通过调用Cluster$Adpative类的join方法返回Invoker对象(基于Dubbo SPI机制实现setXX()方法自动注入属性)</span></span><br><span class=\"line\">    Invoker invoker = cluster.join(directory);</span><br><span class=\"line\">    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invoker;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里看下<code>Cluster$Adpative</code>类的join方法实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.apache.dubbo.rpc.cluster;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cluster</span>$<span class=\"title\">Adaptive</span> <span class=\"keyword\">implements</span> <span class=\"title\">org</span>.<span class=\"title\">apache</span>.<span class=\"title\">dubbo</span>.<span class=\"title\">rpc</span>.<span class=\"title\">cluster</span>.<span class=\"title\">Cluster</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> org.apache.dubbo.common.logger.Logger logger = org.apache.dubbo.common.logger.LoggerFactory.getLogger(ExtensionLoader.class);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> java.util.concurrent.atomic.AtomicInteger count = <span class=\"keyword\">new</span> java.util.concurrent.atomic.AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Invoker <span class=\"title\">join</span><span class=\"params\">(org.apache.dubbo.rpc.cluster.Directory arg0)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.cluster.Directory argument == null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0.getUrl() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.cluster.Directory argument getUrl() == null\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class=\"line\">        String extName = url.getParameter(<span class=\"string\">\"cluster\"</span>, <span class=\"string\">\"failover\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.rpc.cluster.Cluster) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([cluster])\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.rpc.cluster.Cluster extension = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            extension = (org.apache.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.cluster.Cluster.class).getExtension(extName);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count.incrementAndGet() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"Failed to find extension named \"</span> + extName + <span class=\"string\">\" for type org.apache.dubbo.rpc.cluster.Cluster, will use default extension failover instead.\"</span>, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            extension = (org.apache.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.cluster.Cluster.class).getExtension(<span class=\"string\">\"failover\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension.join(arg0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看下FailoverCluster的join方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">join</span><span class=\"params\">(Directory&lt;T&gt; directory)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FailoverClusterInvoker&lt;T&gt;(directory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于Cluster SPI实现中有个MockClusterWrapper是包装类，这里牵扯到<strong>Dubbo的AOP机制(后期详细分析)</strong>，这里先调用它的join方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">join</span><span class=\"params\">(Directory&lt;T&gt; directory)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MockClusterInvoker&lt;T&gt;(directory,</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.cluster.join(directory));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成MockClusterInvoker之后，由于FailoverClusterInvoker是AbstractClusterInvoker的子类，它的invoke方法实现在其父类中，接下来的调用链是<code>MockClusterInvoker.invoke()-&gt;AbstractClusterInvoker.invoke()-&gt;FailoverClusterInvoker.doInvoke()</code>，下面来一步步分析，首先来看MockClusterInvoker类的invoke()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    Result result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value.length() == <span class=\"number\">0</span> || value.equalsIgnoreCase(<span class=\"string\">\"false\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//no mock</span></span><br><span class=\"line\">        result = <span class=\"keyword\">this</span>.invoker.invoke(invocation);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.startsWith(<span class=\"string\">\"force\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"force-mock: \"</span> + invocation.getMethodName() + <span class=\"string\">\" force-mock enabled , url : \"</span> + directory.getUrl());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//force:direct mock</span></span><br><span class=\"line\">        result = doMockInvoke(invocation, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//fail-mock</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            result = <span class=\"keyword\">this</span>.invoker.invoke(invocation);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RpcException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.isBiz()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">                    logger.warn(<span class=\"string\">\"fail-mock: \"</span> + invocation.getMethodName() + <span class=\"string\">\" fail-mock enabled , url : \"</span> + directory.getUrl(), e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                result = doMockInvoke(invocation, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后调用AbstractClusterInvoker的invoke()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(<span class=\"keyword\">final</span> Invocation invocation)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    checkWhetherDestroyed();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// binding attachments into invocation.</span></span><br><span class=\"line\">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contextAttachments != <span class=\"keyword\">null</span> &amp;&amp; contextAttachments.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ((RpcInvocation) invocation).addAttachments(contextAttachments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class=\"line\">    LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class=\"line\">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后调用FailoverClusterInvoker的doInvoke()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation, <span class=\"keyword\">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers;</span><br><span class=\"line\">    checkInvokers(copyinvokers, invocation);</span><br><span class=\"line\">    String methodName = RpcUtils.getMethodName(invocation);</span><br><span class=\"line\">    <span class=\"comment\">//设置重试次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        len = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// retry loop.</span></span><br><span class=\"line\">    RpcException le = <span class=\"keyword\">null</span>; <span class=\"comment\">// last exception.</span></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invoked = <span class=\"keyword\">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size()); <span class=\"comment\">// invoked invokers.</span></span><br><span class=\"line\">    Set&lt;String&gt; providers = <span class=\"keyword\">new</span> HashSet&lt;String&gt;(len);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Reselect before retry to avoid a change of candidate `invokers`.</span></span><br><span class=\"line\">        <span class=\"comment\">//<span class=\"doctag\">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            checkWhetherDestroyed();</span><br><span class=\"line\">            copyinvokers = list(invocation);</span><br><span class=\"line\">            <span class=\"comment\">// check again</span></span><br><span class=\"line\">            checkInvokers(copyinvokers, invocation);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//根据负载均衡策略选择调用者</span></span><br><span class=\"line\">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);</span><br><span class=\"line\">        <span class=\"comment\">//将使用过的invoker放入invoked</span></span><br><span class=\"line\">        invoked.add(invoker);</span><br><span class=\"line\">        RpcContext.getContext().setInvokers((List) invoked);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Result result = invoker.invoke(invocation);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (le != <span class=\"keyword\">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"Although retry the method \"</span> + methodName</span><br><span class=\"line\">                            + <span class=\"string\">\" in the service \"</span> + getInterface().getName()</span><br><span class=\"line\">                            + <span class=\"string\">\" was successful by the provider \"</span> + invoker.getUrl().getAddress()</span><br><span class=\"line\">                            + <span class=\"string\">\", but there have been failed providers \"</span> + providers</span><br><span class=\"line\">                            + <span class=\"string\">\" (\"</span> + providers.size() + <span class=\"string\">\"/\"</span> + copyinvokers.size()</span><br><span class=\"line\">                            + <span class=\"string\">\") from the registry \"</span> + directory.getUrl().getAddress()</span><br><span class=\"line\">                            + <span class=\"string\">\" on the consumer \"</span> + NetUtils.getLocalHost()</span><br><span class=\"line\">                            + <span class=\"string\">\" using the dubbo version \"</span> + Version.getVersion() + <span class=\"string\">\". Last error is: \"</span></span><br><span class=\"line\">                            + le.getMessage(), le);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RpcException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.isBiz()) &#123; <span class=\"comment\">// biz exception.</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            le = e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            le = <span class=\"keyword\">new</span> RpcException(e.getMessage(), e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            providers.add(invoker.getUrl().getAddress());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(le.getCode(), <span class=\"string\">\"Failed to invoke the method \"</span></span><br><span class=\"line\">                           + methodName + <span class=\"string\">\" in the service \"</span> + getInterface().getName()</span><br><span class=\"line\">                           + <span class=\"string\">\". Tried \"</span> + len + <span class=\"string\">\" times of the providers \"</span> + providers</span><br><span class=\"line\">                           + <span class=\"string\">\" (\"</span> + providers.size() + <span class=\"string\">\"/\"</span> + copyinvokers.size()</span><br><span class=\"line\">                           + <span class=\"string\">\") from the registry \"</span> + directory.getUrl().getAddress()</span><br><span class=\"line\">                           + <span class=\"string\">\" on the consumer \"</span> + NetUtils.getLocalHost() + <span class=\"string\">\" using the dubbo version \"</span></span><br><span class=\"line\">                           + Version.getVersion() + <span class=\"string\">\". Last error is: \"</span></span><br><span class=\"line\">                           + le.getMessage(), le.getCause() != <span class=\"keyword\">null</span> ? le.getCause() : le);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以会有如下的线程栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:78)</span><br><span class=\"line\">at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:243)</span><br><span class=\"line\">at org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:75)</span><br></pre></td></tr></table></figure>\n<p>这些类都是关于<strong>Dubbo的集群容错机制</strong>（将会写一篇关于Dubbo的集群容错机制）。</p>\n<p>再往下看invokers是如何生成的呢？又回到AbstractClusterInvoker的invoke方法实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(<span class=\"keyword\">final</span> Invocation invocation)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    checkWhetherDestroyed();</span><br><span class=\"line\">    LoadBalance loadbalance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// binding attachments into invocation.</span></span><br><span class=\"line\">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contextAttachments != <span class=\"keyword\">null</span> &amp;&amp; contextAttachments.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ((RpcInvocation) invocation).addAttachments(contextAttachments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//会调用directory的list方法 返回要调用invokers集合。</span></span><br><span class=\"line\">    <span class=\"comment\">//其实是AbstractDirectory的list方法，这个方法里就是利用路由规则（如果有），从所有</span></span><br><span class=\"line\">    <span class=\"comment\">//提供者中，遴选出符合规则的提供者,接下里才是，集群容错和负载均衡。</span></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (invokers != <span class=\"keyword\">null</span> &amp;&amp; !invokers.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//通过key（loadbalance）从url中取值，默认值为random</span></span><br><span class=\"line\">        loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(<span class=\"number\">0</span>).getUrl()                                                                                .getMethodParameter(RpcUtils.getMethodName(invocation), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看一下list方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class=\"keyword\">throws</span> RpcException &#123;</span><br><span class=\"line\">    <span class=\"comment\">//directory.list(invocation)获取invokers，这里directory是RegistryDirectory</span></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invokers = directory.list(invocation);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invokers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>跟到RegistryDirectory类的list方法，实现在其父类AbstractDirectory中，主要是<strong>生成路由规则</strong>（将会在另一篇文章中详细讲解，敬请期待）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class=\"keyword\">throws</span> RpcException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (destroyed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Directory already destroyed .url: \"</span> + getUrl());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取所有的提供者</span></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br><span class=\"line\">    <span class=\"comment\">//本地路由规则</span></span><br><span class=\"line\">    List&lt;Router&gt; localRouters = <span class=\"keyword\">this</span>.routers; <span class=\"comment\">// local reference</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (localRouters != <span class=\"keyword\">null</span> &amp;&amp; !localRouters.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Router router : localRouters) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (router.getUrl() == <span class=\"keyword\">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//Router接口，实现route的方法，路由获取服务提供者</span></span><br><span class=\"line\">                    invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">\"Failed to execute router: \"</span> + getUrl() + <span class=\"string\">\", cause: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invokers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看一下doList方法，它是个抽象方法具体实现在RegistryDirectory类中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//没有服务提供者或者服务提供者被禁用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forbidden) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. No service provider 2. Service providers are disabled</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(RpcException.FORBIDDEN_EXCEPTION,</span><br><span class=\"line\">                               <span class=\"string\">\"No provider available from registry \"</span> + getUrl().getAddress() + <span class=\"string\">\" for service \"</span> + getConsumerUrl().getServiceKey() + <span class=\"string\">\" on consumer \"</span> + NetUtils.getLocalHost()</span><br><span class=\"line\">                               + <span class=\"string\">\" use dubbo version \"</span> + Version.getVersion() + <span class=\"string\">\", please check status of providers(disabled, not registered or in blacklist).\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invokers = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从这里搜索methodInvokerMap赋值，在refreshInvoker方法里</span></span><br><span class=\"line\">    Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap = <span class=\"keyword\">this</span>.methodInvokerMap; <span class=\"comment\">// local reference</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (localMethodInvokerMap != <span class=\"keyword\">null</span> &amp;&amp; localMethodInvokerMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class=\"line\">        Object[] args = RpcUtils.getArguments(invocation);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args != <span class=\"keyword\">null</span> &amp;&amp; args.length &gt; <span class=\"number\">0</span> &amp;&amp; args[<span class=\"number\">0</span>] != <span class=\"keyword\">null</span></span><br><span class=\"line\">            &amp;&amp; (args[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> String || args[<span class=\"number\">0</span>].getClass().isEnum())) &#123;</span><br><span class=\"line\">            invokers = localMethodInvokerMap.get(methodName + <span class=\"string\">\".\"</span> + args[<span class=\"number\">0</span>]); <span class=\"comment\">// The routing can be enumerated according to the first parameter</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invokers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            invokers = localMethodInvokerMap.get(methodName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invokers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invokers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator = localMethodInvokerMap.values().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                invokers = iterator.next();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invokers == <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(<span class=\"number\">0</span>) : invokers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是<code>refreshInvoker(List&lt;URL&gt; invokerUrls)</code>方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Convert the invokerURL list to the Invoker Map. The rules of the conversion are as follows:</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.If URL has been converted to invoker, it is no longer re-referenced and obtained directly from the cache, and notice that any parameter changes in the URL will be re-referenced.</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.If the incoming invoker list is not empty, it means that it is the latest invoker list</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.If the list of incoming invokerUrl is empty, It means that the rule is only a override rule or a route rule, which needs to be re-contrasted to decide whether to re-reference.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> invokerUrls this parameter can't be null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> 2017/8/31 FIXME The thread pool should be used to refresh the address, otherwise the task may be accumulated.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">refreshInvoker</span><span class=\"params\">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (invokerUrls != <span class=\"keyword\">null</span> &amp;&amp; invokerUrls.size() == <span class=\"number\">1</span> &amp;&amp; invokerUrls.get(<span class=\"number\">0</span>) != <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(<span class=\"number\">0</span>).getProtocol())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//禁止访问</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.forbidden = <span class=\"keyword\">true</span>; <span class=\"comment\">// Forbid to access</span></span><br><span class=\"line\">        <span class=\"comment\">//置空列表</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.methodInvokerMap = <span class=\"keyword\">null</span>; <span class=\"comment\">// Set the method invoker map to null</span></span><br><span class=\"line\">        <span class=\"comment\">//关闭所有invokers</span></span><br><span class=\"line\">        destroyAllInvokers(); <span class=\"comment\">// Close all invokers</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//允许访问</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.forbidden = <span class=\"keyword\">false</span>; <span class=\"comment\">// Allow to access</span></span><br><span class=\"line\">        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class=\"keyword\">this</span>.urlInvokerMap; <span class=\"comment\">// local reference</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class=\"keyword\">this</span>.cachedInvokerUrls != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            invokerUrls.addAll(<span class=\"keyword\">this</span>.cachedInvokerUrls);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.cachedInvokerUrls = <span class=\"keyword\">new</span> HashSet&lt;URL&gt;();</span><br><span class=\"line\">            <span class=\"comment\">//缓存invokerUrls列表，便于交叉对比</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.cachedInvokerUrls.addAll(invokerUrls);<span class=\"comment\">//Cached invoker urls, convenient for comparison</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invokerUrls.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//生成invoker方法 toInvokers</span></span><br><span class=\"line\">        <span class=\"comment\">//将url列表转换成invoker列表</span></span><br><span class=\"line\">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);<span class=\"comment\">// Translate url list to Invoker map</span></span><br><span class=\"line\">        <span class=\"comment\">//换方法名映射invoker列表</span></span><br><span class=\"line\">        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); <span class=\"comment\">// Change method name to map Invoker Map</span></span><br><span class=\"line\">        <span class=\"comment\">// state change</span></span><br><span class=\"line\">        <span class=\"comment\">// If the calculation is wrong, it is not processed.</span></span><br><span class=\"line\">        <span class=\"comment\">//如果计算错误则不进行处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newUrlInvokerMap == <span class=\"keyword\">null</span> || newUrlInvokerMap.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"urls to invokers error .invokerUrls.size :\"</span> + invokerUrls.size() + <span class=\"string\">\", invoker.size :0. urls :\"</span> + invokerUrls.toString()));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//关闭不使用的invoker</span></span><br><span class=\"line\">            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); <span class=\"comment\">// Close the unused Invoker</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"destroyUnusedInvokers error. \"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以知道refreshInvoker()方法会在RegistryDirectory类的notify()方法里调用，这个方法是<strong>订阅注册中心的回调方法</strong>。下面来看一下toInvokers()的方法实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Turn urls into invokers, and if url has been refer, will not re-reference.</span></span><br><span class=\"line\"><span class=\"comment\">     * 将urls转换成invokers，如果url已经被refer过则不在重新引用</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> urls</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> invokers</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class=\"line\">    Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class=\"keyword\">new</span> HashMap&lt;String, Invoker&lt;T&gt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls == <span class=\"keyword\">null</span> || urls.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newUrlInvokerMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Set&lt;String&gt; keys = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">    String queryProtocols = <span class=\"keyword\">this</span>.queryMap.get(Constants.PROTOCOL_KEY);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (URL providerUrl : urls) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If protocol is configured at the reference side, only the matching protocol is selected</span></span><br><span class=\"line\">        <span class=\"comment\">//若果reference端配置了protocol，则只选择匹配的protocol</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queryProtocols != <span class=\"keyword\">null</span> &amp;&amp; queryProtocols.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> accept = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            String[] acceptProtocols = queryProtocols.split(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String acceptProtocol : acceptProtocols) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class=\"line\">                    accept = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!accept) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unsupported protocol \"</span> + providerUrl.getProtocol() + <span class=\"string\">\" in notified url: \"</span> + providerUrl + <span class=\"string\">\" from registry \"</span> + getUrl().getAddress() + <span class=\"string\">\" to consumer \"</span> + NetUtils.getLocalHost()</span><br><span class=\"line\">                                                   + <span class=\"string\">\", supported protocol: \"</span> + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        URL url = mergeUrl(providerUrl);</span><br><span class=\"line\">\t\t<span class=\"comment\">//url参数是排序的</span></span><br><span class=\"line\">        String key = url.toFullString(); <span class=\"comment\">// The parameter urls are sorted</span></span><br><span class=\"line\">        <span class=\"comment\">//跳过重复的url</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (keys.contains(key)) &#123; <span class=\"comment\">// Repeated url</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        keys.add(key);</span><br><span class=\"line\">        <span class=\"comment\">// Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again</span></span><br><span class=\"line\">        <span class=\"comment\">//缓存key为没有合并消费端参数的URL，不管消费端如何合并参数，如果服务端URL发生变化，则重新refer</span></span><br><span class=\"line\">        Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class=\"keyword\">this</span>.urlInvokerMap; <span class=\"comment\">// local reference</span></span><br><span class=\"line\">        Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : localUrlInvokerMap.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invoker == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Not in the cache, refer again</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> enabled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class=\"line\">                    enabled = !url.getParameter(Constants.DISABLED_KEY, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    enabled = url.getParameter(Constants.ENABLED_KEY, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (enabled) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//创建invoker（这里创建invoker）</span></span><br><span class=\"line\">                    invoker = <span class=\"keyword\">new</span> InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">\"Failed to refer invoker for interface:\"</span> + serviceType + <span class=\"string\">\",url:(\"</span> + url + <span class=\"string\">\")\"</span> + t.getMessage(), t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (invoker != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Put new invoker in cache</span></span><br><span class=\"line\">                <span class=\"comment\">//将新的引用放入缓存</span></span><br><span class=\"line\">                newUrlInvokerMap.put(key, invoker);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            newUrlInvokerMap.put(key, invoker);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    keys.clear();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newUrlInvokerMap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>找到了invoker的创建地方，来看下InvokerDelegate，它是RegistryDirectory的内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The delegate class, which is mainly used to store the URL address sent by the registry,and can be reassembled on the basis of providerURL queryMap overrideMap for re-refer.</span></span><br><span class=\"line\"><span class=\"comment\">     * 代理类，主要用于存储注册中心下发的URL地址</span></span><br><span class=\"line\"><span class=\"comment\">     * 用于重新refer时能够根据providerURL queryMap overrideMap重新组装</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InvokerDelegate</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">InvokerWrapper</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> URL providerUrl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InvokerDelegate</span><span class=\"params\">(Invoker&lt;T&gt; invoker, URL url, URL providerUrl)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用父类构造方法</span></span><br><span class=\"line\">        <span class=\"keyword\">super</span>(invoker, url);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.providerUrl = providerUrl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> URL <span class=\"title\">getProviderUrl</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> providerUrl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>invoke方法在父类InvokerWrapper里实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里的invoker是从它的构造方法里传入的</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> invoker.invoke(invocation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以在调用栈里可以看到如下一条信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:56)</span><br></pre></td></tr></table></figure>\n<p>InvokerDelegete构造方法调用的父类InvokerWrapper的构造方法并传入invoker实例，回头看<code>new InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</code>这句，可知上面的invoker的是由<code>protocol.refer(serviceType, url)</code>创建的。</p>\n<p>通过debug可得知这里的protocol是Protocol$Adaptive类型的，这里的url的protocol是dubbo，通过Dubbo SPI机制可以得到这里最后走DubboProtocol类的refer()方法，但是由于Protocol接口实现中由两个包装类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class=\"line\">listener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br></pre></td></tr></table></figure>\n<p>所以这里先执行ProtocolFilterWrapper的refer方法，再执行ProtocolListenerWrapper的refer方法，最后才执行DubboProtocol类的refer方法，ProtocolFilterWrapper类的refer方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> protocol.refer(type, url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法里调用了buildInvokerChain()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">buildInvokerChain</span><span class=\"params\">(<span class=\"keyword\">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class=\"line\">    Invoker&lt;T&gt; last = invoker;</span><br><span class=\"line\">    <span class=\"comment\">//先获取激活的过滤器，我们这里手动配置了monitor MonitorFilter过滤器</span></span><br><span class=\"line\">    <span class=\"comment\">//另外两个自动激活的过滤器是FutureFilter，ConsumerContextFilter</span></span><br><span class=\"line\">    <span class=\"comment\">//这里需要看SPI机制的getActivateExtension方法的相关代码</span></span><br><span class=\"line\">    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!filters.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = filters.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Filter filter = filters.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Invoker&lt;T&gt; next = last;</span><br><span class=\"line\">            last = <span class=\"keyword\">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Class&lt;T&gt; <span class=\"title\">getInterface</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invoker.getInterface();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> URL <span class=\"title\">getUrl</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invoker.getUrl();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invoker.isAvailable();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//实现invoker的invoke方法</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//嵌套进过滤器链</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> filter.invoke(next, invocation);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    invoker.destroy();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invoker.toString();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以有如下的调用栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:47)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)</span><br><span class=\"line\">at org.apache.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:50)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)</span><br></pre></td></tr></table></figure>\n<p>接着ProtocolListenerWrapper的refer方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> protocol.refer(type, url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取激活的监听器，目前dubbo没有提供合适的监听器，只有一个DeprecatedInvokerListener实现类，并且还是Deprecated的</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListenerInvokerWrapper&lt;T&gt;(protocol.refer(type, url),</span><br><span class=\"line\">                                         Collections.unmodifiableList(</span><br><span class=\"line\">                                             ExtensionLoader.getExtensionLoader(InvokerListener.class)</span><br><span class=\"line\">                                             .getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以会出现如下栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:77)</span><br></pre></td></tr></table></figure>\n<p>最后看一下DubboProtocol类的refer方法，这里创建了DubboInvoker对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; serviceType, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    optimizeSerialization(url);</span><br><span class=\"line\">    <span class=\"comment\">// create rpc invoker.</span></span><br><span class=\"line\">    DubboInvoker&lt;T&gt; invoker = <span class=\"keyword\">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class=\"line\">    invokers.add(invoker);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invoker;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DubboInvoker的父类AbstractInvoker实现了invoke方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(Invocation inv)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (destroyed.get()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Rpc invoker for service \"</span> + <span class=\"keyword\">this</span> + <span class=\"string\">\" on consumer \"</span> + NetUtils.getLocalHost()</span><br><span class=\"line\">                               + <span class=\"string\">\" use dubbo version \"</span> + Version.getVersion()</span><br><span class=\"line\">                               + <span class=\"string\">\" is DESTROYED, can not be invoked any more!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RpcInvocation invocation = (RpcInvocation) inv;</span><br><span class=\"line\">    invocation.setInvoker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (attachment != <span class=\"keyword\">null</span> &amp;&amp; attachment.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        invocation.addAttachmentsIfAbsent(attachment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contextAttachments != <span class=\"keyword\">null</span> &amp;&amp; contextAttachments.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * invocation.addAttachmentsIfAbsent(context)&#123;<span class=\"doctag\">@link</span> RpcInvocation#addAttachmentsIfAbsent(Map)&#125;should not be used here,</span></span><br><span class=\"line\"><span class=\"comment\">             * because the &#123;<span class=\"doctag\">@link</span> RpcContext#setAttachment(String, String)&#125; is passed in the Filter when the call is triggered</span></span><br><span class=\"line\"><span class=\"comment\">             * by the built-in retry mechanism of the Dubbo. The attachment to update RpcContext will no longer work, which is</span></span><br><span class=\"line\"><span class=\"comment\">             * a mistake in most cases (for example, through Filter to RpcContext output traceId and spanId and other information).</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">        invocation.addAttachments(contextAttachments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">        invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//doInvoke()方法具体实现在子类中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> doInvoke(invocation);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123; <span class=\"comment\">// biz exception</span></span><br><span class=\"line\">        Throwable te = e.getTargetException();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (te == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (te <span class=\"keyword\">instanceof</span> RpcException) &#123;</span><br><span class=\"line\">                ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult(te);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RpcException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.isBiz()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看一下DubboInvoker实现的doInvoke方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(<span class=\"keyword\">final</span> Invocation invocation)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class=\"line\">    inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br><span class=\"line\">    inv.setAttachment(Constants.VERSION_KEY, version);</span><br><span class=\"line\"></span><br><span class=\"line\">    ExchangeClient currentClient;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clients.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        currentClient = clients[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isAsyncFuture = RpcUtils.isGeneratedFuture(inv) || RpcUtils.isFutureReturnType(inv);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isOneway) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            currentClient.send(inv, isSent);</span><br><span class=\"line\">            RpcContext.getContext().setFuture(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isAsync) &#123;</span><br><span class=\"line\">            ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class=\"line\">            <span class=\"comment\">// For compatibility</span></span><br><span class=\"line\">            FutureAdapter&lt;Object&gt; futureAdapter = <span class=\"keyword\">new</span> FutureAdapter&lt;&gt;(future);</span><br><span class=\"line\">            RpcContext.getContext().setFuture(futureAdapter);</span><br><span class=\"line\"></span><br><span class=\"line\">            Result result;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isAsyncFuture) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// register resultCallback, sometimes we need the asyn result being processed by the filter chain.</span></span><br><span class=\"line\">                result = <span class=\"keyword\">new</span> AsyncRpcResult(futureAdapter, futureAdapter.getResultFuture(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                result = <span class=\"keyword\">new</span> SimpleAsyncRpcResult(futureAdapter, futureAdapter.getResultFuture(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            RpcContext.getContext().setFuture(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (TimeoutException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class=\"string\">\"Invoke remote method timeout. method: \"</span> + invocation.getMethodName() + <span class=\"string\">\", provider: \"</span> + getUrl() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class=\"string\">\"Failed to invoke remote method: \"</span> + invocation.getMethodName() + <span class=\"string\">\", provider: \"</span> + getUrl() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以会有这两句线程栈输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:108)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:154)</span><br></pre></td></tr></table></figure>\n<p>接下来就是用于发送请求的currentClient对象的实现了，它的逻辑可以追踪到DubboProtocol类的refer方法里：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; serviceType, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    optimizeSerialization(url);</span><br><span class=\"line\">    <span class=\"comment\">// create rpc invoker.</span></span><br><span class=\"line\">    DubboInvoker&lt;T&gt; invoker = <span class=\"keyword\">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class=\"line\">    invokers.add(invoker);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invoker;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体的获取逻辑在getClients()方法中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// whether to share connection</span></span><br><span class=\"line\">    <span class=\"comment\">//是否共享连接</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> service_share_connect = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> connections = url.getParameter(Constants.CONNECTIONS_KEY, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// if not configured, connection is shared, otherwise, one connection for one service</span></span><br><span class=\"line\">    <span class=\"comment\">//如果没有配置connection，那么就创建共享连接，否则一个服务一个连接？</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connections == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        service_share_connect = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        connections = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ExchangeClient[] clients = <span class=\"keyword\">new</span> ExchangeClient[connections];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (service_share_connect) &#123;</span><br><span class=\"line\">            clients[i] = getSharedClient(url);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            clients[i] = initClient(url);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clients;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Get shared connection</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ExchangeClient <span class=\"title\">getSharedClient</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    String key = url.getAddress();</span><br><span class=\"line\">    ReferenceCountExchangeClient client = referenceClientMap.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (client != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!client.isClosed()) &#123;</span><br><span class=\"line\">            client.incrementAndGetCount();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            referenceClientMap.remove(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    locks.putIfAbsent(key, <span class=\"keyword\">new</span> Object());</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (locks.get(key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (referenceClientMap.containsKey(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> referenceClientMap.get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExchangeClient exchangeClient = initClient(url);</span><br><span class=\"line\">        client = <span class=\"keyword\">new</span> ReferenceCountExchangeClient(exchangeClient, ghostClientMap);</span><br><span class=\"line\">        referenceClientMap.put(key, client);</span><br><span class=\"line\">        ghostClientMap.remove(key);</span><br><span class=\"line\">        locks.remove(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Create new connection</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ExchangeClient <span class=\"title\">initClient</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// client type setting.</span></span><br><span class=\"line\">    String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));</span><br><span class=\"line\"></span><br><span class=\"line\">    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class=\"line\">    <span class=\"comment\">// enable heartbeat by default</span></span><br><span class=\"line\">    <span class=\"comment\">//默认开启heartbeat</span></span><br><span class=\"line\">    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// BIO is not allowed since it has severe performance issue.</span></span><br><span class=\"line\">    <span class=\"comment\">//BIO存在严重的性能问题，因此不能使用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str != <span class=\"keyword\">null</span> &amp;&amp; str.length() &gt; <span class=\"number\">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Unsupported client type: \"</span> + str + <span class=\"string\">\",\"</span> +</span><br><span class=\"line\">                               <span class=\"string\">\" supported client type is \"</span> + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), <span class=\"string\">\" \"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ExchangeClient client;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// connection should be lazy</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (url.getParameter(Constants.LAZY_CONNECT_KEY, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">            client = <span class=\"keyword\">new</span> LazyConnectExchangeClient(url, requestHandler);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//通过 Exchangers.connect(url, requestHandler); 构建client ，接下来跟踪Exchangers.connect方法</span></span><br><span class=\"line\">\t\t    <span class=\"comment\">//这里会传入一个requestHandler，这个是客户端解救服务端方法返回回调的</span></span><br><span class=\"line\">            client = Exchangers.connect(url, requestHandler);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Fail to create remoting client for service(\"</span> + url + <span class=\"string\">\"): \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里用到了<strong>Facade设计模式，Exchangers是个门面类</strong>，封装了具体查找合适的Exchanger实现，并调用connect方法返回ExchangeClient的过程，相关代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExchangeClient <span class=\"title\">connect</span><span class=\"params\">(URL url, ExchangeHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"handler == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class=\"string\">\"exchange\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//把codec key设置为exchange</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getExchanger(url).connect(url, handler);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Exchanger <span class=\"title\">getExchanger</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class=\"line\">    <span class=\"comment\">//通过exchanger key 获取 Exchanger的spi实现，默认是header，这里是HeaderExchanger类</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getExchanger(type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Exchanger <span class=\"title\">getExchanger</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里返回Exchanger接口的header扩展类的HeaderExchanger</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看一下HeaderExchanger类的connect方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//客户端的连接操作</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ExchangeClient <span class=\"title\">connect</span><span class=\"params\">(URL url, ExchangeHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HeaderExchangeClient(Transporters.connect(url, <span class=\"keyword\">new</span> DecodeHandler(<span class=\"keyword\">new</span> HeaderExchangeHandler(handler))), <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以有栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeClient.request(HeaderExchangeClient.java:90)</span><br></pre></td></tr></table></figure>\n<p>再来看HeaderExchnageClient的request()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HeaderExchangeClient</span><span class=\"params\">(Client client, <span class=\"keyword\">boolean</span> needHeartbeat)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (client == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"client == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.client = client;</span><br><span class=\"line\">    <span class=\"comment\">//初始化HeaderExchangeChannel</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.channel = <span class=\"keyword\">new</span> HeaderExchangeChannel(client);</span><br><span class=\"line\">    String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != <span class=\"keyword\">null</span> &amp;&amp; dubbo.startsWith(<span class=\"string\">\"1.0.\"</span>) ? Constants.DEFAULT_HEARTBEAT : <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (heartbeatTimeout &lt; heartbeat * <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"heartbeatTimeout &lt; heartbeatInterval * 2\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (needHeartbeat) &#123;</span><br><span class=\"line\">        startHeartbeatTimer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ResponseFuture <span class=\"title\">request</span><span class=\"params\">(Object request)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用Channel的request方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> channel.request(request);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此会有如下的栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.request(HeaderExchangeChannel.java:116)</span><br></pre></td></tr></table></figure>\n<p>再来看一下HeaderExchangeChannel的request方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ResponseFuture <span class=\"title\">request</span><span class=\"params\">(Object request)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ResponseFuture <span class=\"title\">request</span><span class=\"params\">(Object request, <span class=\"keyword\">int</span> timeout)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (closed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(<span class=\"keyword\">this</span>.getLocalAddress(), <span class=\"keyword\">null</span>, <span class=\"string\">\"Failed to send request \"</span> + request + <span class=\"string\">\", cause: The channel \"</span> + <span class=\"keyword\">this</span> + <span class=\"string\">\" is closed!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// create request.</span></span><br><span class=\"line\">    Request req = <span class=\"keyword\">new</span> Request();</span><br><span class=\"line\">    req.setVersion(Version.getProtocolVersion());</span><br><span class=\"line\">    req.setTwoWay(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    req.setData(request);</span><br><span class=\"line\">    DefaultFuture future = <span class=\"keyword\">new</span> DefaultFuture(channel, req, timeout);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//发送请求</span></span><br><span class=\"line\">        channel.send(req);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123;</span><br><span class=\"line\">        future.cancel();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>channel.send(req);</code>中channel实例是通过<code>HeaderExchangeChannel(Channel channel)</code>构造函数初始化的，继续往上看是通过构造函数<code>public HeaderExchangeClient(Client client, boolean needHeartbeat)</code>传进来的，最终生成channel的代码是在类<code>HeaderExchanger</code>中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ExchangeClient <span class=\"title\">connect</span><span class=\"params\">(URL url, ExchangeHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HeaderExchangeClient(Transporters.connect(url, <span class=\"keyword\">new</span> DecodeHandler(<span class=\"keyword\">new</span> HeaderExchangeHandler(handler))), <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用<code>Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler)))</code>生成channel实例，<strong>这里Transporters也是个门面类，是Facade设计模式的实现</strong>，继续分析Transporters的connect方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Client <span class=\"title\">connect</span><span class=\"params\">(URL url, ChannelHandler... handlers)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ChannelHandler handler;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handlers == <span class=\"keyword\">null</span> || handlers.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        handler = <span class=\"keyword\">new</span> ChannelHandlerAdapter();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (handlers.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        handler = handlers[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        handler = <span class=\"keyword\">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//所以这里默认返回的NettyClient</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getTransporter().connect(url, handler);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//这个方法根据spi返回NettyTransporter扩展类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Transporter <span class=\"title\">getTransporter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//生成Transporter$Adaptive类</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以最后是通过NettyClient类实例的send方法发送具体请求，NettyClient类的send方法在其祖先类AbstractPeer中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Object message)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    send(message, url.getParameter(Constants.SENT_KEY, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个实现又调用NettyClient父类AbstractClient的send方法实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Object message, <span class=\"keyword\">boolean</span> sent)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (send_reconnect &amp;&amp; !isConnected()) &#123;</span><br><span class=\"line\">        connect();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取具体的channel实例</span></span><br><span class=\"line\">    Channel channel = getChannel();</span><br><span class=\"line\">    <span class=\"comment\">//TODO Can the value returned by getChannel() be null? need improvement.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel == <span class=\"keyword\">null</span> || !channel.isConnected()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(<span class=\"keyword\">this</span>, <span class=\"string\">\"message can not send, because channel is closed . url:\"</span> + getUrl());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    channel.send(message, sent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的getChannel()方法由NettyClient自身实现，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> org.apache.dubbo.remoting.<span class=\"function\">Channel <span class=\"title\">getChannel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Channel c = channel;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span> || !c.isActive())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> NettyChannel.getOrAddChannel(c, getUrl(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以有如下栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:101)</span><br><span class=\"line\">at org.apache.dubbo.remoting.transport.AbstractClient.send(AbstractClient.java:265)</span><br><span class=\"line\">at org.apache.dubbo.remoting.transport.AbstractPeer.send(AbstractPeer.java:53)</span><br></pre></td></tr></table></figure>\n<p>最后就走到NettyChannel的send方法，即到了断点处：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Object message, <span class=\"keyword\">boolean</span> sent)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.send(message, sent);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> success = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> timeout = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//断点处</span></span><br><span class=\"line\">        ChannelFuture future = channel.writeAndFlush(message);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sent) &#123;</span><br><span class=\"line\">            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class=\"line\">            success = future.await(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Throwable cause = future.cause();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cause != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> cause;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(<span class=\"keyword\">this</span>, <span class=\"string\">\"Failed to send message \"</span> + message + <span class=\"string\">\" to \"</span> + getRemoteAddress() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(<span class=\"keyword\">this</span>, <span class=\"string\">\"Failed to send message \"</span> + message + <span class=\"string\">\" to \"</span> + getRemoteAddress()</span><br><span class=\"line\">                                    + <span class=\"string\">\"in timeout(\"</span> + timeout + <span class=\"string\">\"ms) limit\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此，整个消费者调用过程就分析完了，文章中提到的一些关于Dubbo的核心feature将会写文章进一步分析，敬请期待。</p>\n","site":{"data":{}},"excerpt":"<p>在分析Dubbo RPC服务调用过程之前，我们先写一个基于Dubbo实现的<a href=\"https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo\" target=\"_blank\" rel=\"noopener\"><strong>Consumer-Provider的Demo</strong></a>，通过这个Demo来分析具体的RPC调用栈。</p>\n<p>先定义一个接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Junlan Shuai[shuaijunlan@gmail.com].</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> Created on 11:02 AM 2018/07/19.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ITestService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">sayHello</span><span class=\"params\">(String msg)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们基于zookeeper注册中心，服务端配置如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dubbo-server\"</span> <span class=\"attr\">owner</span>=<span class=\"string\">\"Junlan\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">address</span>=<span class=\"string\">\"zookeeper://127.0.0.1:2181\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--protocal configuration--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:protocol</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dubbo\"</span> <span class=\"attr\">port</span>=<span class=\"string\">\"20881\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:provider</span> <span class=\"attr\">server</span>=<span class=\"string\">\"netty\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--service configuration--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:service</span> <span class=\"attr\">interface</span>=<span class=\"string\">\"cn.shuaijunlan.dubbo.learning.service.ITestService\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"testService\"</span> <span class=\"attr\">protocol</span>=<span class=\"string\">\"dubbo\"</span> <span class=\"attr\">loadbalance</span>=<span class=\"string\">\"roundrobin\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cn.shuaijunlan.dubbo.learning.service.impl.TestServiceImpl\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"testService\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>客户端配置如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:application</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dubbo-client\"</span> <span class=\"attr\">owner</span>=<span class=\"string\">\"Junlan\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:consumer</span> <span class=\"attr\">client</span>=<span class=\"string\">\"netty\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:registry</span> <span class=\"attr\">address</span>=<span class=\"string\">\"zookeeper://127.0.0.1:2181\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">interface</span>=<span class=\"string\">\"cn.shuaijunlan.dubbo.learning.service.ITestService\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"testService\"</span> <span class=\"attr\">check</span>=<span class=\"string\">\"false\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>","more":"<p>项目的部分依赖如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.dubbo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>dubbo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.curator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>curator-framework<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.12.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.zookeeper<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>zookeeper<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.4.9<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>具体的服务提供者实现参照<a href=\"https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo/service-provider-a\" target=\"_blank\" rel=\"noopener\"><strong>service-provider-a</strong></a> ，服务消费者实现参照<a href=\"https://github.com/shuaijunlan/Spring-Learning/tree/master/dubbo/dubbo-client-demo\" target=\"_blank\" rel=\"noopener\"><strong>dubbo-client-demo</strong></a>。</p>\n<p>先启动服务提供者服务，下面分析在哪打断点：</p>\n<p>我们看下<code>org.apache.dubbo.remoting.transport.netty4.NettyChannel</code>的<code>send</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Object message, <span class=\"keyword\">boolean</span> sent)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.send(message, sent);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> success = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> timeout = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//向远程服务发送消息，因此我们在这句打个断点</span></span><br><span class=\"line\">        ChannelFuture future = channel.writeAndFlush(message);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sent) &#123;</span><br><span class=\"line\">            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class=\"line\">            success = future.await(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Throwable cause = future.cause();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cause != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> cause;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(<span class=\"keyword\">this</span>, <span class=\"string\">\"Failed to send message \"</span> + message + <span class=\"string\">\" to \"</span> + getRemoteAddress() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(<span class=\"keyword\">this</span>, <span class=\"string\">\"Failed to send message \"</span> + message + <span class=\"string\">\" to \"</span> + getRemoteAddress()</span><br><span class=\"line\">                                    + <span class=\"string\">\"in timeout(\"</span> + timeout + <span class=\"string\">\"ms) limit\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在<code>ChannelFuture future = channel.writeAndFlush(message);</code>这句打个断点，Debug服务消费者，得到如下线程栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;main@1&quot; prio=5 tid=0x1 nid=NA runnable</span><br><span class=\"line\">  java.lang.Thread.State: RUNNABLE</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:101)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.AbstractClient.send(AbstractClient.java:265)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.transport.AbstractPeer.send(AbstractPeer.java:53)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.request(HeaderExchangeChannel.java:116)</span><br><span class=\"line\">\t  at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeClient.request(HeaderExchangeClient.java:90)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.dubbo.ReferenceCountExchangeClient.request(ReferenceCountExchangeClient.java:83)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:108)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:154)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:77)</span><br><span class=\"line\">\t  at org.apache.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:47)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:50)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:56)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:78)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:243)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:75)</span><br><span class=\"line\">\t  at org.apache.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:70)</span><br><span class=\"line\">\t  at org.apache.dubbo.common.bytecode.proxy0.sayHello(proxy0.java:-1)</span><br><span class=\"line\">\t  at cn.shuaijunlan.dubbo.learning.main.Main.main(Main.java:16)</span><br></pre></td></tr></table></figure>\n<p>自底向上，可以直观的看到服务消费者调用要经过的类和方法，下面将进行一步步分析，对每一个类的创建过程和调用过程做出解析：</p>\n<ul>\n<li>第一行栈信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at cn.shuaijunlan.dubbo.learning.main.Main.main(Main.java:16)</span><br></pre></td></tr></table></figure>\n<p>Main.java 类是消费者端的启动类，可以忽略。</p>\n<ul>\n<li>第二行栈信息</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.common.bytecode.proxy0.sayHello(proxy0.java:-1)</span><br></pre></td></tr></table></figure>\n<p><code>org.apache.dubbo.common.bytecode.proxy0</code>类是一个代理类，它代理了所有RPC服务接口的方法调用。这个类实例是什么时候创建的？类代码是怎样的？</p>\n<p><strong>Dubbo基于Spring的构建分析</strong>（参考文章<a href=\"https://shuaijunlan.github.io/2018/08/13/dubbo-basing-on-spring-framework-analysis/\"><strong>《基于Spring构建Dubbo源码分析》</strong></a>）， 代理类的创建是由ReferenceBean类的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> get();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法里触发的，具体的实现在ReferenceConfig类createProxy方法里</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>, <span class=\"string\">\"deprecation\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">createProxy</span><span class=\"params\">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// 用于生成invoker的逻辑，关于invoker生成逻辑这里先忽略，后面会说到</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// create service proxy</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) proxyFactory.getProxy(invoker);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>proxyFactory变量赋值为</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>\n<p><strong>Dubbo SPI机制</strong>(参考文章<a href=\"https://shuaijunlan.github.io/2018/08/09/dubbo-spi-analysis/\"><strong>《Dubbo SPI机制源码分析》</strong></a>)里可以得到ProxyFactory接口的Adaptive类的getProxy方法源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.apache.dubbo.rpc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyFactory</span>$<span class=\"title\">Adaptive</span> <span class=\"keyword\">implements</span> <span class=\"title\">org</span>.<span class=\"title\">apache</span>.<span class=\"title\">dubbo</span>.<span class=\"title\">rpc</span>.<span class=\"title\">ProxyFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> java.lang.<span class=\"function\">Object <span class=\"title\">getProxy</span><span class=\"params\">(org.apache.dubbo.rpc.Invoker arg0)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.Invoker argument == null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0.getUrl() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class=\"line\">        String extName = url.getParameter(<span class=\"string\">\"proxy\"</span>, <span class=\"string\">\"javassist\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.rpc.ProxyFactory) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([proxy])\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension.getProxy(arg0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> java.lang.<span class=\"function\">Object <span class=\"title\">getProxy</span><span class=\"params\">(org.apache.dubbo.rpc.Invoker arg0, <span class=\"keyword\">boolean</span> arg1)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.Invoker argument == null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0.getUrl() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.Invoker argument getUrl() == null\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class=\"line\">        String extName = url.getParameter(<span class=\"string\">\"proxy\"</span>, <span class=\"string\">\"javassist\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.rpc.ProxyFactory) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([proxy])\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension.getProxy(arg0, arg1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Invoker <span class=\"title\">getInvoker</span><span class=\"params\">(java.lang.Object arg0, java.lang.Class arg1, org.apache.dubbo.common.URL arg2)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg2 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.common.URL url = arg2;</span><br><span class=\"line\">        String extName = url.getParameter(<span class=\"string\">\"proxy\"</span>, <span class=\"string\">\"javassist\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.rpc.ProxyFactory) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([proxy])\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension.getInvoker(arg0, arg1, arg2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在如上<code>ProxyFactory$Adaptive</code>类中，调用<code>getProxy(org.apache.dubbo.rpc.Invoker arg0)</code>方法，其中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String extName = url.getParameter(<span class=\"string\">\"proxy\"</span>, <span class=\"string\">\"javassist\"</span>);</span><br><span class=\"line\">org.apache.dubbo.rpc.ProxyFactory extension = (org.apache.dubbo.rpc.ProxyFactory) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.ProxyFactory.class).getExtension(extName);</span><br></pre></td></tr></table></figure>\n<p>默认获取ProxyFactory接口的javassist扩展类JavassistProxyFactory，先调用<code>JavassitProxyFactory</code>的父类ProxyFactory的<code>getProxy(Invoker&lt;T&gt; invoker)</code>方法和<code>getProxy(Invoker&lt;T&gt; invoker, boolean generic)</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getProxy</span><span class=\"params\">(Invoker&lt;T&gt; invoker)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getProxy(invoker, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再调用<code>JavassistProxyFactory</code>类的<code>getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">getProxy</span><span class=\"params\">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class=\"keyword\">new</span> InvokerInvocationHandler(invoker));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再到<strong>生成代理类的Proxy类</strong>（具体过程在另一篇文章中详细分析）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Get proxy.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ics interface class array.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> Proxy instance.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Proxy <span class=\"title\">getProxy</span><span class=\"params\">(Class&lt;?&gt;... ics)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getProxy(ClassHelper.getClassLoader(Proxy.class), ics);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里直接贴出<strong>通过代码hack生成的代理类</strong>源码，这里动态生成了两个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.common.bytecode.ClassGenerator.DC;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Proxy0</span> <span class=\"keyword\">extends</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">DC</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">newInstance</span><span class=\"params\">(InvocationHandler var1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> proxy01(var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Proxy0_my</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个类继承抽象类Proxy，实现了它的抽象方法newInstance，<strong>接口DC是Dubbo内部作为动态类标示的接口</strong>；</p>\n<p>还有一个proxy01，就是在开始方法栈里看到的代理类，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.rpc.service.EchoService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> demo.dubbo.api.DemoService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">proxy01</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClassGenerator</span>.<span class=\"title\">DC</span>, <span class=\"title\">EchoService</span>, <span class=\"title\">DemoService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Method[] methods;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> InvocationHandler handler;</span><br><span class=\"line\">    <span class=\"comment\">//实现了接口方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">sayHello</span><span class=\"params\">(String var1)</span> </span>&#123;</span><br><span class=\"line\">        Object[] var2 = <span class=\"keyword\">new</span> Object[]&#123;var1&#125;;</span><br><span class=\"line\">        Object var3 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            var3 = <span class=\"keyword\">this</span>.handler.invoke(<span class=\"keyword\">this</span>, methods[<span class=\"number\">1</span>], var2);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable throwable) &#123;</span><br><span class=\"line\">            throwable.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (String)var3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object $echo(Object var1) &#123;</span><br><span class=\"line\">        Object[] var2 = <span class=\"keyword\">new</span> Object[]&#123;var1&#125;;</span><br><span class=\"line\">        Object var3 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            var3 = <span class=\"keyword\">this</span>.handler.invoke(<span class=\"keyword\">this</span>, methods[<span class=\"number\">3</span>], var2);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable throwable) &#123;</span><br><span class=\"line\">            throwable.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Object)var3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">proxy01</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//public 构造函数，这里handler是</span></span><br><span class=\"line\">    <span class=\"comment\">//由Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker))语句传入的InvokerInvocationHandler对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">proxy01</span><span class=\"params\">(InvocationHandler var1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handler = var1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到代理类实现类三个接口，<code>ClassGeneratr.DC</code>是Dubbo动态类标识接口，<code>DemoService</code>是实际的业务接口，这样代理就可以调用服务方法了，<code>EchoService</code>是回显测试接口，只有一个<code>$echo(Object var1)</code>法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.apache.dubbo.rpc.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Echo service.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@export</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">EchoService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * echo test.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> message message.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> message.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Object $echo(Object message);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它能为所有的Dubbo RPC服务加上一个回显测试方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过类型强制转换为EchoService，可以测试</span></span><br><span class=\"line\">EchoService echoService = (EchoService) service;</span><br><span class=\"line\">System.out.println(echoService.$echo(<span class=\"string\">\"hello\"</span>));</span><br></pre></td></tr></table></figure>\n<p>到这可以了解代理类生成的整个过程，可以看到sayHello方法的调用其实是调用<code>this.handler.invoke(this, methods[1], var2);</code>，因此这也解释了<strong>线程栈中第三行信息</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:70)</span><br></pre></td></tr></table></figure>\n<p>再往下看<code>org.apache.dubbo.rpc.proxy.InvokerInvocationHandler</code>类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InvokerInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Invoker&lt;?&gt; invoker;</span><br><span class=\"line\">\t<span class=\"comment\">//通过构造函数传入invoker</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InvokerInvocationHandler</span><span class=\"params\">(Invoker&lt;?&gt; handler)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.invoker = handler;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        String methodName = method.getName();</span><br><span class=\"line\">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class=\"line\">        <span class=\"comment\">// 如果是Object类方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//反射调用</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> method.invoke(invoker, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 对toString、hashCode、equals三个方法做了处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"toString\"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> invoker.toString();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"hashCode\"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> invoker.hashCode();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"equals\"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> invoker.equals(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        RpcInvocation invocation;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (RpcUtils.hasGeneratedFuture(method)) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; clazz = method.getDeclaringClass();</span><br><span class=\"line\">            String syncMethodName = methodName.substring(<span class=\"number\">0</span>, methodName.length() - Constants.ASYNC_SUFFIX.length());</span><br><span class=\"line\">            Method syncMethod = clazz.getMethod(syncMethodName, method.getParameterTypes());</span><br><span class=\"line\">            invocation = <span class=\"keyword\">new</span> RpcInvocation(syncMethod, args);</span><br><span class=\"line\">            invocation.setAttachment(Constants.FUTURE_GENERATED_KEY, <span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">            invocation.setAttachment(Constants.ASYNC_KEY, <span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            invocation = <span class=\"keyword\">new</span> RpcInvocation(method, args);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (RpcUtils.hasFutureReturnType(method)) &#123;</span><br><span class=\"line\">                invocation.setAttachment(Constants.FUTURE_RETURNTYPE_KEY, <span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">                invocation.setAttachment(Constants.ASYNC_KEY, <span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoker.invoke(invocation).recreate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里的invoker对象，是通过InvokerInvocationHandler构造方法传入，而且InvokerInvocationHandler对象是由JavassistProxyFactory类的<code>getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</code>方法创建，回到调用<code>proxyFactory.getProxy(invoker);</code>的地方，即ReferenceConfig类的<code>createProxy(Map&lt;String, String&gt; map)</code>方法，以下部分是生成invoker的过程：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isJvmRefer) &#123;</span><br><span class=\"line\">    URL url = <span class=\"keyword\">new</span> URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, <span class=\"number\">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class=\"line\">    invoker = refprotocol.refer(interfaceClass, url);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"Using injvm service \"</span> + interfaceClass.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url != <span class=\"keyword\">null</span> &amp;&amp; url.length() &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// user specified URL, could be peer-to-peer address, or register center's address.</span></span><br><span class=\"line\">        String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (us != <span class=\"keyword\">null</span> &amp;&amp; us.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String u : us) &#123;</span><br><span class=\"line\">                URL url = URL.valueOf(u);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (url.getPath() == <span class=\"keyword\">null</span> || url.getPath().length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    url = url.setPath(interfaceName);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">                    urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// assemble URL from register center's configuration</span></span><br><span class=\"line\">        <span class=\"comment\">//从注册中心获取配置URL</span></span><br><span class=\"line\">        List&lt;URL&gt; us = loadRegistries(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (us != <span class=\"keyword\">null</span> &amp;&amp; !us.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (URL u : us) &#123;</span><br><span class=\"line\">                URL monitorUrl = loadMonitor(u);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (monitorUrl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (urls.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"No such any registry to reference \"</span> + interfaceName + <span class=\"string\">\" on the consumer \"</span> + NetUtils.getLocalHost() + <span class=\"string\">\" use dubbo version \"</span> + Version.getVersion() + <span class=\"string\">\", please config &lt;dubbo:registry address=\\\"...\\\" /&gt; to your spring config.\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//只有一个直连地址或者一个注册中心配置地址</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls.size() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这里的urls.get(0)，可能是直连地址（默认为dubbo协议），也可能是register注册地址（zookeeper协议）</span></span><br><span class=\"line\">        <span class=\"comment\">//示例中使用了zookeeper注册中心，因此会执行这一步</span></span><br><span class=\"line\">        invoker = refprotocol.refer(interfaceClass, urls.get(<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//多个直连地址或者多个注册中心，甚至是两者的结合，执行这一步</span></span><br><span class=\"line\">        List&lt;Invoker&lt;?&gt;&gt; invokers = <span class=\"keyword\">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class=\"line\">        URL registryURL = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (URL url : urls) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建invoker放入invokers</span></span><br><span class=\"line\">            invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">                registryURL = url; <span class=\"comment\">// use last registry url</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (registryURL != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// registry url is available</span></span><br><span class=\"line\">            <span class=\"comment\">// use AvailableCluster only when register's cluster is available</span></span><br><span class=\"line\">            <span class=\"comment\">//这其中包括直连和注册中心混合或者都是注册中心两种情况，默认使用AvailableCluster集群策略</span></span><br><span class=\"line\">            URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);</span><br><span class=\"line\">            invoker = cluster.join(<span class=\"keyword\">new</span> StaticDirectory(u, invokers));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// not a registry url</span></span><br><span class=\"line\">            <span class=\"comment\">//多个直连的URL</span></span><br><span class=\"line\">            invoker = cluster.join(<span class=\"keyword\">new</span> StaticDirectory(invokers));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>经过上面的分析，可以发现invoker是通过<code>refprotocol.refer(interfaceClass, urls.get(0));</code>、<code>cluster.join(new StaticDirectory(u, invokers));</code>和<code>cluster.join(new StaticDirectory(invokers));</code>三种构建语句其中之一生成的，这里是经过第一种方式生成invoker的，下面来分析第一种生成invoker的情况，根据SPI机制这里refprotocol对象是<code>Protocol$Adpative</code>实例，具体refer实现是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Invoker <span class=\"title\">refer</span><span class=\"params\">(java.lang.Class arg0, org.apache.dubbo.common.URL arg1)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arg1 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.common.URL url = arg1;</span><br><span class=\"line\">    String extName = (url.getProtocol() == <span class=\"keyword\">null</span> ? <span class=\"string\">\"MEAT-INF.dubbo\"</span> : url.getProtocol());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.MEAT-INF.dubbo.rpc.Protocol) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([protocol])\"</span>);</span><br><span class=\"line\">    org.apache.dubbo.rpc.Protocol extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> extension.refer(arg0, arg1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例中是通过注册中心，因此这里protocol是register，会走RegistryProtocol类的refer方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//通过register可以获取具体注册中心协议，这里是zookeeper，因此url的协议值被设置为zookeeper</span></span><br><span class=\"line\">    url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);</span><br><span class=\"line\">    <span class=\"comment\">//获取zookeeper Registry实现，即ZookeeperRegistryFactory，并调用getRegistry方法实现</span></span><br><span class=\"line\">    <span class=\"comment\">//获取zookeeper类型的registry对象</span></span><br><span class=\"line\">    Registry registry = registryFactory.getRegistry(url);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// group=\"a,b\" or group=\"*\"</span></span><br><span class=\"line\">    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));</span><br><span class=\"line\">    String group = qs.get(Constants.GROUP_KEY);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (group != <span class=\"keyword\">null</span> &amp;&amp; group.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((Constants.COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class=\"number\">1</span></span><br><span class=\"line\">            || <span class=\"string\">\"*\"</span>.equals(group)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//根据Dubbo SPI机制，给setXxx方法对应的属性赋值为Xxx$Adaptive，这里就是Cluster$Adaptive</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> doRefer(cluster, registry, type, url);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doRefer</span><span class=\"params\">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里的RegistryDirectory和StaticDirectory相对应的，前者是动态从注册中心获取url目录对象，后者是静态指定url目录</span></span><br><span class=\"line\">    RegistryDirectory&lt;T&gt; directory = <span class=\"keyword\">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class=\"line\">    directory.setRegistry(registry);</span><br><span class=\"line\">    directory.setProtocol(protocol);</span><br><span class=\"line\">    <span class=\"comment\">// all attributes of REFER_KEY</span></span><br><span class=\"line\">    Map&lt;String, String&gt; parameters = <span class=\"keyword\">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class=\"line\">    URL subscribeUrl = <span class=\"keyword\">new</span> URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), <span class=\"number\">0</span>, type.getName(), parameters);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Constants.ANY_VALUE.equals(url.getServiceInterface())</span><br><span class=\"line\">        &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">        registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,</span><br><span class=\"line\">                                                     Constants.CHECK_KEY, String.valueOf(<span class=\"keyword\">false</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//订阅注册中心，可以获取服务提供方地址等信息</span></span><br><span class=\"line\">    directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,</span><br><span class=\"line\">                                                  Constants.PROVIDERS_CATEGORY</span><br><span class=\"line\">                                                  + <span class=\"string\">\",\"</span> + Constants.CONFIGURATORS_CATEGORY</span><br><span class=\"line\">                                                  + <span class=\"string\">\",\"</span> + Constants.ROUTERS_CATEGORY));</span><br><span class=\"line\">    <span class=\"comment\">//通过调用Cluster$Adpative类的join方法返回Invoker对象(基于Dubbo SPI机制实现setXX()方法自动注入属性)</span></span><br><span class=\"line\">    Invoker invoker = cluster.join(directory);</span><br><span class=\"line\">    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invoker;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里看下<code>Cluster$Adpative</code>类的join方法实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.apache.dubbo.rpc.cluster;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cluster</span>$<span class=\"title\">Adaptive</span> <span class=\"keyword\">implements</span> <span class=\"title\">org</span>.<span class=\"title\">apache</span>.<span class=\"title\">dubbo</span>.<span class=\"title\">rpc</span>.<span class=\"title\">cluster</span>.<span class=\"title\">Cluster</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> org.apache.dubbo.common.logger.Logger logger = org.apache.dubbo.common.logger.LoggerFactory.getLogger(ExtensionLoader.class);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> java.util.concurrent.atomic.AtomicInteger count = <span class=\"keyword\">new</span> java.util.concurrent.atomic.AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> org.apache.dubbo.rpc.<span class=\"function\">Invoker <span class=\"title\">join</span><span class=\"params\">(org.apache.dubbo.rpc.cluster.Directory arg0)</span> <span class=\"keyword\">throws</span> org.apache.dubbo.rpc.RpcException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.cluster.Directory argument == null\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arg0.getUrl() == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"org.apache.dubbo.rpc.cluster.Directory argument getUrl() == null\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.common.URL url = arg0.getUrl();</span><br><span class=\"line\">        String extName = url.getParameter(<span class=\"string\">\"cluster\"</span>, <span class=\"string\">\"failover\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (extName == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(org.apache.dubbo.rpc.cluster.Cluster) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([cluster])\"</span>);</span><br><span class=\"line\">        org.apache.dubbo.rpc.cluster.Cluster extension = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            extension = (org.apache.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.cluster.Cluster.class).getExtension(extName);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count.incrementAndGet() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"Failed to find extension named \"</span> + extName + <span class=\"string\">\" for type org.apache.dubbo.rpc.cluster.Cluster, will use default extension failover instead.\"</span>, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            extension = (org.apache.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.cluster.Cluster.class).getExtension(<span class=\"string\">\"failover\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> extension.join(arg0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看下FailoverCluster的join方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">join</span><span class=\"params\">(Directory&lt;T&gt; directory)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FailoverClusterInvoker&lt;T&gt;(directory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于Cluster SPI实现中有个MockClusterWrapper是包装类，这里牵扯到<strong>Dubbo的AOP机制(后期详细分析)</strong>，这里先调用它的join方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">join</span><span class=\"params\">(Directory&lt;T&gt; directory)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MockClusterInvoker&lt;T&gt;(directory,</span><br><span class=\"line\">                                     <span class=\"keyword\">this</span>.cluster.join(directory));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成MockClusterInvoker之后，由于FailoverClusterInvoker是AbstractClusterInvoker的子类，它的invoke方法实现在其父类中，接下来的调用链是<code>MockClusterInvoker.invoke()-&gt;AbstractClusterInvoker.invoke()-&gt;FailoverClusterInvoker.doInvoke()</code>，下面来一步步分析，首先来看MockClusterInvoker类的invoke()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    Result result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value.length() == <span class=\"number\">0</span> || value.equalsIgnoreCase(<span class=\"string\">\"false\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//no mock</span></span><br><span class=\"line\">        result = <span class=\"keyword\">this</span>.invoker.invoke(invocation);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value.startsWith(<span class=\"string\">\"force\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"force-mock: \"</span> + invocation.getMethodName() + <span class=\"string\">\" force-mock enabled , url : \"</span> + directory.getUrl());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//force:direct mock</span></span><br><span class=\"line\">        result = doMockInvoke(invocation, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//fail-mock</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            result = <span class=\"keyword\">this</span>.invoker.invoke(invocation);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RpcException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.isBiz()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">                    logger.warn(<span class=\"string\">\"fail-mock: \"</span> + invocation.getMethodName() + <span class=\"string\">\" fail-mock enabled , url : \"</span> + directory.getUrl(), e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                result = doMockInvoke(invocation, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后调用AbstractClusterInvoker的invoke()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(<span class=\"keyword\">final</span> Invocation invocation)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    checkWhetherDestroyed();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// binding attachments into invocation.</span></span><br><span class=\"line\">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contextAttachments != <span class=\"keyword\">null</span> &amp;&amp; contextAttachments.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ((RpcInvocation) invocation).addAttachments(contextAttachments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class=\"line\">    LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class=\"line\">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后调用FailoverClusterInvoker的doInvoke()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"unchecked\"</span>, <span class=\"string\">\"rawtypes\"</span>&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(Invocation invocation, <span class=\"keyword\">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers;</span><br><span class=\"line\">    checkInvokers(copyinvokers, invocation);</span><br><span class=\"line\">    String methodName = RpcUtils.getMethodName(invocation);</span><br><span class=\"line\">    <span class=\"comment\">//设置重试次数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (len &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        len = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// retry loop.</span></span><br><span class=\"line\">    RpcException le = <span class=\"keyword\">null</span>; <span class=\"comment\">// last exception.</span></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invoked = <span class=\"keyword\">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size()); <span class=\"comment\">// invoked invokers.</span></span><br><span class=\"line\">    Set&lt;String&gt; providers = <span class=\"keyword\">new</span> HashSet&lt;String&gt;(len);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//Reselect before retry to avoid a change of candidate `invokers`.</span></span><br><span class=\"line\">        <span class=\"comment\">//<span class=\"doctag\">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            checkWhetherDestroyed();</span><br><span class=\"line\">            copyinvokers = list(invocation);</span><br><span class=\"line\">            <span class=\"comment\">// check again</span></span><br><span class=\"line\">            checkInvokers(copyinvokers, invocation);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//根据负载均衡策略选择调用者</span></span><br><span class=\"line\">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);</span><br><span class=\"line\">        <span class=\"comment\">//将使用过的invoker放入invoked</span></span><br><span class=\"line\">        invoked.add(invoker);</span><br><span class=\"line\">        RpcContext.getContext().setInvokers((List) invoked);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Result result = invoker.invoke(invocation);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (le != <span class=\"keyword\">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">                logger.warn(<span class=\"string\">\"Although retry the method \"</span> + methodName</span><br><span class=\"line\">                            + <span class=\"string\">\" in the service \"</span> + getInterface().getName()</span><br><span class=\"line\">                            + <span class=\"string\">\" was successful by the provider \"</span> + invoker.getUrl().getAddress()</span><br><span class=\"line\">                            + <span class=\"string\">\", but there have been failed providers \"</span> + providers</span><br><span class=\"line\">                            + <span class=\"string\">\" (\"</span> + providers.size() + <span class=\"string\">\"/\"</span> + copyinvokers.size()</span><br><span class=\"line\">                            + <span class=\"string\">\") from the registry \"</span> + directory.getUrl().getAddress()</span><br><span class=\"line\">                            + <span class=\"string\">\" on the consumer \"</span> + NetUtils.getLocalHost()</span><br><span class=\"line\">                            + <span class=\"string\">\" using the dubbo version \"</span> + Version.getVersion() + <span class=\"string\">\". Last error is: \"</span></span><br><span class=\"line\">                            + le.getMessage(), le);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RpcException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.isBiz()) &#123; <span class=\"comment\">// biz exception.</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            le = e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            le = <span class=\"keyword\">new</span> RpcException(e.getMessage(), e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            providers.add(invoker.getUrl().getAddress());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(le.getCode(), <span class=\"string\">\"Failed to invoke the method \"</span></span><br><span class=\"line\">                           + methodName + <span class=\"string\">\" in the service \"</span> + getInterface().getName()</span><br><span class=\"line\">                           + <span class=\"string\">\". Tried \"</span> + len + <span class=\"string\">\" times of the providers \"</span> + providers</span><br><span class=\"line\">                           + <span class=\"string\">\" (\"</span> + providers.size() + <span class=\"string\">\"/\"</span> + copyinvokers.size()</span><br><span class=\"line\">                           + <span class=\"string\">\") from the registry \"</span> + directory.getUrl().getAddress()</span><br><span class=\"line\">                           + <span class=\"string\">\" on the consumer \"</span> + NetUtils.getLocalHost() + <span class=\"string\">\" using the dubbo version \"</span></span><br><span class=\"line\">                           + Version.getVersion() + <span class=\"string\">\". Last error is: \"</span></span><br><span class=\"line\">                           + le.getMessage(), le.getCause() != <span class=\"keyword\">null</span> ? le.getCause() : le);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以会有如下的线程栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:78)</span><br><span class=\"line\">at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:243)</span><br><span class=\"line\">at org.apache.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:75)</span><br></pre></td></tr></table></figure>\n<p>这些类都是关于<strong>Dubbo的集群容错机制</strong>（将会写一篇关于Dubbo的集群容错机制）。</p>\n<p>再往下看invokers是如何生成的呢？又回到AbstractClusterInvoker的invoke方法实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(<span class=\"keyword\">final</span> Invocation invocation)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    checkWhetherDestroyed();</span><br><span class=\"line\">    LoadBalance loadbalance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// binding attachments into invocation.</span></span><br><span class=\"line\">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contextAttachments != <span class=\"keyword\">null</span> &amp;&amp; contextAttachments.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ((RpcInvocation) invocation).addAttachments(contextAttachments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//会调用directory的list方法 返回要调用invokers集合。</span></span><br><span class=\"line\">    <span class=\"comment\">//其实是AbstractDirectory的list方法，这个方法里就是利用路由规则（如果有），从所有</span></span><br><span class=\"line\">    <span class=\"comment\">//提供者中，遴选出符合规则的提供者,接下里才是，集群容错和负载均衡。</span></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (invokers != <span class=\"keyword\">null</span> &amp;&amp; !invokers.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//通过key（loadbalance）从url中取值，默认值为random</span></span><br><span class=\"line\">        loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(<span class=\"number\">0</span>).getUrl()                                                                                .getMethodParameter(RpcUtils.getMethodName(invocation), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看一下list方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class=\"keyword\">throws</span> RpcException &#123;</span><br><span class=\"line\">    <span class=\"comment\">//directory.list(invocation)获取invokers，这里directory是RegistryDirectory</span></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invokers = directory.list(invocation);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invokers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>跟到RegistryDirectory类的list方法，实现在其父类AbstractDirectory中，主要是<strong>生成路由规则</strong>（将会在另一篇文章中详细讲解，敬请期待）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class=\"keyword\">throws</span> RpcException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (destroyed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Directory already destroyed .url: \"</span> + getUrl());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取所有的提供者</span></span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br><span class=\"line\">    <span class=\"comment\">//本地路由规则</span></span><br><span class=\"line\">    List&lt;Router&gt; localRouters = <span class=\"keyword\">this</span>.routers; <span class=\"comment\">// local reference</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (localRouters != <span class=\"keyword\">null</span> &amp;&amp; !localRouters.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Router router : localRouters) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (router.getUrl() == <span class=\"keyword\">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//Router接口，实现route的方法，路由获取服务提供者</span></span><br><span class=\"line\">                    invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">\"Failed to execute router: \"</span> + getUrl() + <span class=\"string\">\", cause: \"</span> + t.getMessage(), t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invokers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再来看一下doList方法，它是个抽象方法具体实现在RegistryDirectory类中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//没有服务提供者或者服务提供者被禁用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forbidden) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. No service provider 2. Service providers are disabled</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(RpcException.FORBIDDEN_EXCEPTION,</span><br><span class=\"line\">                               <span class=\"string\">\"No provider available from registry \"</span> + getUrl().getAddress() + <span class=\"string\">\" for service \"</span> + getConsumerUrl().getServiceKey() + <span class=\"string\">\" on consumer \"</span> + NetUtils.getLocalHost()</span><br><span class=\"line\">                               + <span class=\"string\">\" use dubbo version \"</span> + Version.getVersion() + <span class=\"string\">\", please check status of providers(disabled, not registered or in blacklist).\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    List&lt;Invoker&lt;T&gt;&gt; invokers = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从这里搜索methodInvokerMap赋值，在refreshInvoker方法里</span></span><br><span class=\"line\">    Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap = <span class=\"keyword\">this</span>.methodInvokerMap; <span class=\"comment\">// local reference</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (localMethodInvokerMap != <span class=\"keyword\">null</span> &amp;&amp; localMethodInvokerMap.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class=\"line\">        Object[] args = RpcUtils.getArguments(invocation);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args != <span class=\"keyword\">null</span> &amp;&amp; args.length &gt; <span class=\"number\">0</span> &amp;&amp; args[<span class=\"number\">0</span>] != <span class=\"keyword\">null</span></span><br><span class=\"line\">            &amp;&amp; (args[<span class=\"number\">0</span>] <span class=\"keyword\">instanceof</span> String || args[<span class=\"number\">0</span>].getClass().isEnum())) &#123;</span><br><span class=\"line\">            invokers = localMethodInvokerMap.get(methodName + <span class=\"string\">\".\"</span> + args[<span class=\"number\">0</span>]); <span class=\"comment\">// The routing can be enumerated according to the first parameter</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invokers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            invokers = localMethodInvokerMap.get(methodName);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invokers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invokers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator = localMethodInvokerMap.values().iterator();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (iterator.hasNext()) &#123;</span><br><span class=\"line\">                invokers = iterator.next();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invokers == <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(<span class=\"number\">0</span>) : invokers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是<code>refreshInvoker(List&lt;URL&gt; invokerUrls)</code>方法的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Convert the invokerURL list to the Invoker Map. The rules of the conversion are as follows:</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.If URL has been converted to invoker, it is no longer re-referenced and obtained directly from the cache, and notice that any parameter changes in the URL will be re-referenced.</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.If the incoming invoker list is not empty, it means that it is the latest invoker list</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.If the list of incoming invokerUrl is empty, It means that the rule is only a override rule or a route rule, which needs to be re-contrasted to decide whether to re-reference.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> invokerUrls this parameter can't be null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> 2017/8/31 FIXME The thread pool should be used to refresh the address, otherwise the task may be accumulated.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">refreshInvoker</span><span class=\"params\">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (invokerUrls != <span class=\"keyword\">null</span> &amp;&amp; invokerUrls.size() == <span class=\"number\">1</span> &amp;&amp; invokerUrls.get(<span class=\"number\">0</span>) != <span class=\"keyword\">null</span></span><br><span class=\"line\">        &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(<span class=\"number\">0</span>).getProtocol())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//禁止访问</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.forbidden = <span class=\"keyword\">true</span>; <span class=\"comment\">// Forbid to access</span></span><br><span class=\"line\">        <span class=\"comment\">//置空列表</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.methodInvokerMap = <span class=\"keyword\">null</span>; <span class=\"comment\">// Set the method invoker map to null</span></span><br><span class=\"line\">        <span class=\"comment\">//关闭所有invokers</span></span><br><span class=\"line\">        destroyAllInvokers(); <span class=\"comment\">// Close all invokers</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//允许访问</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.forbidden = <span class=\"keyword\">false</span>; <span class=\"comment\">// Allow to access</span></span><br><span class=\"line\">        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class=\"keyword\">this</span>.urlInvokerMap; <span class=\"comment\">// local reference</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class=\"keyword\">this</span>.cachedInvokerUrls != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            invokerUrls.addAll(<span class=\"keyword\">this</span>.cachedInvokerUrls);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.cachedInvokerUrls = <span class=\"keyword\">new</span> HashSet&lt;URL&gt;();</span><br><span class=\"line\">            <span class=\"comment\">//缓存invokerUrls列表，便于交叉对比</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.cachedInvokerUrls.addAll(invokerUrls);<span class=\"comment\">//Cached invoker urls, convenient for comparison</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invokerUrls.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//生成invoker方法 toInvokers</span></span><br><span class=\"line\">        <span class=\"comment\">//将url列表转换成invoker列表</span></span><br><span class=\"line\">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);<span class=\"comment\">// Translate url list to Invoker map</span></span><br><span class=\"line\">        <span class=\"comment\">//换方法名映射invoker列表</span></span><br><span class=\"line\">        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); <span class=\"comment\">// Change method name to map Invoker Map</span></span><br><span class=\"line\">        <span class=\"comment\">// state change</span></span><br><span class=\"line\">        <span class=\"comment\">// If the calculation is wrong, it is not processed.</span></span><br><span class=\"line\">        <span class=\"comment\">//如果计算错误则不进行处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newUrlInvokerMap == <span class=\"keyword\">null</span> || newUrlInvokerMap.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"urls to invokers error .invokerUrls.size :\"</span> + invokerUrls.size() + <span class=\"string\">\", invoker.size :0. urls :\"</span> + invokerUrls.toString()));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//关闭不使用的invoker</span></span><br><span class=\"line\">            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); <span class=\"comment\">// Close the unused Invoker</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"destroyUnusedInvokers error. \"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以知道refreshInvoker()方法会在RegistryDirectory类的notify()方法里调用，这个方法是<strong>订阅注册中心的回调方法</strong>。下面来看一下toInvokers()的方法实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Turn urls into invokers, and if url has been refer, will not re-reference.</span></span><br><span class=\"line\"><span class=\"comment\">     * 将urls转换成invokers，如果url已经被refer过则不在重新引用</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> urls</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> invokers</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class=\"line\">    Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class=\"keyword\">new</span> HashMap&lt;String, Invoker&lt;T&gt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls == <span class=\"keyword\">null</span> || urls.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newUrlInvokerMap;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Set&lt;String&gt; keys = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">    String queryProtocols = <span class=\"keyword\">this</span>.queryMap.get(Constants.PROTOCOL_KEY);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (URL providerUrl : urls) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If protocol is configured at the reference side, only the matching protocol is selected</span></span><br><span class=\"line\">        <span class=\"comment\">//若果reference端配置了protocol，则只选择匹配的protocol</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queryProtocols != <span class=\"keyword\">null</span> &amp;&amp; queryProtocols.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> accept = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            String[] acceptProtocols = queryProtocols.split(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String acceptProtocol : acceptProtocols) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class=\"line\">                    accept = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!accept) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Unsupported protocol \"</span> + providerUrl.getProtocol() + <span class=\"string\">\" in notified url: \"</span> + providerUrl + <span class=\"string\">\" from registry \"</span> + getUrl().getAddress() + <span class=\"string\">\" to consumer \"</span> + NetUtils.getLocalHost()</span><br><span class=\"line\">                                                   + <span class=\"string\">\", supported protocol: \"</span> + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        URL url = mergeUrl(providerUrl);</span><br><span class=\"line\">\t\t<span class=\"comment\">//url参数是排序的</span></span><br><span class=\"line\">        String key = url.toFullString(); <span class=\"comment\">// The parameter urls are sorted</span></span><br><span class=\"line\">        <span class=\"comment\">//跳过重复的url</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (keys.contains(key)) &#123; <span class=\"comment\">// Repeated url</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        keys.add(key);</span><br><span class=\"line\">        <span class=\"comment\">// Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again</span></span><br><span class=\"line\">        <span class=\"comment\">//缓存key为没有合并消费端参数的URL，不管消费端如何合并参数，如果服务端URL发生变化，则重新refer</span></span><br><span class=\"line\">        Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class=\"keyword\">this</span>.urlInvokerMap; <span class=\"comment\">// local reference</span></span><br><span class=\"line\">        Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : localUrlInvokerMap.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (invoker == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Not in the cache, refer again</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> enabled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class=\"line\">                    enabled = !url.getParameter(Constants.DISABLED_KEY, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    enabled = url.getParameter(Constants.ENABLED_KEY, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (enabled) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//创建invoker（这里创建invoker）</span></span><br><span class=\"line\">                    invoker = <span class=\"keyword\">new</span> InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">\"Failed to refer invoker for interface:\"</span> + serviceType + <span class=\"string\">\",url:(\"</span> + url + <span class=\"string\">\")\"</span> + t.getMessage(), t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (invoker != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Put new invoker in cache</span></span><br><span class=\"line\">                <span class=\"comment\">//将新的引用放入缓存</span></span><br><span class=\"line\">                newUrlInvokerMap.put(key, invoker);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            newUrlInvokerMap.put(key, invoker);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    keys.clear();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newUrlInvokerMap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>找到了invoker的创建地方，来看下InvokerDelegate，它是RegistryDirectory的内部类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The delegate class, which is mainly used to store the URL address sent by the registry,and can be reassembled on the basis of providerURL queryMap overrideMap for re-refer.</span></span><br><span class=\"line\"><span class=\"comment\">     * 代理类，主要用于存储注册中心下发的URL地址</span></span><br><span class=\"line\"><span class=\"comment\">     * 用于重新refer时能够根据providerURL queryMap overrideMap重新组装</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> &lt;T&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InvokerDelegate</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">InvokerWrapper</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> URL providerUrl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">InvokerDelegate</span><span class=\"params\">(Invoker&lt;T&gt; invoker, URL url, URL providerUrl)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用父类构造方法</span></span><br><span class=\"line\">        <span class=\"keyword\">super</span>(invoker, url);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.providerUrl = providerUrl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> URL <span class=\"title\">getProviderUrl</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> providerUrl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>invoke方法在父类InvokerWrapper里实现的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里的invoker是从它的构造方法里传入的</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> invoker.invoke(invocation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以在调用栈里可以看到如下一条信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:56)</span><br></pre></td></tr></table></figure>\n<p>InvokerDelegete构造方法调用的父类InvokerWrapper的构造方法并传入invoker实例，回头看<code>new InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</code>这句，可知上面的invoker的是由<code>protocol.refer(serviceType, url)</code>创建的。</p>\n<p>通过debug可得知这里的protocol是Protocol$Adaptive类型的，这里的url的protocol是dubbo，通过Dubbo SPI机制可以得到这里最后走DubboProtocol类的refer()方法，但是由于Protocol接口实现中由两个包装类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class=\"line\">listener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br></pre></td></tr></table></figure>\n<p>所以这里先执行ProtocolFilterWrapper的refer方法，再执行ProtocolListenerWrapper的refer方法，最后才执行DubboProtocol类的refer方法，ProtocolFilterWrapper类的refer方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> protocol.refer(type, url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法里调用了buildInvokerChain()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">buildInvokerChain</span><span class=\"params\">(<span class=\"keyword\">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class=\"line\">    Invoker&lt;T&gt; last = invoker;</span><br><span class=\"line\">    <span class=\"comment\">//先获取激活的过滤器，我们这里手动配置了monitor MonitorFilter过滤器</span></span><br><span class=\"line\">    <span class=\"comment\">//另外两个自动激活的过滤器是FutureFilter，ConsumerContextFilter</span></span><br><span class=\"line\">    <span class=\"comment\">//这里需要看SPI机制的getActivateExtension方法的相关代码</span></span><br><span class=\"line\">    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!filters.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = filters.size() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Filter filter = filters.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Invoker&lt;T&gt; next = last;</span><br><span class=\"line\">            last = <span class=\"keyword\">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Class&lt;T&gt; <span class=\"title\">getInterface</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invoker.getInterface();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> URL <span class=\"title\">getUrl</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invoker.getUrl();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAvailable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invoker.isAvailable();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//实现invoker的invoke方法</span></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(Invocation invocation)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//嵌套进过滤器链</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> filter.invoke(next, invocation);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    invoker.destroy();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> invoker.toString();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以有如下的调用栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:47)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)</span><br><span class=\"line\">at org.apache.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:50)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:72)</span><br></pre></td></tr></table></figure>\n<p>接着ProtocolListenerWrapper的refer方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; type, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> protocol.refer(type, url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取激活的监听器，目前dubbo没有提供合适的监听器，只有一个DeprecatedInvokerListener实现类，并且还是Deprecated的</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListenerInvokerWrapper&lt;T&gt;(protocol.refer(type, url),</span><br><span class=\"line\">                                         Collections.unmodifiableList(</span><br><span class=\"line\">                                             ExtensionLoader.getExtensionLoader(InvokerListener.class)</span><br><span class=\"line\">                                             .getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以会出现如下栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:77)</span><br></pre></td></tr></table></figure>\n<p>最后看一下DubboProtocol类的refer方法，这里创建了DubboInvoker对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; serviceType, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    optimizeSerialization(url);</span><br><span class=\"line\">    <span class=\"comment\">// create rpc invoker.</span></span><br><span class=\"line\">    DubboInvoker&lt;T&gt; invoker = <span class=\"keyword\">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class=\"line\">    invokers.add(invoker);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invoker;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DubboInvoker的父类AbstractInvoker实现了invoke方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Result <span class=\"title\">invoke</span><span class=\"params\">(Invocation inv)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (destroyed.get()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Rpc invoker for service \"</span> + <span class=\"keyword\">this</span> + <span class=\"string\">\" on consumer \"</span> + NetUtils.getLocalHost()</span><br><span class=\"line\">                               + <span class=\"string\">\" use dubbo version \"</span> + Version.getVersion()</span><br><span class=\"line\">                               + <span class=\"string\">\" is DESTROYED, can not be invoked any more!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RpcInvocation invocation = (RpcInvocation) inv;</span><br><span class=\"line\">    invocation.setInvoker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (attachment != <span class=\"keyword\">null</span> &amp;&amp; attachment.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        invocation.addAttachmentsIfAbsent(attachment);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contextAttachments != <span class=\"keyword\">null</span> &amp;&amp; contextAttachments.size() != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * invocation.addAttachmentsIfAbsent(context)&#123;<span class=\"doctag\">@link</span> RpcInvocation#addAttachmentsIfAbsent(Map)&#125;should not be used here,</span></span><br><span class=\"line\"><span class=\"comment\">             * because the &#123;<span class=\"doctag\">@link</span> RpcContext#setAttachment(String, String)&#125; is passed in the Filter when the call is triggered</span></span><br><span class=\"line\"><span class=\"comment\">             * by the built-in retry mechanism of the Dubbo. The attachment to update RpcContext will no longer work, which is</span></span><br><span class=\"line\"><span class=\"comment\">             * a mistake in most cases (for example, through Filter to RpcContext output traceId and spanId and other information).</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">        invocation.addAttachments(contextAttachments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">        invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//doInvoke()方法具体实现在子类中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> doInvoke(invocation);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InvocationTargetException e) &#123; <span class=\"comment\">// biz exception</span></span><br><span class=\"line\">        Throwable te = e.getTargetException();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (te == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (te <span class=\"keyword\">instanceof</span> RpcException) &#123;</span><br><span class=\"line\">                ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult(te);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RpcException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.isBiz()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult(e);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看一下DubboInvoker实现的doInvoke方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Result <span class=\"title\">doInvoke</span><span class=\"params\">(<span class=\"keyword\">final</span> Invocation invocation)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class=\"line\">    inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br><span class=\"line\">    inv.setAttachment(Constants.VERSION_KEY, version);</span><br><span class=\"line\"></span><br><span class=\"line\">    ExchangeClient currentClient;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clients.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        currentClient = clients[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isAsyncFuture = RpcUtils.isGeneratedFuture(inv) || RpcUtils.isFutureReturnType(inv);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isOneway) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            currentClient.send(inv, isSent);</span><br><span class=\"line\">            RpcContext.getContext().setFuture(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RpcResult();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isAsync) &#123;</span><br><span class=\"line\">            ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class=\"line\">            <span class=\"comment\">// For compatibility</span></span><br><span class=\"line\">            FutureAdapter&lt;Object&gt; futureAdapter = <span class=\"keyword\">new</span> FutureAdapter&lt;&gt;(future);</span><br><span class=\"line\">            RpcContext.getContext().setFuture(futureAdapter);</span><br><span class=\"line\"></span><br><span class=\"line\">            Result result;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isAsyncFuture) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// register resultCallback, sometimes we need the asyn result being processed by the filter chain.</span></span><br><span class=\"line\">                result = <span class=\"keyword\">new</span> AsyncRpcResult(futureAdapter, futureAdapter.getResultFuture(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                result = <span class=\"keyword\">new</span> SimpleAsyncRpcResult(futureAdapter, futureAdapter.getResultFuture(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            RpcContext.getContext().setFuture(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (TimeoutException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class=\"string\">\"Invoke remote method timeout. method: \"</span> + invocation.getMethodName() + <span class=\"string\">\", provider: \"</span> + getUrl() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class=\"string\">\"Failed to invoke remote method: \"</span> + invocation.getMethodName() + <span class=\"string\">\", provider: \"</span> + getUrl() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以会有这两句线程栈输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:108)</span><br><span class=\"line\">at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:154)</span><br></pre></td></tr></table></figure>\n<p>接下来就是用于发送请求的currentClient对象的实现了，它的逻辑可以追踪到DubboProtocol类的refer方法里：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">refer</span><span class=\"params\">(Class&lt;T&gt; serviceType, URL url)</span> <span class=\"keyword\">throws</span> RpcException </span>&#123;</span><br><span class=\"line\">    optimizeSerialization(url);</span><br><span class=\"line\">    <span class=\"comment\">// create rpc invoker.</span></span><br><span class=\"line\">    DubboInvoker&lt;T&gt; invoker = <span class=\"keyword\">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class=\"line\">    invokers.add(invoker);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invoker;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体的获取逻辑在getClients()方法中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// whether to share connection</span></span><br><span class=\"line\">    <span class=\"comment\">//是否共享连接</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> service_share_connect = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> connections = url.getParameter(Constants.CONNECTIONS_KEY, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// if not configured, connection is shared, otherwise, one connection for one service</span></span><br><span class=\"line\">    <span class=\"comment\">//如果没有配置connection，那么就创建共享连接，否则一个服务一个连接？</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (connections == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        service_share_connect = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        connections = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ExchangeClient[] clients = <span class=\"keyword\">new</span> ExchangeClient[connections];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (service_share_connect) &#123;</span><br><span class=\"line\">            clients[i] = getSharedClient(url);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            clients[i] = initClient(url);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clients;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Get shared connection</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ExchangeClient <span class=\"title\">getSharedClient</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    String key = url.getAddress();</span><br><span class=\"line\">    ReferenceCountExchangeClient client = referenceClientMap.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (client != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!client.isClosed()) &#123;</span><br><span class=\"line\">            client.incrementAndGetCount();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            referenceClientMap.remove(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    locks.putIfAbsent(key, <span class=\"keyword\">new</span> Object());</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (locks.get(key)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (referenceClientMap.containsKey(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> referenceClientMap.get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExchangeClient exchangeClient = initClient(url);</span><br><span class=\"line\">        client = <span class=\"keyword\">new</span> ReferenceCountExchangeClient(exchangeClient, ghostClientMap);</span><br><span class=\"line\">        referenceClientMap.put(key, client);</span><br><span class=\"line\">        ghostClientMap.remove(key);</span><br><span class=\"line\">        locks.remove(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Create new connection</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ExchangeClient <span class=\"title\">initClient</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// client type setting.</span></span><br><span class=\"line\">    String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));</span><br><span class=\"line\"></span><br><span class=\"line\">    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class=\"line\">    <span class=\"comment\">// enable heartbeat by default</span></span><br><span class=\"line\">    <span class=\"comment\">//默认开启heartbeat</span></span><br><span class=\"line\">    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// BIO is not allowed since it has severe performance issue.</span></span><br><span class=\"line\">    <span class=\"comment\">//BIO存在严重的性能问题，因此不能使用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (str != <span class=\"keyword\">null</span> &amp;&amp; str.length() &gt; <span class=\"number\">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Unsupported client type: \"</span> + str + <span class=\"string\">\",\"</span> +</span><br><span class=\"line\">                               <span class=\"string\">\" supported client type is \"</span> + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), <span class=\"string\">\" \"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ExchangeClient client;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// connection should be lazy</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (url.getParameter(Constants.LAZY_CONNECT_KEY, <span class=\"keyword\">false</span>)) &#123;</span><br><span class=\"line\">            client = <span class=\"keyword\">new</span> LazyConnectExchangeClient(url, requestHandler);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//通过 Exchangers.connect(url, requestHandler); 构建client ，接下来跟踪Exchangers.connect方法</span></span><br><span class=\"line\">\t\t    <span class=\"comment\">//这里会传入一个requestHandler，这个是客户端解救服务端方法返回回调的</span></span><br><span class=\"line\">            client = Exchangers.connect(url, requestHandler);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RpcException(<span class=\"string\">\"Fail to create remoting client for service(\"</span> + url + <span class=\"string\">\"): \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> client;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里用到了<strong>Facade设计模式，Exchangers是个门面类</strong>，封装了具体查找合适的Exchanger实现，并调用connect方法返回ExchangeClient的过程，相关代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExchangeClient <span class=\"title\">connect</span><span class=\"params\">(URL url, ExchangeHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"handler == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class=\"string\">\"exchange\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//把codec key设置为exchange</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getExchanger(url).connect(url, handler);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Exchanger <span class=\"title\">getExchanger</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class=\"line\">    <span class=\"comment\">//通过exchanger key 获取 Exchanger的spi实现，默认是header，这里是HeaderExchanger类</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getExchanger(type);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Exchanger <span class=\"title\">getExchanger</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里返回Exchanger接口的header扩展类的HeaderExchanger</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看一下HeaderExchanger类的connect方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//客户端的连接操作</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ExchangeClient <span class=\"title\">connect</span><span class=\"params\">(URL url, ExchangeHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HeaderExchangeClient(Transporters.connect(url, <span class=\"keyword\">new</span> DecodeHandler(<span class=\"keyword\">new</span> HeaderExchangeHandler(handler))), <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以有栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeClient.request(HeaderExchangeClient.java:90)</span><br></pre></td></tr></table></figure>\n<p>再来看HeaderExchnageClient的request()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HeaderExchangeClient</span><span class=\"params\">(Client client, <span class=\"keyword\">boolean</span> needHeartbeat)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (client == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"client == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.client = client;</span><br><span class=\"line\">    <span class=\"comment\">//初始化HeaderExchangeChannel</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.channel = <span class=\"keyword\">new</span> HeaderExchangeChannel(client);</span><br><span class=\"line\">    String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != <span class=\"keyword\">null</span> &amp;&amp; dubbo.startsWith(<span class=\"string\">\"1.0.\"</span>) ? Constants.DEFAULT_HEARTBEAT : <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (heartbeatTimeout &lt; heartbeat * <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"heartbeatTimeout &lt; heartbeatInterval * 2\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (needHeartbeat) &#123;</span><br><span class=\"line\">        startHeartbeatTimer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ResponseFuture <span class=\"title\">request</span><span class=\"params\">(Object request)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用Channel的request方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> channel.request(request);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此会有如下的栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel.request(HeaderExchangeChannel.java:116)</span><br></pre></td></tr></table></figure>\n<p>再来看一下HeaderExchangeChannel的request方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ResponseFuture <span class=\"title\">request</span><span class=\"params\">(Object request)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ResponseFuture <span class=\"title\">request</span><span class=\"params\">(Object request, <span class=\"keyword\">int</span> timeout)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (closed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(<span class=\"keyword\">this</span>.getLocalAddress(), <span class=\"keyword\">null</span>, <span class=\"string\">\"Failed to send request \"</span> + request + <span class=\"string\">\", cause: The channel \"</span> + <span class=\"keyword\">this</span> + <span class=\"string\">\" is closed!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// create request.</span></span><br><span class=\"line\">    Request req = <span class=\"keyword\">new</span> Request();</span><br><span class=\"line\">    req.setVersion(Version.getProtocolVersion());</span><br><span class=\"line\">    req.setTwoWay(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    req.setData(request);</span><br><span class=\"line\">    DefaultFuture future = <span class=\"keyword\">new</span> DefaultFuture(channel, req, timeout);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//发送请求</span></span><br><span class=\"line\">        channel.send(req);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemotingException e) &#123;</span><br><span class=\"line\">        future.cancel();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>channel.send(req);</code>中channel实例是通过<code>HeaderExchangeChannel(Channel channel)</code>构造函数初始化的，继续往上看是通过构造函数<code>public HeaderExchangeClient(Client client, boolean needHeartbeat)</code>传进来的，最终生成channel的代码是在类<code>HeaderExchanger</code>中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ExchangeClient <span class=\"title\">connect</span><span class=\"params\">(URL url, ExchangeHandler handler)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HeaderExchangeClient(Transporters.connect(url, <span class=\"keyword\">new</span> DecodeHandler(<span class=\"keyword\">new</span> HeaderExchangeHandler(handler))), <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用<code>Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler)))</code>生成channel实例，<strong>这里Transporters也是个门面类，是Facade设计模式的实现</strong>，继续分析Transporters的connect方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Client <span class=\"title\">connect</span><span class=\"params\">(URL url, ChannelHandler... handlers)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ChannelHandler handler;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handlers == <span class=\"keyword\">null</span> || handlers.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        handler = <span class=\"keyword\">new</span> ChannelHandlerAdapter();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (handlers.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        handler = handlers[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        handler = <span class=\"keyword\">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//所以这里默认返回的NettyClient</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getTransporter().connect(url, handler);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//这个方法根据spi返回NettyTransporter扩展类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Transporter <span class=\"title\">getTransporter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//生成Transporter$Adaptive类</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以最后是通过NettyClient类实例的send方法发送具体请求，NettyClient类的send方法在其祖先类AbstractPeer中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Object message)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    send(message, url.getParameter(Constants.SENT_KEY, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个实现又调用NettyClient父类AbstractClient的send方法实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Object message, <span class=\"keyword\">boolean</span> sent)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (send_reconnect &amp;&amp; !isConnected()) &#123;</span><br><span class=\"line\">        connect();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//获取具体的channel实例</span></span><br><span class=\"line\">    Channel channel = getChannel();</span><br><span class=\"line\">    <span class=\"comment\">//TODO Can the value returned by getChannel() be null? need improvement.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel == <span class=\"keyword\">null</span> || !channel.isConnected()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(<span class=\"keyword\">this</span>, <span class=\"string\">\"message can not send, because channel is closed . url:\"</span> + getUrl());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    channel.send(message, sent);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的getChannel()方法由NettyClient自身实现，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> org.apache.dubbo.remoting.<span class=\"function\">Channel <span class=\"title\">getChannel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Channel c = channel;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span> || !c.isActive())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> NettyChannel.getOrAddChannel(c, getUrl(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以有如下栈信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">at org.apache.dubbo.remoting.transport.netty4.NettyChannel.send(NettyChannel.java:101)</span><br><span class=\"line\">at org.apache.dubbo.remoting.transport.AbstractClient.send(AbstractClient.java:265)</span><br><span class=\"line\">at org.apache.dubbo.remoting.transport.AbstractPeer.send(AbstractPeer.java:53)</span><br></pre></td></tr></table></figure>\n<p>最后就走到NettyChannel的send方法，即到了断点处：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(Object message, <span class=\"keyword\">boolean</span> sent)</span> <span class=\"keyword\">throws</span> RemotingException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.send(message, sent);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> success = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> timeout = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//断点处</span></span><br><span class=\"line\">        ChannelFuture future = channel.writeAndFlush(message);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sent) &#123;</span><br><span class=\"line\">            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class=\"line\">            success = future.await(timeout);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Throwable cause = future.cause();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cause != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> cause;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(<span class=\"keyword\">this</span>, <span class=\"string\">\"Failed to send message \"</span> + message + <span class=\"string\">\" to \"</span> + getRemoteAddress() + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemotingException(<span class=\"keyword\">this</span>, <span class=\"string\">\"Failed to send message \"</span> + message + <span class=\"string\">\" to \"</span> + getRemoteAddress()</span><br><span class=\"line\">                                    + <span class=\"string\">\"in timeout(\"</span> + timeout + <span class=\"string\">\"ms) limit\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到此，整个消费者调用过程就分析完了，文章中提到的一些关于Dubbo的核心feature将会写文章进一步分析，敬请期待。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjq6kwn4o000kzjiaaf3tn6n8","category_id":"cjq6kwn4q000pzjia4ik72n59","_id":"cjq6kwn4u000zzjiaqlbu5kup"},{"post_id":"cjq6kwn5r0034zjiaat8s04cb","category_id":"cjq6kwn5s0037zjia78umicd3","_id":"cjq6kwn5u003fzjiauc9d6d0t"}],"PostTag":[{"post_id":"cjq6kwn490001zjiaf8vzvu6y","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn4k000dzjiayve5x0jz"},{"post_id":"cjq6kwn4k000ezjiap12rh78g","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn4o000jzjia3fv41kgd"},{"post_id":"cjq6kwn4c0003zjiakp30jxne","tag_id":"cjq6kwn4j000bzjiaemvti3fh","_id":"cjq6kwn4p000mzjial4auiond"},{"post_id":"cjq6kwn4h0008zjia583ezy0k","tag_id":"cjq6kwn4n000izjiaw2rkii1a","_id":"cjq6kwn4r000rzjiakq9xfrpc"},{"post_id":"cjq6kwn4j000azjiaa69ql759","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn4t000vzjiafl36w876"},{"post_id":"cjq6kwn4j000azjiaa69ql759","tag_id":"cjq6kwn4q000ozjia7qic388y","_id":"cjq6kwn4t000xzjiap6bcwkq4"},{"post_id":"cjq6kwn4m000gzjiadyfe35j2","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn4u0011zjiahsc71oie"},{"post_id":"cjq6kwn4m000gzjiadyfe35j2","tag_id":"cjq6kwn4s000tzjiarhbwrs38","_id":"cjq6kwn4v0013zjiado8i07da"},{"post_id":"cjq6kwn4o000kzjiaaf3tn6n8","tag_id":"cjq6kwn4u0010zjiarujjgxow","_id":"cjq6kwn4x0017zjian8kblp1q"},{"post_id":"cjq6kwn4p000nzjia7n63vlnp","tag_id":"cjq6kwn4w0015zjia4ll8t31y","_id":"cjq6kwn4y001bzjiagcxu0zqk"},{"post_id":"cjq6kwn4q000qzjia3wg3nk5u","tag_id":"cjq6kwn4y0019zjiag2wu04sm","_id":"cjq6kwn50001fzjia9tzmclya"},{"post_id":"cjq6kwn50001gzjiaywx25rth","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn52001jzjia9xgmdoue"},{"post_id":"cjq6kwn4r000szjiad8o46at1","tag_id":"cjq6kwn4z001dzjiavfcgbars","_id":"cjq6kwn52001lzjiax8pr33vp"},{"post_id":"cjq6kwn51001hzjiaig78enrw","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn55001ozjiall5yy9wf"},{"post_id":"cjq6kwn52001kzjiavdz5yh12","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn56001qzjiajllem2fq"},{"post_id":"cjq6kwn4s000uzjialms1axf5","tag_id":"cjq6kwn51001izjial20b5b4n","_id":"cjq6kwn58001tzjia4e9287qr"},{"post_id":"cjq6kwn52001mzjiaijq128ll","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn5b001vzjia1kyx1ifw"},{"post_id":"cjq6kwn55001pzjiafiz5i81m","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn5c001yzjia6gy3ze9s"},{"post_id":"cjq6kwn4t000wzjiap06t7nq9","tag_id":"cjq6kwn51001izjial20b5b4n","_id":"cjq6kwn5d0020zjiat1btalcr"},{"post_id":"cjq6kwn58001uzjia1q8hdpgf","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn5e0023zjiaaysd0rlb"},{"post_id":"cjq6kwn58001uzjia1q8hdpgf","tag_id":"cjq6kwn4q000ozjia7qic388y","_id":"cjq6kwn5f0025zjiaml5wcpy9"},{"post_id":"cjq6kwn4t000yzjias7dgn4gm","tag_id":"cjq6kwn51001izjial20b5b4n","_id":"cjq6kwn5g0028zjiavlmub1c0"},{"post_id":"cjq6kwn5b001wzjiadqg270c7","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn5g002azjias8w65nuk"},{"post_id":"cjq6kwn4u0012zjiazz9m4jmr","tag_id":"cjq6kwn51001izjial20b5b4n","_id":"cjq6kwn5h002dzjia5rpcavjm"},{"post_id":"cjq6kwn5d0021zjiadhlz1cq8","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn5i002fzjiaonf64k3m"},{"post_id":"cjq6kwn5e0024zjia48uu3pu6","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn5j002izjiaj27wzdaz"},{"post_id":"cjq6kwn4v0014zjiav7pc3l8p","tag_id":"cjq6kwn51001izjial20b5b4n","_id":"cjq6kwn5k002kzjia8k8uv675"},{"post_id":"cjq6kwn4w0016zjiasasfz78n","tag_id":"cjq6kwn51001izjial20b5b4n","_id":"cjq6kwn5l002nzjiaucomvfcu"},{"post_id":"cjq6kwn4x0018zjiap1s442vn","tag_id":"cjq6kwn51001izjial20b5b4n","_id":"cjq6kwn5m002pzjia04u2n2qt"},{"post_id":"cjq6kwn4x0018zjiap1s442vn","tag_id":"cjq6kwn5j002hzjiacmaqxdpj","_id":"cjq6kwn5n002szjia3akkoseg"},{"post_id":"cjq6kwn4y001azjia1zagib5f","tag_id":"cjq6kwn51001izjial20b5b4n","_id":"cjq6kwn5n002uzjia32b5m5af"},{"post_id":"cjq6kwn5m002qzjia1e0k5wpf","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn5o002wzjiah3bui0q5"},{"post_id":"cjq6kwn4z001czjian41vlcih","tag_id":"cjq6kwn5m002rzjiazxhc01jm","_id":"cjq6kwn5p002zzjiad3qotoqz"},{"post_id":"cjq6kwn4z001ezjiae75kqjnp","tag_id":"cjq6kwn51001izjial20b5b4n","_id":"cjq6kwn5r0033zjiawgax282b"},{"post_id":"cjq6kwn5p0030zjiaof5ly35u","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn5r0035zjia2efltni2"},{"post_id":"cjq6kwn5r0034zjiaat8s04cb","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn5s0038zjias6tci231"},{"post_id":"cjq6kwn56001rzjian0f3utzc","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn5s0039zjiagd5lanvo"},{"post_id":"cjq6kwn56001rzjian0f3utzc","tag_id":"cjq6kwn5q0031zjia81wqv6df","_id":"cjq6kwn5t003bzjiasjamfrb8"},{"post_id":"cjq6kwn5c001zzjiat7xsawre","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn5t003czjiahtbrbiyc"},{"post_id":"cjq6kwn5c001zzjiat7xsawre","tag_id":"cjq6kwn5s0036zjiaa3bqunyg","_id":"cjq6kwn5t003ezjia7y96m9gv"},{"post_id":"cjq6kwn5f0026zjia8u7f5jdf","tag_id":"cjq6kwn4e0005zjiaa7ammn2u","_id":"cjq6kwn5u003gzjiapre0f5k5"},{"post_id":"cjq6kwn5f0026zjia8u7f5jdf","tag_id":"cjq6kwn5t003azjiaz2hyfhm3","_id":"cjq6kwn5u003hzjia9wiuhzqj"},{"post_id":"cjq6kwn5g0029zjiafti8s7ky","tag_id":"cjq6kwn5t003dzjiaplo71z13","_id":"cjq6kwn5w003mzjiamhchs5sq"},{"post_id":"cjq6kwn5g0029zjiafti8s7ky","tag_id":"cjq6kwn5u003izjia33zkbims","_id":"cjq6kwn5w003nzjia7jggiab3"},{"post_id":"cjq6kwn5g0029zjiafti8s7ky","tag_id":"cjq6kwn5u003jzjia722cmx5c","_id":"cjq6kwn5x003pzjia5apof9b4"},{"post_id":"cjq6kwn5g0029zjiafti8s7ky","tag_id":"cjq6kwn5v003kzjia4nild45d","_id":"cjq6kwn5x003qzjiapus2mlqs"},{"post_id":"cjq6kwn5h002bzjia0odrvt0s","tag_id":"cjq6kwn5v003lzjia8f9srzbj","_id":"cjq6kwn5x003szjiahm0hzz6e"},{"post_id":"cjq6kwn5i002ezjia3zq29o0p","tag_id":"cjq6kwn5w003ozjiauwwwl3k9","_id":"cjq6kwn5x003tzjiasn93ka2u"},{"post_id":"cjq6kwn5i002gzjiapfsppbx1","tag_id":"cjq6kwn5w003ozjiauwwwl3k9","_id":"cjq6kwn5y003vzjiakv1ickko"},{"post_id":"cjq6kwn5j002jzjia67toukwh","tag_id":"cjq6kwn5w003ozjiauwwwl3k9","_id":"cjq6kwn5y003xzjiau07b1905"},{"post_id":"cjq6kwn5k002lzjiad4e9fzc8","tag_id":"cjq6kwn5v003kzjia4nild45d","_id":"cjq6kwn600040zjiaxrykarzf"},{"post_id":"cjq6kwn5k002lzjiad4e9fzc8","tag_id":"cjq6kwn5y003yzjiafslyfvkw","_id":"cjq6kwn600041zjiaiez1s8mc"},{"post_id":"cjq6kwn5l002ozjiavnfsoja6","tag_id":"cjq6kwn5w003ozjiauwwwl3k9","_id":"cjq6kwn600043zjiaeb8n736j"},{"post_id":"cjq6kwn5n002tzjiaiuc9ed2m","tag_id":"cjq6kwn5w003ozjiauwwwl3k9","_id":"cjq6kwn600045zjiah4m24oyt"},{"post_id":"cjq6kwn5n002vzjiati0ysslh","tag_id":"cjq6kwn5w003ozjiauwwwl3k9","_id":"cjq6kwn610047zjiaxwab09ov"},{"post_id":"cjq6kwn5o002yzjiatflgnrdz","tag_id":"cjq6kwn600046zjiah1zv6fho","_id":"cjq6kwn61004azjiacycshydk"},{"post_id":"cjq6kwn5o002yzjiatflgnrdz","tag_id":"cjq6kwn610048zjia08xw88x0","_id":"cjq6kwn61004bzjiaokasr9br"},{"post_id":"cjq6kwn5q0032zjia6g5felp5","tag_id":"cjq6kwn5u003izjia33zkbims","_id":"cjq6kwn61004czjia8926l2cb"},{"post_id":"cjq6kwn5q0032zjia6g5felp5","tag_id":"cjq6kwn4j000bzjiaemvti3fh","_id":"cjq6kwn61004dzjiats96q1uv"},{"post_id":"cjq6kwn6m004ezjiafzijorx4","tag_id":"cjq6kwn51001izjial20b5b4n","_id":"cjq6kwn6o004fzjiajjb5nmt0"}],"Tag":[{"name":"java","_id":"cjq6kwn4e0005zjiaa7ammn2u"},{"name":"CentOS","_id":"cjq6kwn4j000bzjiaemvti3fh"},{"name":"zookeeper","_id":"cjq6kwn4n000izjiaw2rkii1a"},{"name":"MutliThread","_id":"cjq6kwn4q000ozjia7qic388y"},{"name":"NIO","_id":"cjq6kwn4s000tzjiarhbwrs38"},{"name":"WebSystem","_id":"cjq6kwn4u0010zjiarujjgxow"},{"name":"LRU","_id":"cjq6kwn4w0015zjia4ll8t31y"},{"name":"MyBatis3","_id":"cjq6kwn4y0019zjiag2wu04sm"},{"name":"Spring","_id":"cjq6kwn4z001dzjiavfcgbars"},{"name":"dubbo","_id":"cjq6kwn51001izjial20b5b4n"},{"name":"javassist","_id":"cjq6kwn5j002hzjiacmaqxdpj"},{"name":"http","_id":"cjq6kwn5m002rzjiazxhc01jm"},{"name":"AQS","_id":"cjq6kwn5q0031zjia81wqv6df"},{"name":"SPI","_id":"cjq6kwn5s0036zjiaa3bqunyg"},{"name":"mmap","_id":"cjq6kwn5t003azjiaz2hyfhm3"},{"name":"虚拟化","_id":"cjq6kwn5t003dzjiaplo71z13"},{"name":"KVM","_id":"cjq6kwn5u003izjia33zkbims"},{"name":"网络配置","_id":"cjq6kwn5u003jzjia722cmx5c"},{"name":"Linux","_id":"cjq6kwn5v003kzjia4nild45d"},{"name":"log4j","_id":"cjq6kwn5v003lzjia8f9srzbj"},{"name":"Netty","_id":"cjq6kwn5w003ozjiauwwwl3k9"},{"name":"DirectIO","_id":"cjq6kwn5y003yzjiafslyfvkw"},{"name":"Spring Cloud","_id":"cjq6kwn600046zjiah1zv6fho"},{"name":"Micro Service","_id":"cjq6kwn610048zjia08xw88x0"}]}}