<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Netty数据容器---ByteBuf]]></title>
    <url>%2F2018%2F07%2F24%2FByteBuf-data-container%2F</url>
    <content type="text"><![CDATA[ByteBuf工作原理ByteBuf维护了两个不同的索引：一个用于读取，一个用于写入。当从ByteBuf读取数据时，它的readerINdex将会递增已被读取的字节数。同样的，当你写入ByteBuf的时候，它的writerIndex也会被递增。 上图中表示的是一个读索引和写索引都设置为0的16字节ByteBuf，若果试图访问超出writerIndex范围的数据将会触发一个IndexOutOfBoundsException异常。 ByteBuf的使用模式堆缓冲区最常用的ByteBuf模式是将数据存储在JVM的堆空间中，这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。 直接缓冲区直接缓冲区是通过本地方法调用来分配堆外内存，这样可以避免在每次调用本地I/O操作之前（或者之后）将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。 直接缓冲区的主要缺点是：相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。因为数据不在堆上，所以在操作数据之前不得不进行一次数据复制。 复合缓冲区复合缓冲区主要是为多个ByteBuf提供一个聚合视图，这是一个JDK的ByteBuffer实现完全缺失的特性。]]></content>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty内置传输方式]]></title>
    <url>%2F2018%2F07%2F21%2Fnetty-transport-methods%2F</url>
    <content type="text"><![CDATA[Netty中内置的传输方式主要包括：NIO、Epoll、OIO、Local和Embedded等方式，总结如下： 名称 包名 描述 NIO io.netty.channel.socket.io 使用java.nio.channels包作为基础，基于选择器的方式 Epoll io.netty.channel.epoll 由JNI驱动的epoll()和非阻塞IO，这种传输只有Linux才支持，比NIO传输速度更快，而且是完全非阻塞的 OIO io.netty.channel.socket.oio 使用java.net包作为基础 Local io.netty.channel.local 可以在VM内部通过管道进行通信的本地传输 Embedded io.netty.channel.socket.embedded Embedded 传输，允许使用 ChannelHandler 而又不需要一个真正的基于网络的传输，测试ChannelHandler实现的时候非常有用 基于NIO的传输 Epoll—基于Linux的本地非阻塞传输在Linux内核版2.5.44之后就引入了epoll，提供了比旧的POSIX select和poll系统调用更好的性能。如何应用程序运行在Linux系统智商，则可以利用基于Epoll的方式传输，只需要在代码中将NioEventLoopGroup替换为EpollEventLoopGroup，并且将NioServerSocketChannel.class替换为EpollServerSocketChannel.class。或者用如下方式判断系统是否支持Epoll： 1234567891011121314151617181920212223EventLoopGroup workGroup = Epoll.isAvailable() ? new EpollEventLoopGroup(4) : new NioEventLoopGroup(4);Bootstrap bootstrap = new Bootstrap();bootstrap.group(workGroup) .channel(Epoll.isAvailable() ? EpollSocketChannel.class : NioSocketChannel.class) .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; // Using Java Object serializable, you can also use other serializable frameworks like thrift, Protobuf and so on. ch.pipeline() .addLast(new ObjectDecoder(1024*1024, ClassResolvers.weakCachingConcurrentResolver(this.getClass().getClassLoader())) ) .addLast(new ObjectEncoder()) .addLast(new SimpleChannelInboundHandler&lt;Object&gt;() &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception &#123; System.out.println("Receive msg: " + msg); &#125; &#125;); &#125; &#125;);// Connect to the server syncchannel = bootstrap.connect(host, port).sync().channel(); OIO—阻塞I/O]]></content>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty组件介绍]]></title>
    <url>%2F2018%2F07%2F20%2Fnetty-components-design%2F</url>
    <content type="text"><![CDATA[下面将介绍Netty中所包含的各种组件，主要包括：Channel、EventLoop、ChannelFuture、ChannelHandler和ChannelPipeline等。 Channel、EventLoop和ChannelFuture 一个EventLoopGroup可以包含一个或者多个EventLoop； 一个EventLoop在它的生命周期内只和一个Thread绑定； 所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理； 一个Channel在它的生命周期内只能注册于一个EventLoop； 一个EventLoop可能被分配给多个Channel； 在Netty中所有的I/O操作都是异步的，因此可以通过ChannelFuture来获取响应结果； ChannelHandler和ChannelPipeline ChannelPipeline提供了ChannelHandler链的容器，并定义了同于在该链上传播入站的出站的事件流的API； 一个ChannelIninializer的实现被注册到ServerBootstrap中或这Client的BootStrap中； 当 ChannelInitializer.initChannel() 方法被调用时，ChannelInitializer将在 ChannelPipeline 中安装一组自定义的 ChannelHandler ； ChannelInitializer将它自己从 ChannelPipeline 中移除； 从一个客户端应用程序角度来看，当事件的运动方向是从客户端到服务器，我们称之为出站，反之则称之为入站； 数据出站运动，数据讲从ChannelOutboundHandler链的尾端开始流动，直到它到达链的头部为止，此时数据到达了网络传输层，通常情况下会触发一个写操作。 BootStrap和ServerBootstrap 类别 Bootstrap ServerBootstrap 网络编程中的作用 连接到远程主机和端口 绑定到一个本地端口 EventLoopGroup的数目 1 2（也可以1个） 上图中，客户端创建了一个EventLoopGroup，服务器端使用了两个EventLoopGroup，其中一个EventLoopGroup用来接收客户端发来的请求，另一个EventLoop用来处理连接任务。 示例服务器端 12345678910111213141516171819202122EventLoopGroup bossGroup = new EpollEventLoopGroup(1);EventLoopGroup workerGroup = new EpollEventLoopGroup(4);try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(EpollServerSocketChannel.class) //保持长连接状态 .childOption(ChannelOption.SO_KEEPALIVE, true) .childOption(ChannelOption.TCP_NODELAY, true) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .childHandler(new HttpSnoopServerInitializer()); ChannelFuture ch = b.bind(PORT).sync(); if (ch.isSuccess())&#123; logger.info("Http server start on port :&#123;&#125;", PORT ); &#125; ch.channel().closeFuture().sync();&#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully();&#125; 客户端 123456789EventLoopGroup eventLoopGroup = new EpollEventLoopGroup(8);Bootstrap bootstrap = new Bootstrap() .group(eventLoopGroup) .option(ChannelOption.SO_KEEPALIVE, true) .option(ChannelOption.TCP_NODELAY, true) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .channel(EpollSocketChannel.class) .handler(new RpcClientInitializer());Channel channel = bootstrap.connect("127.0.0.1", port).sync().channel();]]></content>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[User Thread and Daemon Thread in Java]]></title>
    <url>%2F2018%2F07%2F04%2Fuser-thread-and-daemon-thread%2F</url>
    <content type="text"><![CDATA[在Java当中有两种线程，一种是User Thread，另一种是Daemon Thread。一般来说User Thread具有较高的优先级，它主要运行在前台，然而，Daemon Thread具有较低的优先级，主要运行在后台。 User ThreadUser Thread通常由应用或者用户创建的，JVM Instance等待所有的User Thread执行完成Tasks，直到所有的User Thread执行完成JVM才会退出。 Daemon ThreadDaemon Thread通常由JVM创建， 这些线程在后台运行，运行一些后台任务（包括，垃圾回收、内务任务等）。JVM 不会等待所有的Daemon Thrad执行完Tasks，只要所有的User Thread执行完Tasks，JVM就会退出。 User Thread VS Daemon Thread In Java User Threads Daemon Threads JVM waits for user threads to finish their work. It will not exit until all user threads finish their work. JVM will not wait for daemon threads to finish their work. It will exit as soon as all user threads finish their work. User threads are foreground threads. Daemon threads are background threads. User threads are high priority threads. Daemon threads are low priority threads. User threads are created by the application. Daemon threads, in most of time, are created by the JVM. User threads are mainly designed to do some specific task. Daemon threads are designed to support the user threads. JVM will not force the user threads to terminate. It will wait for user threads to terminate themselves. JVM will force the daemon threads to terminate if all user threads have finished their work. Some Things-To-Remember about user threads and daemon threads In Java : You can convert user thread into daemon thread explicitly by calling setDaemon() method of the thread. 123456789101112131415161718public class ThreadsInJava &#123; //Main Thread public static void main(String[] args) &#123; UserThread userThread = new UserThread(); //Creating the UserThread userThread.setDaemon(true); //Changing the thread as Daemon userThread.start(); //Starting the thread &#125;&#125;class UserThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("This is an user thread...."); &#125; &#125;&#125; You can’t set a daemon property after starting the thread. If you try to set the daemon property when the thread is active, It will throw a IllegalThreadStateException at run time. 123456789101112131415161718class UserThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("This is an user thread...."); &#125; &#125;&#125;public class ThreadsInJava &#123; public static void main(String[] args) &#123; UserThread userThread = new UserThread(); //Creating the UserThread userThread.start(); //Starting the thread userThread.setDaemon(true); //This statement will throw IllegalThreadStateException &#125;&#125; You can check whether the thread is user thread or a daemon thread by using isDaemon() method of Thread class. This method returns “true” for a daemon thread and “false” for a user thread. 12345678910111213141516171819202122class UserThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("This is an user thread...."); &#125; &#125;&#125;public class ThreadsInJava &#123; public static void main(String[] args) &#123; UserThread userThread = new UserThread(); //Creating the UserThread System.out.println(userThread.isDaemon()); //Output : false userThread.setDaemon(true); //changing the thread as Daemon userThread.start(); //Starting the thread System.out.println(userThread.isDaemon()); //Output : true &#125;&#125; Daemon property of a thread is inherited from it’s parent thread. i.e The thread created by user thread will be user thread and the thread created by daemon thread will be a daemon thread. 12345678910111213141516171819202122class Thread1 extends Thread &#123; @Override public void run() &#123; Thread t = new Thread(); //Creating a child thread System.out.println(t.isDaemon()); //Checking the Daemon property of a child thread &#125;&#125;public class ThreadsInJava &#123; public static void main(String[] args) &#123; Thread1 t1 = new Thread1(); //Creating the Thread1 t1.start(); //Starting the thread Thread1 t2 = new Thread1(); //Creating the Thread1 t2.setDaemon(true); //changing the thread as Daemon t2.start(); //Starting the thread &#125;&#125; The main thread or primary thread created by JVM is an user thread. Demonstration of User thread and daemon thread : In the below program, The task of daemon thread will not be completed. Program terminates as soon as user thread finishes it’s task. It will not wait for daemon thread to finish it’s task. 1234567891011121314151617181920212223242526272829303132333435/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 10:32 AM 2018/07/06. */class UserThread extends Thread &#123; @Override public void run() &#123; System.out.println("This is a user thread....."); &#125;&#125;class DaemonThread extends Thread &#123; public DaemonThread() &#123; setDaemon(true); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("This is daemon thread....." + i); &#125; &#125;&#125;public class ThreadsInJava &#123; public static void main(String[] args) &#123; DaemonThread daemon = new DaemonThread(); //Creating the DaemonThread daemon.start(); //Starting the daemon thread UserThread userThread = new UserThread(); //Creating the UserThread userThread.start(); //Starting the user thread &#125;&#125; Conclusion1) User threads are created by the application (user) to perform some specific task. Where as daemon threads are mostly created by the JVM to perform some background tasks like garbage collection. 2) JVM will wait for user threads to finish their tasks. JVM will not exit until all user threads finish their tasks. On the other side, JVM will not wait for daemon threads to finish their tasks. It will exit as soon as all user threads finish their tasks. 3) User threads are high priority threads, They are designed mainly to execute some important task in an application. Where as daemon threads are less priority threads. They are designed to serve the user threads. 4) User threads are foreground threads. They always run in foreground and perform some specific task assigned to them. Where as daemon threads are background threads. They always run in background and act in a supporting role to user threads. 5) JVM will not force the user threads to terminate. It will wait for user threads to terminate themselves. On the other hand, JVM will force the daemon threads to terminate if all the user threads have finished their task. 6) User threads are chosen to do the core work of an application. The application is very much dependent on the user threads for it’s smooth execution. Where as daemon threads are chosen to do some supporting tasks. The application is less dependent on the daemon threads for it’s smooth running. REFERENCES Types Of Threads In Java Difference Between User Threads Vs Daemon Threads In Java]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty线程模型分析]]></title>
    <url>%2F2018%2F06%2F26%2Fnetty-thread-model%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP详解]]></title>
    <url>%2F2018%2F05%2F19%2Fhttp%2F</url>
    <content type="text"><![CDATA[The Hypertext Transfer Protocol (HTTP) is an application-level protocol that uses TCP as an underlying transport and typically runs on port 80. HTTP is a stateless protocol i.e. server maintains no information about past client requests. HTTP与TCP/IP的关系HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP有可靠，面向连接的特点。 HTTP是无状态的HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 长连接和短连接在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。 但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入这行代码：Connection:keep-alive 短连接我们模拟一下TCP短连接的情况，client向server发起连接请求，server接到请求，然后双方建立连接。client向server 发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作。为什么呢，一般的server不会回复完client后立即关闭连接的，当然不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server间传递一次读写操作 优点：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段 长连接接下来我们再模拟一下长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。 优点 Lower CPU and memory usage because there are less number of connections. Allows HTTP pipelining of requests and responses. Reduced network congestion (fewer TCP connections). Reduced latency in subsequent requests (no handshaking). Errors can be reported without the penalty of closing the TCP connection. 缺点 Resources may be be kept occupied even when not needed and may not be available to others. REFERENCEPersistent Connections HTTP Non-Persistent &amp; Persistent Connection | Set 1 HTTP长连接和短连接]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty 入门]]></title>
    <url>%2F2018%2F05%2F10%2Fnetty-introduction%2F</url>
    <content type="text"><![CDATA[Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server. 特征 不同的传输类型（blocking and non-blocking socket ）使用统一的API 拥有灵活的易扩展的事件模型 高低自定义的线程模型-single thread, one or more thread pools such as SEDA 高吞吐量，低时延 更少的资源占用 最小化不必要的内存拷贝 完全支持SSL/TLS和StartTLS 入门示例添加依赖123456&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.23.Final&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; Server端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.serialization.ClassResolvers;import io.netty.handler.codec.serialization.ObjectDecoder;import io.netty.handler.codec.serialization.ObjectEncoder;/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 13:44 2018/5/11. */public class NettyServer &#123; public void start(Integer port) throws InterruptedException &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workGroup = new NioEventLoopGroup(4); ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup, workGroup).channel(NioServerSocketChannel.class) .localAddress(port) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline() .addLast(new ObjectDecoder(1024*1024, ClassResolvers.weakCachingConcurrentResolver(this.getClass().getClassLoader())) ) .addLast(new ObjectEncoder()) .addLast(new SimpleChannelInboundHandler&lt;Object&gt;() &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception &#123; System.out.println("Receive message:" + msg); ctx.writeAndFlush("Hello " + msg); &#125; &#125;); &#125; &#125;); ChannelFuture channelFuture = bootstrap.bind().sync(); channelFuture.channel().closeFuture().sync(); bossGroup.shutdownGracefully().sync(); workGroup.shutdownGracefully().sync(); &#125; public static void main(String[] args) &#123; try &#123; NettyServer server = new NettyServer(); server.start(20000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Client端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import io.netty.bootstrap.Bootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.serialization.ClassResolvers;import io.netty.handler.codec.serialization.ObjectDecoder;import io.netty.handler.codec.serialization.ObjectEncoder;/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 13:53 2018/5/11. */public class NettyClient &#123; public Channel channel; public void start(String host, Integer port) throws InterruptedException &#123; EventLoopGroup workGroup = new NioEventLoopGroup(4); Bootstrap bootstrap = new Bootstrap(); bootstrap.group(workGroup) .channel(NioSocketChannel.class) .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; // Using Java Object serializable, you can also use other serializable frameworks like thrift, Protobuf and so on. ch.pipeline() .addLast(new ObjectDecoder(1024*1024, ClassResolvers.weakCachingConcurrentResolver(this.getClass().getClassLoader())) ) .addLast(new ObjectEncoder()) .addLast(new SimpleChannelInboundHandler&lt;Object&gt;() &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception &#123; System.out.println("Receive msg: " + msg); &#125; &#125;); &#125; &#125;); // Connect to the server sync channel = bootstrap.connect(host, port).sync().channel(); &#125; public static void main(String[] args) &#123; try &#123; NettyClient nettyClient = new NettyClient(); nettyClient.start("127.0.0.1", 20000); if (nettyClient.channel != null &amp;&amp; nettyClient.channel.isActive())&#123; System.out.println("Send message to server"); nettyClient.channel.writeAndFlush("Junlan"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java NIO and BIO]]></title>
    <url>%2F2018%2F04%2F19%2FJava-NIO-and-BIO%2F</url>
    <content type="text"><![CDATA[我们都知NIO是非阻塞IO，BIO是阻塞IO，那到底什么是阻塞，什么是非阻塞呢，它们与同步/异步又有什么区别呢？先来了解一下阻塞/非阻塞，同步/异步的概念。 阻塞/非阻塞/同步/异步 阻塞： 当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足； 非阻塞： 当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。 同步： 可以理解为在执行一个函数或方法，只有接收到返回的值或消息后才会继续往下执行其他的命令。 callee执行完成才返回返回值即结果 异步： 可以理解为在执行一个函数或方法，不用等待其返回，继续往下执行其他的命令。 callee不需要执行完成就可返回caller要获取结果，需要通过轮询、回调等机制 Update 同步与异步的区别：函数调用发生时，消息(参数)从caller传递到callee，控制权(指令执行)从caller转移到callee。调用返回时，控制权从callee转移到caller。两者的区别在于，callee是否需要等待执行完成才将控制权转移给caller。 阻塞IO和非阻塞IO通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。 当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段： 查看数据是否就绪； 进行数据拷贝（内核将数据拷贝到用户线程）。 那么阻塞（BIO）和非阻塞（NIO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。 Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待，从jdk1.4开始引入NIO。 基于Java API实现NioServer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 14:19 2018/4/15. * * 基于Java API实现NIO server */public class PlainNioServer &#123; public void server(int port) throws IOException &#123; ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.configureBlocking(false); ServerSocket serverSocket =serverSocketChannel.socket(); //将服务器绑定到选定的端口 InetSocketAddress address = new InetSocketAddress(port); serverSocket.bind(address); //打开Selector来处理Channel Selector selector = Selector.open(); //将ServerSocket注册到Selector以接受连接 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); final ByteBuffer msg = ByteBuffer.wrap("Hi! \r\n".getBytes()); for (;;)&#123; try &#123; //等待需要处理的新事件；阻塞将一直持续到下一个传入事件 selector.select(); &#125; catch (IOException ex)&#123; ex.printStackTrace(); break; &#125; //获取所有接收事件的SelectorKey实例 Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator(); while (iterator.hasNext())&#123; SelectionKey key = iterator.next(); iterator.remove(); //检查事件是否是一个新的已经就绪可以被接受的连接 if (key.isAcceptable())&#123; ServerSocketChannel server = (ServerSocketChannel) key.channel(); SocketChannel client = server.accept(); client.configureBlocking(false); //接受客户端，并将它注册到选择器 client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, msg.duplicate()); System.out.println("Accepted connection from " + client); &#125; //检查套接字是否已经准备好写数据 if (key.isWritable())&#123; SocketChannel client = (SocketChannel)key.channel(); ByteBuffer byteBuffer = (ByteBuffer)key.attachment(); while (byteBuffer.hasRemaining())&#123; //将数据写到已连接的客户端 if (client.write(byteBuffer) == 0)&#123; break; &#125; &#125; //关闭连接 client.close(); &#125; key.cancel(); key.channel().close(); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于HashMap和双向链表实现LRUCache]]></title>
    <url>%2F2018%2F04%2F12%2FLruCache-On-Map-And-LinkedList%2F</url>
    <content type="text"><![CDATA[使用HashMap和双向链表实现LRUCache，HashMap用来定位节点是否已经存在，时间复杂度为O(1)，双向链表用来用来实现LRU规则，移动节点的时间复杂度也是O(1)，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141package cn.shuaijunlan.cache.lru;import java.util.HashMap;/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 10:48 2018/4/12. */public class LruCacheOnLinkedAndMap&lt;K, V&gt; &#123; /** * 定义双向链表节点 * @param &lt;K&gt; * @param &lt;V&gt; */ private class Entry&lt;K, V&gt;&#123; Entry pre; Entry next; K key; V value; public Entry(K key,V value)&#123; this.key = key; this.value = value; &#125; &#125; /** * 缓存大小 */ private final int size; /** * 存储Entry Node */ private HashMap&lt;K,Entry&lt;K,V&gt;&gt; map; /** * 链表尾节点 */ private Entry last; /** * 链表头节点 */ private Entry first; public LruCacheOnLinkedAndMap(int size)&#123; if (size &lt;= 0)&#123; throw new IllegalArgumentException("The size of Cache must more than zero!"); &#125; this.size = size; map = new HashMap(); &#125; public void put(K key, V value)&#123; Entry entry = map.get(key); if (entry == null)&#123; if (map.size() &gt;= this.size)&#123; removeLast(); &#125; entry = new Entry(key, value); &#125; entry.value = value; moveToFirst(entry); map.put(key, entry); &#125; /** * 删除尾节点 */ public void removeLast()&#123; if (last != null)&#123; map.remove(last.key); last = last.pre; if (last == null)&#123; first = null; &#125;else &#123; last.next = null; &#125; &#125; &#125; public Entry get(K key)&#123; Entry entry = map.get(key); if (entry == null)&#123; return null; &#125; moveToFirst(entry); return entry; &#125; /** * 根据LRU规则，将最近使用的节点移至链表头部 * @param entry */ public void moveToFirst(Entry entry)&#123; if (entry == first)&#123; return; &#125; if (entry.pre != null)&#123; entry.pre.next = entry.next; &#125; if (entry.next != null)&#123; entry.next.pre = entry.pre; &#125; if (entry == last)&#123; last = last.pre; &#125; if (first == null || last == null)&#123; first = last = entry; return; &#125; entry.next = first; first.pre = entry; first = entry; entry.pre = null; &#125; public void print() &#123; Entry temp = first; while (temp != null)&#123; System.out.println("Key:" + temp.key + " Value:" + temp.value); temp = temp.next; &#125; System.out.println(map.size()); &#125; /** * 测试函数 * @param args */ public static void main(String[] args) &#123; LruCacheOnLinkedAndMap&lt;String, Integer&gt; lruCacheOnLinkedAndMap = new LruCacheOnLinkedAndMap&lt;&gt;(6); lruCacheOnLinkedAndMap.put("s", 1); lruCacheOnLinkedAndMap.put("h", 2); lruCacheOnLinkedAndMap.put("u", 3); lruCacheOnLinkedAndMap.put("a", 8); lruCacheOnLinkedAndMap.put("i", 4); lruCacheOnLinkedAndMap.put("j", 7); lruCacheOnLinkedAndMap.put("u", 1); lruCacheOnLinkedAndMap.put("s", 10); lruCacheOnLinkedAndMap.print(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java类与对象初始化过程]]></title>
    <url>%2F2018%2F04%2F01%2FJava-Class-and-Object-Initializing-Process%2F</url>
    <content type="text"><![CDATA[看看如下代码，输出结果是啥？1234567891011121314151617181920212223242526272829303132/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 18:59 2018/4/1. */public class Test &#123; public static int k = 0; public static Test t1 = new Test("t1"); public static Test t2 = new Test("t2"); public static int i = print("i"); public static int n = 99; public int j = print("j"); static &#123; print("静态块"); &#125; public Test(String string)&#123; System.out.println((++k) + ":" + string + " i=" + i + " n=" + n); ++i; ++n; &#125; &#123; print("构造块"); &#125; public static int print(String string)&#123; System.out.println((++k) + ":" + string + " i=" + i + " n=" + n); ++n; return ++i; &#125; public static void main(String[] args) &#123; Test test = new Test("init"); &#125;&#125; Output 12345678910111:j i=0 n=02:构造块 i=1 n=13:t1 i=2 n=24:j i=3 n=35:构造块 i=4 n=46:t2 i=5 n=57:i i=6 n=68:静态块 i=7 n=999:j i=8 n=10010:构造块 i=9 n=10111:init i=10 n=102 Reference Java类与对象初始化的过程]]></content>
  </entry>
  <entry>
    <title><![CDATA[Distributed-Lock-Based-On-Zookeeper]]></title>
    <url>%2F2018%2F03%2F31%2FDistributed-Lock-Based-On-Zookeeper%2F</url>
    <content type="text"><![CDATA[基于Zookeeper实现分布式锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import com.google.common.base.Strings;import com.google.common.util.concurrent.ThreadFactoryBuilder;import org.apache.zookeeper.*;import java.io.IOException;import java.util.concurrent.*;/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 15:37 2018/3/31. */public class DistributedLockBasedOnZookeeper &#123; private String hostPort = "host:port"; private String lockNameSpace = "/myLock"; private String nodeString = lockNameSpace + "/test1"; private ZooKeeper zk; public DistributedLockBasedOnZookeeper()&#123; try &#123; zk = new ZooKeeper(hostPort, 6000, event -&gt; &#123; System.out.println("Receive event " + event); if (Watcher.Event.KeeperState.SyncConnected == event.getState())&#123; System.out.println("Connection is established..."); &#125; &#125;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void ensureRootPath() throws InterruptedException &#123; try &#123; if (zk.exists(lockNameSpace, true) == null)&#123; zk.create(lockNameSpace, "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); &#125; &#125; catch (KeeperException e) &#123; e.printStackTrace(); &#125; &#125; private void watchNode(String nodeString, final Thread thread)&#123; try &#123; zk.exists(nodeString, event -&gt; &#123; System.out.println("==" + event.toString()); if (event.getType() == Watcher.Event.EventType.NodeDeleted)&#123; System.out.println("There is a Thread released lock....."); thread.interrupt(); &#125; try &#123; zk.exists(nodeString, true); &#125; catch (KeeperException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125; catch (KeeperException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** * get Lock * @return */ public boolean getLock() throws InterruptedException &#123; String path = null; ensureRootPath(); watchNode(nodeString, Thread.currentThread()); while (true)&#123; try &#123; path = zk.create(nodeString, "".getBytes(),ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL); &#125; catch (KeeperException e) &#123; System.out.println(Thread.currentThread().getName() + "getting Lock but can not get"); Thread.sleep(5000); &#125; if (!Strings.nullToEmpty(path).trim().isEmpty())&#123; System.out.println(Thread.currentThread().getName() + " get Lock..."); return true; &#125; &#125; &#125; /** * release Lock */ public void unlock()&#123; try &#123; zk.delete(nodeString, -1); System.out.println(Thread.currentThread().getName() + " release Lock..."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (KeeperException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat("demo-pool-%d").build(); ExecutorService service = new ThreadPoolExecutor(10, 10, 1000L, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;&gt;(1024), threadFactory, new ThreadPoolExecutor.AbortPolicy()); for (int i = 0; i &lt; 4; i++)&#123; service.execute(() -&gt; &#123; DistributedLockBasedOnZookeeper lockBasedOnZookeeper = new DistributedLockBasedOnZookeeper(); try &#123; lockBasedOnZookeeper.getLock(); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lockBasedOnZookeeper.unlock(); &#125;); &#125; service.shutdown(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[How-to-understand-the-DeadLock]]></title>
    <url>%2F2018%2F03%2F25%2FHow-to-understand-the-DeadLock%2F</url>
    <content type="text"><![CDATA[如何理解如下代码会造成DeadLock1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 10:36 2018/4/14. */public class DeadLock &#123; static class Friend&#123; private final String name; public Friend(String name)&#123; this.name = name; &#125; public String getName()&#123; return this.name; &#125; public synchronized void bow(Friend friend)&#123; System.out.format("%s:%s" + " has bowed to me!%n", this.name, friend.getName()); friend.bowBack(this); &#125; public synchronized void bowBack(Friend friend)&#123; System.out.format("%s:%s" + " has bowed back to me!%n", this.name, friend.getName()); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; final Friend friendA = new Friend("Shuai"); final Friend friendB = new Friend("Junlan"); ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 2, 1000L, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;&gt;(2)); /// Why not using this way to create ThreadPool? // ExecutorService fixedThreadPool = Executors.newFixedThreadPool(2); threadPoolExecutor.execute(() -&gt; friendA.bow(friendB)); threadPoolExecutor.execute(() -&gt; friendB.bow(friendA)); threadPoolExecutor.shutdown(); &#125;&#125; output 12Shuai:Junlan has bowed to me!Junlan:Shuai has bowed to me! Conclusion 类的实例对类中所有的synchronized方法都持有锁；（表述不够官方）]]></content>
      <tags>
        <tag>java</tag>
        <tag>MutliThread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Distributed-Systems-Technologies]]></title>
    <url>%2F2018%2F03%2F22%2FDistributed-Systems-Technologies%2F</url>
    <content type="text"><![CDATA[1.分布式系统中基本概念及常用技术介绍网络I/O模型1.同步和异步 同步： 异步： 2.阻塞和非阻塞 阻塞： 非阻塞: 3.UNIX网络I/O模型远程过程调用（RPC） 2.分布式系统架构体系基于对象的体系结构面向服务的架构（SOA）REST风格的架构微服务架构（MSA）容器技术Serverless架构原则3.分布式消息服务ActiveMQRabbitMQRocketMQKafka]]></content>
  </entry>
  <entry>
    <title><![CDATA[Basing on Spring SpringMVC MyBatis Druid Shrio developing web system]]></title>
    <url>%2F2017%2F11%2F03%2FBasing-on-Spring-SpringMVC-MyBatis-Druid-Shrio-developing-web-system%2F</url>
    <content type="text"><![CDATA[源码下载地址：https://github.com/shuaijunlan/Autumn-Framework 在线Demo：http://autumn.shuaijunlan.cn 项目介绍Autumn-Framework旨在提供通用的web系统解决方案，目前由作者本人一个人维护，更新速度缓慢，但是会持续更新，此项目适合初学者学习使用，也欢迎您加入我一起维护整个项目。 效果图 登录界面 系统主界面 菜单管理 日志管理 技术选型前端以Layui为主要框架，并使用了ECharts、editor.md等其他第三方插件后端主要使用Spring、SpringMVC、MyBatis、Shiro、Druid、Ehcache构建整个web系统，并使用Maven管理项目，使用Mysql存储数据，使用tomcat部署web系统。 代码结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.└── src-------------------------------------------源码根目录 └── main ├── java │ └── com │ └── autumnframework │ └── cms │ ├── architect-------------包含常用的工具类和常量 │ │ ├── conf │ │ ├── constant │ │ ├── filter │ │ ├── interceptor │ │ └── utils │ ├── controller------------控制器层 │ │ └── system │ ├── dao-------------------dao层 │ │ ├── bomapper │ │ └── vomapper │ │ ├── impl │ │ └── interfaces │ ├── model-----------------model层 │ │ ├── bo │ │ ├── po │ │ └── vo │ ├── service---------------service层 │ │ ├── impl │ │ └── interfaces │ └── shiroconfig-----------shiro配置 │ ├── filter │ └── realm ├── resources----------------------------资源文件目录 │ ├── mapperxml------------------------mapper映射文件 │ ├── mybatis-generator----------------mybatis-generator配置文件 │ └── spring---------------------------所有与spring相关的配置文件 └── webapp-------------------------------前端源码文件 ├── BasePlu--------------------------公共库 ├── comm ├── Lib------------------------------第三方库 │ ├── Echarts-3.7.2 │ ├── editor.md │ ├── jquery │ └── layui_v2.1.2 ├── static--------------------------静态资源 ├── Sys-----------------------------系统功能插件目录 │ ├── js │ └── plugin └── WEB-INF └── views ├── error-------------------异常目录 └── main--------------------系统主界面目录 运行系统 拷贝代码到本地git clone git@github.com:shuaijunlan/Autumn-Framework.git 进入Autumn-Framework目录cd Autumn-Framework 执行mvn install 再进入cms目录cd cms 在执行mvn tomcat7:run 最后在浏览器中访问localhost:8081，就可以看到登录界面 Tips：以上所有操作基于您的电脑已经安装了jdk8、maven和git环境 FAQ联系作者您有任何问题都可以随时联系我！ Email：shuaijunlan@gmail.com]]></content>
      <categories>
        <category>WebSystem</category>
      </categories>
      <tags>
        <tag>WebSystem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[analyse the source code of Timer]]></title>
    <url>%2F2017%2F07%2F26%2Fanalyse-the-source-code-of-Timer%2F</url>
    <content type="text"><![CDATA[Timer Class Introduction 在JDK库中Timer类主要负责计划任务的功能，也就是在指定的时间开始执行某任务。 A Simple Example12345678910111213141516171819202122232425262728293031323334353637383940414243import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Timer;import java.util.TimerTask;/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 9:53 2017/7/26. */public class TimerTest &#123; // define a timer private static Timer timer = new Timer(); // define MyTask class static public class MyTask extends TimerTask&#123; private String str; public MyTask(String str)&#123; this.str = str; &#125; @Override public void run() &#123; System.out.println(this.str + "running:" + new Date()); &#125; &#125; // test main public static void main(String[] args) throws ParseException &#123; MyTask myTask1 = new MyTask("task1"); MyTask myTask2 = new MyTask("task2"); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString1 = "2017-07-26 10:06:01"; Date date1 = sdf.parse(dateString1); String dateString2 = "2017-07-26 10:05:01"; Date date2 = sdf.parse(dateString2); timer.schedule(myTask1, date1); timer.schedule(myTask2, date2); &#125;&#125; 在这个例子中，定义了两个TimerTask，并且设定执行时间，调用Timer的schedule()方法，传入任务和时间，执行正确。 Timer源码分析 首先我们以timer.schedule()方法为入口，进一步剖析整个执行流程。看看Timer的schedule()的源码： 123public void schedule(TimerTask task, Date time) &#123; sched(task, time.getTime(), 0);&#125; 再进一步看sched()方法的源码 123456789101112131415161718192021222324252627private void sched(TimerTask task, long time, long period) &#123; if (time &lt; 0) throw new IllegalArgumentException("Illegal execution time."); // Constrain value of period sufficiently to prevent numeric // overflow while still being effectively infinitely large. if (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; 1)) period &gt;&gt;= 1; synchronized(queue) &#123; if (!thread.newTasksMayBeScheduled) throw new IllegalStateException("Timer already cancelled."); synchronized(task.lock) &#123; if (task.state != TimerTask.VIRGIN) throw new IllegalStateException( "Task already scheduled or cancelled"); task.nextExecutionTime = time; task.period = period; task.state = TimerTask.SCHEDULED; &#125; queue.add(task); if (queue.getMin() == task) queue.notify(); &#125;&#125; 在这个函数里面涉及到了两个重要的变量（queue和task）； 首先是获取queue同步锁，设置task的基本属性，包括nextExecutionTime、perid、state； 将task添加到queue中，等待task被执行； TaskQueue源码分析 底层是定义了一个private TimerTask[] queue = new TimerTask[128];数组，用来存储TimerTask，默认值为128； TaskQueue是直接定义在Timer.java的类，是一个优先级队列，是根据nextExecutionTime排序的；最小的nextExecutionTime 如果queue不是空的，最小的TimeTask.nextExecutionTime就是queue[1]； 主要理解两个函数：fixUp()和fixDown(); 12345678910111213141516171819202122private void fixUp(int k) &#123; while (k &gt; 1) &#123; int j = k &gt;&gt; 1; if (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime) break; TimerTask tmp = queue[j]; queue[j] = queue[k]; queue[k] = tmp; k = j; &#125;&#125;private void fixDown(int k) &#123; int j; while ((j = k &lt;&lt; 1) &lt;= size &amp;&amp; j &gt; 0) &#123; if (j &lt; size &amp;&amp; queue[j].nextExecutionTime &gt; queue[j+1].nextExecutionTime) j++; // j indexes smallest kid if (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime) break; TimerTask tmp = queue[j]; queue[j] = queue[k]; queue[k] = tmp; k = j; &#125;&#125; 每次调用add()方法，先将任务添加到quene的最后一个，然后调用fixUp()方法，调整整个queue，将拥有最小nextExecutionTime的TimerTask调整到queue[1]位置，如果位置不够，则需要扩容，按照原来容量的两倍扩容；]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis实战（一)]]></title>
    <url>%2F2017%2F06%2F26%2FMyBatis%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8MyBatis%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[一、MyBatis框架简介 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 二、使用MyBatis框架与原生开发方式对比 数据库连接配置： 使用MyBatis框架： 1234567891011&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://115.28.61.171:3306/xx"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="********"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; 使用JDBC： 1234567891011121314151617public Connection conn = null; public String url="jdbc:mysql://134.78.21.143:3306/xx"; public String password="********"; public String dbName="root"; public String driverName="com.mysql.jdbc.Driver"; public Connection getConnection()throws ClassNotFoundException,SQLException &#123; try &#123; Class.forName(driverName);//指定连接类型 conn = DriverManager.getConnection(url, dbName, password);//获取连接 &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; 查询数据库 使用MyBatis框架： 1234567891011&lt;mapper namespace="com.mb.interfaces.IWcUserOperation"&gt; &lt;resultMap type="WcUser" id="resultListUser"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="openid" property="openid"/&gt; &lt;result column="nickname" property="nickname"/&gt; &lt;result column="province" property="province"/&gt; &lt;/resultMap&gt; &lt;select id="selectUserById" parameterType="int" resultType="WcUser"&gt; select * from WXUSER where id= #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 12IWcUserOperation userOperation = session.getMapper(IWcUserOperation.class); WcUser wcUser = userOperation.selectUserById(15); 使用JDBC： 123456789101112131415161718192021222324252627282930public void getArticle(Connection conn, ArtisvrInitPara yjsvrInitPara, JSONObject jo) &#123; String sql = "select * from "+yjsvrInitPara.getTabname()+" where "+yjsvrInitPara.getExp(); try &#123; st= conn.createStatement(); rs= st.executeQuery(sql); System.out.println(rs); while(rs.next()) &#123; Article ar= new Article(); ar.setId( rs.getInt("id")); ar.setClasses( rs.getString("classes")); ar.setContent( rs.getString("content")); ar.setClirate( rs.getInt("clirate")); ar.setTitle( rs.getString("title")); ar.setFbtime( rs.getString("fbtime")); list.add(ar); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; JSONArray ja=JSONArray.fromObject(list); jo.put("ret", ja); ms.close(rs, st, conn); &#125; 三、总结 使用Mybatis框架可以直接将数据表中每个字段映射到实体类的属性，简化了使用JDBC带来的复杂度。 附录：（完整Demo）（暂时没有时间整理Demo，后期提供） 持续更新中。。。。。。]]></content>
      <tags>
        <tag>MyBatis3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java创建线程的三种方式(Thread/Runnable/Callable)]]></title>
    <url>%2F2017%2F05%2F26%2F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.继承Thread类 此方式只需要重写Thread类中的run()方法即可，示例如下： 1234567891011121314151617/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 19:41 2017/4/10. */public class ExtendThread extends Thread&#123; String name; public ExtendThread(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(name); &#125;&#125; 2.实现Runnable接口 此方式只需要实现Runnable接口中的run()方法，示例如下： 12345678910111213141516/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 19:40 2017/4/10. */public class ImplRunnable implements Runnable&#123; public String name; public ImplRunnable(String name) &#123; this.name = name; &#125; public void run() &#123; System.out.println(name); &#125;&#125; 3.实现Callable接口 实现Callable接口中的calla()方法，示例如下： 123456789101112131415161718import java.util.concurrent.Callable;/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 19:43 2017/4/10. */public class ImplCallable implements Callable&lt;String&gt;&#123; public String name; public ImplCallable(String name) &#123; this.name = name; &#125; public String call() throws Exception &#123; return name; &#125;&#125; 4.Runnable和Callable的区别1234567891011121314151617181920212223public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125;public interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; Callable中申明的方法是call(),Runnable中申明的方法是run(); Callable中的call()方法有返回值，而run()方法没有返回值; call()方法可抛出异常，而run()方法则没有;5.Future详解 12345678public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; cancel()方法：当参数为true时，直接终止当前执行的任务，当参数为false是允许当前的任务执行完成； get()方法：等待任务执行完成，并可以获取任务执行完成的返回结果； ExecutorService中所有的submit()方法都将返回一个Future，从而将Callable或Runnable提交给Executor，并得到一个Future来获得任务的执行结果或取消任务； 附录：测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.BlockJUnit4ClassRunner;import java.util.concurrent.*;/** * @author Junlan Shuai[shuaijunlan@gmail.com]. * @date Created on 19:45 2017/4/10. */@RunWith(BlockJUnit4ClassRunner.class)public class Test1&#123; @Test public void test1() &#123; Thread thread = new ExtendThread("Junlan Shuai"); thread.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void test2() &#123; Thread thread = new Thread(new ImplRunnable("Junlan Shuai")); thread.start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void test3() &#123; ImplCallable implCallable = new ImplCallable("Junlan Shuai"); ExecutorService es = Executors.newFixedThreadPool(3); Future future = es.submit(implCallable); try &#123; System.out.println(future.get()); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>MutliThread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j初级配置教程]]></title>
    <url>%2F2017%2F04%2F26%2Flog4j%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[先来看个采用log4j输出日志的例子 添加依赖包 12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt;&lt;/dependency&gt; 添加配置文件log4j.properties放在/resources目录下面 123456789101112131415161718192021222324252627### 设置###log4j.rootLogger = DEBUG,error,debug,stdout#log4j.rootLogger = INFO,stdout### 输出信息到控制台 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppender#log4j.appender.stdout.Threshold = ERRORlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n### 输出DEBUG 级别以上的日志到=E://logs/debug.log ###log4j.appender.debug = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.debug.File = E://logs/debug.loglog4j.appender.debug.Append = true##Threshold是个全局的过滤器，它将把低于所设置的level的信息过滤不显示出来。log4j.appender.debug.Threshold = DEBUGlog4j.appender.debug.layout = org.apache.log4j.PatternLayoutlog4j.appender.debug.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.error = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.error.File =E://logs/error.loglog4j.appender.error.Append = truelog4j.appender.error.Threshold = ERRORlog4j.appender.error.layout = org.apache.log4j.PatternLayoutlog4j.appender.error.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n java代码 1234567891011121314151617181920212223package com.sh.test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * Created by Mr SJL on 2016/11/26. * * @Author Junlan Shuai */public class App&#123; public static void main(String[] args) &#123; // 记录debug级别的信息 log.debug("This is debug message."); // 记录info级别的信息 log.info("This is info message."); // 记录error级别的信息 log.error("This is error message."); &#125;&#125; 控制台输出结果 log4j主要组件 Log4j有三个主要的组件：Loggers(记录器)，Appenders (输出源)和Layouts(布局)。这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出。综合使用这三个组件可以轻松地记录信息的类型和级别，并可以在运行时控制日志输出的样式和位置。 Loggers Loggers组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR和FATAL。这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，分别用来指定这条日志信息的重要程度，明白这一点很重要，Log4j有一个规则：只输出级别不低于设定级别的日志信息，假设Loggers级别设定为INFO，则INFO、WARN、ERROR和FATAL级别的日志信息都会输出，而级别比INFO低的DEBUG则不会输出。 Appenders 禁用和使用日志请求只是Log4j的基本功能，Log4j日志系统还提供许多强大的功能，比如允许把日志输出到不同的地方，如控制台（Console）、文件（Files）等，可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等等。 常使用的类如下： org.apache.log4j.ConsoleAppender（控制台） org.apache.log4j.FileAppender（文件） org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） Layouts 有时用户希望根据自己的喜好格式化自己的日志输出，Log4j可以在Appenders的后面附加Layouts来完成这个功能。 Layouts提供四种日志输出样式，如根据HTML样式、自由指定样式、包含日志级别与信息的样式和包含日志时间、线程、类别等信息的样式。 常使用的类如下： org.apache.log4j.HTMLLayout（以HTML表格形式布局） org.apache.log4j.PatternLayout（可以灵活地指定布局模式） org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等信息） log4j.properties配置文件详解 在实际应用中，要使Log4j在系统中运行须事先设定配置文件。配置文件事实上也就是对Logger、Appender及Layout进行相应设定。Log4j支持两种配置文件格式，一种是XML格式的文件，一种是properties属性文件。下面以properties属性文件为例介绍 log4j.properties的配置。 配置根Logger log4j.rootLogger = [ level ] , appenderName1, appenderName2, … log4j.additivity.org.apache=false：表示Logger不会在父Logger的appender里输出，默认为true。 level ：设定日志记录的最低级别，可设的值有OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自定义的级别，Log4j建议只使用中间四个级别。通过在这里设定级别，您可以控制应用程序中相应级别的日志信息的开关，比如在这里设定了INFO级别，则应用程序中所有DEBUG级别的日志信息将不会被打印出来。 appenderName：就是指定日志信息要输出到哪里。可以同时指定多个输出目的地，用逗号隔开。 例如：log4j.rootLogger＝INFO,A1,B2,C3 配置控制台输出 1234567### 输出信息到控制台 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppender### 输出ERROR级别以上的日志到控制台 ###log4j.appender.stdout.Threshold = ERRORlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n 配置日志文件输出 12345678### 输出DEBUG 级别以上的日志到=E://logs/debug.log ###log4j.appender.debug = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.debug.File = E://logs/debug.loglog4j.appender.debug.Append = true##Threshold是个全局的过滤器，它将把低于所设置的level的信息过滤不显示出来。log4j.appender.debug.Threshold = DEBUGlog4j.appender.debug.layout = org.apache.log4j.PatternLayoutlog4j.appender.debug.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n REFERENCES Log4j.properties配置详解 最详细的Log4j使用教程]]></content>
      <tags>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections.sort()源码分析（基于jdk1.8）]]></title>
    <url>%2F2017%2F02%2F26%2FCollections.sort()%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Collections类中定义了一系列的静态方法，其中就包括sort方法(下面为该方法的源码),从这个方法的源码中可以看出，它调用的是list.sort()方法，在该方法中先将list转换成数组，然后调用Arrays.sort()方法。在Arrays.sort()方法中，有一个条件判断（LegacyMergeSort.userRequested），当此条件为true时，调用legacyMergeSort(a, c);若为false则调用TimSort.sort(a, 0, a.length, c, null, 0, 0);通过legacyMergeSort(a, c);源码就可以看出此方法实现的是归并排序， Collections.sort()方法源码 1234@SuppressWarnings(&#123;"unchecked", "rawtypes"&#125;)public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123; list.sort(c);&#125; list.sort()方法源码 12345678910@SuppressWarnings(&#123;"unchecked", "rawtypes"&#125;)default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125; Arrays.sort()方法源码 12345678910public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123; if (c == null) &#123; sort(a); &#125; else &#123; if (LegacyMergeSort.userRequested) legacyMergeSort(a, c); else TimSort.sort(a, 0, a.length, c, null, 0, 0); &#125;&#125; mergeSort()方法源码，legacyMergeSort()方法将会在未来的版本中被移除。mergeSort()方法中，当待排序数组长度小于7时，使用的是插入排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** To be removed in a future release. */private static &lt;T&gt; void legacyMergeSort(T[] a, Comparator&lt;? super T&gt; c) &#123; T[] aux = a.clone(); if (c==null) mergeSort(aux, a, 0, a.length, 0); else mergeSort(aux, a, 0, a.length, 0, c);&#125;/** * Tuning parameter: list size at or below which insertion sort will be * used in preference to mergesort. * To be removed in a future release. */private static final int INSERTIONSORT_THRESHOLD = 7;/** * Src is the source array that starts at index 0 * Dest is the (possibly larger) array destination with a possible offset * low is the index in dest to start sorting * high is the end index in dest to end sorting * off is the offset to generate corresponding low, high in src * To be removed in a future release. */@SuppressWarnings(&#123;"unchecked", "rawtypes"&#125;)private static void mergeSort(Object[] src, Object[] dest, int low, int high, int off) &#123; int length = high - low; // Insertion sort on smallest arrays if (length &lt; INSERTIONSORT_THRESHOLD) &#123; for (int i=low; i&lt;high; i++) for (int j=i; j&gt;low &amp;&amp; ((Comparable) dest[j-1]).compareTo(dest[j])&gt;0; j--) swap(dest, j, j-1); return; &#125; // Recursively sort halves of dest into src int destLow = low; int destHigh = high; low += off; high += off; int mid = (low + high) &gt;&gt;&gt; 1; mergeSort(dest, src, low, mid, -off); mergeSort(dest, src, mid, high, -off); // If list is already sorted, just copy from src to dest. This is an // optimization that results in faster sorts for nearly ordered lists. if (((Comparable)src[mid-1]).compareTo(src[mid]) &lt;= 0) &#123; System.arraycopy(src, low, dest, destLow, length); return; &#125; // Merge sorted halves (now in src) into dest for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123; if (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=0) dest[i] = src[p++]; else dest[i] = src[q++]; &#125;&#125;/** * Swaps x[a] with x[b]. */private static void swap(Object[] x, int a, int b) &#123; Object t = x[a]; x[a] = x[b]; x[b] = t;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7设置免密登陆]]></title>
    <url>%2F2016%2F11%2F26%2FCentOS7%E8%AE%BE%E7%BD%AE%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[基本环境 master(centOS7-4:192.168.1.75) slave1(CentOS7-1:192.168.1.21) slave2(CentOS7-2:192.168.1.129) 前提条件 要保证这三台机器之间可以互相ping通 基本配置 在slave1机器上输入命令：vi /etc/ssh/sshd_config 在master机器上输入命令：vi /etc/ssh/sshd_config 在master和slave1上建立相同的用户，此文章以root用户为例，读者可以自行创建其他用户。 登陆到master机器上 执行命令：mkdir .ssh（创建.ssh文件夹），如果存在此文件夹可以不用创建 进入到.ssh目录（执行命令：cd .ssh）,并执行命令：ssh-keygen -t rsa，并一直回车，出现以下结果： 可以看到在.ssh目录下面生成了两个文件：id_rsa（私钥）和id_rsa.pub（公钥）两个文件 使用root用户登陆slave1，同样执行1-3步。 合并id_rsa.pub，追加到authorized_key文件中 root登录master, 在“.ssh”文件夹下，执行命令：scp id_rsa.pub root@slave1:~/.ssh/authorized_keys 拷贝master的公钥id_rsa.pub到slave1的.ssh/authorized_keys。此过程会要求输入密码。 test登录slave,在“.ssh”文件夹下，输入命令：cat id_rsa.pub &gt;&gt; authorized.keys,把slave1的公钥id_rsa.pub追加到slave的authorized_keys文件。 在slave1的“.ssh”文件夹下，复制authorized_keys到master的root，命令“scp authorized_keys root@master:~/.ssh/“，此时，master “.ssh”文件夹下，已经存在与slave1相同的authorized_keys文件 测试登陆 输入命令：ssh master，登陆到master系统 输入命令：exit，退出系统]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7中配置KVM教程]]></title>
    <url>%2F2016%2F11%2F20%2FCentOS7%E4%B8%AD%E9%85%8D%E7%BD%AEKVM%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[基本环境：CentOS7.0 [root@localhost /]# egrep ‘(vmx|svm)’ /proc/cpuinfo 和 Xen 不同，KVM 需要有 CPU 的支持（Intel VT 或 AMD SVM），在安装 KVM 之前检查一下 CPU 是否提供了虚拟技术的支持,可以通过下面命令查询是否支持，如果输出有相关的vmx或者svm，表明CPU支持，否则就不支持。 [root@localhost /]# yum install qemu-kvm qemu-img virt-manager libvirt libvirt-python python-virtinst libvirt-client virt-install virt-viewer kvm相关安装包及其作用（按需选择安装） qemu-kvm：qemu模拟器,主要的KVM程序包 qemu-img：qemu磁盘image管理器 virt-install：基于libvirt服务的虚拟机创建命令，用来创建虚拟机的命令行工具 libvirt：提供libvirtd daemon来管理虚拟机和控制hypervisor libvirt-client：提供客户端API用来访问server和提供管理虚拟机命令行工具的virsh实体 python-virtinst：创建虚拟机所需要的命令行工具和程序库 virt-manager：GUI虚拟机管理工具 virt-top：虚拟机统计命令 virt-viewer：GUI连接程序，连接到已配置好的虚拟机 bridge-utils：创建和管理桥接设备的工具 验证是否安装成功 验证内核模块是否加载 [root@localhost /]# lsmod | grep kvm 启动服务(同时设置了开机自启) [root@localhost /]# systemctl start libvirtd.service 重启服务 [root@localhost /]# systemctl restart libvirtd.service 设置可用 [root@localhost /]# systemctl enable libvirtd.service 查看服务基本信息 [root@localhost /]# systemctl status libvirtd.service 配置虚拟机网络 见《libvirt kvm虚拟机网络配置》一文 在CentOS上安装vnc服务，通过vnc客户端远程连接CentOS，通过图形化界面在宿主机上安装客户机，安装教程见《使用VNC工具初级教程》一文 最后安装客户机 下载虚拟机要安装的ISO系统镜像文件，之后需创建存储池，指定在宿主机上虚拟机磁盘的存储位置，创建存储目录：(目录随便设定，按照自己的需求设定) [root@localhost /]# mkdir -p /home/kvm1 定义一个储存池和绑定目录： [root@localhost /]# virsh pool-define-as vmspool –type dir –target /home/kvm1 建立并激活存储池： [root@localhost /]# virsh pool-build vmspool [root@localhost /]# virsh pool-start vmspool virsh-install: 1、输入虚拟机名称 2、分配多少内存 3、处理器的个数 4、此步可以直接输入iso的位置或是url 5、虚拟机类型KVM 6、定义虚拟机磁盘映像的位置 7、磁盘的大小 6、指定哪个桥或者可以指定多个桥 7、额外的控制台和KS文件 8、连接到系统参数 参数说明注意每行都要空格 -n 虚拟机名称 -r 分配虚拟机内存大小 –vcpus 分配虚拟cpu个数 -c 镜像文件位置 –vnc –vncport=5901 –vnclisten=0.0.0.0 启动图形安装界面 –virt-type 虚拟机模式 -f 虚拟机系统文件存储目录 -s 分配磁盘大小（GB） -w 联网方式（birdge bridge:br0/nat bridge:virbr0） –os-type=’windows’ –os-variant=win2k3 安装windows最好加上这个否则会报错 virt-install工具安装虚拟机后，在目录/etc/libvirt/qemu/下生成xml配置文件 -s 用来指定虚拟磁盘的大小单位为GB -m 指定虚拟网卡的硬件地址默认virt-install自动产生 -p 以半虚拟化方式建立虚拟机 -l 指定安装来源 -x EXTRA, –extra-args=EXTRA当执行从”–location”选项指定位置的客户机安装时，附加内核命令行参数到安装程序。 -v, –hvm 设置全虚拟化 创建第一个guest： [root@localhost /]# virt-install –name=CentOS7-1 –ram=4096 –vcpus=1 –cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso –virt-type=kvm –disk path=/home/kvm1/centos7-1.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=250 –graphics vnc,listen=0.0.0.0,port=5920,password=123456 –network bridge:br0 –accelerate –force –autostart 创建第二个guest： [root@localhost /]# virt-install –name=CentOS7-2 –ram=7168 –vcpus=2,maxvcpus=4 –cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso –virt-type=kvm –disk path=/home/kvm1/centos7-2.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 –graphics vnc,listen=0.0.0.0,port=5921,password=123456 –network bridge:br0 –accelerate –force –autostart 创建第三个guest： [root@localhost /]# virt-install –name=CentOS7-3 –ram=7168 –vcpus=6,maxvcpus=9 –cpuset=6,7,8,9,10,11 –cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso –virt-type=kvm –disk path=/home/kvm1/centos7-3.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 –graphics vnc,listen=0.0.0.0,port=5922,password=123456 –network bridge:br0 –accelerate –force –autostart 创建第四个guest： [root@localhost /]# virt-install –name=CentOS7-4 –ram=7168 –vcpus=6,maxvcpus=9 –cpuset=12,13,14,15,16,17 –cdrom=/home/kvm1/CentOS-7-x86_64-Minimal-1511.iso –virt-type=kvm –disk path=/home/kvm1/centos7-4.img,device=disk,format=qcow2,bus=virtio,cache=writeback,size=400 –graphics vnc,listen=0.0.0.0,port=5923,password=123456 –network bridge:br0 –accelerate –force –autostart 持续更新中…… REFERENCES KVM虚拟机创建功能详细讲解 绑定KVM虚拟机的vcpu与物理CPU 基于Linux命令行KVM虚拟机的安装配置与基本使用 CENTOS7 安装KVM笔记之安装 linux下配置和安装KVM虚拟机]]></content>
      <tags>
        <tag>KVM</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置KVM虚拟机网络的两种方式（Bridge模式和NAT模式）]]></title>
    <url>%2F2016%2F11%2F16%2Flibvirt%20kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Bridge原理(桥接模式) Bridge方式即虚拟网桥的网络连接方式，使客户机和子网里面的机器能够互相通信。可以使虚拟机成为网络中具有独立IP的主机。桥接网络（也叫物理设备共享）被用作把一个物理设备复制到一台虚拟机。网桥多用作高级设置，特别是主机多个网络接口的情况。 在bridged模式下，虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。同时，由于这个虚拟系统是局域网中的一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或路由器访问互联网。使用bridged模式的虚拟系统和宿主机器的关系，就像连接在同一个Hub上的两台电脑。想让它们相互通讯，你就需要为虚拟系统配置IP地址和子网掩码，否则就无法通信（参考dhcp服务器是否开启，如果开启，则可以选择dhcp方式自动获取网络地址）。这种方式最简单，直接将虚拟网卡桥接到一个物理网卡上面，和linux下一个网卡绑定两个不同地址类似，实际上是将网卡设置为混杂模式，从而达到侦听多个IP的能力。在此种模式下，虚拟机内部的网卡（例如linux下的eth0)直接连到了物理网卡所在的网络上，可以想象为虚拟机和host机处于对等的地位，在网络关系上是平等的，没有谁在谁后面的问题。使用这种方式很简单，前提是你可以得到1个以上的地址。 如上图，网桥的基本原理就是创建一个桥接接口br0，在物理网卡和虚拟网络接口之间传递数据。 基本步骤 安装完CentOS7.0， 在/etc/sysconfig/network-scripts/目录下面会生成两个默认网络配置文件。（如图） 继续看文件里面的详细信息。 ifcfg-eth0 ifcfg-lo 配置静态IP 在相同目录下面添加一个ifcfg-br0文件，并在文件中添加如下内容 并且修改ifcfg-eth0文件 配置动态IP 在相同目录下面添加一个ifcfg-br0文件，并在文件中添加如下内容 12345DEVICE=br0TYPE=BridgeNM_CONTROLLED=noBOOTPROTO=dhcpONBOOT=yes 并且修改ifcfg-eth0文件 申明 NAT原理(网络地址转换模式) 使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。很显然，如果你只有一个外网地址，此种方式很合适。 virsh net-list 查看当前活跃的网络，可以看到一个default网络，这个就是一个默认的Nat网络了。 virsh net-dumpxml default 查看网络配置 持续更新中…… REFERENCES libvirt kvm 虚拟机上网 – Bridge桥接]]></content>
      <tags>
        <tag>KVM</tag>
        <tag>虚拟化</tag>
        <tag>网络配置</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中Bean的初始化与销毁（基于Spring4.x）]]></title>
    <url>%2F2016%2F10%2F26%2FSpring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[通过在bean中设置init-method和destroy-method 配置beanspring-lifecycle.xml 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="beanLifeCycle" class="com.sh.imcdemo.services.impl.BeanLifeCycle" init-method="start" destroy-method="stop"&gt;&lt;/bean&gt;&lt;/beans&gt; com.sh.imcdemo.services.impl 实现类 1234567891011121314151617package com.sh.imcdemo.services.impl;/** * Created by Mr SJL on 2016/11/26. * * @Author Junlan Shuai */public class BeanLifeCycle&#123; public void start() &#123; System.out.println("Bean start."); &#125; public void stop() &#123; System.out.println("Bean stop."); &#125;&#125; 通过实现InitializingBean和DisposableBean接口 配置beanspring-lifecycle.xml 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="beanLifeCycle1" class="com.sh.imcdemo.services.impl.BeanLifeCycle"&gt;&lt;/bean&gt;&lt;/beans&gt; com.sh.imcdemo.services.impl实现类 123456789101112131415161718192021222324package com.sh.imcdemo.services.impl;import org.springframework.beans.factory.DisposableBean;import org.springframework.beans.factory.InitializingBean;/** * Created by Mr SJL on 2016/11/26. * * @Author Junlan Shuai */public class BeanLifeCycle implements InitializingBean, DisposableBean&#123; public void destroy() throws Exception &#123; System.out.println("Bean destory."); &#125; public void afterPropertiesSet() throws Exception &#123; System.out.println("Bean afterPropertiesSet."); &#125;&#125; 通过设置default-destroy-method和default-init-method 对于同一配置文件下的所有的Bean都会使用该默认的初始化和销毁方法（但有特殊情况，见本篇总结部分） 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" default-destroy-method="defaultDestroy" default-init-method="defaultInit"&gt; &lt;bean id="beanLifeCycle" class="com.sh.imcdemo.services.impl.BeanLifeCycle"&gt;&lt;/bean&gt;&lt;/beans&gt; com.sh.imcdemo.services.impl 123456789101112131415161718package com.sh.imcdemo.services.impl;/** * Created by Mr SJL on 2016/11/26. * * @Author Junlan Shuai */public class BeanLifeCycle&#123; public void defaultInit() &#123; System.out.println("Bean defaultInit."); &#125; public void defaultDestroy() &#123; System.out.println("Bean defaultDestory"); &#125;&#125; 总结 当三种方式同时使用时，我们会发现，第三种方式被覆盖了，另外两种方式的输出先后顺序是：先是2再是1。 当使用第3种方式时，实现类中不一定非要实现该默认方法，如果没有该方法，则没有处理。 当第2种和第3中方式同时使用时，默认方法却没有被覆盖，两者都会输出，但是第1种和第3种同时使用时，默认方法却被覆盖了。（？？？） 附录 测试基类 com.sh.imcdemo.unitTest 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.sh.imcdemo.unitTest;import org.apache.commons.lang.StringUtils;import org.junit.After;import org.junit.Before;import org.springframework.beans.BeansException;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created by Mr SJL on 2016/11/26. * * @Author Junlan Shuai */public class UnitTestBase&#123; private ClassPathXmlApplicationContext context; private String springXmlpath; public UnitTestBase() &#123; &#125; public UnitTestBase(String springXmlpath) &#123; this.springXmlpath = springXmlpath; &#125; @Before public void before() &#123; if (StringUtils.isEmpty(springXmlpath)) &#123; springXmlpath = "classpath*:spring-*.xml"; &#125; try &#123; context = new ClassPathXmlApplicationContext(springXmlpath.split("[,\\s]+")); context.start(); &#125; catch (BeansException e) &#123; e.printStackTrace(); &#125; &#125; @After public void after() &#123; context.destroy(); &#125; protected &lt;T extends Object&gt; T getBean(String beanId) &#123; return (T)context.getBean(beanId); &#125; protected &lt;T extends Object&gt; T getBean(Class&lt;T&gt; clas) &#123; return context.getBean(clas); &#125;&#125; 测试类com.sh.imcdemo.unitTest 12345678910111213141516171819202122232425262728293031package com.sh.imcdemo.unitTest;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.BlockJUnit4ClassRunner;/** * Created by Mr SJL on 2016/11/26. * * @Author Junlan Shuai */@RunWith(BlockJUnit4ClassRunner.class)public class App3 extends UnitTestBase&#123; public App3() &#123; super("classpath:spring-lifecycle.xml"); &#125; @Test public void test1() &#123; super.getBean("beanLifeCycle"); &#125; @Test public void test2() &#123; super.getBean("beanLifeCycle1"); &#125;&#125; 依赖包pom.xml 1234567891011121314151617181920212223242526272829303132&lt;spring.version&gt;4.3.2.RELEASE&lt;/spring.version&gt;&lt;junit.version&gt;4.11&lt;/junit.version&gt;&lt;!-- Spring依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 单元测试包 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Autoboxing and Autounboxing]]></title>
    <url>%2F2016%2F09%2F26%2FAutopacking%20and%20Autounpacking%2F</url>
    <content type="text"><![CDATA[前言： 首先我们要知道Java中有哪些基本数据类型以及它们各自的封装类:package java.lang; 基本数据类型 封装类 byte Byte boolean Boolean char Character short Short int Integer long Long float Float double Double 一、什么是Autoboxing java中Autoboxing是指将基本数据类型自动转换成封装类类型。比如说： 123456789public void test1()&#123; int a = 10; Integer b = a; System.out.println(b); Character d = 'c'; System.out.println(d);&#125; 函数参数为封装类类型时，调用时传递基本数据类型，会发生Autoboxing。 将基本数据类型变量赋值给封装类类型时，会发生Autoboxing。 二、什么是Autounboxing java中Autounboxing是指将封装类类型自动转换成基本数据类型。比如说： 12345678910public void test2()&#123; Integer a = new Integer(10); int b = a; System.out.println(b); Character c = 'c'; char d = c; System.out.println(d);&#125; 函数参数为基本数据类型，调用时传递封装类类型，会发生Autounboxing。 将封装类类型变量赋值给基本数据类型，或者直接用封装类类型进行基本运算，会发生Autounboxing。 三、以int类型为例，讲解Autoboxing和Autounboxing实现原理 先来看一段代码反汇编的结果 java代码 12345678910111213141516171819package com.sh.$16.$12.$22;/** * Created by Mr SJL on 2016/12/22. * * @Author Junlan Shuai */import java.util.ArrayList;import java.util.List;public class App1&#123; public static void main(String[] args) &#123; Integer integer = 10; int i = integer; &#125;&#125; 反汇编结果 1234567891011121314151617public class com.sh.$16.$12.$22.App1 &#123; public com.sh.$16.$12.$22.App1(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public static void main(java.lang.String[]); Code: 0: bipush 10 2: invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: astore_1 6: aload_1 7: invokevirtual #3 // Method java/lang/Integer.intValue:()I 10: istore_2 11: return&#125; 从以上java代码可以看出，“Integer integer = 10;”此句发生了Autoboxing。从汇编结果可以看出，实际在编译的时候发生了，Integer a = Integer.valueOf(10);调用了Integer类的valueOf方法。 1234567891011121314151617181920/** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 从以上java代码可以看出，“int i = integer;”此句发生了Autounboxing。从汇编结果可以看出，实际在编译的时候发生了，int i = integer.intValue();调用了Integer类的intValue方法。 1234567/** * Returns the value of this &#123;@code Integer&#125; as an * &#123;@code int&#125;. */public int intValue() &#123; return value;&#125; 四、总结 其他基本数据类型的Autoboxing and Autounboxing也满足此。 思考：1234567891011121314151617181920212223242526272829303132package com.sh.$16.$12.$24;/** * Created by Mr SJL on 2016/12/24. * * @Author Junlan Shuai */public class App2&#123; public static void main(String[] args) &#123; int a = 10; int b = 10; Integer c = new Integer(10); Integer d = Integer.valueOf(10); Integer e = 2000; Integer f = 2000; System.out.println("a=b:" +(a==b)); System.out.println("a=c:" +(a==c)); System.out.println("a=d:" +(a==d)); System.out.println("c=d:" +(c==d)); System.out.println("e=f:" +(e==f)); &#125;&#125;// 运行结果：a=b:truea=c:truea=d:truec=d:falsee=f:false]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中常量池详解]]></title>
    <url>%2F2016%2F07%2F26%2FJava%E4%B8%AD%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[阅读这篇文章之前先来理解几个基本的概念 什么是常量 equals()方法和==的区别 引用和对象的区别 1. String常量池1.1 创建String对象的两种方式 通过new来创建String创对象，例如：String a = new String(“a”); 直接将字符串常量赋值给一个对象引用，例如：String b = “b”; 这两种不同的创建方法是有差别的，第一种方式是直接在Java heap内存空间创建一个新的对象，并且引用变量a指向这个对象，第二种方式是引用变量b指向常量池中的字符串。 1.2 先来看一个Demo12345678910111213141516171819202122232425262728293031323334353637package com.sh.oc.test;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.BlockJUnit4ClassRunner;/** * Created by Mr SJL on 2016/12/16. * * @Author Junlan Shuai */@RunWith(BlockJUnit4ClassRunner.class)public class Test1&#123; @Test public void test1() &#123; String a = "helloWorld"; String b = "helloWorld"; String c = new String("helloWorld"); String d = "hello"; String e = new String("hello"); String temp = "World"; String f = "hello" + temp; String g = "hello" + "World"; System.out.println("(1) a=b:" + (a == b)); System.out.println("(2) b=c:" + (b == c)); System.out.println("(3) a=d:" + (a == (d + "World"))); System.out.println("(4) a=e:" + (a == (e + "World"))); System.out.println("(5) c=d:" + (c == (d + "World"))); System.out.println("(6) c=e:" + (c == (e + "World"))); System.out.println("(7) a=g:" + (a == g)); System.out.println("(8) a=f:" + (a == f)); &#125;&#125; 结果输出： 12345678910(1) a=b:true(2) b=c:false(3) a=d:false(4) a=e:false(5) c=d:false(6) c=e:false(7) a=g:true(8) a=f:falseProcess finished with exit code 0 1.3 总结： 对于第(1)个结果，直接将相同的字符串常量赋值给字符串引用变量（后称‘变量’）a，b，在编译的时候该字符串直接保存在常量池中，同时变量a，b同时指向这个字符串常量，所以a==b返回true； 第(2)个结果，对于变量c，是通过new一个对象（该对象保存在java heap中），然后变量c指向这个对象。故变量b和c指向的是不同的内存空间，b==c返回false； 第(3)个结果，对于加法运算d + “World”在执行的时候，首先是通过创建一个StringBuilder对象，然后调用该对象的append()方法，最后调用该对象的toString()方法。也就是相当于执行了new StringBuilder().append(d).append(“Word”).toString()。由StringBuilder源码可知，最后结果返回一个String对象(存放在java heap中)。故变量a和d指向不同的内存地址空间，虽然value是一样的，最终返回false。对于第(4)个结果，原理和(3)一样。 12345@Overridepublic String toString() &#123; // Create a copy, don't share the array return new String(value, 0, count);&#125; 对于第(5)和(6)个结果，因为变量c指向的是在java heap中的一个String对象，并且加法运算(d + “World”)，返回的也是一个String对象，但是它们指向的地址空间不同，故返回false。 对于第(7)和(8)的结果，原理和前面相同。 持续更新中。。。。。。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中“...”的含义]]></title>
    <url>%2F2016%2F06%2F26%2Fjava%E4%B8%AD%E2%80%9C...%E2%80%9D%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[问题来源 在阅读spring源码时发现问题： 123456789/** * Create a new ClassPathXmlApplicationContext, loading the definitions * from the given XML files and automatically refreshing the context. * @param configLocations array of resource locations * @throws BeansException if context creation failed */public ClassPathXmlApplicationContext(String... configLocations) throws BeansException &#123; this(configLocations, true, null);&#125; 简介 是jdk1.5新增加特性，Java语言对方法参数支持一种新写法，叫可变长度参数列表，其语法就是类型后跟…，表示此处接受的参数为0到多个Object类型的对象，或者是一个Object[]。 测试 com.sh.test 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.sh.test;/** * Created by Mr SJL on 2016/11/19. * * @author Junlan Shuai */public class Test1&#123; public static void main(String[] args) &#123; // 创建string对象数组，调用测试函数 String[] colors = new String[]&#123;"green", "blue", "red"&#125;; t1(colors); t2(colors); // 创建string实例，并调用测试函数 String color = "black"; t1(color);// t2(color); // 此处报错 java.lang.String[] can not be applied java.lang.String &#125; /** * 测试函数1 * @param colors String...类型 */ public static void t1(String... colors) &#123; for (String c : colors) &#123; System.out.println(c); &#125; &#125; /** * 测试函数2 * @param colors String[]类型 */ public static void t2(String[] colors) &#123; for (String c : colors) &#123; System.out.println(c); &#125; &#125;&#125; 注意事项 Error:(38, 24) java: 无法在com.sh.test.Test1中同时声明t1(java.lang.String[])和t1(java.lang.String…) 12345678910111213141516171819202122/** * 测试函数1 * @param colors String...类型 */public static void t1(String... colors)&#123; for (String c : colors) &#123; System.out.println(c); &#125;&#125;/** * 测试函数2 * @param colors String[]类型 */public static void t1(String[] colors)&#123; for (String c : colors) &#123; System.out.println(c); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
</search>
